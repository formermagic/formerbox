word = "tree ▁ cat" <newline> user_word = [ ] <newline> position_list = [ ] <newline> display = [ ] <newline> for z in word : <newline> <indent> display . append ( "_" ) <newline> <dedent> g = 0 <newline> t = 0 <newline> b = 0 <newline> user = " ▁ " <newline> while True : <newline> <indent> user = raw_input ( "Letter: ▁ " ) <newline> for x in word : <newline> <indent> position = word . find ( user , t ) <newline> t += 1 <newline> position_list . append ( position ) <newline> <dedent> t = 0 <newline> print position_list <newline> for i in position_list : <newline> <indent> if i not in user_word and i >= 0 : <newline> <indent> user_word . append ( i ) <newline> <dedent> <dedent> print user_word <newline> for y in position_list : <newline> <indent> if y >= 0 : <newline> <indent> display [ y ] = user <newline> <dedent> <dedent> gif = " ▁ ▁ " . join ( display ) <newline> print gif <newline> finish = "" . join ( display ) <newline> if finish == word : <newline> <indent> exit ( ) <newline> <dedent> position_list = [ ] <newline> g += 1 <newline> <dedent>
 # Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ (ASF) ▁ under ▁ one <encdom>  # or ▁ more ▁ contributor ▁ license ▁ agreements. ▁ See ▁ the ▁ NOTICE ▁ file <encdom>  # distributed ▁ with ▁ this ▁ work ▁ for ▁ additional ▁ information <encdom>  # regarding ▁ copyright ▁ ownership. ▁ The ▁ ASF ▁ licenses ▁ this ▁ file <encdom>  # to ▁ you ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the <encdom>  #"License"); ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance <encdom>  # with ▁ the ▁ License. ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, <encdom>  # WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. <encdom>  # See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and <encdom>  # limitations ▁ under ▁ the ▁ License. <encdom> import unittest , os , sys , re , threading , time <newline> myDirectory = os . path . realpath ( sys . argv [ 0 ] ) <newline> rootDirectory = re . sub ( "/testing/.*" , "" , myDirectory ) <newline> sys . path . append ( rootDirectory ) <newline> from testing . lib import BaseTestSuite <newline> excludes = [ ] <newline> import tempfile , getpass <newline> from xml . dom import minidom <newline> from hodlib . Hod . hadoop import hadoopConfig <newline>  # ▁ All ▁ test-case ▁ classes ▁ should ▁ have ▁ the ▁ naming ▁ convention ▁ test_.* <encdom> class test_hadoopConfig ( unittest . TestCase ) : <newline> <indent> def setUp ( self ) : <newline> <indent> self . __hadoopConfig = hadoopConfig ( ) <newline> self . rootDir = '/tmp/hod-%s' % getpass . getuser ( ) <newline> if not os . path . exists ( self . rootDir ) : <newline> <indent> os . mkdir ( self . rootDir ) <newline> <dedent> self . testingDir = tempfile . mkdtemp ( dir = self . rootDir , prefix = 'HadoopTestSuite.test_hadoopConfig' ) <newline> self . confDir = tempfile . mkdtemp ( dir = self . rootDir , prefix = 'HadoopTestSuite.test_hadoopConfig' ) <newline> self . tempDir = '/tmp/hod-%s/something' % getpass . getuser ( ) <newline> self . hadoopSite = os . path . join ( self . confDir , 'hadoop-site.xml' ) <newline> self . numNodes = 4 <newline> self . hdfsAddr = 'nosuchhost1.apache.org:50505' <newline> self . mapredAddr = 'nosuchhost2.apache.org:50506' <newline> self . finalServerParams = { 'mapred.child.java.opts' : '-Xmx1024m' , 'mapred.compress.map.output' : 'false' , } <newline> self . serverParams = { 'mapred.userlog.limit' : '200' , 'mapred.userlog.retain.hours' : '10' , 'mapred.reduce.parallel.copies' : '20' , } <newline> self . clientParams = { 'mapred.tasktracker.tasks.maximum' : '2' , 'io.sort.factor' : '100' , 'io.sort.mb' : '200' , 'mapred.userlog.limit.kb' : '1024' , 'io.file.buffer.size' : '262144' , } <newline> self . clusterFactor = 1.9 <newline> self . mySysDir = '/user/' + getpass . getuser ( ) + '/mapredsystem' <newline> pass <newline> <dedent> def testSuccess ( self ) : <newline> <indent> self . __hadoopConfig . gen_site_conf ( confDir = self . confDir , tempDir = self . tempDir , numNodes = self . numNodes , hdfsAddr = self . hdfsAddr , mrSysDir = self . mySysDir , mapredAddr = self . mapredAddr , clientParams = self . clientParams , serverParams = self . serverParams , finalServerParams = self . finalServerParams , clusterFactor = self . clusterFactor ) <newline> xmldoc = minidom . parse ( self . hadoopSite ) <newline> xmldoc = xmldoc . childNodes [ 0 ]  # ▁ leave ▁ out ▁ xml ▁ spec <encdom> <newline> properties = xmldoc . childNodes  # ▁ children ▁ of ▁ tag ▁ configuration <encdom> <newline> keyvals = { } <newline> for prop in properties : <newline> <indent> if not isinstance ( prop , minidom . Comment ) : <newline>  # ▁ ----- ▁ tag ▁ ----- ▁ -value ▁ elem-- ▁ data ▁ -- ▁ <encdom> <indent> name = prop . getElementsByTagName ( 'name' ) [ 0 ] . childNodes [ 0 ] . data <newline> value = prop . getElementsByTagName ( 'value' ) [ 0 ] . childNodes [ 0 ] . data <newline> keyvals [ name ] = value <newline>  # ▁ fs.default.name ▁ should ▁ start ▁ with ▁ hdfs:// <encdom> <dedent> <dedent> assert ( keyvals [ 'fs.default.name' ] . startswith ( 'hdfs://' ) ) <newline> assert ( keyvals [ 'hadoop.tmp.dir' ] == self . tempDir ) <newline>  # ▁ TODO ▁ other ▁ tests <encdom> pass <newline> <dedent> def tearDown ( self ) : <newline> <indent> if os . path . exists ( self . hadoopSite ) : os . unlink ( self . hadoopSite ) <newline> if os . path . exists ( self . confDir ) : os . rmdir ( self . confDir ) <newline> if os . path . exists ( self . testingDir ) : os . rmdir ( self . testingDir ) <newline> pass <newline> <dedent> <dedent> class HadoopTestSuite ( BaseTestSuite ) : <newline> <indent> def __init__ ( self ) : <newline>  # ▁ suite ▁ setup <encdom> <indent> BaseTestSuite . __init__ ( self , __name__ , excludes ) <newline> pass <newline> <dedent> def cleanUp ( self ) : <newline>  # ▁ suite ▁ tearDown <encdom> <indent> pass <newline> <dedent> <dedent> def RunHadoopTests ( ) : <newline> <indent> suite = HadoopTestSuite ( ) <newline> testResult = suite . runTests ( ) <newline> suite . cleanUp ( ) <newline> return testResult <newline> <dedent> if __name__ == "__main__" : <newline> <indent> RunHadoopTests ( ) <newline> <dedent>
from models import Change <newline> def add_change ( obj , ** kw ) : <newline> <indent>  """ <strnewline> ▁ Alias ▁ to ▁ Change.objects.add_change_for_object <strnewline> ▁ """  <newline> return Change . objects . add_change_for_object ( obj , ** kw ) <newline> <dedent> def get_changes_for ( obj , ** kw ) : <newline> <indent>  """ <strnewline> ▁ Alias ▁ to ▁ Change.objects.get_changes_for_object <strnewline> ▁ """  <newline> return Change . objects . get_changes_for_object ( obj , ** kw ) <newline> <dedent> def get_anonymous_changes_for ( obj , ** kw ) : <newline> <indent>  """ <strnewline> ▁ Alias ▁ to ▁ Change.objects.get_anonymous_changes <strnewline> ▁ """  <newline> return Change . objects . get_changes_for_object ( obj , ** kw ) . anonymous ( ) <newline> <dedent> def get_changes_by ( who , ** kw ) : <newline> <indent>  """ <strnewline> ▁ Alias ▁ to ▁ Change.objects.get_changes_by_user <strnewline> ▁ """  <newline> return Change . objects . get_changes_by_user ( who , ** kw ) <newline> <dedent>
 # ▁ Copyright ▁ 2008 ▁ Armin ▁ Ronacher. <encdom>  # ▁ Licensed ▁ to ▁ PSF ▁ under ▁ a ▁ Contributor ▁ Agreement. <encdom>  """ Fixer ▁ that ▁ cleans ▁ up ▁ a ▁ tuple ▁ argument ▁ to ▁ isinstance ▁ after ▁ the ▁ tokens <strnewline> in ▁ it ▁ were ▁ fixed. ▁ This ▁ is ▁ mainly ▁ used ▁ to ▁ remove ▁ double ▁ occurrences ▁ of <strnewline> tokens ▁ as ▁ a ▁ leftover ▁ of ▁ the ▁ long ▁ -> ▁ int ▁ / ▁ unicode ▁ -> ▁ str ▁ conversion. <strnewline> <strnewline> eg. ▁ isinstance(x, ▁ (int, ▁ long)) ▁ -> ▁ isinstance(x, ▁ (int, ▁ int)) <strnewline> ▁ -> ▁ isinstance(x, ▁ int) <strnewline> """  <newline> from . . import fixer_base <newline> from . . fixer_util import token <newline> class FixIsinstance ( fixer_base . BaseFix ) : <newline> <indent> BM_compatible = True <newline> PATTERN =  """ <strnewline> ▁ ▁ ▁ ▁ power< <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁'isinstance' <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ trailer< ▁'(' ▁ arglist< ▁ any ▁',' ▁ atom< ▁'(' <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ args=testlist_gexp< ▁ any+ ▁ > <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁')' ▁ > ▁ > ▁')' ▁ > <strnewline> ▁ ▁ ▁ ▁ > <strnewline> ▁ ▁ ▁ ▁ """  <newline> run_order = 6 <newline> def transform ( self , node , results ) : <newline> <indent> names_inserted = set ( ) <newline> testlist = results [ "args" ] <newline> args = testlist . children <newline> new_args = [ ] <newline> iterator = enumerate ( args ) <newline> for idx , arg in iterator : <newline> <indent> if arg . type == token . NAME and arg . value in names_inserted : <newline> <indent> if idx < len ( args ) - 1 and args [ idx + 1 ] . type == token . COMMA : <newline> <indent> iterator . next ( ) <newline> continue <newline> <dedent> <dedent> else : <newline> <indent> new_args . append ( arg ) <newline> if arg . type == token . NAME : <newline> <indent> names_inserted . add ( arg . value ) <newline> <dedent> <dedent> <dedent> if new_args and new_args [ - 1 ] . type == token . COMMA : <newline> <indent> del new_args [ - 1 ] <newline> <dedent> if len ( new_args ) == 1 : <newline> <indent> atom = testlist . parent <newline> new_args [ 0 ] . prefix = atom . prefix <newline> atom . replace ( new_args [ 0 ] ) <newline> <dedent> else : <newline> <indent> args [ : ] = new_args <newline> node . changed ( ) <newline> <dedent> <dedent> <dedent>
 # ▁ flasky ▁ extensions. ▁ flasky ▁ pygments ▁ style ▁ based ▁ on ▁ tango ▁ style <encdom> from pygments . style import Style <newline> from pygments . token import Keyword , Name , Comment , String , Error , Number , Operator , Generic , Whitespace , Punctuation , Other , Literal <newline> class FlaskyStyle ( Style ) : <newline> <indent> background_color = " # f8f8f8" <newline> default_style = "" <newline> styles = {  # ▁ No ▁ corresponding ▁ class ▁ for ▁ the ▁ following: <encdom>  # Text: ▁"", ▁ # ▁ class: ▁'' <encdom> Whitespace : "underline ▁ # f8f8f8" ,  # ▁ class: ▁'w' <encdom> Error : " # a40000 ▁ border: # ef2929" ,  # ▁ class: ▁'err' <encdom> Other : " # 000000" ,  # ▁ class ▁'x' <encdom> Comment : "italic ▁ # 8f5902" ,  # ▁ class: ▁'c' <encdom> Comment . Preproc : "noitalic" ,  # ▁ class: ▁'cp' <encdom> Keyword : "bold ▁ # 004461" ,  # ▁ class: ▁'k' <encdom> Keyword . Constant : "bold ▁ # 004461" ,  # ▁ class: ▁'kc' <encdom> Keyword . Declaration : "bold ▁ # 004461" ,  # ▁ class: ▁'kd' <encdom> Keyword . Namespace : "bold ▁ # 004461" ,  # ▁ class: ▁'kn' <encdom> Keyword . Pseudo : "bold ▁ # 004461" ,  # ▁ class: ▁'kp' <encdom> Keyword . Reserved : "bold ▁ # 004461" ,  # ▁ class: ▁'kr' <encdom> Keyword . Type : "bold ▁ # 004461" ,  # ▁ class: ▁'kt' <encdom> Operator : " # 582800" ,  # ▁ class: ▁'o' <encdom> Operator . Word : "bold ▁ # 004461" ,  # ▁ class: ▁'ow' ▁ - ▁ like ▁ keywords <encdom> Punctuation : "bold ▁ # 000000" ,  # ▁ class: ▁'p' <encdom>  # ▁ because ▁ special ▁ names ▁ such ▁ as ▁ Name.Class, ▁ Name.Function, ▁ etc. <encdom>  # ▁ are ▁ not ▁ recognized ▁ as ▁ such ▁ later ▁ in ▁ the ▁ parsing, ▁ we ▁ choose ▁ them <encdom>  # ▁ to ▁ look ▁ the ▁ same ▁ as ▁ ordinary ▁ variables. <encdom> Name : " # 000000" ,  # ▁ class: ▁'n' <encdom> Name . Attribute : " # c4a000" ,  # ▁ class: ▁'na' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Builtin : " # 004461" ,  # ▁ class: ▁'nb' <encdom> Name . Builtin . Pseudo : " # 3465a4" ,  # ▁ class: ▁'bp' <encdom> Name . Class : " # 000000" ,  # ▁ class: ▁'nc' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Constant : " # 000000" ,  # ▁ class: ▁'no' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Decorator : " # 888" ,  # ▁ class: ▁'nd' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Entity : " # ce5c00" ,  # ▁ class: ▁'ni' <encdom> Name . Exception : "bold ▁ # cc0000" ,  # ▁ class: ▁'ne' <encdom> Name . Function : " # 000000" ,  # ▁ class: ▁'nf' <encdom> Name . Property : " # 000000" ,  # ▁ class: ▁'py' <encdom> Name . Label : " # f57900" ,  # ▁ class: ▁'nl' <encdom> Name . Namespace : " # 000000" ,  # ▁ class: ▁'nn' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Other : " # 000000" ,  # ▁ class: ▁'nx' <encdom> Name . Tag : "bold ▁ # 004461" ,  # ▁ class: ▁'nt' ▁ - ▁ like ▁ a ▁ keyword <encdom> Name . Variable : " # 000000" ,  # ▁ class: ▁'nv' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Variable . Class : " # 000000" ,  # ▁ class: ▁'vc' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Variable . Global : " # 000000" ,  # ▁ class: ▁'vg' ▁ - ▁ to ▁ be ▁ revised <encdom> Name . Variable . Instance : " # 000000" ,  # ▁ class: ▁'vi' ▁ - ▁ to ▁ be ▁ revised <encdom> Number : " # 990000" ,  # ▁ class: ▁'m' <encdom> Literal : " # 000000" ,  # ▁ class: ▁'l' <encdom> Literal . Date : " # 000000" ,  # ▁ class: ▁'ld' <encdom> String : " # 4e9a06" ,  # ▁ class: ▁'s' <encdom> String . Backtick : " # 4e9a06" ,  # ▁ class: ▁'sb' <encdom> String . Char : " # 4e9a06" ,  # ▁ class: ▁'sc' <encdom> String . Doc : "italic ▁ # 8f5902" ,  # ▁ class: ▁'sd' ▁ - ▁ like ▁ a ▁ comment <encdom> String . Double : " # 4e9a06" ,  # ▁ class: ▁'s2' <encdom> String . Escape : " # 4e9a06" ,  # ▁ class: ▁'se' <encdom> String . Heredoc : " # 4e9a06" ,  # ▁ class: ▁'sh' <encdom> String . Interpol : " # 4e9a06" ,  # ▁ class: ▁'si' <encdom> String . Other : " # 4e9a06" ,  # ▁ class: ▁'sx' <encdom> String . Regex : " # 4e9a06" ,  # ▁ class: ▁'sr' <encdom> String . Single : " # 4e9a06" ,  # ▁ class: ▁'s1' <encdom> String . Symbol : " # 4e9a06" ,  # ▁ class: ▁'ss' <encdom> Generic : " # 000000" ,  # ▁ class: ▁'g' <encdom> Generic . Deleted : " # a40000" ,  # ▁ class: ▁'gd' <encdom> Generic . Emph : "italic ▁ # 000000" ,  # ▁ class: ▁'ge' <encdom> Generic . Error : " # ef2929" ,  # ▁ class: ▁'gr' <encdom> Generic . Heading : "bold ▁ # 000080" ,  # ▁ class: ▁'gh' <encdom> Generic . Inserted : " # 00A000" ,  # ▁ class: ▁'gi' <encdom> Generic . Output : " # 888" ,  # ▁ class: ▁'go' <encdom> Generic . Prompt : " # 745334" ,  # ▁ class: ▁'gp' <encdom> Generic . Strong : "bold ▁ # 000000" ,  # ▁ class: ▁'gs' <encdom> Generic . Subheading : "bold ▁ # 800080" ,  # ▁ class: ▁'gu' <encdom> Generic . Traceback : "bold ▁ # a40000" ,  # ▁ class: ▁'gt' <encdom> } <newline> <dedent>
from django . http import QueryDict , HttpResponse , HttpResponseRedirect <newline> import gzip <newline> class HttpDataDownloadResponse ( HttpResponse ) : <newline> <indent> fmt = 'csv' <newline> gzipped = True <newline> data = None <newline> def __init__ ( self , data , report , fmt = 'csv' , zipit = True ) : <newline> <indent> if data : <newline> <indent> c_type , download = self . get_mime_type ( fmt ) <newline> fn = report + "." + fmt <newline> if ( zipit ) : <newline> <indent> with gzip . open ( '/tmp/' + fn + '.gz' , 'wb' ) as f : <newline> <indent> f . write ( data ) <newline> <dedent> fn = fn + '.gz' <newline> c_type , download = self . get_mime_type ( 'gzip' ) <newline> with gzip . open ( '/tmp/' + fn + '.gz' , 'wb' ) as f : <newline> <indent> data = f . read ( fn ) <newline> <dedent> <dedent> super ( HttpDataDownloadResponse , self ) . __init__ ( data , content_type = c_type ) <newline> if download : <newline> <indent> self [ 'Content-Disposition' ] = 'attachment; ▁ filename="' + fn + '"' <newline> <dedent> <dedent> else : <newline> <indent> super ( HttpDataDownloadResponse , self ) . __init__ ( 'No ▁ Data' ) <newline> <dedent> <dedent> def get_mime_type ( self , ext ) : <newline> <indent> if ( ext == 'json' ) : <newline> <indent> return 'Content-type: ▁ application/json' , False <newline> <dedent> elif ( ext == 'xml' ) : <newline> <indent> return 'Content-type: ▁ application/xml' , False <newline> <dedent> elif ( ext == 'yaml' ) : <newline> <indent> return 'Content-type: ▁ text/x-yaml' , False <newline> <dedent> elif ( ext == 'csv' ) : <newline> <indent> return 'Content-type: ▁ text/csv' , False <newline> <dedent> elif ( ext == 'gzip' ) : <newline> <indent> return 'Content-type: ▁ application/x-gzip' , True <newline> <dedent> return 'Content-type: ▁ application/octet-stream' , True <newline> <dedent> <dedent>
from __future__ import unicode_literals <newline> import calendar <newline> import datetime <newline> from django . utils . html import avoid_wrapping <newline> from django . utils . timezone import is_aware , utc <newline> from django . utils . translation import ugettext , ungettext_lazy <newline> TIMESINCE_CHUNKS = ( ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d ▁ year' , '%d ▁ years' ) ) , ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d ▁ month' , '%d ▁ months' ) ) , ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d ▁ week' , '%d ▁ weeks' ) ) , ( 60 * 60 * 24 , ungettext_lazy ( '%d ▁ day' , '%d ▁ days' ) ) , ( 60 * 60 , ungettext_lazy ( '%d ▁ hour' , '%d ▁ hours' ) ) , ( 60 , ungettext_lazy ( '%d ▁ minute' , '%d ▁ minutes' ) ) ) <newline> def timesince ( d , now = None , reversed = False ) : <newline> <indent>  """ <strnewline> ▁ Takes ▁ two ▁ datetime ▁ objects ▁ and ▁ returns ▁ the ▁ time ▁ between ▁ d ▁ and ▁ now <strnewline> ▁ as ▁ a ▁ nicely ▁ formatted ▁ string, ▁ e.g. ▁"10 ▁ minutes". ▁ If ▁ d ▁ occurs ▁ after ▁ now, <strnewline> ▁ then ▁"0 ▁ minutes" ▁ is ▁ returned. <strnewline> <strnewline> ▁ Units ▁ used ▁ are ▁ years, ▁ months, ▁ weeks, ▁ days, ▁ hours, ▁ and ▁ minutes. <strnewline> ▁ Seconds ▁ and ▁ microseconds ▁ are ▁ ignored. ▁ Up ▁ to ▁ two ▁ adjacent ▁ units ▁ will ▁ be <strnewline> ▁ displayed. ▁ For ▁ example, ▁"2 ▁ weeks, ▁ 3 ▁ days" ▁ and ▁"1 ▁ year, ▁ 3 ▁ months" ▁ are <strnewline> ▁ possible ▁ outputs, ▁ but ▁"2 ▁ weeks, ▁ 3 ▁ hours" ▁ and ▁"1 ▁ year, ▁ 5 ▁ days" ▁ are ▁ not. <strnewline> <strnewline> ▁ Adapted ▁ from <strnewline> ▁ http://web.archive.org/web/20060617175230/http://blog.natbat.co.uk/archive/2003/Jun/14/time_since <strnewline> ▁ """  <newline>  # ▁ Convert ▁ datetime.date ▁ to ▁ datetime.datetime ▁ for ▁ comparison. <encdom> if not isinstance ( d , datetime . datetime ) : <newline> <indent> d = datetime . datetime ( d . year , d . month , d . day ) <newline> <dedent> if now and not isinstance ( now , datetime . datetime ) : <newline> <indent> now = datetime . datetime ( now . year , now . month , now . day ) <newline> <dedent> if not now : <newline> <indent> now = datetime . datetime . now ( utc if is_aware ( d ) else None ) <newline> <dedent> delta = ( d - now ) if reversed else ( now - d ) <newline>  # ▁ Deal ▁ with ▁ leapyears ▁ by ▁ subtracing ▁ the ▁ number ▁ of ▁ leapdays <encdom> delta -= datetime . timedelta ( calendar . leapdays ( d . year , now . year ) ) <newline>  # ▁ ignore ▁ microseconds <encdom> since = delta . days * 24 * 60 * 60 + delta . seconds <newline> if since <= 0 : <newline>  # ▁ d ▁ is ▁ in ▁ the ▁ future ▁ compared ▁ to ▁ now, ▁ stop ▁ processing. <encdom> <indent> return avoid_wrapping ( ugettext ( '0 ▁ minutes' ) ) <newline> <dedent> for i , ( seconds , name ) in enumerate ( TIMESINCE_CHUNKS ) : <newline> <indent> count = since // seconds <newline> if count != 0 : <newline> <indent> break <newline> <dedent> <dedent> result = avoid_wrapping ( name % count ) <newline> if i + 1 < len ( TIMESINCE_CHUNKS ) : <newline>  # ▁ Now ▁ get ▁ the ▁ second ▁ item <encdom> <indent> seconds2 , name2 = TIMESINCE_CHUNKS [ i + 1 ] <newline> count2 = ( since - ( seconds * count ) ) // seconds2 <newline> if count2 != 0 : <newline> <indent> result += ugettext ( ', ▁ ' ) + avoid_wrapping ( name2 % count2 ) <newline> <dedent> <dedent> return result <newline> <dedent> def timeuntil ( d , now = None ) : <newline> <indent>  """ <strnewline> ▁ Like ▁ timesince, ▁ but ▁ returns ▁ a ▁ string ▁ measuring ▁ the ▁ time ▁ until <strnewline> ▁ the ▁ given ▁ time. <strnewline> ▁ """  <newline> return timesince ( d , now , reversed = True ) <newline> <dedent>
import numpy as np <newline> from itertools import chain , izip <newline> class CTWNode : <newline>  # ▁ Constructor ▁ : ▁ Instances ▁ of ▁ this ▁ class ▁ are ▁ single ▁ nodes ▁ in ▁ the ▁ CTW ▁ tree, ▁ with ▁ pointers ▁ to ▁ parent ▁ node ▁ and ▁ child <encdom>  # ▁ nodes. <encdom> <indent> def __init__ ( self , parent_index , depth ) : <newline> <indent> self . LogProbability = 0  # ▁ Stores ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ data ▁ partition ▁ this ▁ node ▁ has ▁ seen ▁ so ▁ far <encdom> <newline> self . OneCount = 0  # ▁ Stores ▁ the ▁ number ▁ of ▁ 1's ▁ of ▁ the ▁ data ▁ partition ▁ this ▁ node ▁ has ▁ seen ▁ so ▁ far <encdom> <newline> self . ZeroCount = 0  # ▁ Stores ▁ the ▁ number ▁ of ▁ 0's ▁ of ▁ the ▁ data ▁ partition ▁ this ▁ node ▁ has ▁ seen ▁ so ▁ far <encdom> <newline> self . OneChildIndex = - 1  # ▁ The ▁ index ▁ of ▁ the ▁ child ▁ node ▁ when ▁ the ▁ context ▁ splits ▁ on ▁ 1 <encdom> <newline> self . ZeroChildIndex = - 1  # ▁ The ▁ index ▁ of ▁ the ▁ child ▁ node ▁ when ▁ the ▁ context ▁ splits ▁ on ▁ 0 <encdom> <newline> self . ParentNodeIndex = parent_index  # ▁ The ▁ index ▁ of ▁ this ▁ nodes ▁ parent <encdom> <newline> self . Depth = depth  # ▁ The ▁ depth ▁ in ▁ the ▁ tree ▁ of ▁ this ▁ node <encdom> <newline> self . ChildRegister = [ ]  # ▁ Child ▁ nodes ▁ register ▁ there ▁ log ▁ probabilities ▁ here ▁ during ▁ a ▁ recursive ▁ computation ▁ of <encdom> <newline>  # ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ whole ▁ tree <encdom>  # ▁ Prints ▁ the ▁ instance ▁ variables ▁ of ▁ the ▁ node, ▁ used ▁ for ▁ debugging <encdom> <dedent> def print_node ( self ) : <newline> <indent> print ' \n New ▁ Node:' <newline> print 'LogProbability: ▁ ' + np . str ( self . LogProbability ) <newline> print 'OneCount: ▁ ' + np . str ( self . OneCount ) <newline> print 'ZeroCount: ▁ ' + np . str ( self . ZeroCount ) <newline> print 'OneChildIndex: ▁ ' + np . str ( self . OneChildIndex ) <newline> print 'ZeroChildIndex: ▁ ' + np . str ( self . ZeroChildIndex ) <newline> print 'ParentNodeIndex: ▁ ' + np . str ( self . ParentNodeIndex ) <newline> print 'Depth: ▁ ' + np . str ( self . Depth ) <newline> print 'ChildRegister: ▁ ' + np . str ( self . ChildRegister ) <newline>  # ▁ Accessor ▁ for ▁ Depth ▁ property <encdom> <dedent> def get_depth ( self ) : <newline> <indent> return self . Depth <newline>  # ▁ Called ▁ by ▁ child ▁ nodes ▁ during ▁ the ▁ recursive ▁ computation ▁ of ▁ log ▁ probability <encdom> <dedent> def register_log_probability ( self , log_probability ) : <newline> <indent> self . ChildRegister . append ( log_probability ) <newline>  # ▁ Mutator ▁ for ▁ OneChildIndex ▁ property <encdom> <dedent> def register_one_child ( self , one_child_index ) : <newline> <indent> self . OneChildIndex = one_child_index <newline>  # ▁ Mutator ▁ for ▁ ZeroChildIndex ▁ property <encdom> <dedent> def register_zero_child ( self , zero_child_index ) : <newline> <indent> self . ZeroChildIndex = zero_child_index <newline>  # ▁ Updates ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ node ▁ and ▁ increments ▁ the ▁ one ▁ count. ▁ Returns ▁ the ▁ index ▁ of ▁ the ▁ next ▁ node. <encdom> <dedent> def present_one_and_update ( self , cntxt ) : <newline>  # ▁ Update ▁ the ▁ nodes ▁ log ▁ probability ▁ using ▁ KT ▁ estimator <encdom> <indent> self . LogProbability = self . LogProbability + np . log ( self . OneCount + 0.5 ) - np . log ( self . OneCount + self . ZeroCount + 1 ) <newline>  # ▁ Increment ▁ the ▁ nodes ▁ one ▁ count <encdom> self . OneCount += 1 <newline>  # ▁ Return ▁ the ▁ index ▁ of ▁ the ▁ next ▁ child ▁ node ▁ given ▁ the ▁ context ▁ split <encdom> context_bit = cntxt [ self . Depth ] <newline> if context_bit == 1 : <newline> <indent> return self . OneChildIndex <newline> <dedent> else : <newline> <indent> return self . ZeroChildIndex <newline>  # ▁ Updates ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ node ▁ and ▁ increments ▁ the ▁ zero ▁ count. ▁ Returns ▁ the ▁ index ▁ of ▁ the ▁ next ▁ node. <encdom> <dedent> <dedent> def present_zero_and_update ( self , cntxt ) : <newline>  # ▁ Update ▁ the ▁ nodes ▁ log ▁ probability ▁ using ▁ KT ▁ estimator <encdom> <indent> self . LogProbability = self . LogProbability + np . log ( self . ZeroCount + 0.5 ) - np . log ( self . OneCount + self . ZeroCount + 1 ) <newline>  # ▁ Increment ▁ the ▁ nodes ▁ zero ▁ count <encdom> self . ZeroCount += 1 <newline>  # ▁ Return ▁ the ▁ index ▁ of ▁ the ▁ next ▁ child ▁ node ▁ given ▁ the ▁ context ▁ split <encdom> context_bit = cntxt [ self . Depth ] <newline> if context_bit == 1 : <newline> <indent> return self . OneChildIndex <newline> <dedent> else : <newline> <indent> return self . ZeroChildIndex <newline>  # ▁ Computes ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ subtree ▁ under ▁ this ▁ node, ▁ after ▁ the ▁ children ▁ have ▁ registered ▁ there ▁ sub ▁ tree <encdom>  # ▁ log ▁ probabilities. <encdom>  # ▁ Returns ▁ the ▁ value ▁ of ▁ the ▁ log ▁ probability ▁ and ▁ the ▁ index ▁ of ▁ this ▁ nodes ▁ parent. <encdom> <dedent> <dedent> def compute_log_probability ( self ) : <newline>  # ▁ Average ▁ the ▁ probabilities ▁ of ▁ the ▁ child ▁ nodes ▁ and ▁ this ▁ node <encdom> <indent> pass_value = np . logaddexp ( np . log ( 0.5 ) + self . LogProbability , np . log ( 0.5 ) + sum ( self . ChildRegister ) ) <newline>  # ▁ Reset ▁ the ▁ log ▁ probability ▁ register <encdom> self . ChildRegister = [ ] <newline>  # ▁ Return ▁ the ▁ log ▁ probability ▁ of ▁ this ▁ nodes ▁ subtree ▁ and ▁ this ▁ nodes ▁ parent ▁ index ▁ for ▁ registering <encdom> return ( [ pass_value , self . ParentNodeIndex ] ) <newline> <dedent> <dedent> class CTW : <newline>  # ▁ Constructor ▁ : ▁ This ▁ class ▁ implements ▁ the ▁ context ▁ tree ▁ weighting ▁ algorithm. ▁ There ▁ are ▁ methods ▁ to ▁ update ▁ the ▁ model <encdom>  # ▁ with ▁ strings ▁ with ▁ or ▁ without ▁ side ▁ information, ▁ and ▁ get ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ whole ▁ model. <encdom> <indent> def __init__ ( self , max_depth ) : <newline> <indent> self . MaxDepth = max_depth  # ▁ The ▁ context ▁ length ▁ that ▁ is ▁ used ▁ (maximum ▁ order ▁ of ▁ markov ▁ model) <encdom> <newline> self . NodeList = [ CTWNode ( - 1 , 0 ) ]  # ▁ Stores ▁ the ▁ trees ▁ nodes ▁ that ▁ have ▁ been ▁ instantiated <encdom> <newline>  # ▁ Prints ▁ the ▁ instance ▁ variables ▁ of ▁ all ▁ the ▁ nodes ▁ of ▁ the ▁ tree <encdom> <dedent> def print_tree ( self ) : <newline> <indent> print 'MaxDepth: ▁ ' + np . str ( self . MaxDepth ) <newline> for x in self . NodeList : <newline> <indent> x . print_node ( ) <newline>  # ▁ Recursively ▁ compute ▁ the ▁ log ▁ probability ▁ of ▁ the ▁ entire ▁ tree <encdom> <dedent> <dedent> def compute_log_probability ( self ) : <newline>  # ▁ Starting ▁ with ▁ leaves, ▁ register ▁ each ▁ nodes ▁ log ▁ probability ▁ with ▁ it's ▁ parent <encdom> <indent> for x in reversed ( self . NodeList ) : <newline> <indent> [ pass_value , parent_node_index ] = x . compute_log_probability ( ) <newline> if parent_node_index >= 0 : <newline> <indent> self . NodeList [ parent_node_index ] . register_log_probability ( pass_value ) <newline> <dedent> <dedent> return pass_value <newline>  # ▁ Update ▁ the ▁ model ▁ with ▁ a ▁ string ▁ to ▁ model, ▁ and ▁ a ▁ side ▁ information ▁ string ▁ of ▁ the ▁ same ▁ length <encdom> <dedent> def present_bit_string_and_update_with_side_information ( self , bit_string , side_information ) : <newline> <indent> for index in enumerate ( bit_string , start = self . MaxDepth ) : <newline> <indent> if index [ 0 ] + 1 >= len ( bit_string ) : <newline> <indent> break <newline> <dedent> cntxt = list ( chain . from_iterable ( izip ( bit_string [ index [ 0 ] - self . MaxDepth : index [ 0 ] ] , side_information [ ( index [ 0 ] + 1 ) - self . MaxDepth : ( index [ 0 ] + 1 ) ] ) ) ) <newline> if bit_string [ index [ 0 ] ] == 1 : <newline> <indent> self . present_one_and_update_in_context ( cntxt ) <newline> <dedent> else : <newline> <indent> self . present_zero_and_update_in_context ( cntxt ) <newline>  # ▁ Update ▁ the ▁ model ▁ with ▁ a ▁ string ▁ to ▁ model <encdom> <dedent> <dedent> <dedent> def present_bit_string_and_update ( self , bit_string ) : <newline> <indent> for index in enumerate ( bit_string , start = self . MaxDepth ) : <newline> <indent> if index [ 0 ] + 1 >= len ( bit_string ) : <newline> <indent> break <newline> <dedent> if bit_string [ index [ 0 ] + 1 ] == 1 : <newline> <indent> self . present_one_and_update_in_context ( bit_string [ index [ 0 ] - self . MaxDepth : index [ 0 ] ] ) <newline> <dedent> else : <newline> <indent> self . present_zero_and_update_in_context ( bit_string [ index [ 0 ] - self . MaxDepth : index [ 0 ] ] ) <newline>  # ▁ Called ▁ if ▁ current ▁ target ▁ bit ▁ is ▁ a ▁ one. ▁'cntxt' ▁ is ▁ the ▁ bit ▁ string ▁ context ▁ of ▁ the ▁ target. <encdom>  # ▁ Recursively ▁ updates ▁ / ▁ dynamically ▁ adds ▁ nodes ▁ to ▁ the ▁ tree ▁ with ▁ this ▁ information. <encdom> <dedent> <dedent> <dedent> def present_one_and_update_in_context ( self , cntxt ) : <newline> <indent> temp_cntxt = cntxt [ : : - 1 ] <newline> not_done = 1 <newline> index = 0 <newline> count = 0 <newline> while not_done == 1 : <newline> <indent> if count >= self . MaxDepth : <newline> <indent> break <newline> <dedent> next_index = self . NodeList [ index ] . present_one_and_update ( temp_cntxt ) <newline> if next_index >= 0 : <newline> <indent> index = next_index <newline> <dedent> elif ( next_index == - 1 ) and ( self . NodeList [ index ] . get_depth ( ) < self . MaxDepth ) : <newline> <indent> self . NodeList . append ( CTWNode ( index , self . NodeList [ index ] . get_depth ( ) + 1 ) ) <newline> if temp_cntxt [ count ] == 1 : <newline> <indent> self . NodeList [ index ] . register_one_child ( len ( self . NodeList ) - 1 ) <newline> <dedent> else : <newline> <indent> self . NodeList [ index ] . register_zero_child ( len ( self . NodeList ) - 1 ) <newline> <dedent> index = self . NodeList . __len__ ( ) - 1 <newline> <dedent> else : <newline> <indent> not_done = 0 <newline> <dedent> count += 1 <newline>  # ▁ Called ▁ if ▁ current ▁ target ▁ bit ▁ is ▁ a ▁ zero. ▁'cntxt' ▁ is ▁ the ▁ bit ▁ string ▁ context ▁ of ▁ the ▁ target. <encdom>  # ▁ Recursively ▁ updates ▁ / ▁ dynamically ▁ adds ▁ nodes ▁ to ▁ the ▁ tree ▁ with ▁ this ▁ information. <encdom> <dedent> <dedent> def present_zero_and_update_in_context ( self , cntxt ) : <newline> <indent> temp_cntxt = cntxt [ : : - 1 ] <newline> not_done = 1 <newline> index = 0 <newline> count = 0 <newline> while not_done == 1 : <newline> <indent> if count >= self . MaxDepth : <newline> <indent> break <newline> <dedent> next_index = self . NodeList [ index ] . present_zero_and_update ( temp_cntxt ) <newline> if next_index >= 0 : <newline> <indent> index = next_index <newline> <dedent> elif ( next_index == - 1 ) and ( self . NodeList [ index ] . get_depth ( ) < self . MaxDepth ) : <newline> <indent> self . NodeList . append ( CTWNode ( index , self . NodeList [ index ] . get_depth ( ) + 1 ) ) <newline> if temp_cntxt [ count ] == 1 : <newline> <indent> self . NodeList [ index ] . register_one_child ( len ( self . NodeList ) - 1 ) <newline> <dedent> else : <newline> <indent> self . NodeList [ index ] . register_zero_child ( len ( self . NodeList ) - 1 ) <newline> <dedent> index = self . NodeList . __len__ ( ) - 1 <newline> <dedent> else : <newline> <indent> not_done = 0 <newline> <dedent> count += 1 <newline> <dedent> <dedent> <dedent>
 # ▁ Copyright ▁ (c) ▁ The ▁ AcidSWF ▁ Project. <encdom>  # ▁ See ▁ LICENSE.txt ▁ for ▁ details. <encdom> from setuptools import setup , find_packages <newline> setup ( name = "AcidSWF" , version = "1.0" , packages = find_packages ( ) , install_requires = [ 'Twisted>=10.0' ] , author = "AcidSWF ▁ Project" , author_email = "info@collab.nl" , description = "Tools ▁ to ▁ test ▁ open ▁ source ▁ implementations ▁ of ▁ " "Flash ▁ Player ▁ protocols ▁ and ▁ formats ▁ like ▁ AMF ▁ and ▁ RTMP" , license = "GPLv3" , keywords = "amf ▁ rtmp ▁ pyamf ▁ rtmpy" , url = "http://github.com/thijstriemstra/acidswf" , ) <newline>
class A ( object ) : <newline> <indent> __X = 1 <newline> <dedent> a = A ( ) <newline> a . _ < ref > _X  # ▁ must ▁ fail <encdom> <newline>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ OpenERP, ▁ Open ▁ Source ▁ Management ▁ Solution <encdom>  # ▁ Copyright ▁ (C) ▁ 2004-today ▁ OpenERP ▁ SA ▁ (<http://www.openerp.com>) <encdom>  # ▁ This ▁ program ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <encdom>  # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as <encdom>  # ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the <encdom>  # ▁ License, ▁ or ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <encdom>  # ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License <encdom>  # ▁ along ▁ with ▁ this ▁ program. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <encdom> import crm <newline> from datetime import datetime <newline> from operator import itemgetter <newline> import openerp <newline> from openerp import SUPERUSER_ID <newline> from openerp import tools <newline> from openerp . addons . base . res . res_partner import format_address <newline> from openerp . osv import fields , osv , orm <newline> from openerp . tools . translate import _ <newline> from openerp . tools import email_re , email_split <newline> CRM_LEAD_FIELDS_TO_MERGE = [ 'name' , 'partner_id' , 'campaign_id' , 'company_id' , 'country_id' , 'section_id' , 'state_id' , 'stage_id' , 'medium_id' , 'source_id' , 'user_id' , 'title' , 'city' , 'contact_name' , 'description' , 'email' , 'fax' , 'mobile' , 'partner_name' , 'phone' , 'probability' , 'planned_revenue' , 'street' , 'street2' , 'zip' , 'create_date' , 'date_action_last' , 'date_action_next' , 'email_from' , 'email_cc' , 'partner_name' ] <newline> class crm_lead ( format_address , osv . osv ) : <newline> <indent>  """ ▁ CRM ▁ Lead ▁ Case ▁ """  <newline> _name = "crm.lead" <newline> _description = "Lead/Opportunity" <newline> _order = "priority ▁ desc,date_action,id ▁ desc" <newline> _inherit = [ 'mail.thread' , 'ir.needaction_mixin' , 'crm.tracking.mixin' ] <newline> _track = { 'stage_id' : {  # ▁ this ▁ is ▁ only ▁ an ▁ heuristics; ▁ depending ▁ on ▁ your ▁ particular ▁ stage ▁ configuration ▁ it ▁ may ▁ not ▁ match ▁ all ▁'new' ▁ stages <encdom> 'crm.mt_lead_create' : lambda self , cr , uid , obj , ctx = None : obj . probability == 0 and obj . stage_id and obj . stage_id . sequence <= 1 , 'crm.mt_lead_stage' : lambda self , cr , uid , obj , ctx = None : ( obj . stage_id and obj . stage_id . sequence > 1 ) and obj . probability < 100 , 'crm.mt_lead_won' : lambda self , cr , uid , obj , ctx = None : obj . probability == 100 and obj . stage_id and obj . stage_id . fold , 'crm.mt_lead_lost' : lambda self , cr , uid , obj , ctx = None : obj . probability == 0 and obj . stage_id and obj . stage_id . fold and obj . stage_id . sequence > 1 , } , } <newline> _mail_mass_mailing = _ ( 'Leads ▁ / ▁ Opportunities' ) <newline> def get_empty_list_help ( self , cr , uid , help , context = None ) : <newline> <indent> context = dict ( context or { } ) <newline> if context . get ( 'default_type' ) == 'lead' : <newline> <indent> context [ 'empty_list_help_model' ] = 'crm.case.section' <newline> context [ 'empty_list_help_id' ] = context . get ( 'default_section_id' ) <newline> <dedent> context [ 'empty_list_help_document_name' ] = _ ( "leads" ) <newline> return super ( crm_lead , self ) . get_empty_list_help ( cr , uid , help , context = context ) <newline> <dedent> def _get_default_section_id ( self , cr , uid , user_id = False , context = None ) : <newline> <indent>  """ ▁ Gives ▁ default ▁ section ▁ by ▁ checking ▁ if ▁ present ▁ in ▁ the ▁ context ▁ """  <newline> section_id = self . _resolve_section_id_from_context ( cr , uid , context = context ) or False <newline> if not section_id : <newline> <indent> section_id = self . pool . get ( 'res.users' ) . browse ( cr , uid , user_id or uid , context ) . default_section_id . id or False <newline> <dedent> return section_id <newline> <dedent> def _get_default_stage_id ( self , cr , uid , context = None ) : <newline> <indent>  """ ▁ Gives ▁ default ▁ stage_id ▁ """  <newline> section_id = self . _get_default_section_id ( cr , uid , context = context ) <newline> return self . stage_find ( cr , uid , [ ] , section_id , [ ( 'fold' , '=' , False ) ] , context = context ) <newline> <dedent> def _resolve_section_id_from_context ( self , cr , uid , context = None ) : <newline> <indent>  """ ▁ Returns ▁ ID ▁ of ▁ section ▁ based ▁ on ▁ the ▁ value ▁ of ▁'section_id' <strnewline> ▁ context ▁ key, ▁ or ▁ None ▁ if ▁ it ▁ cannot ▁ be ▁ resolved ▁ to ▁ a ▁ single <strnewline> ▁ Sales ▁ Team. <strnewline> ▁ """  <newline> if context is None : <newline> <indent> context = { } <newline> <dedent> if type ( context . get ( 'default_section_id' ) ) in ( int , long ) : <newline> <indent> return context . get ( 'default_section_id' ) <newline> <dedent> if isinstance ( context . get ( 'default_section_id' ) , basestring ) : <newline> <indent> section_ids = self . pool . get ( 'crm.case.section' ) . name_search ( cr , uid , name = context [ 'default_section_id' ] , context = context ) <newline> if len ( section_ids ) == 1 : <newline> <indent> return int ( section_ids [ 0 ] [ 0 ] ) <newline> <dedent> <dedent> return None <newline> <dedent> def _resolve_type_from_context ( self , cr , uid , context = None ) : <newline> <indent>  """ ▁ Returns ▁ the ▁ type ▁ (lead ▁ or ▁ opportunity) ▁ from ▁ the ▁ type ▁ context <strnewline> ▁ key. ▁ Returns ▁ None ▁ if ▁ it ▁ cannot ▁ be ▁ resolved. <strnewline> ▁ """  <newline> if context is None : <newline> <indent> context = { } <newline> <dedent> return context . get ( 'default_type' ) <newline> <dedent> def _read_group_stage_ids ( self , cr , uid , ids , domain , read_group_order = None , access_rights_uid = None , context = None ) : <newline> <indent> access_rights_uid = access_rights_uid or uid <newline> stage_obj = self . pool . get ( 'crm.case.stage' ) <newline> order = stage_obj . _order <newline>  # ▁ lame ▁ hack ▁ to ▁ allow ▁ reverting ▁ search, ▁ should ▁ just ▁ work ▁ in ▁ the ▁ trivial ▁ case <encdom> if read_group_order == 'stage_id ▁ desc' : <newline> <indent> order = "%s ▁ desc" % order <newline>  # ▁ retrieve ▁ section_id ▁ from ▁ the ▁ context ▁ and ▁ write ▁ the ▁ domain <encdom>  # ▁ - ▁ ('id', ▁'in', ▁'ids'): ▁ add ▁ columns ▁ that ▁ should ▁ be ▁ present <encdom>  # ▁ - ▁ OR ▁ ('case_default', ▁'=', ▁ True), ▁ ('fold', ▁'=', ▁ False): ▁ add ▁ default ▁ columns ▁ that ▁ are ▁ not ▁ folded <encdom>  # ▁ - ▁ OR ▁ ('section_ids', ▁'=', ▁ section_id), ▁ ('fold', ▁'=', ▁ False) ▁ if ▁ section_id: ▁ add ▁ section ▁ columns ▁ that ▁ are ▁ not ▁ folded <encdom> <dedent> search_domain = [ ] <newline> section_id = self . _resolve_section_id_from_context ( cr , uid , context = context ) <newline> if section_id : <newline> <indent> search_domain += [ '|' , ( 'section_ids' , '=' , section_id ) ] <newline> search_domain += [ ( 'id' , 'in' , ids ) ] <newline> <dedent> else : <newline> <indent> search_domain += [ '|' , ( 'id' , 'in' , ids ) , ( 'case_default' , '=' , True ) ] <newline>  # ▁ retrieve ▁ type ▁ from ▁ the ▁ context ▁ (if ▁ set: ▁ choose ▁'type' ▁ or ▁'both') <encdom> <dedent> type = self . _resolve_type_from_context ( cr , uid , context = context ) <newline> if type : <newline> <indent> search_domain += [ '|' , ( 'type' , '=' , type ) , ( 'type' , '=' , 'both' ) ] <newline>  # ▁ perform ▁ search <encdom> <dedent> stage_ids = stage_obj . _search ( cr , uid , search_domain , order = order , access_rights_uid = access_rights_uid , context = context ) <newline> result = stage_obj . name_get ( cr , access_rights_uid , stage_ids , context = context ) <newline>  # ▁ restore ▁ order ▁ of ▁ the ▁ search <encdom> result . sort ( lambda x , y : cmp ( stage_ids . index ( x [ 0 ] ) , stage_ids . index ( y [ 0 ] ) ) ) <newline> fold = { } <newline> for stage in stage_obj . browse ( cr , access_rights_uid , stage_ids , context = context ) : <newline> <indent> fold [ stage . id ] = stage . fold or False <newline> <dedent> return result , fold <newline> <dedent> def fields_view_get ( self , cr , user , view_id = None , view_type = 'form' , context = None , toolbar = False , submenu = False ) : <newline> <indent> if context and context . get ( 'opportunity_id' ) : <newline> <indent> action = self . get_formview_action ( cr , user , context [ 'opportunity_id' ] , context = context ) <newline> if action . get ( 'views' ) and any ( view_id for view_id in action [ 'views' ] if view_id [ 1 ] == view_type ) : <newline> <indent> view_id = next ( view_id [ 0 ] for view_id in action [ 'views' ] if view_id [ 1 ] == view_type ) <newline> <dedent> <dedent> res = super ( crm_lead , self ) . fields_view_get ( cr , user , view_id , view_type , context , toolbar = toolbar , submenu = submenu ) <newline> if view_type == 'form' : <newline> <indent> res [ 'arch' ] = self . fields_view_get_address ( cr , user , res [ 'arch' ] , context = context ) <newline> <dedent> return res <newline> <dedent> _group_by_full = { 'stage_id' : _read_group_stage_ids } <newline> def _compute_day ( self , cr , uid , ids , fields , args , context = None ) : <newline> <indent>  """ <strnewline> ▁ :return ▁ dict: ▁ difference ▁ between ▁ current ▁ date ▁ and ▁ log ▁ date <strnewline> ▁ """  <newline> res = { } <newline> for lead in self . browse ( cr , uid , ids , context = context ) : <newline> <indent> for field in fields : <newline> <indent> res [ lead . id ] = { } <newline> duration = 0 <newline> ans = False <newline> if field == 'day_open' : <newline> <indent> if lead . date_open : <newline> <indent> date_create = datetime . strptime ( lead . create_date , "%Y-%m-%d ▁ %H:%M:%S" ) <newline> date_open = datetime . strptime ( lead . date_open , "%Y-%m-%d ▁ %H:%M:%S" ) <newline> ans = date_open - date_create <newline> <dedent> <dedent> elif field == 'day_close' : <newline> <indent> if lead . date_closed : <newline> <indent> date_create = datetime . strptime ( lead . create_date , "%Y-%m-%d ▁ %H:%M:%S" ) <newline> date_close = datetime . strptime ( lead . date_closed , "%Y-%m-%d ▁ %H:%M:%S" ) <newline> ans = date_close - date_create <newline> <dedent> <dedent> if ans : <newline> <indent> duration = abs ( int ( ans . days ) ) <newline> <dedent> res [ lead . id ] [ field ] = duration <newline> <dedent> <dedent> return res <newline> <dedent> def _meeting_count ( self , cr , uid , ids , field_name , arg , context = None ) : <newline> <indent> Event = self . pool [ 'calendar.event' ] <newline> return { opp_id : Event . search_count ( cr , uid , [ ( 'opportunity_id' , '=' , opp_id ) ] , context = context ) for opp_id in ids } <newline> <dedent> _columns = { 'partner_id' : fields . many2one ( 'res.partner' , 'Partner' , ondelete = 'set ▁ null' , track_visibility = 'onchange' , select = True , help = "Linked ▁ partner ▁ (optional). ▁ Usually ▁ created ▁ when ▁ converting ▁ the ▁ lead." ) , 'id' : fields . integer ( 'ID' , readonly = True ) , 'name' : fields . char ( 'Subject' , required = True , select = 1 ) , 'active' : fields . boolean ( 'Active' , required = False ) , 'date_action_last' : fields . datetime ( 'Last ▁ Action' , readonly = 1 ) , 'date_action_next' : fields . datetime ( 'Next ▁ Action' , readonly = 1 ) , 'email_from' : fields . char ( 'Email' , size = 128 , help = "Email ▁ address ▁ of ▁ the ▁ contact" , select = 1 ) , 'section_id' : fields . many2one ( 'crm.case.section' , 'Sales ▁ Team' , select = True , track_visibility = 'onchange' , help = 'When ▁ sending ▁ mails, ▁ the ▁ default ▁ email ▁ address ▁ is ▁ taken ▁ from ▁ the ▁ sales ▁ team.' ) , 'create_date' : fields . datetime ( 'Creation ▁ Date' , readonly = True ) , 'email_cc' : fields . text ( 'Global ▁ CC' , help = "These ▁ email ▁ addresses ▁ will ▁ be ▁ added ▁ to ▁ the ▁ CC ▁ field ▁ of ▁ all ▁ inbound ▁ and ▁ outbound ▁ emails ▁ for ▁ this ▁ record ▁ before ▁ being ▁ sent. ▁ Separate ▁ multiple ▁ email ▁ addresses ▁ with ▁ a ▁ comma" ) , 'description' : fields . text ( 'Notes' ) , 'write_date' : fields . datetime ( 'Update ▁ Date' , readonly = True ) , 'categ_ids' : fields . many2many ( 'crm.case.categ' , 'crm_lead_category_rel' , 'lead_id' , 'category_id' , 'Tags' , domain = "['|', ▁ ('section_id', ▁'=', ▁ section_id), ▁ ('section_id', ▁'=', ▁ False), ▁ ('object_id.model', ▁'=', ▁'crm.lead')]" , help = "Classify ▁ and ▁ analyze ▁ your ▁ lead/opportunity ▁ categories ▁ like: ▁ Training, ▁ Service" ) , 'contact_name' : fields . char ( 'Contact ▁ Name' , size = 64 ) , 'partner_name' : fields . char ( "Customer ▁ Name" , size = 64 , help = 'The ▁ name ▁ of ▁ the ▁ future ▁ partner ▁ company ▁ that ▁ will ▁ be ▁ created ▁ while ▁ converting ▁ the ▁ lead ▁ into ▁ opportunity' , select = 1 ) , 'opt_out' : fields . boolean ( 'Opt-Out' , oldname = 'optout' , help = "If ▁ opt-out ▁ is ▁ checked, ▁ this ▁ contact ▁ has ▁ refused ▁ to ▁ receive ▁ emails ▁ for ▁ mass ▁ mailing ▁ and ▁ marketing ▁ campaign. ▁ " "Filter ▁'Available ▁ for ▁ Mass ▁ Mailing' ▁ allows ▁ users ▁ to ▁ filter ▁ the ▁ leads ▁ when ▁ performing ▁ mass ▁ mailing." ) , 'type' : fields . selection ( [ ( 'lead' , 'Lead' ) , ( 'opportunity' , 'Opportunity' ) , ] , 'Type' , select = True , help = "Type ▁ is ▁ used ▁ to ▁ separate ▁ Leads ▁ and ▁ Opportunities" ) , 'priority' : fields . selection ( crm . AVAILABLE_PRIORITIES , 'Priority' , select = True ) , 'date_closed' : fields . datetime ( 'Closed' , readonly = True , copy = False ) , 'stage_id' : fields . many2one ( 'crm.case.stage' , 'Stage' , track_visibility = 'onchange' , select = True , domain = "['&', ▁ ('section_ids', ▁'=', ▁ section_id), ▁'|', ▁ ('type', ▁'=', ▁ type), ▁ ('type', ▁'=', ▁'both')]" ) , 'user_id' : fields . many2one ( 'res.users' , 'Salesperson' , select = True , track_visibility = 'onchange' ) , 'referred' : fields . char ( 'Referred ▁ By' ) , 'date_open' : fields . datetime ( 'Assigned' , readonly = True ) , 'day_open' : fields . function ( _compute_day , string = 'Days ▁ to ▁ Assign' , multi = 'day_open' , type = "float" , store = { 'crm.lead' : ( lambda self , cr , uid , ids , c = { } : ids , [ 'date_open' ] , 10 ) } ) , 'day_close' : fields . function ( _compute_day , string = 'Days ▁ to ▁ Close' , multi = 'day_open' , type = "float" , store = { 'crm.lead' : ( lambda self , cr , uid , ids , c = { } : ids , [ 'date_closed' ] , 10 ) } ) , 'date_last_stage_update' : fields . datetime ( 'Last ▁ Stage ▁ Update' , select = True ) ,  # ▁ Messaging ▁ and ▁ marketing <encdom> 'message_bounce' : fields . integer ( 'Bounce' ) ,  # ▁ Only ▁ used ▁ for ▁ type ▁ opportunity <encdom> 'probability' : fields . float ( 'Success ▁ Rate ▁ (%)' , group_operator = "avg" ) , 'planned_revenue' : fields . float ( 'Expected ▁ Revenue' , track_visibility = 'always' ) , 'ref' : fields . reference ( 'Reference' , selection = openerp . addons . base . res . res_request . referencable_models ) , 'ref2' : fields . reference ( 'Reference ▁ 2' , selection = openerp . addons . base . res . res_request . referencable_models ) , 'phone' : fields . char ( "Phone" , size = 64 ) , 'date_deadline' : fields . date ( 'Expected ▁ Closing' , help = "Estimate ▁ of ▁ the ▁ date ▁ on ▁ which ▁ the ▁ opportunity ▁ will ▁ be ▁ won." ) , 'date_action' : fields . date ( 'Next ▁ Action ▁ Date' , select = True ) , 'title_action' : fields . char ( 'Next ▁ Action' ) , 'color' : fields . integer ( 'Color ▁ Index' ) , 'partner_address_name' : fields . related ( 'partner_id' , 'name' , type = 'char' , string = 'Partner ▁ Contact ▁ Name' , readonly = True ) , 'partner_address_email' : fields . related ( 'partner_id' , 'email' , type = 'char' , string = 'Partner ▁ Contact ▁ Email' , readonly = True ) , 'company_currency' : fields . related ( 'company_id' , 'currency_id' , type = 'many2one' , string = 'Currency' , readonly = True , relation = "res.currency" ) , 'user_email' : fields . related ( 'user_id' , 'email' , type = 'char' , string = 'User ▁ Email' , readonly = True ) , 'user_login' : fields . related ( 'user_id' , 'login' , type = 'char' , string = 'User ▁ Login' , readonly = True ) ,  # ▁ Fields ▁ for ▁ address, ▁ due ▁ to ▁ separation ▁ from ▁ crm ▁ and ▁ res.partner <encdom> 'street' : fields . char ( 'Street' ) , 'street2' : fields . char ( 'Street2' ) , 'zip' : fields . char ( 'Zip' , change_default = True , size = 24 ) , 'city' : fields . char ( 'City' ) , 'state_id' : fields . many2one ( "res.country.state" , 'State' ) , 'country_id' : fields . many2one ( 'res.country' , 'Country' ) , 'phone' : fields . char ( 'Phone' ) , 'fax' : fields . char ( 'Fax' ) , 'mobile' : fields . char ( 'Mobile' ) , 'function' : fields . char ( 'Function' ) , 'title' : fields . many2one ( 'res.partner.title' , 'Title' ) , 'company_id' : fields . many2one ( 'res.company' , 'Company' , select = 1 ) , 'payment_mode' : fields . many2one ( 'crm.payment.mode' , 'Payment ▁ Mode' , domain = "[('section_id','=',section_id)]" ) , 'planned_cost' : fields . float ( 'Planned ▁ Costs' ) , 'meeting_count' : fields . function ( _meeting_count , string = ' # ▁ Meetings' , type = 'integer' ) , } <newline> _defaults = { 'active' : 1 , 'type' : 'lead' , 'user_id' : lambda s , cr , uid , c : uid , 'stage_id' : lambda s , cr , uid , c : s . _get_default_stage_id ( cr , uid , c ) , 'section_id' : lambda s , cr , uid , c : s . _get_default_section_id ( cr , uid , context = c ) , 'company_id' : lambda s , cr , uid , c : s . pool . get ( 'res.company' ) . _company_default_get ( cr , uid , 'crm.lead' , context = c ) , 'priority' : lambda * a : crm . AVAILABLE_PRIORITIES [ 2 ] [ 0 ] , 'color' : 0 , 'date_last_stage_update' : fields . datetime . now , } <newline> _sql_constraints = [ ( 'check_probability' , 'check(probability ▁ >= ▁ 0 ▁ and ▁ probability ▁ <= ▁ 100)' , 'The ▁ probability ▁ of ▁ closing ▁ the ▁ deal ▁ should ▁ be ▁ between ▁ 0% ▁ and ▁ 100%!' ) ] <newline> def onchange_stage_id ( self , cr , uid , ids , stage_id , context = None ) : <newline> <indent> if not stage_id : <newline> <indent> return { 'value' : { } } <newline> <dedent> stage = self . pool . get ( 'crm.case.stage' ) . browse ( cr , uid , stage_id , context = context ) <newline> if not stage . on_change : <newline> <indent> return { 'value' : { } } <newline> <dedent> vals = { 'probability' : stage . probability } <newline> if stage . probability >= 100 or ( stage . probability == 0 and stage . sequence > 1 ) : <newline> <indent> vals [ 'date_closed' ] = fields . datetime . now ( ) <newline> <dedent> return { 'value' : vals } <newline> <dedent> def on_change_partner_id ( self , cr , uid , ids , partner_id , context = None ) : <newline> <indent> values = { } <newline> if partner_id : <newline> <indent> partner = self . pool . get ( 'res.partner' ) . browse ( cr , uid , partner_id , context = context ) <newline> partner_name = ( partner . parent_id and partner . parent_id . name ) or ( partner . is_company and partner . name ) or False <newline> values = { 'partner_name' : partner_name , 'contact_name' : ( not partner . is_company and partner . name ) or False , 'title' : partner . title and partner . title . id or False , 'street' : partner . street , 'street2' : partner . street2 , 'city' : partner . city , 'state_id' : partner . state_id and partner . state_id . id or False , 'country_id' : partner . country_id and partner . country_id . id or False , 'email_from' : partner . email , 'phone' : partner . phone , 'mobile' : partner . mobile , 'fax' : partner . fax , 'zip' : partner . zip , 'function' : partner . function , } <newline> <dedent> return { 'value' : values } <newline> <dedent> def on_change_user ( self , cr , uid , ids , user_id , context = None ) : <newline> <indent>  """ ▁ When ▁ changing ▁ the ▁ user, ▁ also ▁ set ▁ a ▁ section_id ▁ or ▁ restrict ▁ section ▁ id <strnewline> ▁ to ▁ the ▁ ones ▁ user_id ▁ is ▁ member ▁ of. ▁ """  <newline> section_id = self . _get_default_section_id ( cr , uid , user_id = user_id , context = context ) or False <newline> if user_id and self . pool [ 'res.users' ] . has_group ( cr , uid , 'base.group_multi_salesteams' ) and not section_id : <newline> <indent> section_ids = self . pool . get ( 'crm.case.section' ) . search ( cr , uid , [ '|' , ( 'user_id' , '=' , user_id ) , ( 'member_ids' , '=' , user_id ) ] , context = context ) <newline> if section_ids : <newline> <indent> section_id = section_ids [ 0 ] <newline> <dedent> <dedent> return { 'value' : { 'section_id' : section_id } } <newline> <dedent> def stage_find ( self , cr , uid , cases , section_id , domain = None , order = 'sequence' , context = None ) : <newline> <indent>  """ ▁ Override ▁ of ▁ the ▁ base.stage ▁ method <strnewline> ▁ Parameter ▁ of ▁ the ▁ stage ▁ search ▁ taken ▁ from ▁ the ▁ lead: <strnewline> ▁ - ▁ type: ▁ stage ▁ type ▁ must ▁ be ▁ the ▁ same ▁ or ▁'both' <strnewline> ▁ - ▁ section_id: ▁ if ▁ set, ▁ stages ▁ must ▁ belong ▁ to ▁ this ▁ section ▁ or <strnewline> ▁ be ▁ a ▁ default ▁ stage; ▁ if ▁ not ▁ set, ▁ stages ▁ must ▁ be ▁ default <strnewline> ▁ stages <strnewline> ▁ """  <newline> if isinstance ( cases , ( int , long ) ) : <newline> <indent> cases = self . browse ( cr , uid , cases , context = context ) <newline> <dedent> if context is None : <newline> <indent> context = { } <newline>  # ▁ check ▁ whether ▁ we ▁ should ▁ try ▁ to ▁ add ▁ a ▁ condition ▁ on ▁ type <encdom> <dedent> avoid_add_type_term = any ( [ term for term in domain if len ( term ) == 3 if term [ 0 ] == 'type' ] ) <newline>  # ▁ collect ▁ all ▁ section_ids <encdom> section_ids = set ( ) <newline> types = [ 'both' ] <newline> if not cases and context . get ( 'default_type' ) : <newline> <indent> ctx_type = context . get ( 'default_type' ) <newline> types += [ ctx_type ] <newline> <dedent> if section_id : <newline> <indent> section_ids . add ( section_id ) <newline> <dedent> for lead in cases : <newline> <indent> if lead . section_id : <newline> <indent> section_ids . add ( lead . section_id . id ) <newline> <dedent> if lead . type not in types : <newline> <indent> types . append ( lead . type ) <newline>  # ▁ OR ▁ all ▁ section_ids ▁ and ▁ OR ▁ with ▁ case_default <encdom> <dedent> <dedent> search_domain = [ ] <newline> if section_ids : <newline> <indent> search_domain += [ ( '|' ) ] * len ( section_ids ) <newline> for section_id in section_ids : <newline> <indent> search_domain . append ( ( 'section_ids' , '=' , section_id ) ) <newline> <dedent> <dedent> search_domain . append ( ( 'case_default' , '=' , True ) ) <newline>  # ▁ AND ▁ with ▁ cases ▁ types <encdom> if not avoid_add_type_term : <newline> <indent> search_domain . append ( ( 'type' , 'in' , types ) ) <newline>  # ▁ AND ▁ with ▁ the ▁ domain ▁ in ▁ parameter <encdom> <dedent> search_domain += list ( domain ) <newline>  # ▁ perform ▁ search, ▁ return ▁ the ▁ first ▁ found <encdom> stage_ids = self . pool . get ( 'crm.case.stage' ) . search ( cr , uid , search_domain , order = order , limit = 1 , context = context ) <newline> if stage_ids : <newline> <indent> return stage_ids [ 0 ] <newline> <dedent> return False <newline> <dedent> def case_mark_lost ( self , cr , uid , ids , context = None ) : <newline> <indent>  """ ▁ Mark ▁ the ▁ case ▁ as ▁ lost: ▁ state=cancel ▁ and ▁ probability=0 <strnewline> ▁ """  <newline> stages_leads = { } <newline> for lead in self . browse ( cr , uid , ids , context = context ) : <newline> <indent> stage_id = self . stage_find ( cr , uid , [ lead ] , lead . section_id . id or False , [ ( 'probability' , '=' , 0.0 ) , ( 'on_change' , '=' , True ) , ( 'sequence' , '>' , 1 ) ] , context = context ) <newline> if stage_id : <newline> <indent> if stages_leads . get ( stage_id ) : <newline> <indent> stages_leads [ stage_id ] . append ( lead . id ) <newline> <dedent> else : <newline> <indent> stages_leads [ stage_id ] = [ lead . id ] <newline> <dedent> <dedent> else : <newline> <indent> raise osv . except_osv ( _ ( 'Warning!' ) , _ ( 'To ▁ relieve ▁ your ▁ sales ▁ pipe ▁ and ▁ group ▁ all ▁ Lost ▁ opportunities, ▁ configure ▁ one ▁ of ▁ your ▁ sales ▁ stage ▁ as ▁ follow: \n ' 'probability ▁ = ▁ 0 ▁ %, ▁ select ▁"Change ▁ Probability ▁ Automatically". \n ' 'Create ▁ a ▁ specific ▁ stage ▁ or ▁ edit ▁ an ▁ existing ▁ one ▁ by ▁ editing ▁ columns ▁ of ▁ your ▁ opportunity ▁ pipe.' ) ) <newline> <dedent> <dedent> for stage_id , lead_ids in stages_leads . items ( ) : <newline> <indent> self . write ( cr , uid , lead_ids , { 'stage_id' : stage_id } , context = context ) <newline> <dedent> return True <newline> <dedent> def case_mark_won ( self , cr , uid , ids , context = None ) : <newline> <indent>  """ ▁ Mark ▁ the ▁ case ▁ as ▁ won: ▁ state=done ▁ and ▁ probability=100 <strnewline> ▁ """  <newline> stages_leads = { } <newline> for lead in self . browse ( cr , uid , ids , context = context ) : <newline> <indent> stage_id = self . stage_find ( cr , uid , [ lead ] , lead . section_id . id or False , [ ( 'probability' , '=' , 100.0 ) , ( 'on_change' , '=' , True ) ] , context = context ) <newline> if stage_id : <newline> <indent> if stages_leads . get ( stage_id ) : <newline> <indent> stages_leads [ stage_id ] . append ( lead . id ) <newline> <dedent> else : <newline> <indent> stages_leads [ stage_id ] = [ lead . id ] <newline> <dedent> <dedent> else : <newline> <indent> raise osv . except_osv ( _ ( 'Warning!' ) , _ ( 'To ▁ relieve ▁ your ▁ sales ▁ pipe ▁ and ▁ group ▁ all ▁ Won ▁ opportunities, ▁ configure ▁ one ▁ of ▁ your ▁ sales ▁ stage ▁ as ▁ follow: \n ' 'probability ▁ = ▁ 100 ▁ % ▁ and ▁ select ▁"Change ▁ Probability ▁ Automatically". \n ' 'Create ▁ a ▁ specific ▁ stage ▁ or ▁ edit ▁ an ▁ existing ▁ one ▁ by ▁ editing ▁ columns ▁ of ▁ your ▁ opportunity ▁ pipe.' ) ) <newline> <dedent> <dedent> for stage_id , lead_ids in stages_leads . items ( ) : <newline> <indent> self . write ( cr , uid , lead_ids , { 'stage_id' : stage_id } , context = context ) <newline> <dedent> return True <newline> <dedent> def case_escalate ( self , cr , uid , ids , context = None ) : <newline> <indent>  """ ▁ Escalates ▁ case ▁ to ▁ parent ▁ level ▁ """  <newline> for case in self . browse ( cr , uid , ids , context = context ) : <newline> <indent> data = { 'active' : True } <newline> if case . section_id . parent_id : <newline> <indent> data [ 'section_id' ] = case . section_id . parent_id . id <newline> if case . section_id . parent_id . change_responsible : <newline> <indent> if case . section_id . parent_id . user_id : <newline> <indent> data [ 'user_id' ] = case . section_id . parent_id . user_id . id <newline> <dedent> <dedent> <dedent> else : <newline> <indent> raise osv . except_osv ( _ ( 'Error!' ) , _ ( "You ▁ are ▁ already ▁ at ▁ the ▁ top ▁ level ▁ of ▁ your ▁ sales-team ▁ category. \n Therefore ▁ you ▁ cannot ▁ escalate ▁ furthermore." ) ) <newline> <dedent> self . write ( cr , uid , [ case . id ] , data , context = context ) <newline> <dedent> return True <newline> <dedent> def _merge_get_result_type ( self , cr , uid , opps , context = None ) : <newline> <indent>  """ <strnewline> ▁ Define ▁ the ▁ type ▁ of ▁ the ▁ result ▁ of ▁ the ▁ merge. ▁ If ▁ at ▁ least ▁ one ▁ of ▁ the <strnewline> ▁ element ▁ to ▁ merge ▁ is ▁ an ▁ opp, ▁ the ▁ resulting ▁ new ▁ element ▁ will ▁ be ▁ an ▁ opp. <strnewline> ▁ Otherwise ▁ it ▁ will ▁ be ▁ a ▁ lead. <strnewline> <strnewline> ▁ We'll ▁ directly ▁ use ▁ a ▁ list ▁ of ▁ browse ▁ records ▁ instead ▁ of ▁ a ▁ list ▁ of ▁ ids <strnewline> ▁ for ▁ performances' ▁ sake: ▁ it ▁ will ▁ spare ▁ a ▁ second ▁ browse ▁ of ▁ the <strnewline> ▁ leads/opps. <strnewline> <strnewline> ▁ :param ▁ list ▁ opps: ▁ list ▁ of ▁ browse ▁ records ▁ containing ▁ the ▁ leads/opps ▁ to ▁ process <strnewline> ▁ :return ▁ string ▁ type: ▁ the ▁ type ▁ of ▁ the ▁ final ▁ element <strnewline> ▁ """  <newline> for opp in opps : <newline> <indent> if ( opp . type == 'opportunity' ) : <newline> <indent> return 'opportunity' <newline> <dedent> <dedent> return 'lead' <newline> <dedent> def _merge_data ( self , cr , uid , ids , oldest , fields , context = None ) : <newline> <indent>  """ <strnewline> ▁ Prepare ▁ lead/opp ▁ data ▁ into ▁ a ▁ dictionary ▁ for ▁ merging. ▁ Different ▁ types <strnewline> ▁ of ▁ fields ▁ are ▁ processed ▁ in ▁ different ▁ ways: <strnewline> ▁ - ▁ text: ▁ all ▁ the ▁ values ▁ are ▁ concatenated <strnewline> ▁ - ▁ m2m ▁ and ▁ o2m: ▁ those ▁ fields ▁ aren't ▁ processed <strnewline> ▁ - ▁ m2o: ▁ the ▁ first ▁ not ▁ null ▁ value ▁ prevails ▁ (the ▁ other ▁ are ▁ dropped) <strnewline> ▁ - ▁ any ▁ other ▁ type ▁ of ▁ field: ▁ same ▁ as ▁ m2o <strnewline> <strnewline> ▁ :param ▁ list ▁ ids: ▁ list ▁ of ▁ ids ▁ of ▁ the ▁ leads ▁ to ▁ process <strnewline> ▁ :param ▁ list ▁ fields: ▁ list ▁ of ▁ leads' ▁ fields ▁ to ▁ process <strnewline> ▁ :return ▁ dict ▁ data: ▁ contains ▁ the ▁ merged ▁ values <strnewline> ▁ """  <newline> opportunities = self . browse ( cr , uid , ids , context = context ) <newline> def _get_first_not_null ( attr ) : <newline> <indent> for opp in opportunities : <newline> <indent> if hasattr ( opp , attr ) and bool ( getattr ( opp , attr ) ) : <newline> <indent> return getattr ( opp , attr ) <newline> <dedent> <dedent> return False <newline> <dedent> def _get_first_not_null_id ( attr ) : <newline> <indent> res = _get_first_not_null ( attr ) <newline> return res and res . id or False <newline> <dedent> def _concat_all ( attr ) : <newline> <indent> return ' \n \n ' . join ( filter ( lambda x : x , [ getattr ( opp , attr ) or '' for opp in opportunities if hasattr ( opp , attr ) ] ) ) <newline>  # ▁ Process ▁ the ▁ fields' ▁ values <encdom> <dedent> data = { } <newline> for field_name in fields : <newline> <indent> field = self . _fields . get ( field_name ) <newline> if field is None : <newline> <indent> continue <newline> <dedent> if field . type in ( 'many2many' , 'one2many' ) : <newline> <indent> continue <newline> <dedent> elif field . type == 'many2one' : <newline> <indent> data [ field_name ] = _get_first_not_null_id ( field_name ) <newline> <dedent> elif field . type == 'text' : <newline> <indent> data [ field_name ] = _concat_all ( field_name )  # not ▁ lost <encdom> <newline> <dedent> else : <newline> <indent> data [ field_name ] = _get_first_not_null ( field_name )  # not ▁ lost <encdom> <newline>  # ▁ Define ▁ the ▁ resulting ▁ type ▁ ('lead' ▁ or ▁'opportunity') <encdom> <dedent> <dedent> data [ 'type' ] = self . _merge_get_result_type ( cr , uid , opportunities , context ) <newline> return data <newline> <dedent> def _mail_body ( self , cr , uid , lead , fields , title = False , context = None ) : <newline> <indent> body = [ ] <newline> if title : <newline> <indent> body . append ( "%s \n " % ( title ) ) <newline> <dedent> for field_name in fields : <newline> <indent> field = self . _fields . get ( field_name ) <newline> if field is None : <newline> <indent> continue <newline> <dedent> value = '' <newline> if field . type == 'selection' : <newline> <indent> if callable ( field . selection ) : <newline> <indent> key = field . selection ( self , cr , uid , context = context ) <newline> <dedent> else : <newline> <indent> key = field . selection <newline> <dedent> value = dict ( key ) . get ( lead [ field_name ] , lead [ field_name ] ) <newline> <dedent> elif field . type == 'many2one' : <newline> <indent> if lead [ field_name ] : <newline> <indent> value = lead [ field_name ] . name_get ( ) [ 0 ] [ 1 ] <newline> <dedent> <dedent> elif field . type == 'many2many' : <newline> <indent> if lead [ field_name ] : <newline> <indent> for val in lead [ field_name ] : <newline> <indent> field_value = val . name_get ( ) [ 0 ] [ 1 ] <newline> value += field_value + "," <newline> <dedent> <dedent> <dedent> else : <newline> <indent> value = lead [ field_name ] <newline> <dedent> body . append ( "%s: ▁ %s" % ( field . string , value or '' ) ) <newline> <dedent> return "<br/>" . join ( body + [ '<br/>' ] ) <newline> <dedent> def _merge_notify ( self , cr , uid , opportunity_id , opportunities , context = None ) : <newline> <indent>  """ <strnewline> ▁ Create ▁ a ▁ message ▁ gathering ▁ merged ▁ leads/opps ▁ information. <strnewline> ▁ """  <newline>  # TOFIX: ▁ mail ▁ template ▁ should ▁ be ▁ used ▁ instead ▁ of ▁ fix ▁ body, ▁ subject ▁ text <encdom> details = [ ] <newline> result_type = self . _merge_get_result_type ( cr , uid , opportunities , context ) <newline> if result_type == 'lead' : <newline> <indent> merge_message = _ ( 'Merged ▁ leads' ) <newline> <dedent> else : <newline> <indent> merge_message = _ ( 'Merged ▁ opportunities' ) <newline> <dedent> subject = [ merge_message ] <newline> for opportunity in opportunities : <newline> <indent> subject . append ( opportunity . name ) <newline> title = "%s ▁ : ▁ %s" % ( opportunity . type == 'opportunity' and _ ( 'Merged ▁ opportunity' ) or _ ( 'Merged ▁ lead' ) , opportunity . name ) <newline> fields = list ( CRM_LEAD_FIELDS_TO_MERGE ) <newline> details . append ( self . _mail_body ( cr , uid , opportunity , fields , title = title , context = context ) ) <newline>  # ▁ Chatter ▁ message's ▁ subject <encdom> <dedent> subject = subject [ 0 ] + ": ▁ " + ", ▁ " . join ( subject [ 1 : ] ) <newline> details = " \n \n " . join ( details ) <newline> return self . message_post ( cr , uid , [ opportunity_id ] , body = details , subject = subject , context = context ) <newline> <dedent> def _merge_opportunity_history ( self , cr , uid , opportunity_id , opportunities , context = None ) : <newline> <indent> message = self . pool . get ( 'mail.message' ) <newline> for opportunity in opportunities : <newline> <indent> for history in opportunity . message_ids : <newline> <indent> message . write ( cr , uid , history . id , { 'res_id' : opportunity_id , 'subject' : _ ( "From ▁ %s ▁ : ▁ %s" ) % ( opportunity . name , history . subject ) } , context = context ) <newline> <dedent> <dedent> return True <newline> <dedent> def _merge_opportunity_attachments ( self , cr , uid , opportunity_id , opportunities , context = None ) : <newline> <indent> attach_obj = self . pool . get ( 'ir.attachment' ) <newline>  # ▁ return ▁ attachments ▁ of ▁ opportunity <encdom> def _get_attachments ( opportunity_id ) : <newline> <indent> attachment_ids = attach_obj . search ( cr , uid , [ ( 'res_model' , '=' , self . _name ) , ( 'res_id' , '=' , opportunity_id ) ] , context = context ) <newline> return attach_obj . browse ( cr , uid , attachment_ids , context = context ) <newline> <dedent> first_attachments = _get_attachments ( opportunity_id ) <newline>  # counter ▁ of ▁ all ▁ attachments ▁ to ▁ move. ▁ Used ▁ to ▁ make ▁ sure ▁ the ▁ name ▁ is ▁ different ▁ for ▁ all ▁ attachments <encdom> count = 1 <newline> for opportunity in opportunities : <newline> <indent> attachments = _get_attachments ( opportunity . id ) <newline> for attachment in attachments : <newline> <indent> values = { 'res_id' : opportunity_id , } <newline> for attachment_in_first in first_attachments : <newline> <indent> if attachment . name == attachment_in_first . name : <newline> <indent> values [ 'name' ] = "%s ▁ (%s)" % ( attachment . name , count , ) , <newline> <dedent> <dedent> count += 1 <newline> attachment . write ( values ) <newline> <dedent> <dedent> return True <newline> <dedent> def _merge_opportunity_phonecalls ( self , cr , uid , opportunity_id , opportunities , context = None ) : <newline> <indent> phonecall_obj = self . pool [ 'crm.phonecall' ] <newline> for opportunity in opportunities : <newline> <indent> for phonecall_id in phonecall_obj . search ( cr , uid , [ ( 'opportunity_id' , '=' , opportunity . id ) ] , context = context ) : <newline> <indent> phonecall_obj . write ( cr , uid , phonecall_id , { 'opportunity_id' : opportunity_id } , context = context ) <newline> <dedent> <dedent> return True <newline> <dedent> def get_duplicated_leads ( self , cr , uid , ids , partner_id , include_lost = False , context = None ) : <newline> <indent>  """ <strnewline> ▁ Search ▁ for ▁ opportunities ▁ that ▁ have ▁ the ▁ same ▁ partner ▁ and ▁ that ▁ arent ▁ done ▁ or ▁ cancelled <strnewline> ▁ """  <newline> lead = self . browse ( cr , uid , ids [ 0 ] , context = context ) <newline> email = lead . partner_id and lead . partner_id . email or lead . email_from <newline> return self . pool [ 'crm.lead' ] . _get_duplicated_leads_by_emails ( cr , uid , partner_id , email , include_lost = include_lost , context = context ) <newline> <dedent> def _get_duplicated_leads_by_emails ( self , cr , uid , partner_id , email , include_lost = False , context = None ) : <newline> <indent>  """ <strnewline> ▁ Search ▁ for ▁ opportunities ▁ that ▁ have ▁ the ▁ same ▁ partner ▁ and ▁ that ▁ arent ▁ done ▁ or ▁ cancelled <strnewline> ▁ """  <newline> final_stage_domain = [ ( 'stage_id.probability' , '<' , 100 ) , '|' , ( 'stage_id.probability' , '>' , 0 ) , ( 'stage_id.sequence' , '<=' , 1 ) ] <newline> partner_match_domain = [ ] <newline> for email in set ( email_split ( email ) + [ email ] ) : <newline> <indent> partner_match_domain . append ( ( 'email_from' , '=ilike' , email ) ) <newline> <dedent> if partner_id : <newline> <indent> partner_match_domain . append ( ( 'partner_id' , '=' , partner_id ) ) <newline> <dedent> partner_match_domain = [ '|' ] * ( len ( partner_match_domain ) - 1 ) + partner_match_domain <newline> if not partner_match_domain : <newline> <indent> return [ ] <newline> <dedent> domain = partner_match_domain <newline> if not include_lost : <newline> <indent> domain += final_stage_domain <newline> <dedent> return self . search ( cr , uid , domain , context = context ) <newline> <dedent> def merge_dependences ( self , cr , uid , highest , opportunities , context = None ) : <newline> <indent> self . _merge_notify ( cr , uid , highest , opportunities , context = context ) <newline> self . _merge_opportunity_history ( cr , uid , highest , opportunities , context = context ) <newline> self . _merge_opportunity_attachments ( cr , uid , highest , opportunities , context = context ) <newline> self . _merge_opportunity_phonecalls ( cr , uid , highest , opportunities , context = context ) <newline> <dedent> def merge_opportunity ( self , cr , uid , ids , user_id = False , section_id = False , context = None ) : <newline> <indent>  """ <strnewline> ▁ Different ▁ cases ▁ of ▁ merge: <strnewline> ▁ - ▁ merge ▁ leads ▁ together ▁ = ▁ 1 ▁ new ▁ lead <strnewline> ▁ - ▁ merge ▁ at ▁ least ▁ 1 ▁ opp ▁ with ▁ anything ▁ else ▁ (lead ▁ or ▁ opp) ▁ = ▁ 1 ▁ new ▁ opp <strnewline> <strnewline> ▁ :param ▁ list ▁ ids: ▁ leads/opportunities ▁ ids ▁ to ▁ merge <strnewline> ▁ :return ▁ int ▁ id: ▁ id ▁ of ▁ the ▁ resulting ▁ lead/opp <strnewline> ▁ """  <newline> if context is None : <newline> <indent> context = { } <newline> <dedent> if len ( ids ) <= 1 : <newline> <indent> raise osv . except_osv ( _ ( 'Warning!' ) , _ ( 'Please ▁ select ▁ more ▁ than ▁ one ▁ element ▁ (lead ▁ or ▁ opportunity) ▁ from ▁ the ▁ list ▁ view.' ) ) <newline> <dedent> opportunities = self . browse ( cr , uid , ids , context = context ) <newline> sequenced_opps = [ ] <newline>  # ▁ Sorting ▁ the ▁ leads/opps ▁ according ▁ to ▁ the ▁ confidence ▁ level ▁ of ▁ its ▁ stage, ▁ which ▁ relates ▁ to ▁ the ▁ probability ▁ of ▁ winning ▁ it <encdom>  # ▁ The ▁ confidence ▁ level ▁ increases ▁ with ▁ the ▁ stage ▁ sequence, ▁ except ▁ when ▁ the ▁ stage ▁ probability ▁ is ▁ 0.0 ▁ (Lost ▁ cases) <encdom>  # ▁ An ▁ Opportunity ▁ always ▁ has ▁ higher ▁ confidence ▁ level ▁ than ▁ a ▁ lead, ▁ unless ▁ its ▁ stage ▁ probability ▁ is ▁ 0.0 <encdom> for opportunity in opportunities : <newline> <indent> sequence = - 1 <newline> if opportunity . stage_id and not opportunity . stage_id . fold : <newline> <indent> sequence = opportunity . stage_id . sequence <newline> <dedent> sequenced_opps . append ( ( ( int ( sequence != - 1 and opportunity . type == 'opportunity' ) , sequence , - opportunity . id ) , opportunity ) ) <newline> <dedent> sequenced_opps . sort ( reverse = True ) <newline> opportunities = map ( itemgetter ( 1 ) , sequenced_opps ) <newline> ids = [ opportunity . id for opportunity in opportunities ] <newline> highest = opportunities [ 0 ] <newline> opportunities_rest = opportunities [ 1 : ] <newline> tail_opportunities = opportunities_rest <newline> fields = list ( CRM_LEAD_FIELDS_TO_MERGE ) <newline> merged_data = self . _merge_data ( cr , uid , ids , highest , fields , context = context ) <newline> if user_id : <newline> <indent> merged_data [ 'user_id' ] = user_id <newline> <dedent> if section_id : <newline> <indent> merged_data [ 'section_id' ] = section_id <newline>  # ▁ Merge ▁ notifications ▁ about ▁ loss ▁ of ▁ information <encdom> <dedent> opportunities = [ highest ] <newline> opportunities . extend ( opportunities_rest ) <newline> self . merge_dependences ( cr , uid , highest . id , tail_opportunities , context = context ) <newline>  # ▁ Check ▁ if ▁ the ▁ stage ▁ is ▁ in ▁ the ▁ stages ▁ of ▁ the ▁ sales ▁ team. ▁ If ▁ not, ▁ assign ▁ the ▁ stage ▁ with ▁ the ▁ lowest ▁ sequence <encdom> if merged_data . get ( 'section_id' ) : <newline> <indent> section_stage_ids = self . pool . get ( 'crm.case.stage' ) . search ( cr , uid , [ ( 'section_ids' , 'in' , merged_data [ 'section_id' ] ) , ( 'type' , '=' , merged_data . get ( 'type' ) ) ] , order = 'sequence' , context = context ) <newline> if merged_data . get ( 'stage_id' ) not in section_stage_ids : <newline> <indent> merged_data [ 'stage_id' ] = section_stage_ids and section_stage_ids [ 0 ] or False <newline>  # ▁ Write ▁ merged ▁ data ▁ into ▁ first ▁ opportunity <encdom> <dedent> <dedent> self . write ( cr , uid , [ highest . id ] , merged_data , context = context ) <newline>  # ▁ Delete ▁ tail ▁ opportunities ▁ <encdom>  # ▁ We ▁ use ▁ the ▁ SUPERUSER ▁ to ▁ avoid ▁ access ▁ rights ▁ issues ▁ because ▁ as ▁ the ▁ user ▁ had ▁ the ▁ rights ▁ to ▁ see ▁ the ▁ records ▁ it ▁ should ▁ be ▁ safe ▁ to ▁ do ▁ so <encdom> self . unlink ( cr , SUPERUSER_ID , [ x . id for x in tail_opportunities ] , context = context ) <newline> return highest . id <newline> <dedent> def _convert_opportunity_data ( self , cr , uid , lead , customer , section_id = False , context = None ) : <newline> <indent> crm_stage = self . pool . get ( 'crm.case.stage' ) <newline> contact_id = False <newline> if customer : <newline> <indent> contact_id = self . pool . get ( 'res.partner' ) . address_get ( cr , uid , [ customer . id ] ) [ 'default' ] <newline> <dedent> if not section_id : <newline> <indent> section_id = lead . section_id and lead . section_id . id or False <newline> <dedent> val = { 'planned_revenue' : lead . planned_revenue , 'probability' : lead . probability , 'name' : lead . name , 'partner_id' : customer and customer . id or False , 'type' : 'opportunity' , 'date_action' : fields . datetime . now ( ) , 'date_open' : fields . datetime . now ( ) , 'email_from' : customer and customer . email or lead . email_from , 'phone' : customer and customer . phone or lead . phone , } <newline> if not lead . stage_id or lead . stage_id . type == 'lead' : <newline> <indent> val [ 'stage_id' ] = self . stage_find ( cr , uid , [ lead ] , section_id , [ ( 'type' , 'in' , ( 'opportunity' , 'both' ) ) ] , context = context ) <newline> <dedent> return val <newline> <dedent> def convert_opportunity ( self , cr , uid , ids , partner_id , user_ids = False , section_id = False , context = None ) : <newline> <indent> customer = False <newline> if partner_id : <newline> <indent> partner = self . pool . get ( 'res.partner' ) <newline> customer = partner . browse ( cr , uid , partner_id , context = context ) <newline> <dedent> for lead in self . browse ( cr , uid , ids , context = context ) : <newline>  # ▁ TDE: ▁ was ▁ if ▁ lead.state ▁ in ▁ ('done', ▁'cancel'): <encdom> <indent> if lead . probability == 100 or ( lead . probability == 0 and lead . stage_id . fold ) : <newline> <indent> continue <newline> <dedent> vals = self . _convert_opportunity_data ( cr , uid , lead , customer , section_id , context = context ) <newline> self . write ( cr , uid , [ lead . id ] , vals , context = context ) <newline> <dedent> if user_ids or section_id : <newline> <indent> self . allocate_salesman ( cr , uid , ids , user_ids , section_id , context = context ) <newline> <dedent> return True <newline> <dedent> def _lead_create_contact ( self , cr , uid , lead , name , is_company , parent_id = False , context = None ) : <newline> <indent> partner = self . pool . get ( 'res.partner' ) <newline> vals = { 'name' : name , 'user_id' : lead . user_id . id , 'comment' : lead . description , 'section_id' : lead . section_id . id or False , 'parent_id' : parent_id , 'phone' : lead . phone , 'mobile' : lead . mobile , 'email' : tools . email_split ( lead . email_from ) and tools . email_split ( lead . email_from ) [ 0 ] or False , 'fax' : lead . fax , 'title' : lead . title and lead . title . id or False , 'function' : lead . function , 'street' : lead . street , 'street2' : lead . street2 , 'zip' : lead . zip , 'city' : lead . city , 'country_id' : lead . country_id and lead . country_id . id or False , 'state_id' : lead . state_id and lead . state_id . id or False , 'is_company' : is_company , 'type' : 'contact' } <newline> partner = partner . create ( cr , uid , vals , context = context ) <newline> return partner <newline> <dedent> def _create_lead_partner ( self , cr , uid , lead , context = None ) : <newline> <indent> partner_id = False <newline> if lead . partner_name and lead . contact_name : <newline> <indent> partner_id = self . _lead_create_contact ( cr , uid , lead , lead . partner_name , True , context = context ) <newline> partner_id = self . _lead_create_contact ( cr , uid , lead , lead . contact_name , False , partner_id , context = context ) <newline> <dedent> elif lead . partner_name and not lead . contact_name : <newline> <indent> partner_id = self . _lead_create_contact ( cr , uid , lead , lead . partner_name , True , context = context ) <newline> <dedent> elif not lead . partner_name and lead . contact_name : <newline> <indent> partner_id = self . _lead_create_contact ( cr , uid , lead , lead . contact_name , False , context = context ) <newline> <dedent> elif lead . email_from and self . pool . get ( 'res.partner' ) . _parse_partner_name ( lead . email_from , context = context ) [ 0 ] : <newline> <indent> contact_name = self . pool . get ( 'res.partner' ) . _parse_partner_name ( lead . email_from , context = context ) [ 0 ] <newline> partner_id = self . _lead_create_contact ( cr , uid , lead , contact_name , False , context = context ) <newline> <dedent> else : <newline> <indent> raise osv . except_osv ( _ ( 'Warning!' ) , _ ( 'No ▁ customer ▁ name ▁ defined. ▁ Please ▁ fill ▁ one ▁ of ▁ the ▁ following ▁ fields: ▁ Company ▁ Name, ▁ Contact ▁ Name ▁ or ▁ Email ▁ ("Name ▁ <email@address>")' ) ) <newline> <dedent> return partner_id <newline> <dedent> def handle_partner_assignation ( self , cr , uid , ids , action = 'create' , partner_id = False , context = None ) : <newline> <indent>  """ <strnewline> ▁ Handle ▁ partner ▁ assignation ▁ during ▁ a ▁ lead ▁ conversion. <strnewline> ▁ if ▁ action ▁ is ▁'create', ▁ create ▁ new ▁ partner ▁ with ▁ contact ▁ and ▁ assign ▁ lead ▁ to ▁ new ▁ partner_id. <strnewline> ▁ otherwise ▁ assign ▁ lead ▁ to ▁ the ▁ specified ▁ partner_id <strnewline> <strnewline> ▁ :param ▁ list ▁ ids: ▁ leads/opportunities ▁ ids ▁ to ▁ process <strnewline> ▁ :param ▁ string ▁ action: ▁ what ▁ has ▁ to ▁ be ▁ done ▁ regarding ▁ partners ▁ (create ▁ it, ▁ assign ▁ an ▁ existing ▁ one, ▁ or ▁ nothing) <strnewline> ▁ :param ▁ int ▁ partner_id: ▁ partner ▁ to ▁ assign ▁ if ▁ any <strnewline> ▁ :return ▁ dict: ▁ dictionary ▁ organized ▁ as ▁ followed: ▁ {lead_id: ▁ partner_assigned_id} <strnewline> ▁ """  <newline>  # TODO ▁ this ▁ is ▁ a ▁ duplication ▁ of ▁ the ▁ handle_partner_assignation ▁ method ▁ of ▁ crm_phonecall <encdom> partner_ids = { } <newline> for lead in self . browse ( cr , uid , ids , context = context ) : <newline>  # ▁ If ▁ the ▁ action ▁ is ▁ set ▁ to ▁'create' ▁ and ▁ no ▁ partner_id ▁ is ▁ set, ▁ create ▁ a ▁ new ▁ one <encdom> <indent> if lead . partner_id : <newline> <indent> partner_ids [ lead . id ] = lead . partner_id . id <newline> continue <newline> <dedent> if not partner_id and action == 'create' : <newline> <indent> partner_id = self . _create_lead_partner ( cr , uid , lead , context ) <newline> self . pool [ 'res.partner' ] . write ( cr , uid , partner_id , { 'section_id' : lead . section_id and lead . section_id . id or False } ) <newline> <dedent> if partner_id : <newline> <indent> lead . write ( { 'partner_id' : partner_id } ) <newline> <dedent> partner_ids [ lead . id ] = partner_id <newline> <dedent> return partner_ids <newline> <dedent> def allocate_salesman ( self , cr , uid , ids , user_ids = None , team_id = False , context = None ) : <newline> <indent>  """ <strnewline> ▁ Assign ▁ salesmen ▁ and ▁ salesteam ▁ to ▁ a ▁ batch ▁ of ▁ leads. ▁ If ▁ there ▁ are ▁ more <strnewline> ▁ leads ▁ than ▁ salesmen, ▁ these ▁ salesmen ▁ will ▁ be ▁ assigned ▁ in ▁ round-robin. <strnewline> ▁ E.g.: ▁ 4 ▁ salesmen ▁ (S1, ▁ S2, ▁ S3, ▁ S4) ▁ for ▁ 6 ▁ leads ▁ (L1, ▁ L2, ▁ ... ▁ L6). ▁ They <strnewline> ▁ will ▁ be ▁ assigned ▁ as ▁ followed: ▁ L1 ▁ - ▁ S1, ▁ L2 ▁ - ▁ S2, ▁ L3 ▁ - ▁ S3, ▁ L4 ▁ - ▁ S4, <strnewline> ▁ L5 ▁ - ▁ S1, ▁ L6 ▁ - ▁ S2. <strnewline> <strnewline> ▁ :param ▁ list ▁ ids: ▁ leads/opportunities ▁ ids ▁ to ▁ process <strnewline> ▁ :param ▁ list ▁ user_ids: ▁ salesmen ▁ to ▁ assign <strnewline> ▁ :param ▁ int ▁ team_id: ▁ salesteam ▁ to ▁ assign <strnewline> ▁ :return ▁ bool <strnewline> ▁ """  <newline> index = 0 <newline> for lead_id in ids : <newline> <indent> value = { } <newline> if team_id : <newline> <indent> value [ 'section_id' ] = team_id <newline> <dedent> if user_ids : <newline> <indent> value [ 'user_id' ] = user_ids [ index ] <newline>  # ▁ Cycle ▁ through ▁ user_ids <encdom> index = ( index + 1 ) % len ( user_ids ) <newline> <dedent> if value : <newline> <indent> self . write ( cr , uid , [ lead_id ] , value , context = context ) <newline> <dedent> <dedent> return True <newline> <dedent> def schedule_phonecall ( self , cr , uid , ids , schedule_time , call_summary , desc , phone , contact_name , user_id = False , section_id = False , categ_id = False , action = 'schedule' , context = None ) : <newline> <indent>  """ <strnewline> ▁ :param ▁ string ▁ action: ▁ ('schedule','Schedule ▁ a ▁ call'), ▁ ('log','Log ▁ a ▁ call') <strnewline> ▁ """  <newline> phonecall = self . pool . get ( 'crm.phonecall' ) <newline> model_data = self . pool . get ( 'ir.model.data' ) <newline> phonecall_dict = { } <newline> if not categ_id : <newline> <indent> try : <newline> <indent> res_id = model_data . _get_id ( cr , uid , 'crm' , 'categ_phone2' ) <newline> categ_id = model_data . browse ( cr , uid , res_id , context = context ) . res_id <newline> <dedent> except ValueError : <newline> <indent> pass <newline> <dedent> <dedent> for lead in self . browse ( cr , uid , ids , context = context ) : <newline> <indent> if not section_id : <newline> <indent> section_id = lead . section_id and lead . section_id . id or False <newline> <dedent> if not user_id : <newline> <indent> user_id = lead . user_id and lead . user_id . id or False <newline> <dedent> vals = { 'name' : call_summary , 'opportunity_id' : lead . id , 'user_id' : user_id or False , 'categ_id' : categ_id or False , 'description' : desc or '' , 'date' : schedule_time , 'section_id' : section_id or False , 'partner_id' : lead . partner_id and lead . partner_id . id or False , 'partner_phone' : phone or lead . phone or ( lead . partner_id and lead . partner_id . phone or False ) , 'partner_mobile' : lead . partner_id and lead . partner_id . mobile or False , 'priority' : lead . priority , } <newline> new_id = phonecall . create ( cr , uid , vals , context = context ) <newline> phonecall . write ( cr , uid , [ new_id ] , { 'state' : 'open' } , context = context ) <newline> if action == 'log' : <newline> <indent> phonecall . write ( cr , uid , [ new_id ] , { 'state' : 'done' } , context = context ) <newline> <dedent> phonecall_dict [ lead . id ] = new_id <newline> self . schedule_phonecall_send_note ( cr , uid , [ lead . id ] , new_id , action , context = context ) <newline> <dedent> return phonecall_dict <newline> <dedent> def redirect_opportunity_view ( self , cr , uid , opportunity_id , context = None ) : <newline> <indent> models_data = self . pool . get ( 'ir.model.data' ) <newline>  # ▁ Get ▁ opportunity ▁ views <encdom> dummy , form_view = models_data . get_object_reference ( cr , uid , 'crm' , 'crm_case_form_view_oppor' ) <newline> dummy , tree_view = models_data . get_object_reference ( cr , uid , 'crm' , 'crm_case_tree_view_oppor' ) <newline> return { 'name' : _ ( 'Opportunity' ) , 'view_type' : 'form' , 'view_mode' : 'tree, ▁ form' , 'res_model' : 'crm.lead' , 'domain' : [ ( 'type' , '=' , 'opportunity' ) ] , 'res_id' : int ( opportunity_id ) , 'view_id' : False , 'views' : [ ( form_view or False , 'form' ) , ( tree_view or False , 'tree' ) , ( False , 'kanban' ) , ( False , 'calendar' ) , ( False , 'graph' ) ] , 'type' : 'ir.actions.act_window' , 'context' : { 'default_type' : 'opportunity' } } <newline> <dedent> def redirect_lead_view ( self , cr , uid , lead_id , context = None ) : <newline> <indent> models_data = self . pool . get ( 'ir.model.data' ) <newline>  # ▁ Get ▁ lead ▁ views <encdom> dummy , form_view = models_data . get_object_reference ( cr , uid , 'crm' , 'crm_case_form_view_leads' ) <newline> dummy , tree_view = models_data . get_object_reference ( cr , uid , 'crm' , 'crm_case_tree_view_leads' ) <newline> return { 'name' : _ ( 'Lead' ) , 'view_type' : 'form' , 'view_mode' : 'tree, ▁ form' , 'res_model' : 'crm.lead' , 'domain' : [ ( 'type' , '=' , 'lead' ) ] , 'res_id' : int ( lead_id ) , 'view_id' : False , 'views' : [ ( form_view or False , 'form' ) , ( tree_view or False , 'tree' ) , ( False , 'calendar' ) , ( False , 'graph' ) ] , 'type' : 'ir.actions.act_window' , } <newline> <dedent> def action_schedule_meeting ( self , cr , uid , ids , context = None ) : <newline> <indent>  """ <strnewline> ▁ Open ▁ meeting's ▁ calendar ▁ view ▁ to ▁ schedule ▁ meeting ▁ on ▁ current ▁ opportunity. <strnewline> ▁ :return ▁ dict: ▁ dictionary ▁ value ▁ for ▁ created ▁ Meeting ▁ view <strnewline> ▁ """  <newline> lead = self . browse ( cr , uid , ids [ 0 ] , context ) <newline> res = self . pool . get ( 'ir.actions.act_window' ) . for_xml_id ( cr , uid , 'calendar' , 'action_calendar_event' , context ) <newline> partner_ids = [ self . pool [ 'res.users' ] . browse ( cr , uid , uid , context = context ) . partner_id . id ] <newline> if lead . partner_id : <newline> <indent> partner_ids . append ( lead . partner_id . id ) <newline> <dedent> res [ 'context' ] = { 'search_default_opportunity_id' : lead . type == 'opportunity' and lead . id or False , 'default_opportunity_id' : lead . type == 'opportunity' and lead . id or False , 'default_partner_id' : lead . partner_id and lead . partner_id . id or False , 'default_partner_ids' : partner_ids , 'default_section_id' : lead . section_id and lead . section_id . id or False , 'default_name' : lead . name , } <newline> return res <newline> <dedent> def create ( self , cr , uid , vals , context = None ) : <newline> <indent> context = dict ( context or { } ) <newline> if vals . get ( 'type' ) and not context . get ( 'default_type' ) : <newline> <indent> context [ 'default_type' ] = vals . get ( 'type' ) <newline> <dedent> if vals . get ( 'section_id' ) and not context . get ( 'default_section_id' ) : <newline> <indent> context [ 'default_section_id' ] = vals . get ( 'section_id' ) <newline> <dedent> if vals . get ( 'user_id' ) : <newline> <indent> vals [ 'date_open' ] = fields . datetime . now ( ) <newline>  # ▁ context: ▁ no_log, ▁ because ▁ subtype ▁ already ▁ handle ▁ this <encdom> <dedent> create_context = dict ( context , mail_create_nolog = True ) <newline> return super ( crm_lead , self ) . create ( cr , uid , vals , context = create_context ) <newline> <dedent> def write ( self , cr , uid , ids , vals , context = None ) : <newline>  # ▁ stage ▁ change: ▁ update ▁ date_last_stage_update <encdom> <indent> if 'stage_id' in vals : <newline> <indent> vals [ 'date_last_stage_update' ] = fields . datetime . now ( ) <newline> <dedent> if vals . get ( 'user_id' ) : <newline> <indent> vals [ 'date_open' ] = fields . datetime . now ( ) <newline>  # ▁ stage ▁ change ▁ with ▁ new ▁ stage: ▁ update ▁ probability ▁ and ▁ date_closed <encdom> <dedent> if vals . get ( 'stage_id' ) and not vals . get ( 'probability' ) : <newline> <indent> onchange_stage_values = self . onchange_stage_id ( cr , uid , ids , vals . get ( 'stage_id' ) , context = context ) [ 'value' ] <newline> vals . update ( onchange_stage_values ) <newline> <dedent> return super ( crm_lead , self ) . write ( cr , uid , ids , vals , context = context ) <newline> <dedent> def copy ( self , cr , uid , id , default = None , context = None ) : <newline> <indent> if not default : <newline> <indent> default = { } <newline> <dedent> if not context : <newline> <indent> context = { } <newline> <dedent> lead = self . browse ( cr , uid , id , context = context ) <newline> local_context = dict ( context ) <newline> local_context . setdefault ( 'default_type' , lead . type ) <newline> local_context . setdefault ( 'default_section_id' , lead . section_id . id ) <newline> if lead . type == 'opportunity' : <newline> <indent> default [ 'date_open' ] = fields . datetime . now ( ) <newline> <dedent> else : <newline> <indent> default [ 'date_open' ] = False <newline> <dedent> return super ( crm_lead , self ) . copy ( cr , uid , id , default , context = local_context ) <newline> <dedent> def get_empty_list_help ( self , cr , uid , help , context = None ) : <newline> <indent> context = dict ( context or { } ) <newline> context [ 'empty_list_help_model' ] = 'crm.case.section' <newline> context [ 'empty_list_help_id' ] = context . get ( 'default_section_id' , None ) <newline> context [ 'empty_list_help_document_name' ] = _ ( "opportunity" ) <newline> if context . get ( 'default_type' ) == 'lead' : <newline> <indent> context [ 'empty_list_help_document_name' ] = _ ( "lead" ) <newline> <dedent> return super ( crm_lead , self ) . get_empty_list_help ( cr , uid , help , context = context ) <newline>  # ▁ Mail ▁ Gateway <encdom> <dedent> def message_get_reply_to ( self , cr , uid , ids , context = None ) : <newline> <indent>  """ ▁ Override ▁ to ▁ get ▁ the ▁ reply_to ▁ of ▁ the ▁ parent ▁ project. ▁ """  <newline> leads = self . browse ( cr , SUPERUSER_ID , ids , context = context ) <newline> section_ids = set ( [ lead . section_id . id for lead in leads if lead . section_id ] ) <newline> aliases = self . pool [ 'crm.case.section' ] . message_get_reply_to ( cr , uid , list ( section_ids ) , context = context ) <newline> return dict ( ( lead . id , aliases . get ( lead . section_id and lead . section_id . id or 0 , False ) ) for lead in leads ) <newline> <dedent> def get_formview_id ( self , cr , uid , id , context = None ) : <newline> <indent> obj = self . browse ( cr , uid , id , context = context ) <newline> if obj . type == 'opportunity' : <newline> <indent> model , view_id = self . pool . get ( 'ir.model.data' ) . get_object_reference ( cr , uid , 'crm' , 'crm_case_form_view_oppor' ) <newline> <dedent> else : <newline> <indent> view_id = super ( crm_lead , self ) . get_formview_id ( cr , uid , id , context = context ) <newline> <dedent> return view_id <newline> <dedent> def message_get_suggested_recipients ( self , cr , uid , ids , context = None ) : <newline> <indent> recipients = super ( crm_lead , self ) . message_get_suggested_recipients ( cr , uid , ids , context = context ) <newline> try : <newline> <indent> for lead in self . browse ( cr , uid , ids , context = context ) : <newline> <indent> if lead . partner_id : <newline> <indent> self . _message_add_suggested_recipient ( cr , uid , recipients , lead , partner = lead . partner_id , reason = _ ( 'Customer' ) ) <newline> <dedent> elif lead . email_from : <newline> <indent> self . _message_add_suggested_recipient ( cr , uid , recipients , lead , email = lead . email_from , reason = _ ( 'Customer ▁ Email' ) ) <newline> <dedent> <dedent> <dedent> except ( osv . except_osv , orm . except_orm ) :  # ▁ no ▁ read ▁ access ▁ rights ▁ -> ▁ just ▁ ignore ▁ suggested ▁ recipients ▁ because ▁ this ▁ imply ▁ modifying ▁ followers <encdom> <newline> <indent> pass <newline> <dedent> return recipients <newline> <dedent> def message_new ( self , cr , uid , msg , custom_values = None , context = None ) : <newline> <indent>  """ ▁ Overrides ▁ mail_thread ▁ message_new ▁ that ▁ is ▁ called ▁ by ▁ the ▁ mailgateway <strnewline> ▁ through ▁ message_process. <strnewline> ▁ This ▁ override ▁ updates ▁ the ▁ document ▁ according ▁ to ▁ the ▁ email. <strnewline> ▁ """  <newline> if custom_values is None : <newline> <indent> custom_values = { } <newline> <dedent> defaults = { 'name' : msg . get ( 'subject' ) or _ ( "No ▁ Subject" ) , 'email_from' : msg . get ( 'from' ) , 'email_cc' : msg . get ( 'cc' ) , 'partner_id' : msg . get ( 'author_id' , False ) , 'user_id' : False , } <newline> if msg . get ( 'author_id' ) : <newline> <indent> defaults . update ( self . on_change_partner_id ( cr , uid , None , msg . get ( 'author_id' ) , context = context ) [ 'value' ] ) <newline> <dedent> if msg . get ( 'priority' ) in dict ( crm . AVAILABLE_PRIORITIES ) : <newline> <indent> defaults [ 'priority' ] = msg . get ( 'priority' ) <newline> <dedent> defaults . update ( custom_values ) <newline> return super ( crm_lead , self ) . message_new ( cr , uid , msg , custom_values = defaults , context = context ) <newline> <dedent> def message_update ( self , cr , uid , ids , msg , update_vals = None , context = None ) : <newline> <indent>  """ ▁ Overrides ▁ mail_thread ▁ message_update ▁ that ▁ is ▁ called ▁ by ▁ the ▁ mailgateway <strnewline> ▁ through ▁ message_process. <strnewline> ▁ This ▁ method ▁ updates ▁ the ▁ document ▁ according ▁ to ▁ the ▁ email. <strnewline> ▁ """  <newline> if isinstance ( ids , ( str , int , long ) ) : <newline> <indent> ids = [ ids ] <newline> <dedent> if update_vals is None : update_vals = { } <newline> if msg . get ( 'priority' ) in dict ( crm . AVAILABLE_PRIORITIES ) : <newline> <indent> update_vals [ 'priority' ] = msg . get ( 'priority' ) <newline> <dedent> maps = { 'cost' : 'planned_cost' , 'revenue' : 'planned_revenue' , 'probability' : 'probability' , } <newline> for line in msg . get ( 'body' , '' ) . split ( ' \n ' ) : <newline> <indent> line = line . strip ( ) <newline> res = tools . command_re . match ( line ) <newline> if res and maps . get ( res . group ( 1 ) . lower ( ) ) : <newline> <indent> key = maps . get ( res . group ( 1 ) . lower ( ) ) <newline> update_vals [ key ] = res . group ( 2 ) . lower ( ) <newline> <dedent> <dedent> return super ( crm_lead , self ) . message_update ( cr , uid , ids , msg , update_vals = update_vals , context = context ) <newline>  # ▁ OpenChatter ▁ methods ▁ and ▁ notifications <encdom> <dedent> def schedule_phonecall_send_note ( self , cr , uid , ids , phonecall_id , action , context = None ) : <newline> <indent> phonecall = self . pool . get ( 'crm.phonecall' ) . browse ( cr , uid , [ phonecall_id ] , context = context ) [ 0 ] <newline> if action == 'log' : <newline> <indent> message = _ ( 'Logged ▁ a ▁ call ▁ for ▁ %(date)s. ▁ %(description)s' ) <newline> <dedent> else : <newline> <indent> message = _ ( 'Scheduled ▁ a ▁ call ▁ for ▁ %(date)s. ▁ %(description)s' ) <newline> <dedent> phonecall_date = datetime . strptime ( phonecall . date , tools . DEFAULT_SERVER_DATETIME_FORMAT ) <newline> phonecall_usertime = fields . datetime . context_timestamp ( cr , uid , phonecall_date , context = context ) . strftime ( tools . DEFAULT_SERVER_DATETIME_FORMAT ) <newline> html_time = "<time ▁ datetime='%s+00:00'>%s</time>" % ( phonecall . date , phonecall_usertime ) <newline> message = message % dict ( date = html_time , description = phonecall . description ) <newline> return self . message_post ( cr , uid , ids , body = message , context = context ) <newline> <dedent> def log_meeting ( self , cr , uid , ids , meeting_subject , meeting_date , duration , context = None ) : <newline> <indent> if not duration : <newline> <indent> duration = _ ( 'unknown' ) <newline> <dedent> else : <newline> <indent> duration = str ( duration ) <newline> <dedent> meet_date = datetime . strptime ( meeting_date , tools . DEFAULT_SERVER_DATETIME_FORMAT ) <newline> meeting_usertime = fields . datetime . context_timestamp ( cr , uid , meet_date , context = context ) . strftime ( tools . DEFAULT_SERVER_DATETIME_FORMAT ) <newline> html_time = "<time ▁ datetime='%s+00:00'>%s</time>" % ( meeting_date , meeting_usertime ) <newline> message = _ ( "Meeting ▁ scheduled ▁ at ▁'%s'<br> ▁ Subject: ▁ %s ▁ <br> ▁ Duration: ▁ %s ▁ hour(s)" ) % ( html_time , meeting_subject , duration ) <newline> return self . message_post ( cr , uid , ids , body = message , context = context ) <newline> <dedent> def onchange_state ( self , cr , uid , ids , state_id , context = None ) : <newline> <indent> if state_id : <newline> <indent> country_id = self . pool . get ( 'res.country.state' ) . browse ( cr , uid , state_id , context ) . country_id . id <newline> return { 'value' : { 'country_id' : country_id } } <newline> <dedent> return { } <newline> <dedent> def message_partner_info_from_emails ( self , cr , uid , id , emails , link_mail = False , context = None ) : <newline> <indent> res = super ( crm_lead , self ) . message_partner_info_from_emails ( cr , uid , id , emails , link_mail = link_mail , context = context ) <newline> lead = self . browse ( cr , uid , id , context = context ) <newline> for partner_info in res : <newline> <indent> if not partner_info . get ( 'partner_id' ) and ( lead . partner_name or lead . contact_name ) : <newline> <indent> emails = email_re . findall ( partner_info [ 'full_name' ] or '' ) <newline> email = emails and emails [ 0 ] or '' <newline> if email and lead . email_from and email . lower ( ) == lead . email_from . lower ( ) : <newline> <indent> partner_info [ 'full_name' ] = '%s ▁ <%s>' % ( lead . partner_name or lead . contact_name , email ) <newline> break <newline> <dedent> <dedent> <dedent> return res <newline>  # ▁ vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4: <encdom> <dedent> <dedent>
from __future__ import unicode_literals <newline> from datetime import date <newline> import traceback <newline> import warnings <newline> from django . db import IntegrityError , DatabaseError <newline> from django . utils . encoding import DjangoUnicodeDecodeError <newline> from django . test import TestCase , TransactionTestCase <newline> from . models import DefaultPerson , Person , ManualPrimaryKeyTest , Profile , Tag , Thing <newline> class GetOrCreateTests ( TestCase ) : <newline> <indent> def test_get_or_create ( self ) : <newline> <indent> p = Person . objects . create ( first_name = 'John' , last_name = 'Lennon' , birthday = date ( 1940 , 10 , 9 ) ) <newline> p , created = Person . objects . get_or_create ( first_name = "John" , last_name = "Lennon" , defaults = { "birthday" : date ( 1940 , 10 , 9 ) } ) <newline> self . assertFalse ( created ) <newline> self . assertEqual ( Person . objects . count ( ) , 1 ) <newline> p , created = Person . objects . get_or_create ( first_name = 'George' , last_name = 'Harrison' , defaults = { 'birthday' : date ( 1943 , 2 , 25 ) } ) <newline> self . assertTrue ( created ) <newline> self . assertEqual ( Person . objects . count ( ) , 2 ) <newline>  # ▁ If ▁ we ▁ execute ▁ the ▁ exact ▁ same ▁ statement, ▁ it ▁ won't ▁ create ▁ a ▁ Person. <encdom> p , created = Person . objects . get_or_create ( first_name = 'George' , last_name = 'Harrison' , defaults = { 'birthday' : date ( 1943 , 2 , 25 ) } ) <newline> self . assertFalse ( created ) <newline> self . assertEqual ( Person . objects . count ( ) , 2 ) <newline>  # ▁ If ▁ you ▁ don't ▁ specify ▁ a ▁ value ▁ or ▁ default ▁ value ▁ for ▁ all ▁ required <encdom>  # ▁ fields, ▁ you ▁ will ▁ get ▁ an ▁ error. <encdom> self . assertRaises ( IntegrityError , Person . objects . get_or_create , first_name = "Tom" , last_name = "Smith" ) <newline>  # ▁ If ▁ you ▁ specify ▁ an ▁ existing ▁ primary ▁ key, ▁ but ▁ different ▁ other ▁ fields, <encdom>  # ▁ then ▁ you ▁ will ▁ get ▁ an ▁ error ▁ and ▁ data ▁ will ▁ not ▁ be ▁ updated. <encdom> ManualPrimaryKeyTest . objects . create ( id = 1 , data = "Original" ) <newline> self . assertRaises ( IntegrityError , ManualPrimaryKeyTest . objects . get_or_create , id = 1 , data = "Different" ) <newline> self . assertEqual ( ManualPrimaryKeyTest . objects . get ( id = 1 ) . data , "Original" ) <newline>  # ▁ get_or_create ▁ should ▁ raise ▁ IntegrityErrors ▁ with ▁ the ▁ full ▁ traceback. <encdom>  # ▁ This ▁ is ▁ tested ▁ by ▁ checking ▁ that ▁ a ▁ known ▁ method ▁ call ▁ is ▁ in ▁ the ▁ traceback. <encdom>  # ▁ We ▁ cannot ▁ use ▁ assertRaises/assertRaises ▁ here ▁ because ▁ we ▁ need ▁ to ▁ inspect <encdom>  # ▁ the ▁ actual ▁ traceback. ▁ Refs ▁ # 16340. <encdom> try : <newline> <indent> ManualPrimaryKeyTest . objects . get_or_create ( id = 1 , data = "Different" ) <newline> <dedent> except IntegrityError : <newline> <indent> formatted_traceback = traceback . format_exc ( ) <newline> self . assertIn ( str ( 'obj.save' ) , formatted_traceback ) <newline> <dedent> <dedent> def test_savepoint_rollback ( self ) : <newline>  # ▁ Regression ▁ test ▁ for ▁ # 20463: ▁ the ▁ database ▁ connection ▁ should ▁ still ▁ be <encdom>  # ▁ usable ▁ after ▁ a ▁ DataError ▁ or ▁ ProgrammingError ▁ in ▁ .get_or_create(). <encdom> <indent> try : <newline>  # ▁ Hide ▁ warnings ▁ when ▁ broken ▁ data ▁ is ▁ saved ▁ with ▁ a ▁ warning ▁ (MySQL). <encdom> <indent> with warnings . catch_warnings ( ) : <newline> <indent> warnings . simplefilter ( 'ignore' ) <newline> Person . objects . get_or_create ( birthday = date ( 1970 , 1 , 1 ) , defaults = { 'first_name' : b"\xff" , 'last_name' : b"\xff" } ) <newline> <dedent> <dedent> except ( DatabaseError , DjangoUnicodeDecodeError ) : <newline> <indent> Person . objects . create ( first_name = "Bob" , last_name = "Ross" , birthday = date ( 1950 , 1 , 1 ) ) <newline> <dedent> else : <newline> <indent> self . skipTest ( "This ▁ backend ▁ accepts ▁ broken ▁ utf-8." ) <newline> <dedent> <dedent> def test_get_or_create_empty ( self ) : <newline>  # ▁ Regression ▁ test ▁ for ▁ # 16137: ▁ get_or_create ▁ does ▁ not ▁ require ▁ kwargs. <encdom> <indent> try : <newline> <indent> DefaultPerson . objects . get_or_create ( ) <newline> <dedent> except AssertionError : <newline> <indent> self . fail ( "If ▁ all ▁ the ▁ attributes ▁ on ▁ a ▁ model ▁ have ▁ defaults, ▁ we ▁ " "shouldn't ▁ need ▁ to ▁ pass ▁ any ▁ arguments." ) <newline> <dedent> <dedent> <dedent> class GetOrCreateTransactionTests ( TransactionTestCase ) : <newline> <indent> available_apps = [ 'get_or_create' ] <newline> def test_get_or_create_integrityerror ( self ) : <newline>  # ▁ Regression ▁ test ▁ for ▁ # 15117. ▁ Requires ▁ a ▁ TransactionTestCase ▁ on <encdom>  # ▁ databases ▁ that ▁ delay ▁ integrity ▁ checks ▁ until ▁ the ▁ end ▁ of ▁ transactions, <encdom>  # ▁ otherwise ▁ the ▁ exception ▁ is ▁ never ▁ raised. <encdom> <indent> try : <newline> <indent> Profile . objects . get_or_create ( person = Person ( id = 1 ) ) <newline> <dedent> except IntegrityError : <newline> <indent> pass <newline> <dedent> else : <newline> <indent> self . skipTest ( "This ▁ backend ▁ does ▁ not ▁ support ▁ integrity ▁ checks." ) <newline> <dedent> <dedent> <dedent> class GetOrCreateThroughManyToMany ( TestCase ) : <newline> <indent> def test_get_get_or_create ( self ) : <newline> <indent> tag = Tag . objects . create ( text = 'foo' ) <newline> a_thing = Thing . objects . create ( name = 'a' ) <newline> a_thing . tags . add ( tag ) <newline> obj , created = a_thing . tags . get_or_create ( text = 'foo' ) <newline> self . assertFalse ( created ) <newline> self . assertEqual ( obj . pk , tag . pk ) <newline> <dedent> def test_create_get_or_create ( self ) : <newline> <indent> a_thing = Thing . objects . create ( name = 'a' ) <newline> obj , created = a_thing . tags . get_or_create ( text = 'foo' ) <newline> self . assertTrue ( created ) <newline> self . assertEqual ( obj . text , 'foo' ) <newline> self . assertIn ( obj , a_thing . tags . all ( ) ) <newline> <dedent> def test_something ( self ) : <newline> <indent> Tag . objects . create ( text = 'foo' ) <newline> a_thing = Thing . objects . create ( name = 'a' ) <newline> self . assertRaises ( IntegrityError , a_thing . tags . get_or_create , text = 'foo' ) <newline> <dedent> <dedent> class UpdateOrCreateTests ( TestCase ) : <newline> <indent> def test_update ( self ) : <newline> <indent> Person . objects . create ( first_name = 'John' , last_name = 'Lennon' , birthday = date ( 1940 , 10 , 9 ) ) <newline> p , created = Person . objects . update_or_create ( first_name = 'John' , last_name = 'Lennon' , defaults = { 'birthday' : date ( 1940 , 10 , 10 ) } ) <newline> self . assertFalse ( created ) <newline> self . assertEqual ( p . first_name , 'John' ) <newline> self . assertEqual ( p . last_name , 'Lennon' ) <newline> self . assertEqual ( p . birthday , date ( 1940 , 10 , 10 ) ) <newline> <dedent> def test_create ( self ) : <newline> <indent> p , created = Person . objects . update_or_create ( first_name = 'John' , last_name = 'Lennon' , defaults = { 'birthday' : date ( 1940 , 10 , 10 ) } ) <newline> self . assertTrue ( created ) <newline> self . assertEqual ( p . first_name , 'John' ) <newline> self . assertEqual ( p . last_name , 'Lennon' ) <newline> self . assertEqual ( p . birthday , date ( 1940 , 10 , 10 ) ) <newline> <dedent> def test_create_twice ( self ) : <newline> <indent> params = { 'first_name' : 'John' , 'last_name' : 'Lennon' , 'birthday' : date ( 1940 , 10 , 10 ) , } <newline> Person . objects . update_or_create ( ** params ) <newline>  # ▁ If ▁ we ▁ execute ▁ the ▁ exact ▁ same ▁ statement, ▁ it ▁ won't ▁ create ▁ a ▁ Person. <encdom> p , created = Person . objects . update_or_create ( ** params ) <newline> self . assertFalse ( created ) <newline> <dedent> def test_integrity ( self ) : <newline>  # ▁ If ▁ you ▁ don't ▁ specify ▁ a ▁ value ▁ or ▁ default ▁ value ▁ for ▁ all ▁ required <encdom>  # ▁ fields, ▁ you ▁ will ▁ get ▁ an ▁ error. <encdom> <indent> self . assertRaises ( IntegrityError , Person . objects . update_or_create , first_name = "Tom" , last_name = "Smith" ) <newline> <dedent> def test_manual_primary_key_test ( self ) : <newline>  # ▁ If ▁ you ▁ specify ▁ an ▁ existing ▁ primary ▁ key, ▁ but ▁ different ▁ other ▁ fields, <encdom>  # ▁ then ▁ you ▁ will ▁ get ▁ an ▁ error ▁ and ▁ data ▁ will ▁ not ▁ be ▁ updated. <encdom> <indent> ManualPrimaryKeyTest . objects . create ( id = 1 , data = "Original" ) <newline> self . assertRaises ( IntegrityError , ManualPrimaryKeyTest . objects . update_or_create , id = 1 , data = "Different" ) <newline> self . assertEqual ( ManualPrimaryKeyTest . objects . get ( id = 1 ) . data , "Original" ) <newline> <dedent> def test_error_contains_full_traceback ( self ) : <newline>  # ▁ update_or_create ▁ should ▁ raise ▁ IntegrityErrors ▁ with ▁ the ▁ full ▁ traceback. <encdom>  # ▁ This ▁ is ▁ tested ▁ by ▁ checking ▁ that ▁ a ▁ known ▁ method ▁ call ▁ is ▁ in ▁ the ▁ traceback. <encdom>  # ▁ We ▁ cannot ▁ use ▁ assertRaises/assertRaises ▁ here ▁ because ▁ we ▁ need ▁ to ▁ inspect <encdom>  # ▁ the ▁ actual ▁ traceback. ▁ Refs ▁ # 16340. <encdom> <indent> try : <newline> <indent> ManualPrimaryKeyTest . objects . update_or_create ( id = 1 , data = "Different" ) <newline> <dedent> except IntegrityError : <newline> <indent> formatted_traceback = traceback . format_exc ( ) <newline> self . assertIn ( 'obj.save' , formatted_traceback ) <newline> <dedent> <dedent> <dedent>
 # ▁ Standard ▁ scientific ▁ Python ▁ imports <encdom> import matplotlib . pyplot as plt <newline>  # ▁ Import ▁ datasets, ▁ classifiers ▁ and ▁ performance ▁ metrics <encdom> from sklearn import datasets <newline>  # ▁ The ▁ digits ▁ dataset <encdom> digits = datasets . load_digits ( ) <newline> images_and_labels = list ( zip ( digits . images , digits . target ) ) <newline> for index , ( image , label ) in enumerate ( images_and_labels [ 10 : 20 ] ) : <newline> <indent> plt . axis ( 'off' ) <newline> plt . imshow ( image , cmap = plt . cm . gray_r , interpolation = 'nearest' ) <newline> plt . savefig ( "figures/%i.png" % label ) <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  """ <strnewline> ▁ tests.test_config <strnewline> ▁ ~~~~~ <strnewline> <strnewline> ▁ :copyright: ▁ (c) ▁ 2015 ▁ by ▁ the ▁ Flask ▁ Team, ▁ see ▁ AUTHORS ▁ for ▁ more ▁ details. <strnewline> ▁ :license: ▁ BSD, ▁ see ▁ LICENSE ▁ for ▁ more ▁ details. <strnewline> """  <newline> import pytest <newline> import os <newline> import flask <newline>  # ▁ config ▁ keys ▁ used ▁ for ▁ the ▁ TestConfig <encdom> TEST_KEY = 'foo' <newline> SECRET_KEY = 'devkey' <newline> def common_object_test ( app ) : <newline> <indent> assert app . secret_key == 'devkey' <newline> assert app . config [ 'TEST_KEY' ] == 'foo' <newline> assert 'TestConfig' not in app . config <newline> <dedent> def test_config_from_file ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> app . config . from_pyfile ( __file__ . rsplit ( '.' , 1 ) [ 0 ] + '.py' ) <newline> common_object_test ( app ) <newline> <dedent> def test_config_from_object ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> app . config . from_object ( __name__ ) <newline> common_object_test ( app ) <newline> <dedent> def test_config_from_json ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> current_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) <newline> app . config . from_json ( os . path . join ( current_dir , 'static' , 'config.json' ) ) <newline> common_object_test ( app ) <newline> <dedent> def test_config_from_mapping ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> app . config . from_mapping ( { 'SECRET_KEY' : 'devkey' , 'TEST_KEY' : 'foo' } ) <newline> common_object_test ( app ) <newline> app = flask . Flask ( __name__ ) <newline> app . config . from_mapping ( [ ( 'SECRET_KEY' , 'devkey' ) , ( 'TEST_KEY' , 'foo' ) ] ) <newline> common_object_test ( app ) <newline> app = flask . Flask ( __name__ ) <newline> app . config . from_mapping ( SECRET_KEY = 'devkey' , TEST_KEY = 'foo' ) <newline> common_object_test ( app ) <newline> app = flask . Flask ( __name__ ) <newline> with pytest . raises ( TypeError ) : <newline> <indent> app . config . from_mapping ( { } , { } ) <newline> <dedent> <dedent> def test_config_from_class ( ) : <newline> <indent> class Base ( object ) : <newline> <indent> TEST_KEY = 'foo' <newline> <dedent> class Test ( Base ) : <newline> <indent> SECRET_KEY = 'devkey' <newline> <dedent> app = flask . Flask ( __name__ ) <newline> app . config . from_object ( Test ) <newline> common_object_test ( app ) <newline> <dedent> def test_config_from_envvar ( ) : <newline> <indent> env = os . environ <newline> try : <newline> <indent> os . environ = { } <newline> app = flask . Flask ( __name__ ) <newline> try : <newline> <indent> app . config . from_envvar ( 'FOO_SETTINGS' ) <newline> <dedent> except RuntimeError as e : <newline> <indent> assert "'FOO_SETTINGS' ▁ is ▁ not ▁ set" in str ( e ) <newline> <dedent> else : <newline> <indent> assert 0 , 'expected ▁ exception' <newline> <dedent> assert not app . config . from_envvar ( 'FOO_SETTINGS' , silent = True ) <newline> os . environ = { 'FOO_SETTINGS' : __file__ . rsplit ( '.' , 1 ) [ 0 ] + '.py' } <newline> assert app . config . from_envvar ( 'FOO_SETTINGS' ) <newline> common_object_test ( app ) <newline> <dedent> finally : <newline> <indent> os . environ = env <newline> <dedent> <dedent> def test_config_from_envvar_missing ( ) : <newline> <indent> env = os . environ <newline> try : <newline> <indent> os . environ = { 'FOO_SETTINGS' : 'missing.cfg' } <newline> try : <newline> <indent> app = flask . Flask ( __name__ ) <newline> app . config . from_envvar ( 'FOO_SETTINGS' ) <newline> <dedent> except IOError as e : <newline> <indent> msg = str ( e ) <newline> assert msg . startswith ( '[Errno ▁ 2] ▁ Unable ▁ to ▁ load ▁ configuration ▁ ' 'file ▁ (No ▁ such ▁ file ▁ or ▁ directory):' ) <newline> assert msg . endswith ( "missing.cfg'" ) <newline> <dedent> else : <newline> <indent> assert False , 'expected ▁ IOError' <newline> <dedent> assert not app . config . from_envvar ( 'FOO_SETTINGS' , silent = True ) <newline> <dedent> finally : <newline> <indent> os . environ = env <newline> <dedent> <dedent> def test_config_missing ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> try : <newline> <indent> app . config . from_pyfile ( 'missing.cfg' ) <newline> <dedent> except IOError as e : <newline> <indent> msg = str ( e ) <newline> assert msg . startswith ( '[Errno ▁ 2] ▁ Unable ▁ to ▁ load ▁ configuration ▁ ' 'file ▁ (No ▁ such ▁ file ▁ or ▁ directory):' ) <newline> assert msg . endswith ( "missing.cfg'" ) <newline> <dedent> else : <newline> <indent> assert 0 , 'expected ▁ config' <newline> <dedent> assert not app . config . from_pyfile ( 'missing.cfg' , silent = True ) <newline> <dedent> def test_config_missing_json ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> try : <newline> <indent> app . config . from_json ( 'missing.json' ) <newline> <dedent> except IOError as e : <newline> <indent> msg = str ( e ) <newline> assert msg . startswith ( '[Errno ▁ 2] ▁ Unable ▁ to ▁ load ▁ configuration ▁ ' 'file ▁ (No ▁ such ▁ file ▁ or ▁ directory):' ) <newline> assert msg . endswith ( "missing.json'" ) <newline> <dedent> else : <newline> <indent> assert 0 , 'expected ▁ config' <newline> <dedent> assert not app . config . from_json ( 'missing.json' , silent = True ) <newline> <dedent> def test_custom_config_class ( ) : <newline> <indent> class Config ( flask . Config ) : <newline> <indent> pass <newline> <dedent> class Flask ( flask . Flask ) : <newline> <indent> config_class = Config <newline> <dedent> app = Flask ( __name__ ) <newline> assert isinstance ( app . config , Config ) <newline> app . config . from_object ( __name__ ) <newline> common_object_test ( app ) <newline> <dedent> def test_session_lifetime ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> app . config [ 'PERMANENT_SESSION_LIFETIME' ] = 42 <newline> assert app . permanent_session_lifetime . seconds == 42 <newline> <dedent> def test_get_namespace ( ) : <newline> <indent> app = flask . Flask ( __name__ ) <newline> app . config [ 'FOO_OPTION_1' ] = 'foo ▁ option ▁ 1' <newline> app . config [ 'FOO_OPTION_2' ] = 'foo ▁ option ▁ 2' <newline> app . config [ 'BAR_STUFF_1' ] = 'bar ▁ stuff ▁ 1' <newline> app . config [ 'BAR_STUFF_2' ] = 'bar ▁ stuff ▁ 2' <newline> foo_options = app . config . get_namespace ( 'FOO_' ) <newline> assert 2 == len ( foo_options ) <newline> assert 'foo ▁ option ▁ 1' == foo_options [ 'option_1' ] <newline> assert 'foo ▁ option ▁ 2' == foo_options [ 'option_2' ] <newline> bar_options = app . config . get_namespace ( 'BAR_' , lowercase = False ) <newline> assert 2 == len ( bar_options ) <newline> assert 'bar ▁ stuff ▁ 1' == bar_options [ 'STUFF_1' ] <newline> assert 'bar ▁ stuff ▁ 2' == bar_options [ 'STUFF_2' ] <newline> foo_options = app . config . get_namespace ( 'FOO_' , trim_namespace = False ) <newline> assert 2 == len ( foo_options ) <newline> assert 'foo ▁ option ▁ 1' == foo_options [ 'foo_option_1' ] <newline> assert 'foo ▁ option ▁ 2' == foo_options [ 'foo_option_2' ] <newline> bar_options = app . config . get_namespace ( 'BAR_' , lowercase = False , trim_namespace = False ) <newline> assert 2 == len ( bar_options ) <newline> assert 'bar ▁ stuff ▁ 1' == bar_options [ 'BAR_STUFF_1' ] <newline> assert 'bar ▁ stuff ▁ 2' == bar_options [ 'BAR_STUFF_2' ] <newline> <dedent>
 """ <strnewline> Miscellaneous ▁ function ▁ (re)definitions ▁ from ▁ the ▁ Py3.4+ ▁ standard ▁ library <strnewline> for ▁ Python ▁ 2.6/2.7. <strnewline> <strnewline> - ▁ math.ceil ▁ (for ▁ Python ▁ 2.7) <strnewline> - ▁ collections.OrderedDict ▁ (for ▁ Python ▁ 2.6) <strnewline> - ▁ collections.Counter ▁ (for ▁ Python ▁ 2.6) <strnewline> - ▁ collections.ChainMap ▁ (for ▁ all ▁ versions ▁ prior ▁ to ▁ Python ▁ 3.3) <strnewline> - ▁ itertools.count ▁ (for ▁ Python ▁ 2.6, ▁ with ▁ step ▁ parameter) <strnewline> - ▁ subprocess.check_output ▁ (for ▁ Python ▁ 2.6) <strnewline> - ▁ reprlib.recursive_repr ▁ (for ▁ Python ▁ 2.6+) <strnewline> - ▁ functools.cmp_to_key ▁ (for ▁ Python ▁ 2.6) <strnewline> """  <newline> from __future__ import absolute_import <newline> import subprocess <newline> from math import ceil as oldceil <newline> from collections import Mapping , MutableMapping <newline> from operator import itemgetter as _itemgetter , eq as _eq <newline> import sys <newline> import heapq as _heapq <newline> from _weakref import proxy as _proxy <newline> from itertools import repeat as _repeat , chain as _chain , starmap as _starmap <newline> from socket import getaddrinfo , SOCK_STREAM , error , socket <newline> from future . utils import iteritems , itervalues , PY26 , PY3 <newline> def ceil ( x ) : <newline> <indent>  """ <strnewline> ▁ Return ▁ the ▁ ceiling ▁ of ▁ x ▁ as ▁ an ▁ int. <strnewline> ▁ This ▁ is ▁ the ▁ smallest ▁ integral ▁ value ▁ >= ▁ x. <strnewline> ▁ """  <newline> return int ( oldceil ( x ) ) <newline>  # # # ▁ reprlib.recursive_repr ▁ decorator ▁ from ▁ Py3.4 <encdom> <dedent> from itertools import islice <newline> if PY3 : <newline> <indent> try : <newline> <indent> from _thread import get_ident <newline> <dedent> except ImportError : <newline> <indent> from _dummy_thread import get_ident <newline> <dedent> <dedent> else : <newline> <indent> try : <newline> <indent> from thread import get_ident <newline> <dedent> except ImportError : <newline> <indent> from dummy_thread import get_ident <newline> <dedent> <dedent> def recursive_repr ( fillvalue = '...' ) : <newline> <indent> 'Decorator ▁ to ▁ make ▁ a ▁ repr ▁ function ▁ return ▁ fillvalue ▁ for ▁ a ▁ recursive ▁ call' <newline> def decorating_function ( user_function ) : <newline> <indent> repr_running = set ( ) <newline> def wrapper ( self ) : <newline> <indent> key = id ( self ) , get_ident ( ) <newline> if key in repr_running : <newline> <indent> return fillvalue <newline> <dedent> repr_running . add ( key ) <newline> try : <newline> <indent> result = user_function ( self ) <newline> <dedent> finally : <newline> <indent> repr_running . discard ( key ) <newline> <dedent> return result <newline>  # ▁ Can't ▁ use ▁ functools.wraps() ▁ here ▁ because ▁ of ▁ bootstrap ▁ issues <encdom> <dedent> wrapper . __module__ = getattr ( user_function , '__module__' ) <newline> wrapper . __doc__ = getattr ( user_function , '__doc__' ) <newline> wrapper . __name__ = getattr ( user_function , '__name__' ) <newline> wrapper . __annotations__ = getattr ( user_function , '__annotations__' , { } ) <newline> return wrapper <newline> <dedent> return decorating_function <newline>  # # # ▁ OrderedDict <encdom> <dedent> class _Link ( object ) : <newline> <indent> __slots__ = 'prev' , 'next' , 'key' , '__weakref__' <newline> <dedent> class OrderedDict ( dict ) : <newline> <indent> 'Dictionary ▁ that ▁ remembers ▁ insertion ▁ order' <newline>  # ▁ An ▁ inherited ▁ dict ▁ maps ▁ keys ▁ to ▁ values. <encdom>  # ▁ The ▁ inherited ▁ dict ▁ provides ▁ __getitem__, ▁ __len__, ▁ __contains__, ▁ and ▁ get. <encdom>  # ▁ The ▁ remaining ▁ methods ▁ are ▁ order-aware. <encdom>  # ▁ Big-O ▁ running ▁ times ▁ for ▁ all ▁ methods ▁ are ▁ the ▁ same ▁ as ▁ regular ▁ dictionaries. <encdom>  # ▁ The ▁ internal ▁ self.__map ▁ dict ▁ maps ▁ keys ▁ to ▁ links ▁ in ▁ a ▁ doubly ▁ linked ▁ list. <encdom>  # ▁ The ▁ circular ▁ doubly ▁ linked ▁ list ▁ starts ▁ and ▁ ends ▁ with ▁ a ▁ sentinel ▁ element. <encdom>  # ▁ The ▁ sentinel ▁ element ▁ never ▁ gets ▁ deleted ▁ (this ▁ simplifies ▁ the ▁ algorithm). <encdom>  # ▁ The ▁ sentinel ▁ is ▁ in ▁ self.__hardroot ▁ with ▁ a ▁ weakref ▁ proxy ▁ in ▁ self.__root. <encdom>  # ▁ The ▁ prev ▁ links ▁ are ▁ weakref ▁ proxies ▁ (to ▁ prevent ▁ circular ▁ references). <encdom>  # ▁ Individual ▁ links ▁ are ▁ kept ▁ alive ▁ by ▁ the ▁ hard ▁ reference ▁ in ▁ self.__map. <encdom>  # ▁ Those ▁ hard ▁ references ▁ disappear ▁ when ▁ a ▁ key ▁ is ▁ deleted ▁ from ▁ an ▁ OrderedDict. <encdom> def __init__ ( * args , ** kwds ) : <newline> <indent>  ''' Initialize ▁ an ▁ ordered ▁ dictionary. ▁ The ▁ signature ▁ is ▁ the ▁ same ▁ as <strnewline> ▁ regular ▁ dictionaries, ▁ but ▁ keyword ▁ arguments ▁ are ▁ not ▁ recommended ▁ because <strnewline> ▁ their ▁ insertion ▁ order ▁ is ▁ arbitrary. <strnewline> <strnewline> ▁ '''  <newline> if not args : <newline> <indent> raise TypeError ( "descriptor ▁'__init__' ▁ of ▁'OrderedDict' ▁ object ▁ " "needs ▁ an ▁ argument" ) <newline> <dedent> self = args [ 0 ] <newline> args = args [ 1 : ] <newline> if len ( args ) > 1 : <newline> <indent> raise TypeError ( 'expected ▁ at ▁ most ▁ 1 ▁ arguments, ▁ got ▁ %d' % len ( args ) ) <newline> <dedent> try : <newline> <indent> self . __root <newline> <dedent> except AttributeError : <newline> <indent> self . __hardroot = _Link ( ) <newline> self . __root = root = _proxy ( self . __hardroot ) <newline> root . prev = root . next = root <newline> self . __map = { } <newline> <dedent> self . __update ( * args , ** kwds ) <newline> <dedent> def __setitem__ ( self , key , value , dict_setitem = dict . __setitem__ , proxy = _proxy , Link = _Link ) : <newline> <indent> 'od.__setitem__(i, ▁ y) ▁ <==> ▁ od[i]=y' <newline>  # ▁ Setting ▁ a ▁ new ▁ item ▁ creates ▁ a ▁ new ▁ link ▁ at ▁ the ▁ end ▁ of ▁ the ▁ linked ▁ list, <encdom>  # ▁ and ▁ the ▁ inherited ▁ dictionary ▁ is ▁ updated ▁ with ▁ the ▁ new ▁ key/value ▁ pair. <encdom> if key not in self : <newline> <indent> self . __map [ key ] = link = Link ( ) <newline> root = self . __root <newline> last = root . prev <newline> link . prev , link . next , link . key = last , root , key <newline> last . next = link <newline> root . prev = proxy ( link ) <newline> <dedent> dict_setitem ( self , key , value ) <newline> <dedent> def __delitem__ ( self , key , dict_delitem = dict . __delitem__ ) : <newline> <indent> 'od.__delitem__(y) ▁ <==> ▁ del ▁ od[y]' <newline>  # ▁ Deleting ▁ an ▁ existing ▁ item ▁ uses ▁ self.__map ▁ to ▁ find ▁ the ▁ link ▁ which ▁ gets <encdom>  # ▁ removed ▁ by ▁ updating ▁ the ▁ links ▁ in ▁ the ▁ predecessor ▁ and ▁ successor ▁ nodes. <encdom> dict_delitem ( self , key ) <newline> link = self . __map . pop ( key ) <newline> link_prev = link . prev <newline> link_next = link . next <newline> link_prev . next = link_next <newline> link_next . prev = link_prev <newline> <dedent> def __iter__ ( self ) : <newline> <indent> 'od.__iter__() ▁ <==> ▁ iter(od)' <newline>  # ▁ Traverse ▁ the ▁ linked ▁ list ▁ in ▁ order. <encdom> root = self . __root <newline> curr = root . next <newline> while curr is not root : <newline> <indent> yield curr . key <newline> curr = curr . next <newline> <dedent> <dedent> def __reversed__ ( self ) : <newline> <indent> 'od.__reversed__() ▁ <==> ▁ reversed(od)' <newline>  # ▁ Traverse ▁ the ▁ linked ▁ list ▁ in ▁ reverse ▁ order. <encdom> root = self . __root <newline> curr = root . prev <newline> while curr is not root : <newline> <indent> yield curr . key <newline> curr = curr . prev <newline> <dedent> <dedent> def clear ( self ) : <newline> <indent> 'od.clear() ▁ -> ▁ None. ▁ Remove ▁ all ▁ items ▁ from ▁ od.' <newline> root = self . __root <newline> root . prev = root . next = root <newline> self . __map . clear ( ) <newline> dict . clear ( self ) <newline> <dedent> def popitem ( self , last = True ) : <newline> <indent>  ''' od.popitem() ▁ -> ▁ (k, ▁ v), ▁ return ▁ and ▁ remove ▁ a ▁ (key, ▁ value) ▁ pair. <strnewline> ▁ Pairs ▁ are ▁ returned ▁ in ▁ LIFO ▁ order ▁ if ▁ last ▁ is ▁ true ▁ or ▁ FIFO ▁ order ▁ if ▁ false. <strnewline> <strnewline> ▁ '''  <newline> if not self : <newline> <indent> raise KeyError ( 'dictionary ▁ is ▁ empty' ) <newline> <dedent> root = self . __root <newline> if last : <newline> <indent> link = root . prev <newline> link_prev = link . prev <newline> link_prev . next = root <newline> root . prev = link_prev <newline> <dedent> else : <newline> <indent> link = root . next <newline> link_next = link . next <newline> root . next = link_next <newline> link_next . prev = root <newline> <dedent> key = link . key <newline> del self . __map [ key ] <newline> value = dict . pop ( self , key ) <newline> return key , value <newline> <dedent> def move_to_end ( self , key , last = True ) : <newline> <indent>  ''' Move ▁ an ▁ existing ▁ element ▁ to ▁ the ▁ end ▁ (or ▁ beginning ▁ if ▁ last==False). <strnewline> <strnewline> ▁ Raises ▁ KeyError ▁ if ▁ the ▁ element ▁ does ▁ not ▁ exist. <strnewline> ▁ When ▁ last=True, ▁ acts ▁ like ▁ a ▁ fast ▁ version ▁ of ▁ self[key]=self.pop(key). <strnewline> <strnewline> ▁ '''  <newline> link = self . __map [ key ] <newline> link_prev = link . prev <newline> link_next = link . next <newline> link_prev . next = link_next <newline> link_next . prev = link_prev <newline> root = self . __root <newline> if last : <newline> <indent> last = root . prev <newline> link . prev = last <newline> link . next = root <newline> last . next = root . prev = link <newline> <dedent> else : <newline> <indent> first = root . next <newline> link . prev = root <newline> link . next = first <newline> root . next = first . prev = link <newline> <dedent> <dedent> def __sizeof__ ( self ) : <newline> <indent> sizeof = sys . getsizeof <newline> n = len ( self ) + 1  # ▁ number ▁ of ▁ links ▁ including ▁ root <encdom> <newline> size = sizeof ( self . __dict__ )  # ▁ instance ▁ dictionary <encdom> <newline> size += sizeof ( self . __map ) * 2  # ▁ internal ▁ dict ▁ and ▁ inherited ▁ dict <encdom> <newline> size += sizeof ( self . __hardroot ) * n  # ▁ link ▁ objects <encdom> <newline> size += sizeof ( self . __root ) * n  # ▁ proxy ▁ objects <encdom> <newline> return size <newline> <dedent> update = __update = MutableMapping . update <newline> keys = MutableMapping . keys <newline> values = MutableMapping . values <newline> items = MutableMapping . items <newline> __ne__ = MutableMapping . __ne__ <newline> __marker = object ( ) <newline> def pop ( self , key , default = __marker ) : <newline> <indent>  ''' od.pop(k[,d]) ▁ -> ▁ v, ▁ remove ▁ specified ▁ key ▁ and ▁ return ▁ the ▁ corresponding <strnewline> ▁ value. ▁ If ▁ key ▁ is ▁ not ▁ found, ▁ d ▁ is ▁ returned ▁ if ▁ given, ▁ otherwise ▁ KeyError <strnewline> ▁ is ▁ raised. <strnewline> <strnewline> ▁ '''  <newline> if key in self : <newline> <indent> result = self [ key ] <newline> del self [ key ] <newline> return result <newline> <dedent> if default is self . __marker : <newline> <indent> raise KeyError ( key ) <newline> <dedent> return default <newline> <dedent> def setdefault ( self , key , default = None ) : <newline> <indent> 'od.setdefault(k[,d]) ▁ -> ▁ od.get(k,d), ▁ also ▁ set ▁ od[k]=d ▁ if ▁ k ▁ not ▁ in ▁ od' <newline> if key in self : <newline> <indent> return self [ key ] <newline> <dedent> self [ key ] = default <newline> return default <newline> <dedent> @ recursive_repr ( ) <newline> def __repr__ ( self ) : <newline> <indent> 'od.__repr__() ▁ <==> ▁ repr(od)' <newline> if not self : <newline> <indent> return '%s()' % ( self . __class__ . __name__ , ) <newline> <dedent> return '%s(%r)' % ( self . __class__ . __name__ , list ( self . items ( ) ) ) <newline> <dedent> def __reduce__ ( self ) : <newline> <indent> 'Return ▁ state ▁ information ▁ for ▁ pickling' <newline> inst_dict = vars ( self ) . copy ( ) <newline> for k in vars ( OrderedDict ( ) ) : <newline> <indent> inst_dict . pop ( k , None ) <newline> <dedent> return self . __class__ , ( ) , inst_dict or None , None , iter ( self . items ( ) ) <newline> <dedent> def copy ( self ) : <newline> <indent> 'od.copy() ▁ -> ▁ a ▁ shallow ▁ copy ▁ of ▁ od' <newline> return self . __class__ ( self ) <newline> <dedent> @ classmethod <newline> def fromkeys ( cls , iterable , value = None ) : <newline> <indent>  ''' OD.fromkeys(S[, ▁ v]) ▁ -> ▁ New ▁ ordered ▁ dictionary ▁ with ▁ keys ▁ from ▁ S. <strnewline> ▁ If ▁ not ▁ specified, ▁ the ▁ value ▁ defaults ▁ to ▁ None. <strnewline> <strnewline> ▁ '''  <newline> self = cls ( ) <newline> for key in iterable : <newline> <indent> self [ key ] = value <newline> <dedent> return self <newline> <dedent> def __eq__ ( self , other ) : <newline> <indent>  ''' od.__eq__(y) ▁ <==> ▁ od==y. ▁ Comparison ▁ to ▁ another ▁ OD ▁ is ▁ order-sensitive <strnewline> ▁ while ▁ comparison ▁ to ▁ a ▁ regular ▁ mapping ▁ is ▁ order-insensitive. <strnewline> <strnewline> ▁ '''  <newline> if isinstance ( other , OrderedDict ) : <newline> <indent> return dict . __eq__ ( self , other ) and all ( map ( _eq , self , other ) ) <newline> <dedent> return dict . __eq__ ( self , other ) <newline>  # ▁ {{{ ▁ http://code.activestate.com/recipes/576611/ ▁ (r11) <encdom> <dedent> <dedent> try : <newline> <indent> from operator import itemgetter <newline> from heapq import nlargest <newline> <dedent> except ImportError : <newline> <indent> pass <newline>  # # # ▁ Counter <encdom> <dedent> def _count_elements ( mapping , iterable ) : <newline> <indent> 'Tally ▁ elements ▁ from ▁ the ▁ iterable.' <newline> mapping_get = mapping . get <newline> for elem in iterable : <newline> <indent> mapping [ elem ] = mapping_get ( elem , 0 ) + 1 <newline> <dedent> <dedent> class Counter ( dict ) : <newline> <indent>  ''' Dict ▁ subclass ▁ for ▁ counting ▁ hashable ▁ items. ▁ Sometimes ▁ called ▁ a ▁ bag <strnewline> ▁ or ▁ multiset. ▁ Elements ▁ are ▁ stored ▁ as ▁ dictionary ▁ keys ▁ and ▁ their ▁ counts <strnewline> ▁ are ▁ stored ▁ as ▁ dictionary ▁ values. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('abcdeabcdabcaba') ▁ # ▁ count ▁ elements ▁ from ▁ a ▁ string <strnewline> <strnewline> ▁ >>> ▁ c.most_common(3) ▁ # ▁ three ▁ most ▁ common ▁ elements <strnewline> ▁ [('a', ▁ 5), ▁ ('b', ▁ 4), ▁ ('c', ▁ 3)] <strnewline> ▁ >>> ▁ sorted(c) ▁ # ▁ list ▁ all ▁ unique ▁ elements <strnewline> ▁ ['a', ▁'b', ▁'c', ▁'d', ▁'e'] <strnewline> ▁ >>> ▁''.join(sorted(c.elements())) ▁ # ▁ list ▁ elements ▁ with ▁ repetitions <strnewline> ▁'aaaaabbbbcccdde' <strnewline> ▁ >>> ▁ sum(c.values()) ▁ # ▁ total ▁ of ▁ all ▁ counts <strnewline> ▁ 15 <strnewline> <strnewline> ▁ >>> ▁ c['a'] ▁ # ▁ count ▁ of ▁ letter ▁'a' <strnewline> ▁ 5 <strnewline> ▁ >>> ▁ for ▁ elem ▁ in ▁'shazam': ▁ # ▁ update ▁ counts ▁ from ▁ an ▁ iterable <strnewline> ▁ ... ▁ c[elem] ▁ += ▁ 1 ▁ # ▁ by ▁ adding ▁ 1 ▁ to ▁ each ▁ element's ▁ count <strnewline> ▁ >>> ▁ c['a'] ▁ # ▁ now ▁ there ▁ are ▁ seven ▁'a' <strnewline> ▁ 7 <strnewline> ▁ >>> ▁ del ▁ c['b'] ▁ # ▁ remove ▁ all ▁'b' <strnewline> ▁ >>> ▁ c['b'] ▁ # ▁ now ▁ there ▁ are ▁ zero ▁'b' <strnewline> ▁ 0 <strnewline> <strnewline> ▁ >>> ▁ d ▁ = ▁ Counter('simsalabim') ▁ # ▁ make ▁ another ▁ counter <strnewline> ▁ >>> ▁ c.update(d) ▁ # ▁ add ▁ in ▁ the ▁ second ▁ counter <strnewline> ▁ >>> ▁ c['a'] ▁ # ▁ now ▁ there ▁ are ▁ nine ▁'a' <strnewline> ▁ 9 <strnewline> <strnewline> ▁ >>> ▁ c.clear() ▁ # ▁ empty ▁ the ▁ counter <strnewline> ▁ >>> ▁ c <strnewline> ▁ Counter() <strnewline> <strnewline> ▁ Note: ▁ If ▁ a ▁ count ▁ is ▁ set ▁ to ▁ zero ▁ or ▁ reduced ▁ to ▁ zero, ▁ it ▁ will ▁ remain <strnewline> ▁ in ▁ the ▁ counter ▁ until ▁ the ▁ entry ▁ is ▁ deleted ▁ or ▁ the ▁ counter ▁ is ▁ cleared: <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('aaabbc') <strnewline> ▁ >>> ▁ c['b'] ▁ -= ▁ 2 ▁ # ▁ reduce ▁ the ▁ count ▁ of ▁'b' ▁ by ▁ two <strnewline> ▁ >>> ▁ c.most_common() ▁ # ▁'b' ▁ is ▁ still ▁ in, ▁ but ▁ its ▁ count ▁ is ▁ zero <strnewline> ▁ [('a', ▁ 3), ▁ ('c', ▁ 1), ▁ ('b', ▁ 0)] <strnewline> <strnewline> ▁ '''  <newline>  # ▁ References: <encdom>  # ▁ http://en.wikipedia.org/wiki/Multiset <encdom>  # ▁ http://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html <encdom>  # ▁ http://www.demo2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm <encdom>  # ▁ http://code.activestate.com/recipes/259174/ <encdom>  # ▁ Knuth, ▁ TAOCP ▁ Vol. ▁ II ▁ section ▁ 4.6.3 <encdom> def __init__ ( * args , ** kwds ) : <newline> <indent>  ''' Create ▁ a ▁ new, ▁ empty ▁ Counter ▁ object. ▁ And ▁ if ▁ given, ▁ count ▁ elements <strnewline> ▁ from ▁ an ▁ input ▁ iterable. ▁ Or, ▁ initialize ▁ the ▁ count ▁ from ▁ another ▁ mapping <strnewline> ▁ of ▁ elements ▁ to ▁ their ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter() ▁ # ▁ a ▁ new, ▁ empty ▁ counter <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('gallahad') ▁ # ▁ a ▁ new ▁ counter ▁ from ▁ an ▁ iterable <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter({'a': ▁ 4, ▁'b': ▁ 2}) ▁ # ▁ a ▁ new ▁ counter ▁ from ▁ a ▁ mapping <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter(a=4, ▁ b=2) ▁ # ▁ a ▁ new ▁ counter ▁ from ▁ keyword ▁ args <strnewline> <strnewline> ▁ '''  <newline> if not args : <newline> <indent> raise TypeError ( "descriptor ▁'__init__' ▁ of ▁'Counter' ▁ object ▁ " "needs ▁ an ▁ argument" ) <newline> <dedent> self = args [ 0 ] <newline> args = args [ 1 : ] <newline> if len ( args ) > 1 : <newline> <indent> raise TypeError ( 'expected ▁ at ▁ most ▁ 1 ▁ arguments, ▁ got ▁ %d' % len ( args ) ) <newline> <dedent> super ( Counter , self ) . __init__ ( ) <newline> self . update ( * args , ** kwds ) <newline> <dedent> def __missing__ ( self , key ) : <newline> <indent> 'The ▁ count ▁ of ▁ elements ▁ not ▁ in ▁ the ▁ Counter ▁ is ▁ zero.' <newline>  # ▁ Needed ▁ so ▁ that ▁ self[missing_item] ▁ does ▁ not ▁ raise ▁ KeyError <encdom> return 0 <newline> <dedent> def most_common ( self , n = None ) : <newline> <indent>  ''' List ▁ the ▁ n ▁ most ▁ common ▁ elements ▁ and ▁ their ▁ counts ▁ from ▁ the ▁ most <strnewline> ▁ common ▁ to ▁ the ▁ least. ▁ If ▁ n ▁ is ▁ None, ▁ then ▁ list ▁ all ▁ element ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ Counter('abcdeabcdabcaba').most_common(3) <strnewline> ▁ [('a', ▁ 5), ▁ ('b', ▁ 4), ▁ ('c', ▁ 3)] <strnewline> <strnewline> ▁ '''  <newline>  # ▁ Emulate ▁ Bag.sortedByCount ▁ from ▁ Smalltalk <encdom> if n is None : <newline> <indent> return sorted ( self . items ( ) , key = _itemgetter ( 1 ) , reverse = True ) <newline> <dedent> return _heapq . nlargest ( n , self . items ( ) , key = _itemgetter ( 1 ) ) <newline> <dedent> def elements ( self ) : <newline> <indent>  ''' Iterator ▁ over ▁ elements ▁ repeating ▁ each ▁ as ▁ many ▁ times ▁ as ▁ its ▁ count. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('ABCABC') <strnewline> ▁ >>> ▁ sorted(c.elements()) <strnewline> ▁ ['A', ▁'A', ▁'B', ▁'B', ▁'C', ▁'C'] <strnewline> <strnewline> ▁ # ▁ Knuth's ▁ example ▁ for ▁ prime ▁ factors ▁ of ▁ 1836: ▁ 2**2 ▁ * ▁ 3**3 ▁ * ▁ 17**1 <strnewline> ▁ >>> ▁ prime_factors ▁ = ▁ Counter({2: ▁ 2, ▁ 3: ▁ 3, ▁ 17: ▁ 1}) <strnewline> ▁ >>> ▁ product ▁ = ▁ 1 <strnewline> ▁ >>> ▁ for ▁ factor ▁ in ▁ prime_factors.elements(): ▁ # ▁ loop ▁ over ▁ factors <strnewline> ▁ ... ▁ product ▁ *= ▁ factor ▁ # ▁ and ▁ multiply ▁ them <strnewline> ▁ >>> ▁ product <strnewline> ▁ 1836 <strnewline> <strnewline> ▁ Note, ▁ if ▁ an ▁ element's ▁ count ▁ has ▁ been ▁ set ▁ to ▁ zero ▁ or ▁ is ▁ a ▁ negative <strnewline> ▁ number, ▁ elements() ▁ will ▁ ignore ▁ it. <strnewline> <strnewline> ▁ '''  <newline>  # ▁ Emulate ▁ Bag.do ▁ from ▁ Smalltalk ▁ and ▁ Multiset.begin ▁ from ▁ C++. <encdom> return _chain . from_iterable ( _starmap ( _repeat , self . items ( ) ) ) <newline>  # ▁ Override ▁ dict ▁ methods ▁ where ▁ necessary <encdom> <dedent> @ classmethod <newline> def fromkeys ( cls , iterable , v = None ) : <newline>  # ▁ There ▁ is ▁ no ▁ equivalent ▁ method ▁ for ▁ counters ▁ because ▁ setting ▁ v=1 <encdom>  # ▁ means ▁ that ▁ no ▁ element ▁ can ▁ have ▁ a ▁ count ▁ greater ▁ than ▁ one. <encdom> <indent> raise NotImplementedError ( 'Counter.fromkeys() ▁ is ▁ undefined. ▁ ▁ Use ▁ Counter(iterable) ▁ instead.' ) <newline> <dedent> def update ( * args , ** kwds ) : <newline> <indent>  ''' Like ▁ dict.update() ▁ but ▁ add ▁ counts ▁ instead ▁ of ▁ replacing ▁ them. <strnewline> <strnewline> ▁ Source ▁ can ▁ be ▁ an ▁ iterable, ▁ a ▁ dictionary, ▁ or ▁ another ▁ Counter ▁ instance. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('which') <strnewline> ▁ >>> ▁ c.update('witch') ▁ # ▁ add ▁ elements ▁ from ▁ another ▁ iterable <strnewline> ▁ >>> ▁ d ▁ = ▁ Counter('watch') <strnewline> ▁ >>> ▁ c.update(d) ▁ # ▁ add ▁ elements ▁ from ▁ another ▁ counter <strnewline> ▁ >>> ▁ c['h'] ▁ # ▁ four ▁'h' ▁ in ▁ which, ▁ witch, ▁ and ▁ watch <strnewline> ▁ 4 <strnewline> <strnewline> ▁ '''  <newline>  # ▁ The ▁ regular ▁ dict.update() ▁ operation ▁ makes ▁ no ▁ sense ▁ here ▁ because ▁ the <encdom>  # ▁ replace ▁ behavior ▁ results ▁ in ▁ the ▁ some ▁ of ▁ original ▁ untouched ▁ counts <encdom>  # ▁ being ▁ mixed-in ▁ with ▁ all ▁ of ▁ the ▁ other ▁ counts ▁ for ▁ a ▁ mismash ▁ that <encdom>  # ▁ doesn't ▁ have ▁ a ▁ straight-forward ▁ interpretation ▁ in ▁ most ▁ counting <encdom>  # ▁ contexts. ▁ Instead, ▁ we ▁ implement ▁ straight-addition. ▁ Both ▁ the ▁ inputs <encdom>  # ▁ and ▁ outputs ▁ are ▁ allowed ▁ to ▁ contain ▁ zero ▁ and ▁ negative ▁ counts. <encdom> if not args : <newline> <indent> raise TypeError ( "descriptor ▁'update' ▁ of ▁'Counter' ▁ object ▁ " "needs ▁ an ▁ argument" ) <newline> <dedent> self = args [ 0 ] <newline> args = args [ 1 : ] <newline> if len ( args ) > 1 : <newline> <indent> raise TypeError ( 'expected ▁ at ▁ most ▁ 1 ▁ arguments, ▁ got ▁ %d' % len ( args ) ) <newline> <dedent> iterable = args [ 0 ] if args else None <newline> if iterable is not None : <newline> <indent> if isinstance ( iterable , Mapping ) : <newline> <indent> if self : <newline> <indent> self_get = self . get <newline> for elem , count in iterable . items ( ) : <newline> <indent> self [ elem ] = count + self_get ( elem , 0 ) <newline> <dedent> <dedent> else : <newline> <indent> super ( Counter , self ) . update ( iterable )  # ▁ fast ▁ path ▁ when ▁ counter ▁ is ▁ empty <encdom> <newline> <dedent> <dedent> else : <newline> <indent> _count_elements ( self , iterable ) <newline> <dedent> <dedent> if kwds : <newline> <indent> self . update ( kwds ) <newline> <dedent> <dedent> def subtract ( * args , ** kwds ) : <newline> <indent>  ''' Like ▁ dict.update() ▁ but ▁ subtracts ▁ counts ▁ instead ▁ of ▁ replacing ▁ them. <strnewline> ▁ Counts ▁ can ▁ be ▁ reduced ▁ below ▁ zero. ▁ Both ▁ the ▁ inputs ▁ and ▁ outputs ▁ are <strnewline> ▁ allowed ▁ to ▁ contain ▁ zero ▁ and ▁ negative ▁ counts. <strnewline> <strnewline> ▁ Source ▁ can ▁ be ▁ an ▁ iterable, ▁ a ▁ dictionary, ▁ or ▁ another ▁ Counter ▁ instance. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('which') <strnewline> ▁ >>> ▁ c.subtract('witch') ▁ # ▁ subtract ▁ elements ▁ from ▁ another ▁ iterable <strnewline> ▁ >>> ▁ c.subtract(Counter('watch')) ▁ # ▁ subtract ▁ elements ▁ from ▁ another ▁ counter <strnewline> ▁ >>> ▁ c['h'] ▁ # ▁ 2 ▁ in ▁ which, ▁ minus ▁ 1 ▁ in ▁ witch, ▁ minus ▁ 1 ▁ in ▁ watch <strnewline> ▁ 0 <strnewline> ▁ >>> ▁ c['w'] ▁ # ▁ 1 ▁ in ▁ which, ▁ minus ▁ 1 ▁ in ▁ witch, ▁ minus ▁ 1 ▁ in ▁ watch <strnewline> ▁ -1 <strnewline> <strnewline> ▁ '''  <newline> if not args : <newline> <indent> raise TypeError ( "descriptor ▁'subtract' ▁ of ▁'Counter' ▁ object ▁ " "needs ▁ an ▁ argument" ) <newline> <dedent> self = args [ 0 ] <newline> args = args [ 1 : ] <newline> if len ( args ) > 1 : <newline> <indent> raise TypeError ( 'expected ▁ at ▁ most ▁ 1 ▁ arguments, ▁ got ▁ %d' % len ( args ) ) <newline> <dedent> iterable = args [ 0 ] if args else None <newline> if iterable is not None : <newline> <indent> self_get = self . get <newline> if isinstance ( iterable , Mapping ) : <newline> <indent> for elem , count in iterable . items ( ) : <newline> <indent> self [ elem ] = self_get ( elem , 0 ) - count <newline> <dedent> <dedent> else : <newline> <indent> for elem in iterable : <newline> <indent> self [ elem ] = self_get ( elem , 0 ) - 1 <newline> <dedent> <dedent> <dedent> if kwds : <newline> <indent> self . subtract ( kwds ) <newline> <dedent> <dedent> def copy ( self ) : <newline> <indent> 'Return ▁ a ▁ shallow ▁ copy.' <newline> return self . __class__ ( self ) <newline> <dedent> def __reduce__ ( self ) : <newline> <indent> return self . __class__ , ( dict ( self ) , ) <newline> <dedent> def __delitem__ ( self , elem ) : <newline> <indent> 'Like ▁ dict.__delitem__() ▁ but ▁ does ▁ not ▁ raise ▁ KeyError ▁ for ▁ missing ▁ values.' <newline> if elem in self : <newline> <indent> super ( Counter , self ) . __delitem__ ( elem ) <newline> <dedent> <dedent> def __repr__ ( self ) : <newline> <indent> if not self : <newline> <indent> return '%s()' % self . __class__ . __name__ <newline> <dedent> try : <newline> <indent> items = ', ▁ ' . join ( map ( '%r: ▁ %r' . __mod__ , self . most_common ( ) ) ) <newline> return '%s({%s})' % ( self . __class__ . __name__ , items ) <newline> <dedent> except TypeError : <newline>  # ▁ handle ▁ case ▁ where ▁ values ▁ are ▁ not ▁ orderable <encdom> <indent> return '{0}({1!r})' . format ( self . __class__ . __name__ , dict ( self ) ) <newline>  # ▁ Multiset-style ▁ mathematical ▁ operations ▁ discussed ▁ in: <encdom>  # ▁ Knuth ▁ TAOCP ▁ Volume ▁ II ▁ section ▁ 4.6.3 ▁ exercise ▁ 19 <encdom>  # ▁ and ▁ at ▁ http://en.wikipedia.org/wiki/Multiset <encdom>  # ▁ Outputs ▁ guaranteed ▁ to ▁ only ▁ include ▁ positive ▁ counts. <encdom>  # ▁ To ▁ strip ▁ negative ▁ and ▁ zero ▁ counts, ▁ add-in ▁ an ▁ empty ▁ counter: <encdom>  # ▁ c ▁ += ▁ Counter() <encdom> <dedent> <dedent> def __add__ ( self , other ) : <newline> <indent>  ''' Add ▁ counts ▁ from ▁ two ▁ counters. <strnewline> <strnewline> ▁ >>> ▁ Counter('abbb') ▁ + ▁ Counter('bcc') <strnewline> ▁ Counter({'b': ▁ 4, ▁'c': ▁ 2, ▁'a': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> if not isinstance ( other , Counter ) : <newline> <indent> return NotImplemented <newline> <dedent> result = Counter ( ) <newline> for elem , count in self . items ( ) : <newline> <indent> newcount = count + other [ elem ] <newline> if newcount > 0 : <newline> <indent> result [ elem ] = newcount <newline> <dedent> <dedent> for elem , count in other . items ( ) : <newline> <indent> if elem not in self and count > 0 : <newline> <indent> result [ elem ] = count <newline> <dedent> <dedent> return result <newline> <dedent> def __sub__ ( self , other ) : <newline> <indent>  ''' ▁ Subtract ▁ count, ▁ but ▁ keep ▁ only ▁ results ▁ with ▁ positive ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ Counter('abbbc') ▁ - ▁ Counter('bccd') <strnewline> ▁ Counter({'b': ▁ 2, ▁'a': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> if not isinstance ( other , Counter ) : <newline> <indent> return NotImplemented <newline> <dedent> result = Counter ( ) <newline> for elem , count in self . items ( ) : <newline> <indent> newcount = count - other [ elem ] <newline> if newcount > 0 : <newline> <indent> result [ elem ] = newcount <newline> <dedent> <dedent> for elem , count in other . items ( ) : <newline> <indent> if elem not in self and count < 0 : <newline> <indent> result [ elem ] = 0 - count <newline> <dedent> <dedent> return result <newline> <dedent> def __or__ ( self , other ) : <newline> <indent>  ''' Union ▁ is ▁ the ▁ maximum ▁ of ▁ value ▁ in ▁ either ▁ of ▁ the ▁ input ▁ counters. <strnewline> <strnewline> ▁ >>> ▁ Counter('abbb') ▁ | ▁ Counter('bcc') <strnewline> ▁ Counter({'b': ▁ 3, ▁'c': ▁ 2, ▁'a': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> if not isinstance ( other , Counter ) : <newline> <indent> return NotImplemented <newline> <dedent> result = Counter ( ) <newline> for elem , count in self . items ( ) : <newline> <indent> other_count = other [ elem ] <newline> newcount = other_count if count < other_count else count <newline> if newcount > 0 : <newline> <indent> result [ elem ] = newcount <newline> <dedent> <dedent> for elem , count in other . items ( ) : <newline> <indent> if elem not in self and count > 0 : <newline> <indent> result [ elem ] = count <newline> <dedent> <dedent> return result <newline> <dedent> def __and__ ( self , other ) : <newline> <indent>  ''' ▁ Intersection ▁ is ▁ the ▁ minimum ▁ of ▁ corresponding ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ Counter('abbb') ▁ & ▁ Counter('bcc') <strnewline> ▁ Counter({'b': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> if not isinstance ( other , Counter ) : <newline> <indent> return NotImplemented <newline> <dedent> result = Counter ( ) <newline> for elem , count in self . items ( ) : <newline> <indent> other_count = other [ elem ] <newline> newcount = count if count < other_count else other_count <newline> if newcount > 0 : <newline> <indent> result [ elem ] = newcount <newline> <dedent> <dedent> return result <newline> <dedent> def __pos__ ( self ) : <newline> <indent> 'Adds ▁ an ▁ empty ▁ counter, ▁ effectively ▁ stripping ▁ negative ▁ and ▁ zero ▁ counts' <newline> return self + Counter ( ) <newline> <dedent> def __neg__ ( self ) : <newline> <indent>  ''' Subtracts ▁ from ▁ an ▁ empty ▁ counter. ▁ Strips ▁ positive ▁ and ▁ zero ▁ counts, <strnewline> ▁ and ▁ flips ▁ the ▁ sign ▁ on ▁ negative ▁ counts. <strnewline> <strnewline> ▁ '''  <newline> return Counter ( ) - self <newline> <dedent> def _keep_positive ( self ) : <newline> <indent>  ''' Internal ▁ method ▁ to ▁ strip ▁ elements ▁ with ▁ a ▁ negative ▁ or ▁ zero ▁ count '''  <newline> nonpositive = [ elem for elem , count in self . items ( ) if not count > 0 ] <newline> for elem in nonpositive : <newline> <indent> del self [ elem ] <newline> <dedent> return self <newline> <dedent> def __iadd__ ( self , other ) : <newline> <indent>  ''' Inplace ▁ add ▁ from ▁ another ▁ counter, ▁ keeping ▁ only ▁ positive ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('abbb') <strnewline> ▁ >>> ▁ c ▁ += ▁ Counter('bcc') <strnewline> ▁ >>> ▁ c <strnewline> ▁ Counter({'b': ▁ 4, ▁'c': ▁ 2, ▁'a': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> for elem , count in other . items ( ) : <newline> <indent> self [ elem ] += count <newline> <dedent> return self . _keep_positive ( ) <newline> <dedent> def __isub__ ( self , other ) : <newline> <indent>  ''' Inplace ▁ subtract ▁ counter, ▁ but ▁ keep ▁ only ▁ results ▁ with ▁ positive ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('abbbc') <strnewline> ▁ >>> ▁ c ▁ -= ▁ Counter('bccd') <strnewline> ▁ >>> ▁ c <strnewline> ▁ Counter({'b': ▁ 2, ▁'a': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> for elem , count in other . items ( ) : <newline> <indent> self [ elem ] -= count <newline> <dedent> return self . _keep_positive ( ) <newline> <dedent> def __ior__ ( self , other ) : <newline> <indent>  ''' Inplace ▁ union ▁ is ▁ the ▁ maximum ▁ of ▁ value ▁ from ▁ either ▁ counter. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('abbb') <strnewline> ▁ >>> ▁ c ▁ |= ▁ Counter('bcc') <strnewline> ▁ >>> ▁ c <strnewline> ▁ Counter({'b': ▁ 3, ▁'c': ▁ 2, ▁'a': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> for elem , other_count in other . items ( ) : <newline> <indent> count = self [ elem ] <newline> if other_count > count : <newline> <indent> self [ elem ] = other_count <newline> <dedent> <dedent> return self . _keep_positive ( ) <newline> <dedent> def __iand__ ( self , other ) : <newline> <indent>  ''' Inplace ▁ intersection ▁ is ▁ the ▁ minimum ▁ of ▁ corresponding ▁ counts. <strnewline> <strnewline> ▁ >>> ▁ c ▁ = ▁ Counter('abbb') <strnewline> ▁ >>> ▁ c ▁ &= ▁ Counter('bcc') <strnewline> ▁ >>> ▁ c <strnewline> ▁ Counter({'b': ▁ 1}) <strnewline> <strnewline> ▁ '''  <newline> for elem , count in self . items ( ) : <newline> <indent> other_count = other [ elem ] <newline> if other_count < count : <newline> <indent> self [ elem ] = other_count <newline> <dedent> <dedent> return self . _keep_positive ( ) <newline> <dedent> <dedent> def check_output ( * popenargs , ** kwargs ) : <newline> <indent>  """ <strnewline> ▁ For ▁ Python ▁ 2.6 ▁ compatibility: ▁ see <strnewline> ▁ http://stackoverflow.com/questions/4814970/ <strnewline> ▁ """  <newline> if 'stdout' in kwargs : <newline> <indent> raise ValueError ( 'stdout ▁ argument ▁ not ▁ allowed, ▁ it ▁ will ▁ be ▁ overridden.' ) <newline> <dedent> process = subprocess . Popen ( stdout = subprocess . PIPE , * popenargs , ** kwargs ) <newline> output , unused_err = process . communicate ( ) <newline> retcode = process . poll ( ) <newline> if retcode : <newline> <indent> cmd = kwargs . get ( "args" ) <newline> if cmd is None : <newline> <indent> cmd = popenargs [ 0 ] <newline> <dedent> raise subprocess . CalledProcessError ( retcode , cmd ) <newline> <dedent> return output <newline> <dedent> def count ( start = 0 , step = 1 ) : <newline> <indent>  """ <strnewline> ▁ ``itertools.count`` ▁ in ▁ Py ▁ 2.6 ▁ doesn't ▁ accept ▁ a ▁ step <strnewline> ▁ parameter. ▁ This ▁ is ▁ an ▁ enhanced ▁ version ▁ of ▁ ``itertools.count`` <strnewline> ▁ for ▁ Py2.6 ▁ equivalent ▁ to ▁ ``itertools.count`` ▁ in ▁ Python ▁ 2.7+. <strnewline> ▁ """  <newline> while True : <newline> <indent> yield start <newline> start += step <newline>  # # # ▁ ChainMap ▁ (helper ▁ for ▁ configparser ▁ and ▁ string.Template) <encdom>  # # # ▁ From ▁ the ▁ Py3.4 ▁ source ▁ code. ▁ See ▁ also: <encdom>  # # # ▁ https://github.com/kkxue/Py2ChainMap/blob/master/py2chainmap.py <encdom> <dedent> <dedent> class ChainMap ( MutableMapping ) : <newline> <indent>  ''' ▁ A ▁ ChainMap ▁ groups ▁ multiple ▁ dicts ▁ (or ▁ other ▁ mappings) ▁ together <strnewline> ▁ to ▁ create ▁ a ▁ single, ▁ updateable ▁ view. <strnewline> <strnewline> ▁ The ▁ underlying ▁ mappings ▁ are ▁ stored ▁ in ▁ a ▁ list. ▁ That ▁ list ▁ is ▁ public ▁ and ▁ can <strnewline> ▁ accessed ▁ or ▁ updated ▁ using ▁ the ▁ *maps* ▁ attribute. ▁ There ▁ is ▁ no ▁ other ▁ state. <strnewline> <strnewline> ▁ Lookups ▁ search ▁ the ▁ underlying ▁ mappings ▁ successively ▁ until ▁ a ▁ key ▁ is ▁ found. <strnewline> ▁ In ▁ contrast, ▁ writes, ▁ updates, ▁ and ▁ deletions ▁ only ▁ operate ▁ on ▁ the ▁ first <strnewline> ▁ mapping. <strnewline> <strnewline> ▁ '''  <newline> def __init__ ( self , * maps ) : <newline> <indent>  ''' Initialize ▁ a ▁ ChainMap ▁ by ▁ setting ▁ *maps* ▁ to ▁ the ▁ given ▁ mappings. <strnewline> ▁ If ▁ no ▁ mappings ▁ are ▁ provided, ▁ a ▁ single ▁ empty ▁ dictionary ▁ is ▁ used. <strnewline> <strnewline> ▁ '''  <newline> self . maps = list ( maps ) or [ { } ]  # ▁ always ▁ at ▁ least ▁ one ▁ map <encdom> <newline> <dedent> def __missing__ ( self , key ) : <newline> <indent> raise KeyError ( key ) <newline> <dedent> def __getitem__ ( self , key ) : <newline> <indent> for mapping in self . maps : <newline> <indent> try : <newline> <indent> return mapping [ key ]  # ▁ can't ▁ use ▁'key ▁ in ▁ mapping' ▁ with ▁ defaultdict <encdom> <newline> <dedent> except KeyError : <newline> <indent> pass <newline> <dedent> <dedent> return self . __missing__ ( key )  # ▁ support ▁ subclasses ▁ that ▁ define ▁ __missing__ <encdom> <newline> <dedent> def get ( self , key , default = None ) : <newline> <indent> return self [ key ] if key in self else default <newline> <dedent> def __len__ ( self ) : <newline> <indent> return len ( set ( ) . union ( * self . maps ) )  # ▁ reuses ▁ stored ▁ hash ▁ values ▁ if ▁ possible <encdom> <newline> <dedent> def __iter__ ( self ) : <newline> <indent> return iter ( set ( ) . union ( * self . maps ) ) <newline> <dedent> def __contains__ ( self , key ) : <newline> <indent> return any ( key in m for m in self . maps ) <newline> <dedent> def __bool__ ( self ) : <newline> <indent> return any ( self . maps ) <newline>  # ▁ Py2 ▁ compatibility: <encdom> <dedent> __nonzero__ = __bool__ <newline> @ recursive_repr ( ) <newline> def __repr__ ( self ) : <newline> <indent> return '{0.__class__.__name__}({1})' . format ( self , ', ▁ ' . join ( map ( repr , self . maps ) ) ) <newline> <dedent> @ classmethod <newline> def fromkeys ( cls , iterable , * args ) : <newline> <indent> 'Create ▁ a ▁ ChainMap ▁ with ▁ a ▁ single ▁ dict ▁ created ▁ from ▁ the ▁ iterable.' <newline> return cls ( dict . fromkeys ( iterable , * args ) ) <newline> <dedent> def copy ( self ) : <newline> <indent> 'New ▁ ChainMap ▁ or ▁ subclass ▁ with ▁ a ▁ new ▁ copy ▁ of ▁ maps[0] ▁ and ▁ refs ▁ to ▁ maps[1:]' <newline> return self . __class__ ( self . maps [ 0 ] . copy ( ) , * self . maps [ 1 : ] ) <newline> <dedent> __copy__ = copy <newline> def new_child ( self , m = None ) :  # ▁ like ▁ Django's ▁ Context.push() <encdom> <newline> <indent>  ''' <strnewline> ▁ New ▁ ChainMap ▁ with ▁ a ▁ new ▁ map ▁ followed ▁ by ▁ all ▁ previous ▁ maps. ▁ If ▁ no <strnewline> ▁ map ▁ is ▁ provided, ▁ an ▁ empty ▁ dict ▁ is ▁ used. <strnewline> ▁ '''  <newline> if m is None : <newline> <indent> m = { } <newline> <dedent> return self . __class__ ( m , * self . maps ) <newline> <dedent> @ property <newline> def parents ( self ) :  # ▁ like ▁ Django's ▁ Context.pop() <encdom> <newline> <indent> 'New ▁ ChainMap ▁ from ▁ maps[1:].' <newline> return self . __class__ ( * self . maps [ 1 : ] ) <newline> <dedent> def __setitem__ ( self , key , value ) : <newline> <indent> self . maps [ 0 ] [ key ] = value <newline> <dedent> def __delitem__ ( self , key ) : <newline> <indent> try : <newline> <indent> del self . maps [ 0 ] [ key ] <newline> <dedent> except KeyError : <newline> <indent> raise KeyError ( 'Key ▁ not ▁ found ▁ in ▁ the ▁ first ▁ mapping: ▁ {!r}' . format ( key ) ) <newline> <dedent> <dedent> def popitem ( self ) : <newline> <indent> 'Remove ▁ and ▁ return ▁ an ▁ item ▁ pair ▁ from ▁ maps[0]. ▁ Raise ▁ KeyError ▁ is ▁ maps[0] ▁ is ▁ empty.' <newline> try : <newline> <indent> return self . maps [ 0 ] . popitem ( ) <newline> <dedent> except KeyError : <newline> <indent> raise KeyError ( 'No ▁ keys ▁ found ▁ in ▁ the ▁ first ▁ mapping.' ) <newline> <dedent> <dedent> def pop ( self , key , * args ) : <newline> <indent> 'Remove ▁ *key* ▁ from ▁ maps[0] ▁ and ▁ return ▁ its ▁ value. ▁ Raise ▁ KeyError ▁ if ▁ *key* ▁ not ▁ in ▁ maps[0].' <newline> try : <newline> <indent> return self . maps [ 0 ] . pop ( key , * args ) <newline> <dedent> except KeyError : <newline> <indent> raise KeyError ( 'Key ▁ not ▁ found ▁ in ▁ the ▁ first ▁ mapping: ▁ {!r}' . format ( key ) ) <newline> <dedent> <dedent> def clear ( self ) : <newline> <indent> 'Clear ▁ maps[0], ▁ leaving ▁ maps[1:] ▁ intact.' <newline> self . maps [ 0 ] . clear ( ) <newline>  # ▁ Re-use ▁ the ▁ same ▁ sentinel ▁ as ▁ in ▁ the ▁ Python ▁ stdlib ▁ socket ▁ module: <encdom> <dedent> <dedent> from socket import _GLOBAL_DEFAULT_TIMEOUT <newline>  # ▁ Was: ▁ _GLOBAL_DEFAULT_TIMEOUT ▁ = ▁ object() <encdom> def create_connection ( address , timeout = _GLOBAL_DEFAULT_TIMEOUT , source_address = None ) : <newline> <indent>  """ Backport ▁ of ▁ 3-argument ▁ create_connection() ▁ for ▁ Py2.6. <strnewline> <strnewline> ▁ Connect ▁ to ▁ *address* ▁ and ▁ return ▁ the ▁ socket ▁ object. <strnewline> <strnewline> ▁ Convenience ▁ function. ▁ Connect ▁ to ▁ *address* ▁ (a ▁ 2-tuple ▁ ``(host, <strnewline> ▁ port)``) ▁ and ▁ return ▁ the ▁ socket ▁ object. ▁ Passing ▁ the ▁ optional <strnewline> ▁ *timeout* ▁ parameter ▁ will ▁ set ▁ the ▁ timeout ▁ on ▁ the ▁ socket ▁ instance <strnewline> ▁ before ▁ attempting ▁ to ▁ connect. ▁ If ▁ no ▁ *timeout* ▁ is ▁ supplied, ▁ the <strnewline> ▁ global ▁ default ▁ timeout ▁ setting ▁ returned ▁ by ▁ :func:`getdefaulttimeout` <strnewline> ▁ is ▁ used. ▁ If ▁ *source_address* ▁ is ▁ set ▁ it ▁ must ▁ be ▁ a ▁ tuple ▁ of ▁ (host, ▁ port) <strnewline> ▁ for ▁ the ▁ socket ▁ to ▁ bind ▁ as ▁ a ▁ source ▁ address ▁ before ▁ making ▁ the ▁ connection. <strnewline> ▁ An ▁ host ▁ of ▁'' ▁ or ▁ port ▁ 0 ▁ tells ▁ the ▁ OS ▁ to ▁ use ▁ the ▁ default. <strnewline> ▁ """  <newline> host , port = address <newline> err = None <newline> for res in getaddrinfo ( host , port , 0 , SOCK_STREAM ) : <newline> <indent> af , socktype , proto , canonname , sa = res <newline> sock = None <newline> try : <newline> <indent> sock = socket ( af , socktype , proto ) <newline> if timeout is not _GLOBAL_DEFAULT_TIMEOUT : <newline> <indent> sock . settimeout ( timeout ) <newline> <dedent> if source_address : <newline> <indent> sock . bind ( source_address ) <newline> <dedent> sock . connect ( sa ) <newline> return sock <newline> <dedent> except error as _ : <newline> <indent> err = _ <newline> if sock is not None : <newline> <indent> sock . close ( ) <newline> <dedent> <dedent> <dedent> if err is not None : <newline> <indent> raise err <newline> <dedent> else : <newline> <indent> raise error ( "getaddrinfo ▁ returns ▁ an ▁ empty ▁ list" ) <newline>  # ▁ Backport ▁ from ▁ Py2.7 ▁ for ▁ Py2.6: <encdom> <dedent> <dedent> def cmp_to_key ( mycmp ) : <newline> <indent>  """ Convert ▁ a ▁ cmp= ▁ function ▁ into ▁ a ▁ key= ▁ function """  <newline> class K ( object ) : <newline> <indent> __slots__ = [ 'obj' ] <newline> def __init__ ( self , obj , * args ) : <newline> <indent> self . obj = obj <newline> <dedent> def __lt__ ( self , other ) : <newline> <indent> return mycmp ( self . obj , other . obj ) < 0 <newline> <dedent> def __gt__ ( self , other ) : <newline> <indent> return mycmp ( self . obj , other . obj ) > 0 <newline> <dedent> def __eq__ ( self , other ) : <newline> <indent> return mycmp ( self . obj , other . obj ) == 0 <newline> <dedent> def __le__ ( self , other ) : <newline> <indent> return mycmp ( self . obj , other . obj ) <= 0 <newline> <dedent> def __ge__ ( self , other ) : <newline> <indent> return mycmp ( self . obj , other . obj ) >= 0 <newline> <dedent> def __ne__ ( self , other ) : <newline> <indent> return mycmp ( self . obj , other . obj ) != 0 <newline> <dedent> def __hash__ ( self ) : <newline> <indent> raise TypeError ( 'hash ▁ not ▁ implemented' ) <newline> <dedent> <dedent> return K <newline>  # ▁ Back ▁ up ▁ our ▁ definitions ▁ above ▁ in ▁ case ▁ they're ▁ useful <encdom> <dedent> _OrderedDict = OrderedDict <newline> _Counter = Counter <newline> _check_output = check_output <newline> _count = count <newline> _ceil = ceil <newline> __count_elements = _count_elements <newline> _recursive_repr = recursive_repr <newline> _ChainMap = ChainMap <newline> _create_connection = create_connection <newline> _cmp_to_key = cmp_to_key <newline>  # ▁ Overwrite ▁ the ▁ definitions ▁ above ▁ with ▁ the ▁ usual ▁ ones <encdom>  # ▁ from ▁ the ▁ standard ▁ library: <encdom> if sys . version_info >= ( 2 , 7 ) : <newline> <indent> from collections import OrderedDict , Counter <newline> from itertools import count <newline> from functools import cmp_to_key <newline> try : <newline> <indent> from subprocess import check_output <newline> <dedent> except ImportError : <newline>  # ▁ Not ▁ available. ▁ This ▁ happens ▁ with ▁ Google ▁ App ▁ Engine: ▁ see ▁ issue ▁ # 231 <encdom> <indent> pass <newline> <dedent> from socket import create_connection <newline> <dedent> if sys . version_info >= ( 3 , 0 ) : <newline> <indent> from math import ceil <newline> from collections import _count_elements <newline> <dedent> if sys . version_info >= ( 3 , 3 ) : <newline> <indent> from reprlib import recursive_repr <newline> from collections import ChainMap <newline> <dedent>
from django . db import models <newline> from django . test import SimpleTestCase <newline> class AbsoluteUrlOverrideTests ( SimpleTestCase ) : <newline> <indent> def test_get_absolute_url ( self ) : <newline> <indent>  """ <strnewline> ▁ get_absolute_url() ▁ functions ▁ as ▁ a ▁ normal ▁ method. <strnewline> ▁ """  <newline> get_absolute_url = lambda o : '/test-a/%s/' % o . pk <newline> TestA = self . _create_model_class ( 'TestA' , get_absolute_url ) <newline> self . assertTrue ( hasattr ( TestA , 'get_absolute_url' ) ) <newline> obj = TestA ( pk = 1 , name = 'Foo' ) <newline> self . assertEqual ( '/test-a/%s/' % obj . pk , obj . get_absolute_url ( ) ) <newline> <dedent> def test_override_get_absolute_url ( self ) : <newline> <indent>  """ <strnewline> ▁ ABSOLUTE_URL_OVERRIDES ▁ should ▁ override ▁ get_absolute_url(). <strnewline> ▁ """  <newline> get_absolute_url = lambda o : '/test-b/%s/' % o . pk <newline> with self . settings ( ABSOLUTE_URL_OVERRIDES = { 'absolute_url_overrides.testb' : lambda o : '/overridden-test-b/%s/' % o . pk , } , ) : <newline> <indent> TestB = self . _create_model_class ( 'TestB' , get_absolute_url ) <newline> obj = TestB ( pk = 1 , name = 'Foo' ) <newline> self . assertEqual ( '/overridden-test-b/%s/' % obj . pk , obj . get_absolute_url ( ) ) <newline> <dedent> <dedent> def test_insert_get_absolute_url ( self ) : <newline> <indent>  """ <strnewline> ▁ ABSOLUTE_URL_OVERRIDES ▁ should ▁ work ▁ even ▁ if ▁ the ▁ model ▁ doesn't ▁ have ▁ a <strnewline> ▁ get_absolute_url() ▁ method. <strnewline> ▁ """  <newline> with self . settings ( ABSOLUTE_URL_OVERRIDES = { 'absolute_url_overrides.testc' : lambda o : '/test-c/%s/' % o . pk , } , ) : <newline> <indent> TestC = self . _create_model_class ( 'TestC' ) <newline> obj = TestC ( pk = 1 , name = 'Foo' ) <newline> self . assertEqual ( '/test-c/%s/' % obj . pk , obj . get_absolute_url ( ) ) <newline> <dedent> <dedent> def _create_model_class ( self , class_name , get_absolute_url_method = None ) : <newline> <indent> attrs = { 'name' : models . CharField ( max_length = 50 ) , '__module__' : 'absolute_url_overrides' , } <newline> if get_absolute_url_method : <newline> <indent> attrs [ 'get_absolute_url' ] = get_absolute_url_method <newline> <dedent> return type ( class_name , ( models . Model , ) , attrs ) <newline> <dedent> <dedent>
 ''' <strnewline> Created ▁ on ▁ 13 ▁ Jul ▁ 2017 <strnewline> <strnewline> @author: ▁ T <strnewline> '''  <newline> from tkinter import * <newline> from tkinter . ttk import * <newline> class TkCanvas ( ) : <newline> <indent> def __init__ ( self , root ) : <newline> <indent> self . frame = Frame ( root ) <newline> self . canvas = Canvas ( self . frame ) <newline> self . canvas . grid ( row = 0 , column = 0 ) <newline> self . draw_rect ( ) <newline> btnQuit = Button ( self . frame , text = "Quit" , command = self . quit ) <newline> btnQuit . grid ( row = 1 , column = 0 , sticky = ( S , E ) ) <newline>  # ▁ add ▁ to ▁ draw ▁ <encdom> self . frame . columnconfigure ( 0 , weight = 2 ) <newline> self . frame . rowconfigure ( 0 , weight = 2 ) <newline> self . frame . pack ( fill = BOTH , expand = True ) <newline>  # ▁ Adding ▁ mose ▁ events <encdom> self . canvas . bind ( "<Button-1>" , self . start_line ) <newline> self . canvas . bind ( "<B1-Motion>" , self . draw_line ) <newline> self . initial = ( 0 , 0 ) <newline> <dedent> def draw_rect ( self ) : <newline> <indent> self . canvas . create_rectangle ( ( 100 , 100 ) , ( 30 , 40 ) ) <newline> <dedent> def quit ( self ) : <newline> <indent> self . frame . quit ( ) <newline> <dedent> def start_line ( self , event ) : <newline> <indent> self . inital = ( event . x , event . y ) <newline> <dedent> def draw_line ( self , event ) : <newline> <indent> self . canvas . create_line ( ( self . inital [ 0 ] , self . inital [ 1 ] , event . x , event . y ) ) <newline> self . inital = ( event . x , event . y ) <newline> <dedent> <dedent> if __name__ == '__main__' : <newline> <indent> root = Tk ( ) <newline> app = TkCanvas ( root ) <newline> root . mainloop ( ) <newline> <dedent>
import tests . model_control . test_ozone_custom_models_enabled as testmod <newline> testmod . build_model ( [ 'Anscombe' ] , [ 'LinearTrend' ] , [ 'Seasonal_Second' ] , [ 'MLP' ] ) ; <newline>
 """ <strnewline> Author: ▁ Kelly ▁ Chan <strnewline> Date: ▁ July ▁ 12 ▁ 2014 <strnewline> """  <newline> import time <newline> import rauth <newline> import pandas <newline> import simplejson as json <newline> def defineParams ( latitude , longitude ) : <newline> <indent> params = { } <newline> params [ "term" ] = "restaurants" <newline> params [ "ll" ] = "{},{}" . format ( str ( latitude ) , str ( longitude ) ) <newline> params [ "radius_filter" ] = "2000" <newline> params [ "limit" ] = "10" <newline> return params <newline> <dedent> def getData ( params ) : <newline>  # ▁ setting ▁ up ▁ personal ▁ Yelp ▁ account <encdom> <indent> consumer_key = "XXX" <newline> consumer_secret = "XXXX" <newline> token = "XXX" <newline> token_secret = "XXX" <newline> session = rauth . OAuth1Session ( consumer_key = consumer_key , consumer_secret = consumer_secret , access_token = token , access_token_secret = token_secret ) <newline> request = session . get ( "http://api.yelp.com/v2/search" , params = params ) <newline>  # ▁ transforming ▁ the ▁ data ▁ in ▁ JSON ▁ format <encdom> data = request . json ( ) <newline> session . close ( ) <newline> return data <newline> <dedent> def main ( ) : <newline> <indent> locations = [ ( 39.98 , - 82.98 ) , ( 42.24 , - 83.61 ) , ( 41.33 , - 89.13 ) ] <newline> apiData = [ ] <newline> for latitude , longitude in locations : <newline> <indent> params = defineParams ( latitude , longitude ) <newline> apiData . append ( getData ( params ) ) <newline> time . sleep ( 1.0 ) <newline>  # print ▁ len(apiData) <encdom> <dedent> for key in apiData [ 0 ] . keys ( ) : <newline> <indent> print key <newline> <dedent> for record in apiData : <newline> <indent> print record [ "businesses" ] <newline> print record [ 'total' ] <newline> print record [ 'region' ] <newline> <dedent> print ( json . dumps ( apiData , sort_keys = True , indent = 4 * ' ▁ ' ) ) <newline> <dedent> if __name__ == '__main__' : <newline> <indent> main ( ) <newline> <dedent>
 # ▁ sign ▁ option ▁ is ▁ available ▁ for ▁ numeric ▁ only <encdom> "{:+}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:+}" . format ( 1 ) <newline> "{:+}" . format ( 1.0 ) <newline> "{:+}" . format ( complex ( 2 , 3 ) ) <newline>  # ▁ alternate ▁ form ▁ option ▁ is ▁ available ▁ for ▁ numeric ▁ only <encdom> "{: # }" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{: # }" . format ( 1 ) <newline> "{: # }" . format ( 1.0 ) <newline> "{: # }" . format ( complex ( 2 , 3 ) ) <newline>  # ▁ thousand ▁ separator ▁ is ▁ available ▁ for ▁ numeric ▁ only ▁ <encdom> "{:,}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:,}" . format ( 1 ) <newline> "{:,}" . format ( 1.0 ) <newline> "{:,}" . format ( complex ( 2 , 3 ) ) <newline>  # ▁ zero ▁ padding ▁ is ▁ available ▁ for ▁ numeric ▁ only <encdom> "{:0}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:0}" . format ( 1 ) <newline> "{:0}" . format ( 1.0 ) <newline> "{:0}" . format ( complex ( 2 , 3 ) ) <newline>  # ▁ precision ▁ is ▁ available ▁ for ▁ str, ▁ float, ▁ and ▁ complex <encdom> "{:.2}" . format ( "s" ) <newline> "{:.2}" . format ( 1.0 ) <newline> "{:.2}" . format ( complex ( 2 , 3 ) ) <newline>  # ▁ presentation ▁ types ▁ for ▁ integer <encdom> "{:b}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:c}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:d}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:o}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:x}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:X}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:n}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:b}" . format ( 1 ) <newline> "{:c}" . format ( 1 ) <newline> "{:d}" . format ( 1 ) <newline> "{:o}" . format ( 1 ) <newline> "{:x}" . format ( 1 ) <newline> "{:X}" . format ( 1 ) <newline> "{:n}" . format ( 1 ) <newline> "{:b}" . format ( True ) <newline> "{:c}" . format ( True ) <newline> "{:d}" . format ( True ) <newline> "{:o}" . format ( True ) <newline> "{:x}" . format ( True ) <newline> "{:X}" . format ( True ) <newline> "{:n}" . format ( True ) <newline> "{:b}" . format ( < warning descr = "Unexpected ▁ type ▁ float" > 1.0 < / warning > ) <newline> "{:c}" . format ( < warning descr = "Unexpected ▁ type ▁ float" > 1.0 < / warning > ) <newline> "{:d}" . format ( < warning descr = "Unexpected ▁ type ▁ float" > 1.0 < / warning > ) <newline> "{:o}" . format ( < warning descr = "Unexpected ▁ type ▁ float" > 1.0 < / warning > ) <newline> "{:x}" . format ( < warning descr = "Unexpected ▁ type ▁ float" > 1.0 < / warning > ) <newline> "{:X}" . format ( < warning descr = "Unexpected ▁ type ▁ float" > 1.0 < / warning > ) <newline> "{:n}" . format ( 1.0 ) <newline> "{:b}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:c}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:d}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:o}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:x}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:X}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:n}" . format ( complex ( 2 , 3 ) ) <newline>  # ▁ presentation ▁ types ▁ for ▁ floating ▁ and ▁ decimal ▁ values <encdom> "{:e}" . format ( 1 ) <newline> "{:E}" . format ( 1 ) <newline> "{:f}" . format ( 1 ) <newline> "{:F}" . format ( 1 ) <newline> "{:g}" . format ( 1 ) <newline> "{:G}" . format ( 1 ) <newline> "{:%}" . format ( 1 ) <newline> "{:e}" . format ( True ) <newline> "{:E}" . format ( True ) <newline> "{:f}" . format ( True ) <newline> "{:F}" . format ( True ) <newline> "{:g}" . format ( True ) <newline> "{:G}" . format ( True ) <newline> "{:%}" . format ( True ) <newline> "{:e}" . format ( 1.0 ) <newline> "{:E}" . format ( 1.0 ) <newline> "{:f}" . format ( 1.0 ) <newline> "{:F}" . format ( 1.0 ) <newline> "{:g}" . format ( 1.0 ) <newline> "{:G}" . format ( 1.0 ) <newline> "{:%}" . format ( 1.0 ) <newline> "{:e}" . format ( complex ( 2 , 3 ) ) <newline> "{:E}" . format ( complex ( 2 , 3 ) ) <newline> "{:f}" . format ( complex ( 2 , 3 ) ) <newline> "{:F}" . format ( complex ( 2 , 3 ) ) <newline> "{:g}" . format ( complex ( 2 , 3 ) ) <newline> "{:G}" . format ( complex ( 2 , 3 ) ) <newline> "{:%}" . format ( < warning descr = "Unexpected ▁ type ▁ complex" > complex ( 2 , 3 ) < / warning > ) <newline> "{:e}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:E}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:f}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:F}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:g}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:G}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline> "{:%}" . format ( < warning descr = "Unexpected ▁ type ▁ str" > "s" < / warning > ) <newline>  # ▁ types ▁ combinations <encdom> < warning descr = "The ▁ format ▁ options ▁ in ▁ chunk ▁ \"0\" ▁ are ▁ incompatible" > "{:,s}" < / warning > . format ( 1 ) <newline>  # ▁ refrefence <encdom> a = dict ( a = 1 , b = 1 ) <newline> "{:s}" . format ( a ) <newline> "{:s}" . format ( None ) <newline>
from base import * <newline> class Test ( TestBase ) : <newline> <indent> def __init__ ( self ) : <newline> <indent> TestBase . __init__ ( self , __file__ ) <newline> self . name = "Double ▁ dot" <newline> self . request = "GET ▁ /whatever/../ ▁ HTTP/1.0 \n " <newline> self . expected_error = 200 <newline> <dedent> <dedent>
import res_config <newline> import google_calendar <newline> import controllers <newline>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ OpenERP, ▁ Open ▁ Source ▁ Management ▁ Solution <encdom>  # ▁ Copyright ▁ (C) ▁ 2004-2010 ▁ Tiny ▁ SPRL ▁ (<http://tiny.be>). <encdom>  # ▁ This ▁ program ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <encdom>  # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as <encdom>  # ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the <encdom>  # ▁ License, ▁ or ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <encdom>  # ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License <encdom>  # ▁ along ▁ with ▁ this ▁ program. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <encdom> import event_confirm <newline>  # ▁ vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4: <encdom>
 # # # # ▁ NOTICE: ▁ THIS ▁ FILE ▁ IS ▁ AUTOGENERATED <encdom>  # # # # ▁ MODIFICATIONS ▁ MAY ▁ BE ▁ LOST ▁ IF ▁ DONE ▁ IMPROPERLY <encdom>  # # # # ▁ PLEASE ▁ SEE ▁ THE ▁ ONLINE ▁ DOCUMENTATION ▁ FOR ▁ EXAMPLES <encdom> from swgpy . object import * <newline> def create ( kernel ) : <newline> <indent> result = Intangible ( ) <newline> result . template = "object/draft_schematic/armor/component/shared_armor_layer_ris.iff" <newline> result . attribute_template_id = - 1 <newline> result . stfName ( "string_id_table" , "" ) <newline>  # # # # ▁ BEGIN ▁ MODIFICATIONS ▁ # # # # <encdom>  # # # # ▁ END ▁ MODIFICATIONS ▁ # # # # <encdom> return result <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ pelisalacarta ▁ - ▁ XBMC ▁ Plugin <encdom>  # ▁ Conector ▁ para ▁ upafile <encdom>  # ▁ http://blog.tvalacarta.info/plugin-xbmc/pelisalacarta/ <encdom> import urlparse , urllib2 , urllib , re <newline> import os <newline> from core import scrapertools <newline> from core import logger <newline> from core import config <newline> from core import unpackerjs <newline> def test_video_exists ( page_url ) : <newline> <indent> return True , "" <newline> <dedent> def get_video_url ( page_url , premium = False , user = "" , password = "" , video_password = "" ) : <newline> <indent> logger . info ( "[upafile.py] ▁ get_video_url(page_url='%s')" % page_url ) <newline> video_urls = [ ] <newline> data = scrapertools . cache_page ( page_url ) <newline>  # <script ▁ type='text/javascript'>eval(function(p,a,c,k,e,d){while(c--)if(k[c])p=p.replace(new ▁ RegExp('\\b'+c.toString(a)+'\\b','g'),k[c]);return ▁ p}('11 ▁ 0=10 ▁ z(\'2://4.3/6/6.y\',\'6\',\'x\',\'w\',\'9\');0.5(\'v\',\'u\');0.5(\'t\',\'s\');0.5(\'r\',\'q\');0.1(\'p\',\'\');0.1(\'o\',\'2://a.4.3:n/d/m/8.l\');0.1(\'k\',\'2://a.4.3/i/j/h.g\');0.1(\'7\',\'8\');0.1(\'7\',\'2\');0.1(\'2.f\',\'e\');0.c(\'b\');',36,38,'s1|addVariable|http|com|upafile|addParam|player|provider|video||s82|flvplayer|write||start|startparam|jpg|idyoybh552bf||00024|image|mp4|k65ufdsgg7pvam5r5o22urriqvsqzkkf4cu3biws2xwxsvgmrfmjyfbz|182|file|duration|opaque|wmode|always|allowscriptaccess|true|allowfullscreen|400|500|swf|SWFObject|new|var'.split('|'))) <encdom> patron = "<script ▁ type='text/javascript'>(eval\(function\(p,a,c,k,e,d\).*?)</script>" <newline> matches = re . compile ( patron , re . DOTALL ) . findall ( data ) <newline> cifrado = "" <newline> for match in matches : <newline> <indent> logger . info ( "match=" + match ) <newline> if "mp4" in match or "flv" in match or "video" in match : <newline> <indent> cifrado = match <newline> break <newline>  # ▁ Extrae ▁ la ▁ URL ▁ del ▁ vídeo <encdom> <dedent> <dedent> logger . info ( "cifrado=" + cifrado ) <newline> descifrado = unpackerjs . unpackjs ( cifrado ) <newline> descifrado = descifrado . replace ( "\\" , "" ) <newline> logger . info ( "descifrado=" + descifrado ) <newline>  # s1.addVariable('file','http://s82.upafile.com:182/d/k65ufdsgg7pvam5r5o22urriqvsqzkkf4cu3biws2xwxsvgmrfkxwzx4/video.mp4') <encdom> media_url = scrapertools . get_match ( descifrado , "addVariable\('file','([^']+)'" ) <newline> if len ( matches ) > 0 : <newline> <indent> video_urls . append ( [ scrapertools . get_filename_from_url ( media_url ) [ - 4 : ] + " ▁ [upafile]" , media_url ] ) <newline> <dedent> for video_url in video_urls : <newline> <indent> logger . info ( "[upafile.py] ▁ %s ▁ - ▁ %s" % ( video_url [ 0 ] , video_url [ 1 ] ) ) <newline> <dedent> return video_urls <newline>  # ▁ Encuentra ▁ vídeos ▁ del ▁ servidor ▁ en ▁ el ▁ texto ▁ pasado <encdom> <dedent> def find_videos ( data ) : <newline> <indent> encontrados = set ( ) <newline> devuelve = [ ] <newline>  # http://upafile.com/idyoybh552bf <encdom> data = urllib . unquote ( data ) <newline> patronvideos = '(upafile.com/[a-z0-9]+)' <newline> logger . info ( "[upafile.py] ▁ find_videos ▁ # " + patronvideos + " # " ) <newline> matches = re . compile ( patronvideos , re . DOTALL ) . findall ( data ) <newline> for match in matches : <newline> <indent> titulo = "[upafile]" <newline> url = "http://" + match <newline> if url not in encontrados : <newline> <indent> logger . info ( " ▁ ▁ url=" + url ) <newline> devuelve . append ( [ titulo , url , 'upafile' ] ) <newline> encontrados . add ( url ) <newline> <dedent> else : <newline> <indent> logger . info ( " ▁ ▁ url ▁ duplicada=" + url ) <newline> <dedent> <dedent> return devuelve <newline> <dedent>
 # !/usr/bin/env ▁ python <encdom>  """ <strnewline> obelisk-cardiograph <strnewline> Script ▁ to ▁ monitor ▁ obelisk ▁ servers' ▁ heartbeat. <strnewline> Author: ▁ Noel ▁ Maersk ▁ <veox ▁ ta ▁ wemakethings ▁ tod ▁ net> <strnewline> License: ▁ Affero ▁ GNU ▁ GPLv3 ▁ (see ▁ LICENSE). <strnewline> <strnewline> A ▁ few ▁ examples ▁ from ▁ `zguide` ▁ were ▁ used, ▁ see: <strnewline> https://github.com/imatix/zguide <strnewline> <strnewline> """  <newline> import zmq <newline>  # ▁ This ▁ list ▁ is ▁ necessarily ▁ over ▁ 72 ▁ characters ▁ wide. <encdom> serverlist = [ { 'address' : 'tcp://obelisk.coinkite.com:9092' , 'network' : 'bitcoin' } , { 'address' : 'tcp://preacher.veox.pw:9092' , 'network' : 'bitcoin-testnet' } ] <newline> class Server ( object ) : <newline> <indent> def __init__ ( self , zmqcontext , properties ) : <newline> <indent>  # ▁ Consider ▁ using ▁ an ▁ initialiser ▁ wrapper ▁ as ▁ in <encdom>  # ▁ https://stackoverflow.com/questions/1389180 <encdom>  # ▁ if ▁ the ▁ property ▁ list ▁ gets ▁ too ▁ long. <encdom>  # ▁ Alternatively, ▁ find ▁ if ▁ there's ▁ a ▁ lib ▁ way ▁ to ▁ do ▁ it. <encdom> self . _address = properties [ 'address' ] <newline> self . _network = properties [ 'network' ] <newline> self . socket = zmqcontext . socket ( zmq . SUB ) <newline> <dedent> @ property <newline> def address ( self ) : <newline> <indent>  """ tcp://<server-address>:<port> """  <newline> return self . _address <newline> <dedent> @ address . setter <newline> def address ( self , value ) : <newline> <indent> self . _address = value <newline> <dedent> @ property <newline> def network ( self ) : <newline> <indent>  """ Human-readable ▁ string ▁ description ▁ of ▁ the ▁ P2P ▁ network. """  <newline> return self . _network <newline> <dedent> @ network . setter <newline> def network ( self , value ) : <newline> <indent> self . _network = value <newline> <dedent> def receive_heartbeat ( self ) : <newline> <indent> rawreply = self . socket . recv ( ) <newline> reply = rawreply [ : : - 1 ]  # ▁ obelisk ▁ sends ▁ little-endian <encdom> <newline> return ':' . join ( hex ( x ) [ 2 : ] for x in reply ) <newline> <dedent> def connect ( self , address = None ) : <newline> <indent> if address == None : <newline> <indent> address = self . _address <newline> <dedent> self . socket . connect ( address ) <newline> self . socket . setsockopt ( zmq . SUBSCRIBE , b'' ) <newline> <dedent> def disconnect ( self ) : <newline> <indent> self . socket . close ( ) <newline> <dedent> <dedent> def main ( ) : <newline> <indent>  """ ▁ main ▁ method ▁ """  <newline> context = zmq . Context ( ) <newline> servers = [ ] <newline> for i in serverlist : <newline> <indent> server = Server ( context , i ) <newline> server . connect ( ) <newline> servers . append ( server ) <newline> <dedent> print ( "Entering ▁ main ▁ loop." ) <newline> while True : <newline> <indent> for server in servers : <newline> <indent> print ( server . network , server . address , server . receive_heartbeat ( ) ) <newline>  # ▁ We ▁ never ▁ get ▁ here ▁ but ▁ clean ▁ up ▁ anyhow <encdom> <dedent> <dedent> for server in servers : <newline> <indent> server . disconnect ( ) <newline> <dedent> context . term ( ) <newline> <dedent> if __name__ == "__main__" : <newline> <indent> main ( ) <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ OpenERP, ▁ Open ▁ Source ▁ Management ▁ Solution <encdom>  # ▁ Copyright ▁ (C) ▁ 2004-2010 ▁ Tiny ▁ SPRL ▁ (<http://tiny.be>). <encdom>  # ▁ This ▁ program ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <encdom>  # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as <encdom>  # ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the <encdom>  # ▁ License, ▁ or ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <encdom>  # ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License <encdom>  # ▁ along ▁ with ▁ this ▁ program. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. ▁ <encdom> import purchase <newline> import partner <newline> import stock <newline> import wizard <newline> import report <newline> import stock <newline> import company <newline> import edi <newline> import res_config <newline>  # ▁ vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4: <encdom>
import logging <newline> import os <newline> import tempfile <newline> from flexget import plugin <newline> from flexget . event import event <newline> log = logging . getLogger ( 'subtitles' ) <newline> class PluginPeriscope ( object ) : <newline> <indent>  """ <strnewline> ▁ Search ▁ and ▁ download ▁ subtitles ▁ using ▁ Periscope ▁ by ▁ Patrick ▁ Dessalle ▁ <strnewline> ▁ (http://code.google.com/p/periscope/). <strnewline> ▁ <strnewline> ▁ Example ▁ (complete ▁ task):: <strnewline> <strnewline> ▁ subs: <strnewline> ▁ find: <strnewline> ▁ path: ▁ <strnewline> ▁ - ▁ d:\media\incoming <strnewline> ▁ regexp: ▁'.*\.(avi|mkv|mp4)$' <strnewline> ▁ recursive: ▁ yes <strnewline> ▁ accept_all: ▁ yes <strnewline> ▁ periscope: <strnewline> ▁ languages: <strnewline> ▁ - ▁ it <strnewline> ▁ alternatives: <strnewline> ▁ - ▁ en <strnewline> ▁ overwrite: ▁ yes <strnewline> ▁ """  <newline> schema = { 'type' : 'object' , 'properties' : { 'languages' : { 'type' : 'array' , 'items' : { 'type' : 'string' } , 'minItems' : 1 } , 'alternatives' : { 'type' : 'array' , 'items' : { 'type' : 'string' } } , 'overwrite' : { 'type' : 'boolean' , 'default' : False } , 'subexts' : { 'type' : 'array' , 'items' : { 'type' : 'string' } , 'default' : [ 'srt' , 'stp' , 'sub' , 'stl' , 'ssa' ] } , } , 'additionalProperties' : False } <newline> def on_task_start ( self , task , config ) : <newline> <indent> try : <newline> <indent> import periscope <newline> <dedent> except ImportError as e : <newline> <indent> log . debug ( 'Error ▁ importing ▁ Periscope: ▁ %s' % e ) <newline> raise plugin . DependencyError ( 'periscope' , 'periscope' , 'Periscope ▁ module ▁ required. ▁ ImportError: ▁ %s' % e ) <newline> <dedent> <dedent> def subbed ( self , filename ) : <newline> <indent> for ext in self . exts : <newline> <indent> if os . path . exists ( os . path . splitext ( filename ) [ 0 ] + ext ) : <newline> <indent> return True <newline> <dedent> <dedent> return False <newline> <dedent> def on_task_output ( self , task , config ) : <newline> <indent>  """ <strnewline> ▁ Configuration:: <strnewline> ▁ periscope: <strnewline> ▁ languages: ▁ List ▁ of ▁ languages ▁ in ▁ order ▁ of ▁ preference ▁ (at ▁ least ▁ one ▁ is ▁ required). <strnewline> ▁ alternatives: ▁ List ▁ of ▁ second-choice ▁ languages; ▁ subs ▁ will ▁ be ▁ downloaded ▁ but ▁ entries ▁ rejected. <strnewline> ▁ overwrite: ▁ If ▁ yes ▁ it ▁ will ▁ try ▁ to ▁ download ▁ even ▁ for ▁ videos ▁ that ▁ are ▁ already ▁ subbed. ▁ Default: ▁ no. <strnewline> ▁ subexts: ▁ List ▁ of ▁ subtitles ▁ file ▁ extensions ▁ to ▁ check ▁ (only ▁ useful ▁ with ▁ overwrite=no). ▁ <strnewline> ▁ Default: ▁ srt, ▁ stp, ▁ sub, ▁ stl, ▁ ssa. <strnewline> ▁ """  <newline> if not task . accepted : <newline> <indent> log . debug ( 'nothing ▁ accepted, ▁ aborting' ) <newline> return <newline> <dedent> import periscope <newline> psc = periscope . Periscope ( tempfile . gettempdir ( ) ) <newline> logging . getLogger ( 'periscope' ) . setLevel ( logging . CRITICAL )  # ▁ LOT ▁ of ▁ messages ▁ otherwise <encdom> <newline> langs = [ s . encode ( 'utf8' ) for s in config [ 'languages' ] ]  # ▁ avoid ▁ unicode ▁ warnings <encdom> <newline> alts = [ s . encode ( 'utf8' ) for s in config . get ( 'alternatives' , [ ] ) ] <newline> if not config [ 'overwrite' ] : <newline> <indent> self . exts = [ '.' + s for s in config [ 'subexts' ] ] <newline> <dedent> for entry in task . accepted : <newline> <indent> if 'location' not in entry : <newline> <indent> log . warning ( 'Cannot ▁ act ▁ on ▁ entries ▁ that ▁ do ▁ not ▁ represent ▁ a ▁ local ▁ file.' ) <newline> <dedent> elif not os . path . exists ( entry [ 'location' ] ) : <newline> <indent> entry . fail ( 'file ▁ not ▁ found: ▁ %s' % entry [ 'location' ] ) <newline> <dedent> elif '$RECYCLE.BIN' in entry [ 'location' ] : <newline> <indent> continue  # ▁ ignore ▁ deleted ▁ files ▁ in ▁ Windows ▁ shares <encdom> <newline> <dedent> elif not config [ 'overwrite' ] and self . subbed ( entry [ 'location' ] ) : <newline> <indent> log . warning ( 'cannot ▁ overwrite ▁ existing ▁ subs ▁ for ▁ %s' % entry [ 'location' ] ) <newline> <dedent> else : <newline> <indent> try : <newline> <indent> if psc . downloadSubtitle ( entry [ 'location' ] . encode ( "utf8" ) , langs ) : <newline> <indent> log . info ( 'Subtitles ▁ found ▁ for ▁ %s' % entry [ 'location' ] ) <newline> <dedent> elif alts and psc . downloadSubtitle ( entry [ 'location' ] . encode ( 'utf8' ) , alts ) : <newline> <indent> entry . fail ( 'subtitles ▁ found ▁ for ▁ a ▁ second-choice ▁ language.' ) <newline> <dedent> else : <newline> <indent> entry . fail ( 'cannot ▁ find ▁ any ▁ subtitles ▁ for ▁ now.' ) <newline> <dedent> <dedent> except Exception as err : <newline>  # ▁ don't ▁ want ▁ to ▁ abort ▁ the ▁ entire ▁ task ▁ for ▁ errors ▁ in ▁ a ▁ <encdom>  # ▁ single ▁ video ▁ file ▁ or ▁ for ▁ occasional ▁ network ▁ timeouts <encdom> <indent> entry . fail ( err . message ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> @ event ( 'plugin.register' ) <newline> def register_plugin ( ) : <newline> <indent> plugin . register ( PluginPeriscope , 'periscope' , api_ver = 2 ) <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ Scrapyd ▁ documentation ▁ build ▁ configuration ▁ file, ▁ created ▁ by <encdom>  # ▁ sphinx-quickstart ▁ on ▁ Thu ▁ Feb ▁ 14 ▁ 11:23:13 ▁ 2013. <encdom>  # ▁ This ▁ file ▁ is ▁ execfile()d ▁ with ▁ the ▁ current ▁ directory ▁ set ▁ to ▁ its ▁ containing ▁ dir. <encdom>  # ▁ Note ▁ that ▁ not ▁ all ▁ possible ▁ configuration ▁ values ▁ are ▁ present ▁ in ▁ this <encdom>  # ▁ autogenerated ▁ file. <encdom>  # ▁ All ▁ configuration ▁ values ▁ have ▁ a ▁ default; ▁ values ▁ that ▁ are ▁ commented ▁ out <encdom>  # ▁ serve ▁ to ▁ show ▁ the ▁ default. <encdom> import sys , os <newline>  # ▁ If ▁ extensions ▁ (or ▁ modules ▁ to ▁ document ▁ with ▁ autodoc) ▁ are ▁ in ▁ another ▁ directory, <encdom>  # ▁ add ▁ these ▁ directories ▁ to ▁ sys.path ▁ here. ▁ If ▁ the ▁ directory ▁ is ▁ relative ▁ to ▁ the <encdom>  # ▁ documentation ▁ root, ▁ use ▁ os.path.abspath ▁ to ▁ make ▁ it ▁ absolute, ▁ like ▁ shown ▁ here. <encdom>  # sys.path.insert(0, ▁ os.path.abspath('.')) <encdom>  # ▁ -- ▁ General ▁ configuration ▁ ----- <encdom>  # ▁ If ▁ your ▁ documentation ▁ needs ▁ a ▁ minimal ▁ Sphinx ▁ version, ▁ state ▁ it ▁ here. <encdom>  # needs_sphinx ▁ = ▁'1.0' <encdom>  # ▁ Add ▁ any ▁ Sphinx ▁ extension ▁ module ▁ names ▁ here, ▁ as ▁ strings. ▁ They ▁ can ▁ be ▁ extensions <encdom>  # ▁ coming ▁ with ▁ Sphinx ▁ (named ▁'sphinx.ext.*') ▁ or ▁ your ▁ custom ▁ ones. <encdom> extensions = [ ] <newline>  # ▁ Add ▁ any ▁ paths ▁ that ▁ contain ▁ templates ▁ here, ▁ relative ▁ to ▁ this ▁ directory. <encdom> templates_path = [ '_templates' ] <newline>  # ▁ The ▁ suffix ▁ of ▁ source ▁ filenames. <encdom> source_suffix = '.rst' <newline>  # ▁ The ▁ encoding ▁ of ▁ source ▁ files. <encdom>  # source_encoding ▁ = ▁'utf-8-sig' <encdom>  # ▁ The ▁ master ▁ toctree ▁ document. <encdom> master_doc = 'index' <newline>  # ▁ General ▁ information ▁ about ▁ the ▁ project. <encdom> project = u'Scrapyd' <newline> copyright = u'2013, ▁ Scrapy ▁ group' <newline>  # ▁ The ▁ version ▁ info ▁ for ▁ the ▁ project ▁ you're ▁ documenting, ▁ acts ▁ as ▁ replacement ▁ for <encdom>  # ▁ |version| ▁ and ▁ |release|, ▁ also ▁ used ▁ in ▁ various ▁ other ▁ places ▁ throughout ▁ the <encdom>  # ▁ built ▁ documents. <encdom>  # ▁ The ▁ short ▁ X.Y ▁ version. <encdom> version = '0.18' <newline>  # ▁ The ▁ full ▁ version, ▁ including ▁ alpha/beta/rc ▁ tags. <encdom> release = '0.18' <newline>  # ▁ The ▁ language ▁ for ▁ content ▁ autogenerated ▁ by ▁ Sphinx. ▁ Refer ▁ to ▁ documentation <encdom>  # ▁ for ▁ a ▁ list ▁ of ▁ supported ▁ languages. <encdom>  # language ▁ = ▁ None <encdom>  # ▁ There ▁ are ▁ two ▁ options ▁ for ▁ replacing ▁ |today|: ▁ either, ▁ you ▁ set ▁ today ▁ to ▁ some <encdom>  # ▁ non-false ▁ value, ▁ then ▁ it ▁ is ▁ used: <encdom>  # today ▁ = ▁'' <encdom>  # ▁ Else, ▁ today_fmt ▁ is ▁ used ▁ as ▁ the ▁ format ▁ for ▁ a ▁ strftime ▁ call. <encdom>  # today_fmt ▁ = ▁'%B ▁ %d, ▁ %Y' <encdom>  # ▁ List ▁ of ▁ patterns, ▁ relative ▁ to ▁ source ▁ directory, ▁ that ▁ match ▁ files ▁ and <encdom>  # ▁ directories ▁ to ▁ ignore ▁ when ▁ looking ▁ for ▁ source ▁ files. <encdom> exclude_patterns = [ '_build' ] <newline>  # ▁ The ▁ reST ▁ default ▁ role ▁ (used ▁ for ▁ this ▁ markup: ▁ `text`) ▁ to ▁ use ▁ for ▁ all ▁ documents. <encdom>  # default_role ▁ = ▁ None <encdom>  # ▁ If ▁ true, ▁'()' ▁ will ▁ be ▁ appended ▁ to ▁ :func: ▁ etc. ▁ cross-reference ▁ text. <encdom>  # add_function_parentheses ▁ = ▁ True <encdom>  # ▁ If ▁ true, ▁ the ▁ current ▁ module ▁ name ▁ will ▁ be ▁ prepended ▁ to ▁ all ▁ description <encdom>  # ▁ unit ▁ titles ▁ (such ▁ as ▁ .. ▁ function::). <encdom>  # add_module_names ▁ = ▁ True <encdom>  # ▁ If ▁ true, ▁ sectionauthor ▁ and ▁ moduleauthor ▁ directives ▁ will ▁ be ▁ shown ▁ in ▁ the <encdom>  # ▁ output. ▁ They ▁ are ▁ ignored ▁ by ▁ default. <encdom>  # show_authors ▁ = ▁ False <encdom>  # ▁ The ▁ name ▁ of ▁ the ▁ Pygments ▁ (syntax ▁ highlighting) ▁ style ▁ to ▁ use. <encdom> pygments_style = 'sphinx' <newline>  # ▁ A ▁ list ▁ of ▁ ignored ▁ prefixes ▁ for ▁ module ▁ index ▁ sorting. <encdom>  # modindex_common_prefix ▁ = ▁ [] <encdom>  # ▁ -- ▁ Options ▁ for ▁ HTML ▁ output ▁ ----- <encdom>  # ▁ The ▁ theme ▁ to ▁ use ▁ for ▁ HTML ▁ and ▁ HTML ▁ Help ▁ pages. ▁ See ▁ the ▁ documentation ▁ for <encdom>  # ▁ a ▁ list ▁ of ▁ builtin ▁ themes. <encdom> html_theme = 'default' <newline>  # ▁ Theme ▁ options ▁ are ▁ theme-specific ▁ and ▁ customize ▁ the ▁ look ▁ and ▁ feel ▁ of ▁ a ▁ theme <encdom>  # ▁ further. ▁ For ▁ a ▁ list ▁ of ▁ options ▁ available ▁ for ▁ each ▁ theme, ▁ see ▁ the <encdom>  # ▁ documentation. <encdom>  # html_theme_options ▁ = ▁ {} <encdom>  # ▁ Add ▁ any ▁ paths ▁ that ▁ contain ▁ custom ▁ themes ▁ here, ▁ relative ▁ to ▁ this ▁ directory. <encdom>  # html_theme_path ▁ = ▁ [] <encdom>  # ▁ The ▁ name ▁ for ▁ this ▁ set ▁ of ▁ Sphinx ▁ documents. ▁ If ▁ None, ▁ it ▁ defaults ▁ to <encdom>  # ▁"<project> ▁ v<release> ▁ documentation". <encdom>  # html_title ▁ = ▁ None <encdom>  # ▁ A ▁ shorter ▁ title ▁ for ▁ the ▁ navigation ▁ bar. ▁ Default ▁ is ▁ the ▁ same ▁ as ▁ html_title. <encdom>  # html_short_title ▁ = ▁ None <encdom>  # ▁ The ▁ name ▁ of ▁ an ▁ image ▁ file ▁ (relative ▁ to ▁ this ▁ directory) ▁ to ▁ place ▁ at ▁ the ▁ top <encdom>  # ▁ of ▁ the ▁ sidebar. <encdom>  # html_logo ▁ = ▁ None <encdom>  # ▁ The ▁ name ▁ of ▁ an ▁ image ▁ file ▁ (within ▁ the ▁ static ▁ path) ▁ to ▁ use ▁ as ▁ favicon ▁ of ▁ the <encdom>  # ▁ docs. ▁ This ▁ file ▁ should ▁ be ▁ a ▁ Windows ▁ icon ▁ file ▁ (.ico) ▁ being ▁ 16x16 ▁ or ▁ 32x32 <encdom>  # ▁ pixels ▁ large. <encdom>  # html_favicon ▁ = ▁ None <encdom>  # ▁ Add ▁ any ▁ paths ▁ that ▁ contain ▁ custom ▁ static ▁ files ▁ (such ▁ as ▁ style ▁ sheets) ▁ here, <encdom>  # ▁ relative ▁ to ▁ this ▁ directory. ▁ They ▁ are ▁ copied ▁ after ▁ the ▁ builtin ▁ static ▁ files, <encdom>  # ▁ so ▁ a ▁ file ▁ named ▁"default.css" ▁ will ▁ overwrite ▁ the ▁ builtin ▁"default.css". <encdom> html_static_path = [ '_static' ] <newline>  # ▁ If ▁ not ▁'', ▁ a ▁'Last ▁ updated ▁ on:' ▁ timestamp ▁ is ▁ inserted ▁ at ▁ every ▁ page ▁ bottom, <encdom>  # ▁ using ▁ the ▁ given ▁ strftime ▁ format. <encdom>  # html_last_updated_fmt ▁ = ▁'%b ▁ %d, ▁ %Y' <encdom>  # ▁ If ▁ true, ▁ SmartyPants ▁ will ▁ be ▁ used ▁ to ▁ convert ▁ quotes ▁ and ▁ dashes ▁ to <encdom>  # ▁ typographically ▁ correct ▁ entities. <encdom>  # html_use_smartypants ▁ = ▁ True <encdom>  # ▁ Custom ▁ sidebar ▁ templates, ▁ maps ▁ document ▁ names ▁ to ▁ template ▁ names. <encdom>  # html_sidebars ▁ = ▁ {} <encdom>  # ▁ Additional ▁ templates ▁ that ▁ should ▁ be ▁ rendered ▁ to ▁ pages, ▁ maps ▁ page ▁ names ▁ to <encdom>  # ▁ template ▁ names. <encdom>  # html_additional_pages ▁ = ▁ {} <encdom>  # ▁ If ▁ false, ▁ no ▁ module ▁ index ▁ is ▁ generated. <encdom>  # html_domain_indices ▁ = ▁ True <encdom>  # ▁ If ▁ false, ▁ no ▁ index ▁ is ▁ generated. <encdom>  # html_use_index ▁ = ▁ True <encdom>  # ▁ If ▁ true, ▁ the ▁ index ▁ is ▁ split ▁ into ▁ individual ▁ pages ▁ for ▁ each ▁ letter. <encdom>  # html_split_index ▁ = ▁ False <encdom>  # ▁ If ▁ true, ▁ links ▁ to ▁ the ▁ reST ▁ sources ▁ are ▁ added ▁ to ▁ the ▁ pages. <encdom>  # html_show_sourcelink ▁ = ▁ True <encdom>  # ▁ If ▁ true, ▁"Created ▁ using ▁ Sphinx" ▁ is ▁ shown ▁ in ▁ the ▁ HTML ▁ footer. ▁ Default ▁ is ▁ True. <encdom>  # html_show_sphinx ▁ = ▁ True <encdom>  # ▁ If ▁ true, ▁"(C) ▁ Copyright ▁ ..." ▁ is ▁ shown ▁ in ▁ the ▁ HTML ▁ footer. ▁ Default ▁ is ▁ True. <encdom>  # html_show_copyright ▁ = ▁ True <encdom>  # ▁ If ▁ true, ▁ an ▁ OpenSearch ▁ description ▁ file ▁ will ▁ be ▁ output, ▁ and ▁ all ▁ pages ▁ will <encdom>  # ▁ contain ▁ a ▁ <link> ▁ tag ▁ referring ▁ to ▁ it. ▁ The ▁ value ▁ of ▁ this ▁ option ▁ must ▁ be ▁ the <encdom>  # ▁ base ▁ URL ▁ from ▁ which ▁ the ▁ finished ▁ HTML ▁ is ▁ served. <encdom>  # html_use_opensearch ▁ = ▁'' <encdom>  # ▁ This ▁ is ▁ the ▁ file ▁ name ▁ suffix ▁ for ▁ HTML ▁ files ▁ (e.g. ▁".xhtml"). <encdom>  # html_file_suffix ▁ = ▁ None <encdom>  # ▁ Output ▁ file ▁ base ▁ name ▁ for ▁ HTML ▁ help ▁ builder. <encdom> htmlhelp_basename = 'Scrapyddoc' <newline>  # ▁ -- ▁ Options ▁ for ▁ LaTeX ▁ output ▁ ----- <encdom> latex_elements = {  # ▁ The ▁ paper ▁ size ▁ ('letterpaper' ▁ or ▁'a4paper'). <encdom>  #'papersize': ▁'letterpaper', <encdom>  # ▁ The ▁ font ▁ size ▁ ('10pt', ▁'11pt' ▁ or ▁'12pt'). <encdom>  #'pointsize': ▁'10pt', <encdom>  # ▁ Additional ▁ stuff ▁ for ▁ the ▁ LaTeX ▁ preamble. <encdom>  #'preamble': ▁'', <encdom> } <newline>  # ▁ Grouping ▁ the ▁ document ▁ tree ▁ into ▁ LaTeX ▁ files. ▁ List ▁ of ▁ tuples <encdom>  # ▁ (source ▁ start ▁ file, ▁ target ▁ name, ▁ title, ▁ author, ▁ documentclass ▁ [howto/manual]). <encdom> latex_documents = [ ( 'index' , 'Scrapyd.tex' , u'Scrapyd ▁ Documentation' , u'Scrapy ▁ group' , 'manual' ) , ] <newline>  # ▁ The ▁ name ▁ of ▁ an ▁ image ▁ file ▁ (relative ▁ to ▁ this ▁ directory) ▁ to ▁ place ▁ at ▁ the ▁ top ▁ of <encdom>  # ▁ the ▁ title ▁ page. <encdom>  # latex_logo ▁ = ▁ None <encdom>  # ▁ For ▁"manual" ▁ documents, ▁ if ▁ this ▁ is ▁ true, ▁ then ▁ toplevel ▁ headings ▁ are ▁ parts, <encdom>  # ▁ not ▁ chapters. <encdom>  # latex_use_parts ▁ = ▁ False <encdom>  # ▁ If ▁ true, ▁ show ▁ page ▁ references ▁ after ▁ internal ▁ links. <encdom>  # latex_show_pagerefs ▁ = ▁ False <encdom>  # ▁ If ▁ true, ▁ show ▁ URL ▁ addresses ▁ after ▁ external ▁ links. <encdom>  # latex_show_urls ▁ = ▁ False <encdom>  # ▁ Documents ▁ to ▁ append ▁ as ▁ an ▁ appendix ▁ to ▁ all ▁ manuals. <encdom>  # latex_appendices ▁ = ▁ [] <encdom>  # ▁ If ▁ false, ▁ no ▁ module ▁ index ▁ is ▁ generated. <encdom>  # latex_domain_indices ▁ = ▁ True <encdom>  # ▁ -- ▁ Options ▁ for ▁ manual ▁ page ▁ output ▁ ----- <encdom>  # ▁ One ▁ entry ▁ per ▁ manual ▁ page. ▁ List ▁ of ▁ tuples <encdom>  # ▁ (source ▁ start ▁ file, ▁ name, ▁ description, ▁ authors, ▁ manual ▁ section). <encdom> man_pages = [ ( 'index' , 'scrapyd' , u'Scrapyd ▁ Documentation' , [ u'Scrapy ▁ group' ] , 1 ) ] <newline>  # ▁ If ▁ true, ▁ show ▁ URL ▁ addresses ▁ after ▁ external ▁ links. <encdom>  # man_show_urls ▁ = ▁ False <encdom>  # ▁ -- ▁ Options ▁ for ▁ Texinfo ▁ output ▁ ----- <encdom>  # ▁ Grouping ▁ the ▁ document ▁ tree ▁ into ▁ Texinfo ▁ files. ▁ List ▁ of ▁ tuples <encdom>  # ▁ (source ▁ start ▁ file, ▁ target ▁ name, ▁ title, ▁ author, <encdom>  # ▁ dir ▁ menu ▁ entry, ▁ description, ▁ category) <encdom> texinfo_documents = [ ( 'index' , 'Scrapyd' , u'Scrapyd ▁ Documentation' , u'Scrapy ▁ group' , 'Scrapyd' , 'One ▁ line ▁ description ▁ of ▁ project.' , 'Miscellaneous' ) , ] <newline>  # ▁ Documents ▁ to ▁ append ▁ as ▁ an ▁ appendix ▁ to ▁ all ▁ manuals. <encdom>  # texinfo_appendices ▁ = ▁ [] <encdom>  # ▁ If ▁ false, ▁ no ▁ module ▁ index ▁ is ▁ generated. <encdom>  # texinfo_domain_indices ▁ = ▁ True <encdom>  # ▁ How ▁ to ▁ display ▁ URL ▁ addresses: ▁'footnote', ▁'no', ▁ or ▁'inline'. <encdom>  # texinfo_show_urls ▁ = ▁'footnote' <encdom>
 # ▁ stdlib <encdom> import logging <newline> import mock <newline>  # ▁ project <encdom> from tests . checks . common import AgentCheckTest <newline> from utils . dockerutil import DockerUtil <newline>  # ▁ 3rd ▁ party <encdom> from nose . plugins . attrib import attr <newline> log = logging . getLogger ( 'tests' ) <newline> CONTAINERS_TO_RUN = [ "nginx:latest" , "redis:latest" , ] <newline> MOCK_CONFIG = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "collect_disk_stats" : True , } ] } <newline> POD_NAME_LABEL = "io.kubernetes.pod.name" <newline> def reset_docker_settings ( ) : <newline> <indent>  """ Populate ▁ docker ▁ settings ▁ with ▁ default, ▁ dummy ▁ settings """  <newline> DockerUtil ( ) . set_docker_settings ( { } , { } ) <newline> <dedent> @ attr ( requires = 'docker_daemon' ) <newline> class TestCheckDockerDaemon ( AgentCheckTest ) : <newline> <indent> CHECK_NAME = 'docker_daemon' <newline>  # ▁ Mock ▁ tests ▁ # <encdom> def mock_normal_get_info ( self ) : <newline> <indent> return { 'DriverStatus' : [ [ 'Data ▁ Space ▁ Used' , '1 ▁ GB' ] , [ 'Data ▁ Space ▁ Available' , '9 ▁ GB' ] , [ 'Data ▁ Space ▁ Total' , '10 ▁ GB' ] , [ 'Metadata ▁ Space ▁ Used' , '1 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Available' , '9 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Total' , '10 ▁ MB' ] , ] } <newline> <dedent> def mock_get_info_no_used ( self ) : <newline> <indent> return { 'DriverStatus' : [ [ 'Data ▁ Space ▁ Available' , '9 ▁ GB' ] , [ 'Data ▁ Space ▁ Total' , '10 ▁ GB' ] , [ 'Metadata ▁ Space ▁ Available' , '9 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Total' , '10 ▁ MB' ] , ] } <newline> <dedent> def mock_get_info_no_data ( self ) : <newline> <indent> return { 'DriverStatus' : [ [ 'Metadata ▁ Space ▁ Available' , '9 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Total' , '10 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Used' , '1 ▁ MB' ] , ] } <newline> <dedent> def mock_get_info_invalid_values ( self ) : <newline> <indent> return { 'DriverStatus' : [ [ 'Metadata ▁ Space ▁ Available' , '9 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Total' , '10 ▁ MB' ] , [ 'Metadata ▁ Space ▁ Used' , '11 ▁ MB' ] , ] } <newline> <dedent> def mock_get_info_all_zeros ( self ) : <newline> <indent> return { 'DriverStatus' : [ [ 'Data ▁ Space ▁ Available' , '0 ▁ MB' ] , [ 'Data ▁ Space ▁ Total' , '0 ▁ GB' ] , [ 'Data ▁ Space ▁ Used' , '0 ▁ KB' ] , ] } <newline> <dedent> @ mock . patch ( 'docker.Client.info' ) <newline> def test_devicemapper_disk_metrics ( self , mock_info ) : <newline> <indent> mock_info . return_value = self . mock_normal_get_info ( ) <newline> self . run_check ( MOCK_CONFIG , force_reload = True ) <newline> self . assertMetric ( 'docker.data.free' , value = 9e9 ) <newline> self . assertMetric ( 'docker.data.used' , value = 1e9 ) <newline> self . assertMetric ( 'docker.data.total' , value = 10e9 ) <newline> self . assertMetric ( 'docker.data.percent' , value = 10.0 ) <newline> self . assertMetric ( 'docker.metadata.free' , value = 9e6 ) <newline> self . assertMetric ( 'docker.metadata.used' , value = 1e6 ) <newline> self . assertMetric ( 'docker.metadata.total' , value = 10e6 ) <newline> self . assertMetric ( 'docker.metadata.percent' , value = 10.0 ) <newline> <dedent> @ mock . patch ( 'docker.Client.info' ) <newline> def test_devicemapper_no_used_info ( self , mock_info ) : <newline> <indent>  """ Disk ▁ metrics ▁ collection ▁ should ▁ still ▁ work ▁ and ▁ `percent` ▁ can ▁ be ▁ calculated """  <newline> mock_info . return_value = self . mock_get_info_no_used ( ) <newline> self . run_check ( MOCK_CONFIG , force_reload = True ) <newline> self . assertMetric ( 'docker.data.free' , value = 9e9 ) <newline> self . assertMetric ( 'docker.data.total' , value = 10e9 ) <newline> self . assertMetric ( 'docker.data.percent' , value = 10.0 ) <newline> self . assertMetric ( 'docker.metadata.free' , value = 9e6 ) <newline> self . assertMetric ( 'docker.metadata.total' , value = 10e6 ) <newline> self . assertMetric ( 'docker.metadata.percent' , value = 10.0 ) <newline> <dedent> @ mock . patch ( 'docker.Client.info' ) <newline> def test_devicemapper_no_data_info ( self , mock_info ) : <newline> <indent>  """ Disk ▁ metrics ▁ collection ▁ should ▁ still ▁ partially ▁ work ▁ for ▁ metadata """  <newline> mock_info . return_value = self . mock_get_info_no_data ( ) <newline> self . run_check ( MOCK_CONFIG , force_reload = True ) <newline> self . assertMetric ( 'docker.metadata.free' , value = 9e6 ) <newline> self . assertMetric ( 'docker.metadata.total' , value = 10e6 ) <newline> self . assertMetric ( 'docker.metadata.percent' , value = 10.0 ) <newline> <dedent> @ mock . patch ( 'docker.Client.info' ) <newline> def test_devicemapper_invalid_values ( self , mock_info ) : <newline> <indent>  """ Invalid ▁ values ▁ are ▁ detected ▁ in ▁ _calc_percent_disk_stats, ▁ so ▁ percent ▁ should ▁ be ▁ missing """  <newline> mock_info . return_value = self . mock_get_info_invalid_values ( ) <newline> self . run_check ( MOCK_CONFIG , force_reload = True ) <newline> metric_names = [ metric [ 0 ] for metric in self . metrics ] <newline> self . assertMetric ( 'docker.metadata.free' , value = 9e6 ) <newline> self . assertMetric ( 'docker.metadata.used' , value = 11e6 ) <newline> self . assertMetric ( 'docker.metadata.total' , value = 10e6 ) <newline> self . assertNotIn ( 'docker.metadata.percent' , metric_names ) <newline> <dedent> @ mock . patch ( 'docker.Client.info' ) <newline> def test_devicemapper_all_zeros ( self , mock_info ) : <newline> <indent>  """ Percentage ▁ should ▁ not ▁ be ▁ calculated, ▁ other ▁ metrics ▁ should ▁ be ▁ collected ▁ correctly """  <newline> mock_info . return_value = self . mock_get_info_all_zeros ( ) <newline> self . run_check ( MOCK_CONFIG , force_reload = True ) <newline> metric_names = [ metric [ 0 ] for metric in self . metrics ] <newline> self . assertMetric ( 'docker.data.free' , value = 0 ) <newline> self . assertMetric ( 'docker.data.used' , value = 0 ) <newline> self . assertMetric ( 'docker.data.total' , value = 0 ) <newline> self . assertNotIn ( 'docker.data.percent' , metric_names ) <newline>  # ▁ integration ▁ tests ▁ # <encdom> <dedent> def setUp ( self ) : <newline> <indent> self . docker_client = DockerUtil ( ) . client <newline> for c in CONTAINERS_TO_RUN : <newline> <indent> images = [ i [ "RepoTags" ] [ 0 ] for i in self . docker_client . images ( c . split ( ":" ) [ 0 ] ) if i [ "RepoTags" ] [ 0 ] . startswith ( c ) ] <newline> if len ( images ) == 0 : <newline> <indent> for line in self . docker_client . pull ( c , stream = True ) : <newline> <indent> print line <newline> <dedent> <dedent> <dedent> self . containers = [ ] <newline> for c in CONTAINERS_TO_RUN : <newline> <indent> name = "test-new-{0}" . format ( c . replace ( ":" , "-" ) ) <newline> host_config = None <newline> labels = None <newline> if c == "nginx:latest" : <newline> <indent> host_config = { "Memory" : 137438953472 } <newline> labels = { "label1" : "nginx" , "foo" : "bar" } <newline> <dedent> cont = self . docker_client . create_container ( c , detach = True , name = name , host_config = host_config , labels = labels ) <newline> self . containers . append ( cont ) <newline> <dedent> for c in self . containers : <newline> <indent> log . info ( "Starting ▁ container: ▁ {0}" . format ( c ) ) <newline> self . docker_client . start ( c ) <newline> <dedent> <dedent> def tearDown ( self ) : <newline> <indent> for c in self . containers : <newline> <indent> log . info ( "Stopping ▁ container: ▁ {0}" . format ( c ) ) <newline> self . docker_client . remove_container ( c , force = True ) <newline> <dedent> <dedent> def test_basic_config_single ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.mem.cache' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "collect_image_size" : True , "collect_images_stats" : True } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> <dedent> def test_basic_config_twice ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.cpu.system' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.cpu.system' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.cpu.user' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.cpu.user' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.io.read_bytes' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.io.read_bytes' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.io.write_bytes' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.io.write_bytes' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_rcvd' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_rcvd' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_sent' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_sent' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) ] <newline> custom_tags = [ "extra_tag" , "env:testing" ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "tags" : custom_tags , "collect_image_size" : True , "collect_images_stats" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check_twice ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> expected_tags = list ( custom_tags ) <newline> if tags is not None : <newline> <indent> expected_tags += tags <newline> <dedent> self . assertMetric ( mname , tags = expected_tags , count = 1 , at_least = 1 ) <newline> <dedent> <dedent> def test_exclude_filter ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.cpu.system' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.cpu.user' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.io.read_bytes' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.io.write_bytes' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_rcvd' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_sent' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "exclude" : [ "docker_image:nginx" ] , "collect_images_stats" : True , "collect_image_size" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check_twice ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> perf_metrics = [ "docker.cpu.system" , "docker.cpu.user" , "docker.io.read_bytes" , "docker.io.write_bytes" , "docker.mem.cache" , "docker.mem.rss" , "docker.net.bytes_rcvd" , "docker.net.bytes_sent" ] <newline> nginx_tags = [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] <newline> for mname in perf_metrics : <newline> <indent> self . assertMetric ( mname , tags = nginx_tags , count = 0 ) <newline> <dedent> <dedent> def test_include_filter ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.cpu.system' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.cpu.user' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.io.read_bytes' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.io.write_bytes' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_rcvd' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.net.bytes_sent' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "include" : [ "image_name:redis" ] , "exclude" : [ ".*" ] , "collect_images_stats" : True , "collect_image_size" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check_twice ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> perf_metrics = [ "docker.cpu.system" , "docker.cpu.user" , "docker.io.read_bytes" , "docker.io.write_bytes" , "docker.mem.cache" , "docker.mem.rss" , "docker.net.bytes_rcvd" , "docker.net.bytes_sent" ] <newline> nginx_tags = [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] <newline> for m in perf_metrics : <newline> <indent> self . assertMetric ( mname , tags = nginx_tags , count = 0 ) <newline> <dedent> <dedent> def test_tags_options ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.containers.running' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.containers.stopped' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.containers.stopped' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.cpu.system' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.cpu.system' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.cpu.user' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.cpu.user' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.io.read_bytes' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.io.read_bytes' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.io.write_bytes' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.io.write_bytes' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.mem.cache' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.mem.cache' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.mem.rss' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.mem.rss' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.net.bytes_rcvd' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) , ( 'docker.net.bytes_rcvd' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.net.bytes_sent' , [ "container_command:nginx ▁ -g ▁'daemon ▁ off;'" ] ) , ( 'docker.net.bytes_sent' , [ 'container_command:docker-entrypoint.sh ▁ redis-server' ] ) ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "performance_tags" : [ "container_command" ] , "container_tags" : [ "container_command" ] , "collect_images_stats" : True , "collect_image_size" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check_twice ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> <dedent> def test_set_docker_settings ( self ) : <newline> <indent>  """ Test ▁ a ▁ client ▁ settings ▁ update """  <newline> self . assertEqual ( DockerUtil ( ) . settings [ "version" ] , "auto" ) <newline> cur_loc = __file__ <newline> init_config = { "api_version" : "foobar" , "timeout" : "42" , "tls_client_cert" : cur_loc , "tls_client_key" : cur_loc , "tls_cacert" : cur_loc , "tls" : True } <newline> instance = { "url" : "https://foo.bar:42" , } <newline> DockerUtil ( ) . set_docker_settings ( init_config , instance ) <newline> client = DockerUtil ( ) . client <newline> self . assertEqual ( client . verify , cur_loc ) <newline> self . assertEqual ( client . cert , ( cur_loc , cur_loc ) ) <newline> reset_docker_settings ( ) <newline> <dedent> def test_labels_collection ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' , 'label1:nginx' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' , 'label1:nginx' ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.mem.cache' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' , 'label1:nginx' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' , 'label1:nginx' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.limit' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' , 'label1:nginx' ] ) , ( 'docker.mem.in_use' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' , 'label1:nginx' ] ) , ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "collect_labels_as_tags" : [ "label1" ] , "collect_image_size" : True , "collect_images_stats" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> <dedent> def test_histogram ( self ) : <newline> <indent> metric_suffix = [ "count" , "avg" , "median" , "max" , "95percentile" ] <newline> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ] <newline> histo_metrics = [ ( 'docker.mem.cache' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.limit' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.in_use' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "collect_image_size" : True , "collect_images_stats" : True , "use_histogram" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> for mname , tags in histo_metrics : <newline> <indent> for suffix in metric_suffix : <newline> <indent> self . assertMetric ( mname + "." + suffix , tags = tags , at_least = 1 ) <newline> <dedent> <dedent> <dedent> def test_events ( self ) : <newline> <indent> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "collect_images_stats" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check ( config , force_reload = True ) <newline> self . assertEqual ( len ( self . events ) , 2 ) <newline> <dedent> def test_container_size ( self ) : <newline> <indent> expected_metrics = [ ( 'docker.containers.running' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.containers.running' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.containers.stopped' , [ 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.image.virtual_size' , [ 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.images.available' , None ) , ( 'docker.images.intermediate' , None ) , ( 'docker.mem.cache' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.cache' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.rss' , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( 'docker.mem.limit' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( 'docker.mem.in_use' , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) ,  # ▁ Container ▁ size ▁ metrics <encdom> ( "docker.container.size_rootfs" , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ( "docker.container.size_rootfs" , [ 'container_name:test-new-redis-latest' , 'docker_image:redis:latest' , 'image_name:redis' , 'image_tag:latest' ] ) , ( "docker.container.size_rw" , [ 'container_name:test-new-nginx-latest' , 'docker_image:nginx:latest' , 'image_name:nginx' , 'image_tag:latest' ] ) , ] <newline> config = { "init_config" : { } , "instances" : [ { "url" : "unix://var/run/docker.sock" , "collect_container_size" : True , "collect_image_size" : True , "collect_images_stats" : True , } , ] , } <newline> DockerUtil ( ) . set_docker_settings ( config [ 'init_config' ] , config [ 'instances' ] [ 0 ] ) <newline> self . run_check ( config , force_reload = True ) <newline> for mname , tags in expected_metrics : <newline> <indent> self . assertMetric ( mname , tags = tags , count = 1 , at_least = 1 ) <newline> <dedent> <dedent> def test_image_tags_extraction ( self ) : <newline> <indent> entities = [  # ▁ ({'Image': ▁ image_name}, ▁ [expected_image_name, ▁ expected_image_tag]) <encdom> ( { 'Image' : 'nginx:latest' } , [ [ 'nginx' ] , [ 'latest' ] ] ) , ( { 'Image' : 'localhost/nginx:latest' } , [ [ 'localhost/nginx' ] , [ 'latest' ] ] ) , ( { 'Image' : 'localhost:5000/nginx:latest' } , [ [ 'localhost:5000/nginx' ] , [ 'latest' ] ] ) , ( { 'RepoTags' : [ 'redis:latest' ] } , [ [ 'redis' ] , [ 'latest' ] ] ) , ( { 'RepoTags' : [ 'localhost/redis:latest' ] } , [ [ 'localhost/redis' ] , [ 'latest' ] ] ) , ( { 'RepoTags' : [ 'localhost:5000/redis:latest' ] } , [ [ 'localhost:5000/redis' ] , [ 'latest' ] ] ) , ( { 'RepoTags' : [ 'localhost:5000/redis:latest' , 'localhost:5000/redis:v1.1' ] } , [ [ 'localhost:5000/redis' ] , [ 'latest' , 'v1.1' ] ] ) , ] <newline> for entity in entities : <newline> <indent> self . assertEqual ( sorted ( DockerUtil . image_tag_extractor ( entity [ 0 ] , 0 ) ) , sorted ( entity [ 1 ] [ 0 ] ) ) <newline> self . assertEqual ( sorted ( DockerUtil . image_tag_extractor ( entity [ 0 ] , 1 ) ) , sorted ( entity [ 1 ] [ 1 ] ) ) <newline> <dedent> <dedent> def test_container_name_extraction ( self ) : <newline> <indent> containers = [ ( { 'Id' : 'deadbeef' } , [ 'deadbeef' ] ) , ( { 'Names' : [ '/redis' ] , 'Id' : 'deadbeef' } , [ 'redis' ] ) , ( { 'Names' : [ '/mongo' , '/redis/mongo' ] , 'Id' : 'deadbeef' } , [ 'mongo' ] ) , ( { 'Names' : [ '/redis/mongo' , '/mongo' ] , 'Id' : 'deadbeef' } , [ 'mongo' ] ) , ] <newline> for co in containers : <newline> <indent> self . assertEqual ( DockerUtil . container_name_extractor ( co [ 0 ] ) , co [ 1 ] ) <newline> <dedent> <dedent> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ Third ▁ Party ▁ Library ▁ Imports <encdom> from django . utils . six . moves . urllib_parse import quote <newline>  # ▁ First ▁ Party ▁ Library ▁ Imports <encdom> from shibauth_rit . conf import settings <newline>  # ▁ Local ▁ Imports <encdom> from . compat import reverse <newline> def login_link ( request ) : <newline> <indent>  """ <strnewline> ▁ This ▁ assumes ▁ your ▁ login ▁ link ▁ is ▁ the ▁ Shibboleth ▁ login ▁ page ▁ for ▁ your ▁ server <strnewline> ▁ and ▁ uses ▁ the ▁'target' ▁ url ▁ parameter. <strnewline> ▁ """  <newline> full_path = quote ( request . get_full_path ( ) ) <newline> login = reverse ( 'shibauth_rit:shibauth_login' ) <newline> login_link = "%s?target=%s" % ( login , full_path ) <newline> return { 'login_link' : login_link } <newline> <dedent> def logout_link ( request , * args ) : <newline> <indent>  """ <strnewline> ▁ This ▁ assumes ▁ your ▁ login ▁ link ▁ is ▁ the ▁ Shibboleth ▁ login ▁ page ▁ for ▁ your ▁ server <strnewline> ▁ and ▁ uses ▁ the ▁'target' ▁ url ▁ parameter. <strnewline> ▁ e.g: ▁ https://school.edu/Shibboleth.sso/Login <strnewline> ▁ """  <newline> LOGOUT_REDIRECT_URL = getattr ( settings , "SHIBAUTH_LOGOUT_REDIRECT_URL" ) <newline>  # ▁ LOGOUT_REDIRECT_URL ▁ specifies ▁ a ▁ default ▁ logout ▁ page ▁ that ▁ will ▁ always ▁ be ▁ used ▁ when <encdom>  # ▁ users ▁ logout ▁ from ▁ Shibboleth. <encdom> target = LOGOUT_REDIRECT_URL or quote ( request . build_absolute_uri ( ) ) <newline> logout = reverse ( 'shibauth_rit:shibauth_logout' ) <newline> logout_link = "%s?target=%s" % ( logout , target ) <newline> return { 'logout_link' : logout_link } <newline> <dedent>
 # !/usr/bin/env ▁ python <encdom> import argparse <newline> import errno <newline> import os <newline> import subprocess <newline> import sys <newline> import tempfile <newline> from lib . config import PLATFORM , get_target_arch , get_chromedriver_version <newline> from lib . util import atom_gyp , execute , get_atom_shell_version , parse_version , scoped_cwd <newline> from lib . github import GitHub <newline> ATOM_SHELL_REPO = 'atom/electron' <newline> ATOM_SHELL_VERSION = get_atom_shell_version ( ) <newline> PROJECT_NAME = atom_gyp ( ) [ 'project_name%' ] <newline> PRODUCT_NAME = atom_gyp ( ) [ 'product_name%' ] <newline> SOURCE_ROOT = os . path . abspath ( os . path . dirname ( os . path . dirname ( __file__ ) ) ) <newline> OUT_DIR = os . path . join ( SOURCE_ROOT , 'out' , 'R' ) <newline> DIST_DIR = os . path . join ( SOURCE_ROOT , 'dist' ) <newline> DIST_NAME = '{0}-{1}-{2}-{3}.zip' . format ( PROJECT_NAME , ATOM_SHELL_VERSION , PLATFORM , get_target_arch ( ) ) <newline> SYMBOLS_NAME = '{0}-{1}-{2}-{3}-symbols.zip' . format ( PROJECT_NAME , ATOM_SHELL_VERSION , PLATFORM , get_target_arch ( ) ) <newline> MKSNAPSHOT_NAME = 'mksnapshot-{0}-{1}-{2}.zip' . format ( ATOM_SHELL_VERSION , PLATFORM , get_target_arch ( ) ) <newline> def main ( ) : <newline> <indent> args = parse_args ( ) <newline> if not args . publish_release : <newline> <indent> if not dist_newer_than_head ( ) : <newline> <indent> create_dist = os . path . join ( SOURCE_ROOT , 'script' , 'create-dist.py' ) <newline> execute ( [ sys . executable , create_dist ] ) <newline> <dedent> build_version = get_atom_shell_build_version ( ) <newline> if not ATOM_SHELL_VERSION . startswith ( build_version ) : <newline> <indent> error = 'Tag ▁ name ▁ ({0}) ▁ should ▁ match ▁ build ▁ version ▁ ({1}) \n ' . format ( ATOM_SHELL_VERSION , build_version ) <newline> sys . stderr . write ( error ) <newline> sys . stderr . flush ( ) <newline> return 1 <newline> <dedent> <dedent> github = GitHub ( auth_token ( ) ) <newline> releases = github . repos ( ATOM_SHELL_REPO ) . releases . get ( ) <newline> tag_exists = False <newline> for release in releases : <newline> <indent> if not release [ 'draft' ] and release [ 'tag_name' ] == args . version : <newline> <indent> tag_exists = True <newline> break <newline> <dedent> <dedent> release = create_or_get_release_draft ( github , releases , args . version , tag_exists ) <newline> if args . publish_release : <newline>  # ▁ Upload ▁ the ▁ SHASUMS.txt. <encdom> <indent> execute ( [ sys . executable , os . path . join ( SOURCE_ROOT , 'script' , 'upload-checksums.py' ) , '-v' , ATOM_SHELL_VERSION ] ) <newline>  # ▁ Upload ▁ the ▁ index.json. <encdom> execute ( [ sys . executable , os . path . join ( SOURCE_ROOT , 'script' , 'upload-index-json.py' ) ] ) <newline>  # ▁ Press ▁ the ▁ publish ▁ button. <encdom> publish_release ( github , release [ 'id' ] ) <newline>  # ▁ Do ▁ not ▁ upload ▁ other ▁ files ▁ when ▁ passed ▁"-p". <encdom> return <newline>  # ▁ Upload ▁ atom-shell ▁ with ▁ GitHub ▁ Releases ▁ API. <encdom> <dedent> upload_atom_shell ( github , release , os . path . join ( DIST_DIR , DIST_NAME ) ) <newline> upload_atom_shell ( github , release , os . path . join ( DIST_DIR , SYMBOLS_NAME ) ) <newline>  # ▁ Upload ▁ chromedriver ▁ and ▁ mksnapshot ▁ for ▁ minor ▁ version ▁ update. <encdom> if parse_version ( args . version ) [ 2 ] == '0' : <newline> <indent> chromedriver = 'chromedriver-{0}-{1}-{2}.zip' . format ( get_chromedriver_version ( ) , PLATFORM , get_target_arch ( ) ) <newline> upload_atom_shell ( github , release , os . path . join ( DIST_DIR , chromedriver ) ) <newline> upload_atom_shell ( github , release , os . path . join ( DIST_DIR , MKSNAPSHOT_NAME ) ) <newline> <dedent> if PLATFORM == 'win32' and not tag_exists : <newline>  # ▁ Upload ▁ node ▁ headers. <encdom> <indent> execute ( [ sys . executable , os . path . join ( SOURCE_ROOT , 'script' , 'upload-node-headers.py' ) , '-v' , args . version ] ) <newline> <dedent> <dedent> def parse_args ( ) : <newline> <indent> parser = argparse . ArgumentParser ( description = 'upload ▁ distribution ▁ file' ) <newline> parser . add_argument ( '-v' , '--version' , help = 'Specify ▁ the ▁ version' , default = ATOM_SHELL_VERSION ) <newline> parser . add_argument ( '-p' , '--publish-release' , help = 'Publish ▁ the ▁ release' , action = 'store_true' ) <newline> return parser . parse_args ( ) <newline> <dedent> def get_atom_shell_build_version ( ) : <newline> <indent> if get_target_arch ( ) == 'arm' or os . environ . has_key ( 'CI' ) : <newline>  # ▁ In ▁ CI ▁ we ▁ just ▁ build ▁ as ▁ told. <encdom> <indent> return ATOM_SHELL_VERSION <newline> <dedent> if PLATFORM == 'darwin' : <newline> <indent> atom_shell = os . path . join ( SOURCE_ROOT , 'out' , 'R' , '{0}.app' . format ( PRODUCT_NAME ) , 'Contents' , 'MacOS' , PRODUCT_NAME ) <newline> <dedent> elif PLATFORM == 'win32' : <newline> <indent> atom_shell = os . path . join ( SOURCE_ROOT , 'out' , 'R' , '{0}.exe' . format ( PROJECT_NAME ) ) <newline> <dedent> else : <newline> <indent> atom_shell = os . path . join ( SOURCE_ROOT , 'out' , 'R' , PROJECT_NAME ) <newline> <dedent> return subprocess . check_output ( [ atom_shell , '--version' ] ) . strip ( ) <newline> <dedent> def dist_newer_than_head ( ) : <newline> <indent> with scoped_cwd ( SOURCE_ROOT ) : <newline> <indent> try : <newline> <indent> head_time = subprocess . check_output ( [ 'git' , 'log' , '--pretty=format:%at' , '-n' , '1' ] ) . strip ( ) <newline> dist_time = os . path . getmtime ( os . path . join ( DIST_DIR , DIST_NAME ) ) <newline> <dedent> except OSError as e : <newline> <indent> if e . errno != errno . ENOENT : <newline> <indent> raise <newline> <dedent> return False <newline> <dedent> <dedent> return dist_time > int ( head_time ) <newline> <dedent> def get_text_with_editor ( name ) : <newline> <indent> editor = os . environ . get ( 'EDITOR' , 'nano' ) <newline> initial_message = ' \n # ▁ Please ▁ enter ▁ the ▁ body ▁ of ▁ your ▁ release ▁ note ▁ for ▁ %s.' % name <newline> t = tempfile . NamedTemporaryFile ( suffix = '.tmp' , delete = False ) <newline> t . write ( initial_message ) <newline> t . close ( ) <newline> subprocess . call ( [ editor , t . name ] ) <newline> text = '' <newline> for line in open ( t . name , 'r' ) : <newline> <indent> if len ( line ) == 0 or line [ 0 ] != ' # ' : <newline> <indent> text += line <newline> <dedent> <dedent> os . unlink ( t . name ) <newline> return text <newline> <dedent> def create_or_get_release_draft ( github , releases , tag , tag_exists ) : <newline>  # ▁ Search ▁ for ▁ existing ▁ draft. <encdom> <indent> for release in releases : <newline> <indent> if release [ 'draft' ] : <newline> <indent> return release <newline> <dedent> <dedent> if tag_exists : <newline> <indent> tag = 'do-not-publish-me' <newline> <dedent> return create_release_draft ( github , tag ) <newline> <dedent> def create_release_draft ( github , tag ) : <newline> <indent> if os . environ . has_key ( 'CI' ) : <newline> <indent> name = '{0} ▁ pending ▁ draft' . format ( PROJECT_NAME ) <newline> body = '(placeholder)' <newline> <dedent> else : <newline> <indent> name = '{0} ▁ {1}' . format ( PROJECT_NAME , tag ) <newline> body = get_text_with_editor ( name ) <newline> <dedent> if body == '' : <newline> <indent> sys . stderr . write ( 'Quit ▁ due ▁ to ▁ empty ▁ release ▁ note. \n ' ) <newline> sys . exit ( 0 ) <newline> <dedent> data = dict ( tag_name = tag , name = name , body = body , draft = True ) <newline> r = github . repos ( ATOM_SHELL_REPO ) . releases . post ( data = data ) <newline> return r <newline> <dedent> def upload_atom_shell ( github , release , file_path ) : <newline>  # ▁ Delete ▁ the ▁ original ▁ file ▁ before ▁ uploading ▁ in ▁ CI. <encdom> <indent> if os . environ . has_key ( 'CI' ) : <newline> <indent> try : <newline> <indent> for asset in release [ 'assets' ] : <newline> <indent> if asset [ 'name' ] == os . path . basename ( file_path ) : <newline> <indent> github . repos ( ATOM_SHELL_REPO ) . releases . assets ( asset [ 'id' ] ) . delete ( ) <newline> break <newline> <dedent> <dedent> <dedent> except Exception : <newline> <indent> pass <newline>  # ▁ Upload ▁ the ▁ file. <encdom> <dedent> <dedent> params = { 'name' : os . path . basename ( file_path ) } <newline> headers = { 'Content-Type' : 'application/zip' } <newline> with open ( file_path , 'rb' ) as f : <newline> <indent> github . repos ( ATOM_SHELL_REPO ) . releases ( release [ 'id' ] ) . assets . post ( params = params , headers = headers , data = f , verify = False ) <newline> <dedent> <dedent> def publish_release ( github , release_id ) : <newline> <indent> data = dict ( draft = False ) <newline> github . repos ( ATOM_SHELL_REPO ) . releases ( release_id ) . patch ( data = data ) <newline> <dedent> def auth_token ( ) : <newline> <indent> token = os . environ . get ( 'ATOM_SHELL_GITHUB_TOKEN' ) <newline> message = ( 'Error: ▁ Please ▁ set ▁ the ▁ $ATOM_SHELL_GITHUB_TOKEN ▁ ' 'environment ▁ variable, ▁ which ▁ is ▁ your ▁ personal ▁ token' ) <newline> assert token , message <newline> return token <newline> <dedent> if __name__ == '__main__' : <newline> <indent> import sys <newline> sys . exit ( main ( ) ) <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  """ <strnewline> /***** <strnewline> Name ▁ : ▁ DB ▁ Manager <strnewline> Description ▁ : ▁ Database ▁ manager ▁ plugin ▁ for ▁ QGIS <strnewline> Date ▁ : ▁ Oct ▁ 13, ▁ 2011 <strnewline> copyright ▁ : ▁ (C) ▁ 2011 ▁ by ▁ Giuseppe ▁ Sucameli <strnewline> email ▁ : ▁ brush.tyler@gmail.com <strnewline> <strnewline> The ▁ content ▁ of ▁ this ▁ file ▁ is ▁ based ▁ on <strnewline> - ▁ PG_Manager ▁ by ▁ Martin ▁ Dobias ▁ (GPLv2 ▁ license) <strnewline> ▁ *****/ <strnewline> <strnewline> /***** <strnewline> ▁ * ▁ * <strnewline> ▁ * ▁ This ▁ program ▁ is ▁ free ▁ software; ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify ▁ * <strnewline> ▁ * ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ▁ * <strnewline> ▁ * ▁ the ▁ Free ▁ Software ▁ Foundation; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License, ▁ or ▁ * <strnewline> ▁ * ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. ▁ * <strnewline> ▁ * ▁ * <strnewline> ▁ *****/ <strnewline> """  <newline> from qgis . PyQt . QtCore import Qt <newline> from qgis . PyQt . QtWidgets import QDialog , QApplication <newline> from . db_plugins . plugin import DbError <newline> from . dlg_db_error import DlgDbError <newline> from . db_plugins . plugin import TableConstraint <newline> from . ui . ui_DlgCreateConstraint import Ui_DbManagerDlgCreateConstraint as Ui_Dialog <newline> class DlgCreateConstraint ( QDialog , Ui_Dialog ) : <newline> <indent> def __init__ ( self , parent = None , table = None , db = None ) : <newline> <indent> QDialog . __init__ ( self , parent ) <newline> self . table = table <newline> self . db = self . table . database ( ) if self . table and self . table . database ( ) else db <newline> self . setupUi ( self ) <newline> self . buttonBox . accepted . connect ( self . createConstraint ) <newline> self . populateColumns ( ) <newline> <dedent> def populateColumns ( self ) : <newline> <indent> self . cboColumn . clear ( ) <newline> for fld in self . table . fields ( ) : <newline> <indent> self . cboColumn . addItem ( fld . name ) <newline> <dedent> <dedent> def createConstraint ( self ) : <newline> <indent> constr = self . getConstraint ( ) <newline>  # ▁ now ▁ create ▁ the ▁ constraint <encdom> QApplication . setOverrideCursor ( Qt . WaitCursor ) <newline> try : <newline> <indent> self . table . addConstraint ( constr ) <newline> <dedent> except DbError as e : <newline> <indent> DlgDbError . showError ( e , self ) <newline> return <newline> <dedent> finally : <newline> <indent> QApplication . restoreOverrideCursor ( ) <newline> <dedent> self . accept ( ) <newline> <dedent> def getConstraint ( self ) : <newline> <indent> constr = TableConstraint ( self . table ) <newline> constr . name = u"" <newline> constr . type = TableConstraint . TypePrimaryKey if self . radPrimaryKey . isChecked ( ) else TableConstraint . TypeUnique <newline> constr . columns = [ ] <newline> column = self . cboColumn . currentText ( ) <newline> for fld in self . table . fields ( ) : <newline> <indent> if fld . name == column : <newline> <indent> constr . columns . append ( fld . num ) <newline> break <newline> <dedent> <dedent> return constr <newline> <dedent> <dedent>
 """ Test ▁ the ▁ NO-IP ▁ component. """  <newline> import asyncio <newline> from datetime import timedelta <newline> import pytest <newline> from homeassistant . setup import async_setup_component <newline> from homeassistant . components import no_ip <newline> from homeassistant . util . dt import utcnow <newline> from tests . common import async_fire_time_changed <newline> DOMAIN = 'test.example.com' <newline> PASSWORD = 'xyz789' <newline> UPDATE_URL = no_ip . UPDATE_URL <newline> USERNAME = 'abc@123.com' <newline> @ pytest . fixture <newline> def setup_no_ip ( hass , aioclient_mock ) : <newline> <indent>  """ Fixture ▁ that ▁ sets ▁ up ▁ NO-IP. """  <newline> aioclient_mock . get ( UPDATE_URL , params = { 'hostname' : DOMAIN } , text = 'good ▁ 0.0.0.0' ) <newline> hass . loop . run_until_complete ( async_setup_component ( hass , no_ip . DOMAIN , { no_ip . DOMAIN : { 'domain' : DOMAIN , 'username' : USERNAME , 'password' : PASSWORD , } } ) ) <newline> <dedent> @ asyncio . coroutine <newline> def test_setup ( hass , aioclient_mock ) : <newline> <indent>  """ Test ▁ setup ▁ works ▁ if ▁ update ▁ passes. """  <newline> aioclient_mock . get ( UPDATE_URL , params = { 'hostname' : DOMAIN } , text = 'nochg ▁ 0.0.0.0' ) <newline> result = yield from async_setup_component ( hass , no_ip . DOMAIN , { no_ip . DOMAIN : { 'domain' : DOMAIN , 'username' : USERNAME , 'password' : PASSWORD , } } ) <newline> assert result <newline> assert aioclient_mock . call_count == 1 <newline> async_fire_time_changed ( hass , utcnow ( ) + timedelta ( minutes = 5 ) ) <newline> yield from hass . async_block_till_done ( ) <newline> assert aioclient_mock . call_count == 2 <newline> <dedent> @ asyncio . coroutine <newline> def test_setup_fails_if_update_fails ( hass , aioclient_mock ) : <newline> <indent>  """ Test ▁ setup ▁ fails ▁ if ▁ first ▁ update ▁ fails. """  <newline> aioclient_mock . get ( UPDATE_URL , params = { 'hostname' : DOMAIN } , text = 'nohost' ) <newline> result = yield from async_setup_component ( hass , no_ip . DOMAIN , { no_ip . DOMAIN : { 'domain' : DOMAIN , 'username' : USERNAME , 'password' : PASSWORD , } } ) <newline> assert not result <newline> assert aioclient_mock . call_count == 1 <newline> <dedent> @ asyncio . coroutine <newline> def test_setup_fails_if_wrong_auth ( hass , aioclient_mock ) : <newline> <indent>  """ Test ▁ setup ▁ fails ▁ if ▁ first ▁ update ▁ fails ▁ through ▁ wrong ▁ authentication. """  <newline> aioclient_mock . get ( UPDATE_URL , params = { 'hostname' : DOMAIN } , text = 'badauth' ) <newline> result = yield from async_setup_component ( hass , no_ip . DOMAIN , { no_ip . DOMAIN : { 'domain' : DOMAIN , 'username' : USERNAME , 'password' : PASSWORD , } } ) <newline> assert not result <newline> assert aioclient_mock . call_count == 1 <newline> <dedent>
 """ <strnewline> This ▁ module ▁ creates ▁ a ▁ sysadmin ▁ dashboard ▁ for ▁ managing ▁ and ▁ viewing <strnewline> courses. <strnewline> """  <newline> import csv <newline> import json <newline> import logging <newline> import os <newline> import subprocess <newline> import time <newline> import StringIO <newline> from django . conf import settings <newline> from django . contrib . auth import authenticate <newline> from django . contrib . auth . decorators import login_required <newline> from django . contrib . auth . models import User <newline> from django . core . exceptions import PermissionDenied <newline> from django . core . paginator import Paginator , PageNotAnInteger , EmptyPage <newline> from django . db import IntegrityError <newline> from django . http import HttpResponse , Http404 <newline> from django . utils . decorators import method_decorator <newline> from django . utils . html import escape <newline> from django . utils import timezone <newline> from django . utils . translation import ugettext as _ <newline> from django . views . decorators . cache import cache_control <newline> from django . views . generic . base import TemplateView <newline> from django . views . decorators . http import condition <newline> from django_future . csrf import ensure_csrf_cookie <newline> from edxmako . shortcuts import render_to_response <newline> import mongoengine <newline> from path import path <newline> from courseware . courses import get_course_by_id <newline> import dashboard . git_import as git_import <newline> from dashboard . git_import import GitImportError <newline> from student . roles import CourseStaffRole , CourseInstructorRole <newline> from dashboard . models import CourseImportLog <newline> from external_auth . models import ExternalAuthMap <newline> from external_auth . views import generate_password <newline> from student . models import CourseEnrollment , UserProfile , Registration <newline> import track . views <newline> from xmodule . modulestore import ModuleStoreEnum <newline> from xmodule . modulestore . django import modulestore <newline> from xmodule . modulestore . xml import XMLModuleStore <newline> from opaque_keys . edx . locations import SlashSeparatedCourseKey <newline> log = logging . getLogger ( __name__ ) <newline> class SysadminDashboardView ( TemplateView ) : <newline> <indent>  """ Base ▁ class ▁ for ▁ sysadmin ▁ dashboard ▁ views ▁ with ▁ common ▁ methods """  <newline> template_name = 'sysadmin_dashboard.html' <newline> def __init__ ( self , ** kwargs ) : <newline> <indent>  """ <strnewline> ▁ Initialize ▁ base ▁ sysadmin ▁ dashboard ▁ class ▁ with ▁ modulestore, <strnewline> ▁ modulestore_type ▁ and ▁ return ▁ msg <strnewline> ▁ """  <newline> self . def_ms = modulestore ( ) <newline> self . is_using_mongo = True <newline> if isinstance ( self . def_ms , XMLModuleStore ) : <newline> <indent> self . is_using_mongo = False <newline> <dedent> self . msg = u'' <newline> self . datatable = [ ] <newline> super ( SysadminDashboardView , self ) . __init__ ( ** kwargs ) <newline> <dedent> @ method_decorator ( ensure_csrf_cookie ) <newline> @ method_decorator ( login_required ) <newline> @ method_decorator ( cache_control ( no_cache = True , no_store = True , must_revalidate = True ) ) <newline> @ method_decorator ( condition ( etag_func = None ) ) <newline> def dispatch ( self , * args , ** kwargs ) : <newline> <indent> return super ( SysadminDashboardView , self ) . dispatch ( * args , ** kwargs ) <newline> <dedent> def get_courses ( self ) : <newline> <indent>  """ ▁ Get ▁ an ▁ iterable ▁ list ▁ of ▁ courses. """  <newline> return self . def_ms . get_courses ( ) <newline> <dedent> def return_csv ( self , filename , header , data ) : <newline> <indent>  """ <strnewline> ▁ Convenient ▁ function ▁ for ▁ handling ▁ the ▁ http ▁ response ▁ of ▁ a ▁ csv. <strnewline> ▁ data ▁ should ▁ be ▁ iterable ▁ and ▁ is ▁ used ▁ to ▁ stream ▁ object ▁ over ▁ http <strnewline> ▁ """  <newline> csv_file = StringIO . StringIO ( ) <newline> writer = csv . writer ( csv_file , dialect = 'excel' , quotechar = '"' , quoting = csv . QUOTE_ALL ) <newline> writer . writerow ( header ) <newline>  # ▁ Setup ▁ streaming ▁ of ▁ the ▁ data <encdom> def read_and_flush ( ) : <newline> <indent>  """ Read ▁ and ▁ clear ▁ buffer ▁ for ▁ optimization """  <newline> csv_file . seek ( 0 ) <newline> csv_data = csv_file . read ( ) <newline> csv_file . seek ( 0 ) <newline> csv_file . truncate ( ) <newline> return csv_data <newline> <dedent> def csv_data ( ) : <newline> <indent>  """ Generator ▁ for ▁ handling ▁ potentially ▁ large ▁ CSVs """  <newline> for row in data : <newline> <indent> writer . writerow ( row ) <newline> <dedent> csv_data = read_and_flush ( ) <newline> yield csv_data <newline> <dedent> response = HttpResponse ( csv_data ( ) , mimetype = 'text/csv' ) <newline> response [ 'Content-Disposition' ] = 'attachment; ▁ filename={0}' . format ( filename ) <newline> return response <newline> <dedent> <dedent> class Users ( SysadminDashboardView ) : <newline> <indent>  """ <strnewline> ▁ The ▁ status ▁ view ▁ provides ▁ Web ▁ based ▁ user ▁ management, ▁ a ▁ listing ▁ of <strnewline> ▁ courses ▁ loaded, ▁ and ▁ user ▁ statistics <strnewline> ▁ """  <newline> def fix_external_auth_map_passwords ( self ) : <newline> <indent>  """ <strnewline> ▁ This ▁ corrects ▁ any ▁ passwords ▁ that ▁ have ▁ drifted ▁ from ▁ eamap ▁ to <strnewline> ▁ internal ▁ django ▁ auth. ▁ Needs ▁ to ▁ be ▁ removed ▁ when ▁ fixed ▁ in ▁ external_auth <strnewline> ▁ """  <newline> msg = '' <newline> for eamap in ExternalAuthMap . objects . all ( ) : <newline> <indent> euser = eamap . user <newline> epass = eamap . internal_password <newline> if euser is None : <newline> <indent> continue <newline> <dedent> try : <newline> <indent> testuser = authenticate ( username = euser . username , password = epass ) <newline> <dedent> except ( TypeError , PermissionDenied , AttributeError ) , err : <newline>  # ▁ Translators: ▁ This ▁ message ▁ means ▁ that ▁ the ▁ user ▁ could ▁ not ▁ be ▁ authenticated ▁ (that ▁ is, ▁ we ▁ could <encdom>  # ▁ not ▁ log ▁ them ▁ in ▁ for ▁ some ▁ reason ▁ - ▁ maybe ▁ they ▁ don't ▁ have ▁ permission, ▁ or ▁ their ▁ password ▁ was ▁ wrong) <encdom> <indent> msg += _ ( 'Failed ▁ in ▁ authenticating ▁ {username}, ▁ error ▁ {error} \n ' ) . format ( username = euser , error = err ) <newline> continue <newline> <dedent> if testuser is None : <newline>  # ▁ Translators: ▁ This ▁ message ▁ means ▁ that ▁ the ▁ user ▁ could ▁ not ▁ be ▁ authenticated ▁ (that ▁ is, ▁ we ▁ could <encdom>  # ▁ not ▁ log ▁ them ▁ in ▁ for ▁ some ▁ reason ▁ - ▁ maybe ▁ they ▁ don't ▁ have ▁ permission, ▁ or ▁ their ▁ password ▁ was ▁ wrong) <encdom> <indent> msg += _ ( 'Failed ▁ in ▁ authenticating ▁ {username} \n ' ) . format ( username = euser ) <newline>  # ▁ Translators: ▁ this ▁ means ▁ that ▁ the ▁ password ▁ has ▁ been ▁ corrected ▁ (sometimes ▁ the ▁ database ▁ needs ▁ to ▁ be ▁ resynchronized) <encdom>  # ▁ Translate ▁ this ▁ as ▁ meaning ▁"the ▁ password ▁ was ▁ fixed" ▁ or ▁"the ▁ password ▁ was ▁ corrected". <encdom> msg += _ ( 'fixed ▁ password' ) <newline> euser . set_password ( epass ) <newline> euser . save ( ) <newline> continue <newline> <dedent> <dedent> if not msg : <newline>  # ▁ Translators: ▁ this ▁ means ▁ everything ▁ happened ▁ successfully, ▁ yay! <encdom> <indent> msg = _ ( 'All ▁ ok!' ) <newline> <dedent> return msg <newline> <dedent> def create_user ( self , uname , name , password = None ) : <newline> <indent>  """ ▁ Creates ▁ a ▁ user ▁ (both ▁ SSL ▁ and ▁ regular) """  <newline> if not uname : <newline> <indent> return _ ( 'Must ▁ provide ▁ username' ) <newline> <dedent> if not name : <newline> <indent> return _ ( 'Must ▁ provide ▁ full ▁ name' ) <newline> <dedent> email_domain = getattr ( settings , 'SSL_AUTH_EMAIL_DOMAIN' , 'MIT.EDU' ) <newline> msg = u'' <newline> if settings . FEATURES [ 'AUTH_USE_CERTIFICATES' ] : <newline> <indent> if '@' not in uname : <newline> <indent> email = '{0}@{1}' . format ( uname , email_domain ) <newline> <dedent> else : <newline> <indent> email = uname <newline> <dedent> if not email . endswith ( '@{0}' . format ( email_domain ) ) : <newline>  # ▁ Translators: ▁ Domain ▁ is ▁ an ▁ email ▁ domain, ▁ such ▁ as ▁"@gmail.com" <encdom> <indent> msg += _ ( 'Email ▁ address ▁ must ▁ end ▁ in ▁ {domain}' ) . format ( domain = "@{0}" . format ( email_domain ) ) <newline> return msg <newline> <dedent> mit_domain = 'ssl:MIT' <newline> if ExternalAuthMap . objects . filter ( external_id = email , external_domain = mit_domain ) : <newline> <indent> msg += _ ( 'Failed ▁ - ▁ email ▁ {email_addr} ▁ already ▁ exists ▁ as ▁ {external_id}' ) . format ( email_addr = email , external_id = "external_id" ) <newline> return msg <newline> <dedent> new_password = generate_password ( ) <newline> <dedent> else : <newline> <indent> if not password : <newline> <indent> return _ ( 'Password ▁ must ▁ be ▁ supplied ▁ if ▁ not ▁ using ▁ certificates' ) <newline> <dedent> email = uname <newline> if '@' not in email : <newline> <indent> msg += _ ( 'email ▁ address ▁ required ▁ (not ▁ username)' ) <newline> return msg <newline> <dedent> new_password = password <newline> <dedent> user = User ( username = uname , email = email , is_active = True ) <newline> user . set_password ( new_password ) <newline> try : <newline> <indent> user . save ( ) <newline> <dedent> except IntegrityError : <newline> <indent> msg += _ ( 'Oops, ▁ failed ▁ to ▁ create ▁ user ▁ {user}, ▁ {error}' ) . format ( user = user , error = "IntegrityError" ) <newline> return msg <newline> <dedent> reg = Registration ( ) <newline> reg . register ( user ) <newline> profile = UserProfile ( user = user ) <newline> profile . name = name <newline> profile . save ( ) <newline> if settings . FEATURES [ 'AUTH_USE_CERTIFICATES' ] : <newline> <indent> credential_string = getattr ( settings , 'SSL_AUTH_DN_FORMAT_STRING' , '/C=US/ST=Massachusetts/O=Massachusetts ▁ Institute ▁ of ▁ Technology/OU=Client ▁ CA ▁ v1/CN={0}/emailAddress={1}' ) <newline> credentials = credential_string . format ( name , email ) <newline> eamap = ExternalAuthMap ( external_id = email , external_email = email , external_domain = mit_domain , external_name = name , internal_password = new_password , external_credentials = json . dumps ( credentials ) , ) <newline> eamap . user = user <newline> eamap . dtsignup = timezone . now ( ) <newline> eamap . save ( ) <newline> <dedent> msg += _ ( 'User ▁ {user} ▁ created ▁ successfully!' ) . format ( user = user ) <newline> return msg <newline> <dedent> def delete_user ( self , uname ) : <newline> <indent>  """ Deletes ▁ a ▁ user ▁ from ▁ django ▁ auth """  <newline> if not uname : <newline> <indent> return _ ( 'Must ▁ provide ▁ username' ) <newline> <dedent> if '@' in uname : <newline> <indent> try : <newline> <indent> user = User . objects . get ( email = uname ) <newline> <dedent> except User . DoesNotExist , err : <newline> <indent> msg = _ ( 'Cannot ▁ find ▁ user ▁ with ▁ email ▁ address ▁ {email_addr}' ) . format ( email_addr = uname ) <newline> return msg <newline> <dedent> <dedent> else : <newline> <indent> try : <newline> <indent> user = User . objects . get ( username = uname ) <newline> <dedent> except User . DoesNotExist , err : <newline> <indent> msg = _ ( 'Cannot ▁ find ▁ user ▁ with ▁ username ▁ {username} ▁ - ▁ {error}' ) . format ( username = uname , error = str ( err ) ) <newline> return msg <newline> <dedent> <dedent> user . delete ( ) <newline> return _ ( 'Deleted ▁ user ▁ {username}' ) . format ( username = uname ) <newline> <dedent> def make_common_context ( self ) : <newline> <indent>  """ Returns ▁ the ▁ datatable ▁ used ▁ for ▁ this ▁ view """  <newline> self . datatable = { } <newline> self . datatable = dict ( header = [ _ ( 'Statistic' ) , _ ( 'Value' ) ] , title = _ ( 'Site ▁ statistics' ) ) <newline> self . datatable [ 'data' ] = [ [ _ ( 'Total ▁ number ▁ of ▁ users' ) , User . objects . all ( ) . count ( ) ] ] <newline> self . msg += u'<h2>{0}</h2>' . format ( _ ( 'Courses ▁ loaded ▁ in ▁ the ▁ modulestore' ) ) <newline> self . msg += u'<ol>' <newline> for course in self . get_courses ( ) : <newline> <indent> self . msg += u'<li>{0} ▁ ({1})</li>' . format ( escape ( course . id . to_deprecated_string ( ) ) , course . location . to_deprecated_string ( ) ) <newline> <dedent> self . msg += u'</ol>' <newline> <dedent> def get ( self , request ) : <newline> <indent> if not request . user . is_staff : <newline> <indent> raise Http404 <newline> <dedent> self . make_common_context ( ) <newline> context = { 'datatable' : self . datatable , 'msg' : self . msg , 'djangopid' : os . getpid ( ) , 'modeflag' : { 'users' : 'active-section' } , 'edx_platform_version' : getattr ( settings , 'EDX_PLATFORM_VERSION_STRING' , '' ) , } <newline> return render_to_response ( self . template_name , context ) <newline> <dedent> def post ( self , request ) : <newline> <indent>  """ Handle ▁ various ▁ actions ▁ available ▁ on ▁ page """  <newline> if not request . user . is_staff : <newline> <indent> raise Http404 <newline> <dedent> self . make_common_context ( ) <newline> action = request . POST . get ( 'action' , '' ) <newline> track . views . server_track ( request , action , { } , page = 'user_sysdashboard' ) <newline> if action == 'download_users' : <newline> <indent> header = [ _ ( 'username' ) , _ ( 'email' ) , ] <newline> data = ( [ u . username , u . email ] for u in ( User . objects . all ( ) . iterator ( ) ) ) <newline> return self . return_csv ( 'users_{0}.csv' . format ( request . META [ 'SERVER_NAME' ] ) , header , data ) <newline> <dedent> elif action == 'repair_eamap' : <newline> <indent> self . msg = u'<h4>{0}</h4><pre>{1}</pre>{2}' . format ( _ ( 'Repair ▁ Results' ) , self . fix_external_auth_map_passwords ( ) , self . msg ) <newline> self . datatable = { } <newline> <dedent> elif action == 'create_user' : <newline> <indent> uname = request . POST . get ( 'student_uname' , '' ) . strip ( ) <newline> name = request . POST . get ( 'student_fullname' , '' ) . strip ( ) <newline> password = request . POST . get ( 'student_password' , '' ) . strip ( ) <newline> self . msg = u'<h4>{0}</h4><p>{1}</p><hr ▁ />{2}' . format ( _ ( 'Create ▁ User ▁ Results' ) , self . create_user ( uname , name , password ) , self . msg ) <newline> <dedent> elif action == 'del_user' : <newline> <indent> uname = request . POST . get ( 'student_uname' , '' ) . strip ( ) <newline> self . msg = u'<h4>{0}</h4><p>{1}</p><hr ▁ />{2}' . format ( _ ( 'Delete ▁ User ▁ Results' ) , self . delete_user ( uname ) , self . msg ) <newline> <dedent> context = { 'datatable' : self . datatable , 'msg' : self . msg , 'djangopid' : os . getpid ( ) , 'modeflag' : { 'users' : 'active-section' } , 'edx_platform_version' : getattr ( settings , 'EDX_PLATFORM_VERSION_STRING' , '' ) , } <newline> return render_to_response ( self . template_name , context ) <newline> <dedent> <dedent> class Courses ( SysadminDashboardView ) : <newline> <indent>  """ <strnewline> ▁ This ▁ manages ▁ adding/updating ▁ courses ▁ from ▁ git, ▁ deleting ▁ courses, ▁ and <strnewline> ▁ provides ▁ course ▁ listing ▁ information. <strnewline> ▁ """  <newline> def git_info_for_course ( self , cdir ) : <newline> <indent>  """ This ▁ pulls ▁ out ▁ some ▁ git ▁ info ▁ like ▁ the ▁ last ▁ commit """  <newline> cmd = '' <newline> gdir = settings . DATA_DIR / cdir <newline> info = [ '' , '' , '' ] <newline>  # ▁ Try ▁ the ▁ data ▁ dir, ▁ then ▁ try ▁ to ▁ find ▁ it ▁ in ▁ the ▁ git ▁ import ▁ dir <encdom> if not gdir . exists ( ) : <newline> <indent> gdir = path ( git_import . GIT_REPO_DIR ) / cdir <newline> if not gdir . exists ( ) : <newline> <indent> return info <newline> <dedent> <dedent> cmd = [ 'git' , 'log' , '-1' , '--format=format:{ ▁"commit": ▁"%H", ▁"author": ▁"%an ▁ %ae", ▁"date": ▁"%ad"}' , ] <newline> try : <newline> <indent> output_json = json . loads ( subprocess . check_output ( cmd , cwd = gdir ) ) <newline> info = [ output_json [ 'commit' ] , output_json [ 'date' ] , output_json [ 'author' ] , ] <newline> <dedent> except ( ValueError , subprocess . CalledProcessError ) : <newline> <indent> pass <newline> <dedent> return info <newline> <dedent> def get_course_from_git ( self , gitloc , branch ) : <newline> <indent>  """ This ▁ downloads ▁ and ▁ runs ▁ the ▁ checks ▁ for ▁ importing ▁ a ▁ course ▁ in ▁ git """  <newline> if not ( gitloc . endswith ( '.git' ) or gitloc . startswith ( 'http:' ) or gitloc . startswith ( 'https:' ) or gitloc . startswith ( 'git:' ) ) : <newline> <indent> return _ ( "The ▁ git ▁ repo ▁ location ▁ should ▁ end ▁ with ▁'.git', ▁ " "and ▁ be ▁ a ▁ valid ▁ url" ) <newline> <dedent> if self . is_using_mongo : <newline> <indent> return self . import_mongo_course ( gitloc , branch ) <newline> <dedent> return self . import_xml_course ( gitloc , branch ) <newline> <dedent> def import_mongo_course ( self , gitloc , branch ) : <newline> <indent>  """ <strnewline> ▁ Imports ▁ course ▁ using ▁ management ▁ command ▁ and ▁ captures ▁ logging ▁ output <strnewline> ▁ at ▁ debug ▁ level ▁ for ▁ display ▁ in ▁ template <strnewline> ▁ """  <newline> msg = u'' <newline> log . debug ( 'Adding ▁ course ▁ using ▁ git ▁ repo ▁ {0}' . format ( gitloc ) ) <newline>  # ▁ Grab ▁ logging ▁ output ▁ for ▁ debugging ▁ imports <encdom> output = StringIO . StringIO ( ) <newline> import_log_handler = logging . StreamHandler ( output ) <newline> import_log_handler . setLevel ( logging . DEBUG ) <newline> logger_names = [ 'xmodule.modulestore.xml_importer' , 'dashboard.git_import' , 'xmodule.modulestore.xml' , 'xmodule.seq_module' , ] <newline> loggers = [ ] <newline> for logger_name in logger_names : <newline> <indent> logger = logging . getLogger ( logger_name ) <newline> logger . setLevel ( logging . DEBUG ) <newline> logger . addHandler ( import_log_handler ) <newline> loggers . append ( logger ) <newline> <dedent> error_msg = '' <newline> try : <newline> <indent> git_import . add_repo ( gitloc , None , branch ) <newline> <dedent> except GitImportError as ex : <newline> <indent> error_msg = str ( ex ) <newline> <dedent> ret = output . getvalue ( ) <newline>  # ▁ Remove ▁ handler ▁ hijacks <encdom> for logger in loggers : <newline> <indent> logger . setLevel ( logging . NOTSET ) <newline> logger . removeHandler ( import_log_handler ) <newline> <dedent> if error_msg : <newline> <indent> msg_header = error_msg <newline> color = 'red' <newline> <dedent> else : <newline> <indent> msg_header = _ ( 'Added ▁ Course' ) <newline> color = 'blue' <newline> <dedent> msg = u"<h4 ▁ style='color:{0}'>{1}</h4>" . format ( color , msg_header ) <newline> msg += u"<pre>{0}</pre>" . format ( escape ( ret ) ) <newline> return msg <newline> <dedent> def import_xml_course ( self , gitloc , branch ) : <newline> <indent>  """ Imports ▁ a ▁ git ▁ course ▁ into ▁ the ▁ XMLModuleStore """  <newline> msg = u'' <newline> if not getattr ( settings , 'GIT_IMPORT_WITH_XMLMODULESTORE' , False ) : <newline>  # ▁ Translators: ▁"GIT_IMPORT_WITH_XMLMODULESTORE" ▁ is ▁ a ▁ variable ▁ name. <encdom>  # ▁"XMLModuleStore" ▁ and ▁"MongoDB" ▁ are ▁ database ▁ systems. ▁ You ▁ should ▁ not <encdom>  # ▁ translate ▁ these ▁ names. <encdom> <indent> return _ ( 'Refusing ▁ to ▁ import. ▁ GIT_IMPORT_WITH_XMLMODULESTORE ▁ is ▁ ' 'not ▁ turned ▁ on, ▁ and ▁ it ▁ is ▁ generally ▁ not ▁ safe ▁ to ▁ import ▁ ' 'into ▁ an ▁ XMLModuleStore ▁ with ▁ multithreaded. ▁ We ▁ ' 'recommend ▁ you ▁ enable ▁ the ▁ MongoDB ▁ based ▁ module ▁ store ▁ ' 'instead, ▁ unless ▁ this ▁ is ▁ a ▁ development ▁ environment.' ) <newline> <dedent> cdir = ( gitloc . rsplit ( '/' , 1 ) [ 1 ] ) [ : - 4 ] <newline> gdir = settings . DATA_DIR / cdir <newline> if os . path . exists ( gdir ) : <newline> <indent> msg += _ ( "The ▁ course ▁ {0} ▁ already ▁ exists ▁ in ▁ the ▁ data ▁ directory! ▁ " "(reloading ▁ anyway)" ) . format ( cdir ) <newline> cmd = [ 'git' , 'pull' , ] <newline> cwd = gdir <newline> <dedent> else : <newline> <indent> cmd = [ 'git' , 'clone' , gitloc , ] <newline> cwd = settings . DATA_DIR <newline> <dedent> cwd = os . path . abspath ( cwd ) <newline> try : <newline> <indent> cmd_output = escape ( subprocess . check_output ( cmd , stderr = subprocess . STDOUT , cwd = cwd ) ) <newline> <dedent> except subprocess . CalledProcessError as ex : <newline> <indent> log . exception ( 'Git ▁ pull ▁ or ▁ clone ▁ output ▁ was: ▁ %r' , ex . output ) <newline>  # ▁ Translators: ▁ unable ▁ to ▁ download ▁ the ▁ course ▁ content ▁ from <encdom>  # ▁ the ▁ source ▁ git ▁ repository. ▁ Clone ▁ occurs ▁ if ▁ this ▁ is ▁ brand <encdom>  # ▁ new, ▁ and ▁ pull ▁ is ▁ when ▁ it ▁ is ▁ being ▁ updated ▁ from ▁ the <encdom>  # ▁ source. <encdom> return _ ( 'Unable ▁ to ▁ clone ▁ or ▁ pull ▁ repository. ▁ Please ▁ check ▁ ' 'your ▁ url. ▁ Output ▁ was: ▁ {0!r}' ) . format ( ex . output ) <newline> <dedent> msg += u'<pre>{0}</pre>' . format ( cmd_output ) <newline> if not os . path . exists ( gdir ) : <newline> <indent> msg += _ ( 'Failed ▁ to ▁ clone ▁ repository ▁ to ▁ {directory_name}' ) . format ( directory_name = gdir ) <newline> return msg <newline>  # ▁ Change ▁ branch ▁ if ▁ specified <encdom> <dedent> if branch : <newline> <indent> try : <newline> <indent> git_import . switch_branch ( branch , gdir ) <newline> <dedent> except GitImportError as ex : <newline> <indent> return str ( ex ) <newline>  # ▁ Translators: ▁ This ▁ is ▁ a ▁ git ▁ repository ▁ branch, ▁ which ▁ is ▁ a <encdom>  # ▁ specific ▁ version ▁ of ▁ a ▁ courses ▁ content <encdom> <dedent> msg += u'<p>{0}</p>' . format ( _ ( 'Successfully ▁ switched ▁ to ▁ branch: ▁ ' '{branch_name}' ) . format ( branch_name = branch ) ) <newline> <dedent> self . def_ms . try_load_course ( os . path . abspath ( gdir ) ) <newline> errlog = self . def_ms . errored_courses . get ( cdir , '' ) <newline> if errlog : <newline> <indent> msg += u'<hr ▁ width="50%"><pre>{0}</pre>' . format ( escape ( errlog ) ) <newline> <dedent> else : <newline> <indent> course = self . def_ms . courses [ os . path . abspath ( gdir ) ] <newline> msg += _ ( 'Loaded ▁ course ▁ {course_name}<br/>Errors:' ) . format ( course_name = "{} ▁ {}" . format ( cdir , course . display_name ) ) <newline> errors = self . def_ms . get_course_errors ( course . id ) <newline> if not errors : <newline> <indent> msg += u'None' <newline> <dedent> else : <newline> <indent> msg += u'<ul>' <newline> for ( summary , err ) in errors : <newline> <indent> msg += u'<li><pre>{0}: ▁ {1}</pre></li>' . format ( escape ( summary ) , escape ( err ) ) <newline> <dedent> msg += u'</ul>' <newline> <dedent> <dedent> return msg <newline> <dedent> def make_datatable ( self ) : <newline> <indent>  """ Creates ▁ course ▁ information ▁ datatable """  <newline> data = [ ] <newline> for course in self . get_courses ( ) : <newline> <indent> gdir = course . id . course <newline> data . append ( [ course . display_name , course . id . to_deprecated_string ( ) ] + self . git_info_for_course ( gdir ) ) <newline> <dedent> return dict ( header = [ _ ( 'Course ▁ Name' ) , _ ( 'Directory/ID' ) ,  # ▁ Translators: ▁"Git ▁ Commit" ▁ is ▁ a ▁ computer ▁ command; ▁ see ▁ http://gitref.org/basic/ # commit <encdom> _ ( 'Git ▁ Commit' ) , _ ( 'Last ▁ Change' ) , _ ( 'Last ▁ Editor' ) ] , title = _ ( 'Information ▁ about ▁ all ▁ courses' ) , data = data ) <newline> <dedent> def get ( self , request ) : <newline> <indent>  """ Displays ▁ forms ▁ and ▁ course ▁ information """  <newline> if not request . user . is_staff : <newline> <indent> raise Http404 <newline> <dedent> context = { 'datatable' : self . make_datatable ( ) , 'msg' : self . msg , 'djangopid' : os . getpid ( ) , 'modeflag' : { 'courses' : 'active-section' } , 'edx_platform_version' : getattr ( settings , 'EDX_PLATFORM_VERSION_STRING' , '' ) , } <newline> return render_to_response ( self . template_name , context ) <newline> <dedent> def post ( self , request ) : <newline> <indent>  """ Handle ▁ all ▁ actions ▁ from ▁ courses ▁ view """  <newline> if not request . user . is_staff : <newline> <indent> raise Http404 <newline> <dedent> action = request . POST . get ( 'action' , '' ) <newline> track . views . server_track ( request , action , { } , page = 'courses_sysdashboard' ) <newline> courses = { course . id : course for course in self . get_courses ( ) } <newline> if action == 'add_course' : <newline> <indent> gitloc = request . POST . get ( 'repo_location' , '' ) . strip ( ) . replace ( ' ▁ ' , '' ) . replace ( ';' , '' ) <newline> branch = request . POST . get ( 'repo_branch' , '' ) . strip ( ) . replace ( ' ▁ ' , '' ) . replace ( ';' , '' ) <newline> self . msg += self . get_course_from_git ( gitloc , branch ) <newline> <dedent> elif action == 'del_course' : <newline> <indent> course_id = request . POST . get ( 'course_id' , '' ) . strip ( ) <newline> course_key = SlashSeparatedCourseKey . from_deprecated_string ( course_id ) <newline> course_found = False <newline> if course_key in courses : <newline> <indent> course_found = True <newline> course = courses [ course_key ] <newline> <dedent> else : <newline> <indent> try : <newline> <indent> course = get_course_by_id ( course_key ) <newline> course_found = True <newline> <dedent> except Exception , err :  # ▁ pylint: ▁ disable=broad-except <encdom> <newline> <indent> self . msg += _ ( 'Error ▁ - ▁ cannot ▁ get ▁ course ▁ with ▁ ID ▁ {0}<br/><pre>{1}</pre>' ) . format ( course_key , escape ( str ( err ) ) ) <newline> <dedent> <dedent> is_xml_course = ( modulestore ( ) . get_modulestore_type ( course_key ) == ModuleStoreEnum . Type . xml ) <newline> if course_found and is_xml_course : <newline> <indent> cdir = course . data_dir <newline> self . def_ms . courses . pop ( cdir ) <newline>  # ▁ now ▁ move ▁ the ▁ directory ▁ (don't ▁ actually ▁ delete ▁ it) <encdom> new_dir = "{course_dir}_deleted_{timestamp}" . format ( course_dir = cdir , timestamp = int ( time . time ( ) ) ) <newline> os . rename ( settings . DATA_DIR / cdir , settings . DATA_DIR / new_dir ) <newline> self . msg += ( u"<font ▁ color='red'>Deleted ▁ " u"{0} ▁ = ▁ {1} ▁ ({2})</font>" . format ( cdir , course . id , course . display_name ) ) <newline> <dedent> elif course_found and not is_xml_course : <newline>  # ▁ delete ▁ course ▁ that ▁ is ▁ stored ▁ with ▁ mongodb ▁ backend <encdom> <indent> self . def_ms . delete_course ( course . id , request . user . id ) <newline>  # ▁ don't ▁ delete ▁ user ▁ permission ▁ groups, ▁ though <encdom> self . msg += u"<font ▁ color='red'>{0} ▁ {1} ▁ = ▁ {2} ▁ ({3})</font>" . format ( _ ( 'Deleted' ) , course . location . to_deprecated_string ( ) , course . id . to_deprecated_string ( ) , course . display_name ) <newline> <dedent> <dedent> context = { 'datatable' : self . make_datatable ( ) , 'msg' : self . msg , 'djangopid' : os . getpid ( ) , 'modeflag' : { 'courses' : 'active-section' } , 'edx_platform_version' : getattr ( settings , 'EDX_PLATFORM_VERSION_STRING' , '' ) , } <newline> return render_to_response ( self . template_name , context ) <newline> <dedent> <dedent> class Staffing ( SysadminDashboardView ) : <newline> <indent>  """ <strnewline> ▁ The ▁ status ▁ view ▁ provides ▁ a ▁ view ▁ of ▁ staffing ▁ and ▁ enrollment ▁ in <strnewline> ▁ courses ▁ that ▁ include ▁ an ▁ option ▁ to ▁ download ▁ the ▁ data ▁ as ▁ a ▁ csv. <strnewline> ▁ """  <newline> def get ( self , request ) : <newline> <indent>  """ Displays ▁ course ▁ Enrollment ▁ and ▁ staffing ▁ course ▁ statistics """  <newline> if not request . user . is_staff : <newline> <indent> raise Http404 <newline> <dedent> data = [ ] <newline> for course in self . get_courses ( ) :  # ▁ pylint: ▁ disable=unused-variable <encdom> <newline> <indent> datum = [ course . display_name , course . id ] <newline> datum += [ CourseEnrollment . objects . filter ( course_id = course . id ) . count ( ) ] <newline> datum += [ CourseStaffRole ( course . id ) . users_with_role ( ) . count ( ) ] <newline> datum += [ ',' . join ( [ x . username for x in CourseInstructorRole ( course . id ) . users_with_role ( ) ] ) ] <newline> data . append ( datum ) <newline> <dedent> datatable = dict ( header = [ _ ( 'Course ▁ Name' ) , _ ( 'course_id' ) , _ ( ' # ▁ enrolled' ) , _ ( ' # ▁ staff' ) , _ ( 'instructors' ) ] , title = _ ( 'Enrollment ▁ information ▁ for ▁ all ▁ courses' ) , data = data ) <newline> context = { 'datatable' : datatable , 'msg' : self . msg , 'djangopid' : os . getpid ( ) , 'modeflag' : { 'staffing' : 'active-section' } , 'edx_platform_version' : getattr ( settings , 'EDX_PLATFORM_VERSION_STRING' , '' ) , } <newline> return render_to_response ( self . template_name , context ) <newline> <dedent> def post ( self , request ) : <newline> <indent>  """ Handle ▁ all ▁ actions ▁ from ▁ staffing ▁ and ▁ enrollment ▁ view """  <newline> action = request . POST . get ( 'action' , '' ) <newline> track . views . server_track ( request , action , { } , page = 'staffing_sysdashboard' ) <newline> if action == 'get_staff_csv' : <newline> <indent> data = [ ] <newline> roles = [ CourseInstructorRole , CourseStaffRole , ] <newline> for course in self . get_courses ( ) :  # ▁ pylint: ▁ disable=unused-variable <encdom> <newline> <indent> for role in roles : <newline> <indent> for user in role ( course . id ) . users_with_role ( ) : <newline> <indent> datum = [ course . id , role , user . username , user . email , user . profile . name ] <newline> data . append ( datum ) <newline> <dedent> <dedent> <dedent> header = [ _ ( 'course_id' ) , _ ( 'role' ) , _ ( 'username' ) , _ ( 'email' ) , _ ( 'full_name' ) , ] <newline> return self . return_csv ( 'staff_{0}.csv' . format ( request . META [ 'SERVER_NAME' ] ) , header , data ) <newline> <dedent> return self . get ( request ) <newline> <dedent> <dedent> class GitLogs ( TemplateView ) : <newline> <indent>  """ <strnewline> ▁ This ▁ provides ▁ a ▁ view ▁ into ▁ the ▁ import ▁ of ▁ courses ▁ from ▁ git ▁ repositories. <strnewline> ▁ It ▁ is ▁ convenient ▁ for ▁ allowing ▁ course ▁ teams ▁ to ▁ see ▁ what ▁ may ▁ be ▁ wrong ▁ with <strnewline> ▁ their ▁ xml <strnewline> ▁ """  <newline> template_name = 'sysadmin_dashboard_gitlogs.html' <newline> @ method_decorator ( login_required ) <newline> def get ( self , request , * args , ** kwargs ) : <newline> <indent>  """ Shows ▁ logs ▁ of ▁ imports ▁ that ▁ happened ▁ as ▁ a ▁ result ▁ of ▁ a ▁ git ▁ import """  <newline> course_id = kwargs . get ( 'course_id' ) <newline> if course_id : <newline> <indent> course_id = SlashSeparatedCourseKey . from_deprecated_string ( course_id ) <newline> <dedent> page_size = 10 <newline>  # ▁ Set ▁ mongodb ▁ defaults ▁ even ▁ if ▁ it ▁ isn't ▁ defined ▁ in ▁ settings <encdom> mongo_db = { 'host' : 'localhost' , 'user' : '' , 'password' : '' , 'db' : 'xlog' , } <newline>  # ▁ Allow ▁ overrides <encdom> if hasattr ( settings , 'MONGODB_LOG' ) : <newline> <indent> for config_item in [ 'host' , 'user' , 'password' , 'db' , ] : <newline> <indent> mongo_db [ config_item ] = settings . MONGODB_LOG . get ( config_item , mongo_db [ config_item ] ) <newline> <dedent> <dedent> mongouri = 'mongodb://{user}:{password}@{host}/{db}' . format ( ** mongo_db ) <newline> error_msg = '' <newline> try : <newline> <indent> if mongo_db [ 'user' ] and mongo_db [ 'password' ] : <newline> <indent> mdb = mongoengine . connect ( mongo_db [ 'db' ] , host = mongouri ) <newline> <dedent> else : <newline> <indent> mdb = mongoengine . connect ( mongo_db [ 'db' ] , host = mongo_db [ 'host' ] ) <newline> <dedent> <dedent> except mongoengine . connection . ConnectionError : <newline> <indent> log . exception ( 'Unable ▁ to ▁ connect ▁ to ▁ mongodb ▁ to ▁ save ▁ log, ▁ ' 'please ▁ check ▁ MONGODB_LOG ▁ settings.' ) <newline> <dedent> if course_id is None : <newline>  # ▁ Require ▁ staff ▁ if ▁ not ▁ going ▁ to ▁ specific ▁ course <encdom> <indent> if not request . user . is_staff : <newline> <indent> raise Http404 <newline> <dedent> cilset = CourseImportLog . objects . order_by ( '-created' ) <newline> <dedent> else : <newline> <indent> try : <newline> <indent> course = get_course_by_id ( course_id ) <newline> <dedent> except Exception :  # ▁ pylint: ▁ disable=broad-except <encdom> <newline> <indent> log . info ( 'Cannot ▁ find ▁ course ▁ {0}' . format ( course_id ) ) <newline> raise Http404 <newline>  # ▁ Allow ▁ only ▁ course ▁ team, ▁ instructors, ▁ and ▁ staff <encdom> <dedent> if not ( request . user . is_staff or CourseInstructorRole ( course . id ) . has_user ( request . user ) or CourseStaffRole ( course . id ) . has_user ( request . user ) ) : <newline> <indent> raise Http404 <newline> <dedent> log . debug ( 'course_id={0}' . format ( course_id ) ) <newline> cilset = CourseImportLog . objects . filter ( course_id = course_id ) . order_by ( '-created' ) <newline> log . debug ( 'cilset ▁ length={0}' . format ( len ( cilset ) ) ) <newline>  # ▁ Paginate ▁ the ▁ query ▁ set <encdom> <dedent> paginator = Paginator ( cilset , page_size ) <newline> try : <newline> <indent> logs = paginator . page ( request . GET . get ( 'page' ) ) <newline> <dedent> except PageNotAnInteger : <newline> <indent> logs = paginator . page ( 1 ) <newline> <dedent> except EmptyPage : <newline>  # ▁ If ▁ the ▁ page ▁ is ▁ too ▁ high ▁ or ▁ low <encdom> <indent> given_page = int ( request . GET . get ( 'page' ) ) <newline> page = min ( max ( 1 , given_page ) , paginator . num_pages ) <newline> logs = paginator . page ( page ) <newline> <dedent> mdb . disconnect ( ) <newline> context = { 'logs' : logs , 'course_id' : course_id . to_deprecated_string ( ) if course_id else None , 'error_msg' : error_msg , 'page_size' : page_size } <newline> return render_to_response ( self . template_name , context ) <newline> <dedent> <dedent>
 # !/usr/bin/python <encdom>  # ▁ Copyright ▁ 2015 ▁ Google ▁ Inc. ▁ All ▁ Rights ▁ Reserved. <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); <encdom>  # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. <encdom>  # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, <encdom>  # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. <encdom>  # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and <encdom>  # ▁ limitations ▁ under ▁ the ▁ License. <encdom>
 # !/usr/bin/env ▁ python <encdom>  # ▁ Copyright ▁ (c) ▁ 2012 ▁ Google ▁ Inc. ▁ All ▁ rights ▁ reserved. <encdom>  # ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD-style ▁ license ▁ that ▁ can ▁ be <encdom>  # ▁ found ▁ in ▁ the ▁ LICENSE ▁ file. <encdom>  """ <strnewline> Verifies ▁ that ▁ list ▁ xcode_settings ▁ are ▁ flattened ▁ before ▁ being ▁ exported ▁ to ▁ the <strnewline> environment. <strnewline> """  <newline> import TestGyp <newline> import sys <newline> if sys . platform == 'darwin' : <newline> <indent> test = TestGyp . TestGyp ( formats = [ 'ninja' , 'make' , 'xcode' ] ) <newline> CHDIR = 'non-strs-flattened-to-env' <newline> INFO_PLIST_PATH = 'Test.app/Contents/Info.plist' <newline> test . run_gyp ( 'test.gyp' , chdir = CHDIR ) <newline> test . build ( 'test.gyp' , test . ALL , chdir = CHDIR ) <newline> info_plist = test . built_file_path ( INFO_PLIST_PATH , chdir = CHDIR ) <newline> test . must_exist ( info_plist ) <newline> test . must_contain ( info_plist ,  ''' \ <strnewline> \t<key>My ▁ Variable</key> <strnewline> \t<string>some ▁ expansion</string> '''  ) <newline> test . must_contain ( info_plist ,  ''' \ <strnewline> \t<key>CFlags</key> <strnewline> \t<string>-fstack-protector-all ▁ -fno-strict-aliasing ▁ -DS="A ▁ Space"</string> '''  ) <newline> test . pass_test ( ) <newline> <dedent>
 # ▁ coding=utf-8 <encdom>  # ▁ Copyright ▁ (c) ▁ Microsoft ▁ Corporation. ▁ All ▁ rights ▁ reserved. <encdom>  # ▁ Licensed ▁ under ▁ the ▁ MIT ▁ License. ▁ See ▁ License.txt ▁ in ▁ the ▁ project ▁ root ▁ for <encdom>  # ▁ license ▁ information. <encdom>  # ▁ Code ▁ generated ▁ by ▁ Microsoft ▁ (R) ▁ AutoRest ▁ Code ▁ Generator. <encdom>  # ▁ Changes ▁ may ▁ cause ▁ incorrect ▁ behavior ▁ and ▁ will ▁ be ▁ lost ▁ if ▁ the ▁ code ▁ is <encdom>  # ▁ regenerated. <encdom> try : <newline> <indent> from . _models_py3 import ClassicAdministrator <newline> <dedent> except ( SyntaxError , ImportError ) : <newline> <indent> from . _models import ClassicAdministrator <newline> <dedent> from . _paged_models import ClassicAdministratorPaged <newline> __all__ = [ 'ClassicAdministrator' , 'ClassicAdministratorPaged' , ] <newline>
from pybindgen import Module , FileCodeSink , param , retval , cppclass , typehandlers <newline> import pybindgen . settings <newline> import warnings <newline> class ErrorHandler ( pybindgen . settings . ErrorHandler ) : <newline> <indent> def handle_error ( self , wrapper , exception , traceback_ ) : <newline> <indent> warnings . warn ( "exception ▁ %r ▁ in ▁ wrapper ▁ %s" % ( exception , wrapper ) ) <newline> return True <newline> <dedent> <dedent> pybindgen . settings . error_handler = ErrorHandler ( ) <newline> import sys <newline> def module_init ( ) : <newline> <indent> root_module = Module ( 'ns.olsr' , cpp_namespace = '::ns3' ) <newline> return root_module <newline> <dedent> def register_types ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Address ▁ [class] <encdom> module . add_class ( 'Address' , import_from_module = 'ns.network' ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Address::MaxSize_e ▁ [enumeration] <encdom> module . add_enum ( 'MaxSize_e' , [ 'MAX_SIZE' ] , outer_class = root_module [ 'ns3::Address' ] , import_from_module = 'ns.network' ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList ▁ [class] <encdom> module . add_class ( 'AttributeConstructionList' , import_from_module = 'ns.core' ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::Item ▁ [struct] <encdom> module . add_class ( 'Item' , import_from_module = 'ns.core' , outer_class = root_module [ 'ns3::AttributeConstructionList' ] ) <newline> typehandlers . add_type_alias ( u'std::list< ▁ ns3::AttributeConstructionList::Item ▁ > ▁ const_iterator' , u'ns3::AttributeConstructionList::CIterator' ) <newline> typehandlers . add_type_alias ( u'std::list< ▁ ns3::AttributeConstructionList::Item ▁ > ▁ const_iterator*' , u'ns3::AttributeConstructionList::CIterator*' ) <newline> typehandlers . add_type_alias ( u'std::list< ▁ ns3::AttributeConstructionList::Item ▁ > ▁ const_iterator&' , u'ns3::AttributeConstructionList::CIterator&' ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer ▁ [class] <encdom> module . add_class ( 'Buffer' , import_from_module = 'ns.network' ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Iterator ▁ [class] <encdom> module . add_class ( 'Iterator' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::Buffer' ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::ByteTagIterator ▁ [class] <encdom> module . add_class ( 'ByteTagIterator' , import_from_module = 'ns.network' ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::ByteTagIterator::Item ▁ [class] <encdom> module . add_class ( 'Item' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::ByteTagIterator' ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList ▁ [class] <encdom> module . add_class ( 'ByteTagList' , import_from_module = 'ns.network' ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator ▁ [class] <encdom> module . add_class ( 'Iterator' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::ByteTagList' ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item ▁ [struct] <encdom> module . add_class ( 'Item' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::ByteTagList::Iterator' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackBase ▁ [class] <encdom> module . add_class ( 'CallbackBase' , import_from_module = 'ns.core' ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::AttributeAccessor' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::EventImpl' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Hash::Implementation' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::NixVector' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::Packet> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Packet' ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ [struct] <encdom> module . add_class ( 'DefaultDeleter' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::TraceSourceAccessor' ] ) <newline>  # # ▁ event-garbage-collector.h ▁ (module ▁'core'): ▁ ns3::EventGarbageCollector ▁ [class] <encdom> module . add_class ( 'EventGarbageCollector' , import_from_module = 'ns.core' ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ ns3::EventId ▁ [class] <encdom> module . add_class ( 'EventId' , import_from_module = 'ns.core' ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ ns3::Hasher ▁ [class] <encdom> module . add_class ( 'Hasher' , import_from_module = 'ns.core' ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress ▁ [class] <encdom> module . add_class ( 'Inet6SocketAddress' , import_from_module = 'ns.network' ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress ▁ [class] <encdom> root_module [ 'ns3::Inet6SocketAddress' ] . implicitly_converts_to ( root_module [ 'ns3::Address' ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress ▁ [class] <encdom> module . add_class ( 'InetSocketAddress' , import_from_module = 'ns.network' ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress ▁ [class] <encdom> root_module [ 'ns3::InetSocketAddress' ] . implicitly_converts_to ( root_module [ 'ns3::Address' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<0> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '0' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<0>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 0 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<1> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '1' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<1>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 1 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<2> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '2' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<2>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 2 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<3> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '3' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<3>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 3 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<4> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '4' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<4>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 4 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<5> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '5' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<5>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 5 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<6> ▁ [struct] <encdom> module . add_class ( 'IntToType' , import_from_module = 'ns.core' , template_parameters = [ '6' ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<6>::v_e ▁ [enumeration] <encdom> module . add_enum ( 'v_e' , [ 'value' ] , outer_class = root_module [ 'ns3::IntToType< ▁ 6 ▁ >' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ [class] <encdom> module . add_class ( 'Ipv4Address' , import_from_module = 'ns.network' ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ [class] <encdom> root_module [ 'ns3::Ipv4Address' ] . implicitly_converts_to ( root_module [ 'ns3::Address' ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress ▁ [class] <encdom> module . add_class ( 'Ipv4InterfaceAddress' , import_from_module = 'ns.internet' ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e ▁ [enumeration] <encdom> module . add_enum ( 'InterfaceAddressScope_e' , [ 'HOST' , 'LINK' , 'GLOBAL' ] , outer_class = root_module [ 'ns3::Ipv4InterfaceAddress' ] , import_from_module = 'ns.internet' ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Mask ▁ [class] <encdom> module . add_class ( 'Ipv4Mask' , import_from_module = 'ns.network' ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingHelper ▁ [class] <encdom> module . add_class ( 'Ipv4RoutingHelper' , allow_subclassing = True , import_from_module = 'ns.internet' ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address ▁ [class] <encdom> module . add_class ( 'Ipv6Address' , import_from_module = 'ns.network' ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address ▁ [class] <encdom> root_module [ 'ns3::Ipv6Address' ] . implicitly_converts_to ( root_module [ 'ns3::Address' ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix ▁ [class] <encdom> module . add_class ( 'Ipv6Prefix' , import_from_module = 'ns.network' ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48Address ▁ [class] <encdom> module . add_class ( 'Mac48Address' , import_from_module = 'ns.network' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Mac48Address ▁ )' , u'ns3::Mac48Address::TracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Mac48Address ▁ )*' , u'ns3::Mac48Address::TracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Mac48Address ▁ )&' , u'ns3::Mac48Address::TracedCallback&' ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48Address ▁ [class] <encdom> root_module [ 'ns3::Mac48Address' ] . implicitly_converts_to ( root_module [ 'ns3::Address' ] ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ ns3::Mac8Address ▁ [class] <encdom> module . add_class ( 'Mac8Address' , import_from_module = 'ns.network' ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ ns3::Mac8Address ▁ [class] <encdom> root_module [ 'ns3::Mac8Address' ] . implicitly_converts_to ( root_module [ 'ns3::Address' ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer ▁ [class] <encdom> module . add_class ( 'NodeContainer' , import_from_module = 'ns.network' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::Ptr< ▁ ns3::Node ▁ > ▁ > ▁ const_iterator' , u'ns3::NodeContainer::Iterator' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::Ptr< ▁ ns3::Node ▁ > ▁ > ▁ const_iterator*' , u'ns3::NodeContainer::Iterator*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::Ptr< ▁ ns3::Node ▁ > ▁ > ▁ const_iterator&' , u'ns3::NodeContainer::Iterator&' ) <newline>  # # ▁ non-copyable.h ▁ (module ▁'core'): ▁ ns3::NonCopyable ▁ [class] <encdom> module . add_class ( 'NonCopyable' , destructor_visibility = 'protected' , import_from_module = 'ns.core' ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ ns3::ObjectBase ▁ [class] <encdom> module . add_class ( 'ObjectBase' , allow_subclassing = True , import_from_module = 'ns.core' ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::ObjectDeleter ▁ [struct] <encdom> module . add_class ( 'ObjectDeleter' , import_from_module = 'ns.core' ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactory ▁ [class] <encdom> module . add_class ( 'ObjectFactory' , import_from_module = 'ns.core' ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ ns3::OlsrHelper ▁ [class] <encdom> module . add_class ( 'OlsrHelper' , parent = root_module [ 'ns3::Ipv4RoutingHelper' ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata ▁ [class] <encdom> module . add_class ( 'PacketMetadata' , import_from_module = 'ns.network' ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item ▁ [struct] <encdom> module . add_class ( 'Item' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::PacketMetadata' ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::ItemType ▁ [enumeration] <encdom> module . add_enum ( 'ItemType' , [ 'PAYLOAD' , 'HEADER' , 'TRAILER' ] , outer_class = root_module [ 'ns3::PacketMetadata::Item' ] , import_from_module = 'ns.network' ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::ItemIterator ▁ [class] <encdom> module . add_class ( 'ItemIterator' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::PacketMetadata' ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketTagIterator ▁ [class] <encdom> module . add_class ( 'PacketTagIterator' , import_from_module = 'ns.network' ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketTagIterator::Item ▁ [class] <encdom> module . add_class ( 'Item' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::PacketTagIterator' ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList ▁ [class] <encdom> module . add_class ( 'PacketTagList' , import_from_module = 'ns.network' ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData ▁ [struct] <encdom> module . add_class ( 'TagData' , import_from_module = 'ns.network' , outer_class = root_module [ 'ns3::PacketTagList' ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter> ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Object' , 'ns3::ObjectBase' , 'ns3::ObjectDeleter' ] , parent = root_module [ 'ns3::ObjectBase' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ ns3::Simulator ▁ [class] <encdom> module . add_class ( 'Simulator' , destructor_visibility = 'private' , import_from_module = 'ns.core' ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ ns3::Simulator ▁ [enumeration] <encdom> module . add_enum ( '' , [ 'NO_CONTEXT' ] , outer_class = root_module [ 'ns3::Simulator' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ ns3::SystemWallClockMs ▁ [class] <encdom> module . add_class ( 'SystemWallClockMs' , import_from_module = 'ns.core' ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ ns3::Tag ▁ [class] <encdom> module . add_class ( 'Tag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::ObjectBase' ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ ns3::TagBuffer ▁ [class] <encdom> module . add_class ( 'TagBuffer' , import_from_module = 'ns.network' ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeWithUnit ▁ [class] <encdom> module . add_class ( 'TimeWithUnit' , import_from_module = 'ns.core' ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer ▁ [class] <encdom> module . add_class ( 'Timer' , import_from_module = 'ns.core' ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer::DestroyPolicy ▁ [enumeration] <encdom> module . add_enum ( 'DestroyPolicy' , [ 'CANCEL_ON_DESTROY' , 'REMOVE_ON_DESTROY' , 'CHECK_ON_DESTROY' ] , outer_class = root_module [ 'ns3::Timer' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer::State ▁ [enumeration] <encdom> module . add_enum ( 'State' , [ 'RUNNING' , 'EXPIRED' , 'SUSPENDED' ] , outer_class = root_module [ 'ns3::Timer' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ timer-impl.h ▁ (module ▁'core'): ▁ ns3::TimerImpl ▁ [class] <encdom> module . add_class ( 'TimerImpl' , allow_subclassing = True , import_from_module = 'ns.core' ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ [class] <encdom> module . add_class ( 'TypeId' , import_from_module = 'ns.core' ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeFlag ▁ [enumeration] <encdom> module . add_enum ( 'AttributeFlag' , [ 'ATTR_GET' , 'ATTR_SET' , 'ATTR_CONSTRUCT' , 'ATTR_SGC' ] , outer_class = root_module [ 'ns3::TypeId' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::SupportLevel ▁ [enumeration] <encdom> module . add_enum ( 'SupportLevel' , [ 'SUPPORTED' , 'DEPRECATED' , 'OBSOLETE' ] , outer_class = root_module [ 'ns3::TypeId' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation ▁ [struct] <encdom> module . add_class ( 'AttributeInformation' , import_from_module = 'ns.core' , outer_class = root_module [ 'ns3::TypeId' ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation ▁ [struct] <encdom> module . add_class ( 'TraceSourceInformation' , import_from_module = 'ns.core' , outer_class = root_module [ 'ns3::TypeId' ] ) <newline> typehandlers . add_type_alias ( u'uint32_t' , u'ns3::TypeId::hash_t' ) <newline> typehandlers . add_type_alias ( u'uint32_t*' , u'ns3::TypeId::hash_t*' ) <newline> typehandlers . add_type_alias ( u'uint32_t&' , u'ns3::TypeId::hash_t&' ) <newline>  # # ▁ empty.h ▁ (module ▁'core'): ▁ ns3::empty ▁ [class] <encdom> module . add_class ( 'empty' , import_from_module = 'ns.core' ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t ▁ [class] <encdom> module . add_class ( 'int64x64_t' , import_from_module = 'ns.core' ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::impl_type ▁ [enumeration] <encdom> module . add_enum ( 'impl_type' , [ 'int128_impl' , 'cairo_impl' , 'ld_impl' ] , outer_class = root_module [ 'ns3::int64x64_t' ] , import_from_module = 'ns.core' ) <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ ns3::Chunk ▁ [class] <encdom> module . add_class ( 'Chunk' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::ObjectBase' ] ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ ns3::Header ▁ [class] <encdom> module . add_class ( 'Header' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Chunk' ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header ▁ [class] <encdom> module . add_class ( 'Ipv4Header' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::Header' ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header::DscpType ▁ [enumeration] <encdom> module . add_enum ( 'DscpType' , [ 'DscpDefault' , 'DSCP_CS1' , 'DSCP_AF11' , 'DSCP_AF12' , 'DSCP_AF13' , 'DSCP_CS2' , 'DSCP_AF21' , 'DSCP_AF22' , 'DSCP_AF23' , 'DSCP_CS3' , 'DSCP_AF31' , 'DSCP_AF32' , 'DSCP_AF33' , 'DSCP_CS4' , 'DSCP_AF41' , 'DSCP_AF42' , 'DSCP_AF43' , 'DSCP_CS5' , 'DSCP_EF' , 'DSCP_CS6' , 'DSCP_CS7' ] , outer_class = root_module [ 'ns3::Ipv4Header' ] , import_from_module = 'ns.internet' ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header::EcnType ▁ [enumeration] <encdom> module . add_enum ( 'EcnType' , [ 'ECN_NotECT' , 'ECN_ECT1' , 'ECN_ECT0' , 'ECN_CE' ] , outer_class = root_module [ 'ns3::Ipv4Header' ] , import_from_module = 'ns.internet' ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object ▁ [class] <encdom> module . add_class ( 'Object' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter ▁ >' ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object::AggregateIterator ▁ [class] <encdom> module . add_class ( 'AggregateIterator' , import_from_module = 'ns.core' , outer_class = root_module [ 'ns3::Object' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::RandomVariableStream ▁ [class] <encdom> module . add_class ( 'RandomVariableStream' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::Object' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::SequentialRandomVariable ▁ [class] <encdom> module . add_class ( 'SequentialRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::AttributeAccessor' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::AttributeAccessor>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::AttributeChecker' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::AttributeChecker>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::AttributeValue' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::AttributeValue>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::CallbackImplBase' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::CallbackImplBase>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::EventImpl' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::EventImpl>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Hash::Implementation' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::Hash::Implementation>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Ipv4MulticastRoute' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::Ipv4MulticastRoute>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4Route> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Ipv4Route' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::Ipv4Route>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::NixVector' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::NixVector>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::OutputStreamWrapper> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::OutputStreamWrapper' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::OutputStreamWrapper>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Packet> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::Packet' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::Packet>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ > ▁ [class] <encdom> module . add_class ( 'SimpleRefCount' , automatic_type_narrowing = True , import_from_module = 'ns.core' , template_parameters = [ 'ns3::TraceSourceAccessor' , 'ns3::empty' , 'ns3::DefaultDeleter<ns3::TraceSourceAccessor>' ] , parent = root_module [ 'ns3::empty' ] , memory_policy = cppclass . ReferenceCountingMethodsPolicy ( incref_method = 'Ref' , decref_method = 'Unref' , peekref_method = 'GetReferenceCount' ) ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket ▁ [class] <encdom> module . add_class ( 'Socket' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Object' ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::SocketErrno ▁ [enumeration] <encdom> module . add_enum ( 'SocketErrno' , [ 'ERROR_NOTERROR' , 'ERROR_ISCONN' , 'ERROR_NOTCONN' , 'ERROR_MSGSIZE' , 'ERROR_AGAIN' , 'ERROR_SHUTDOWN' , 'ERROR_OPNOTSUPP' , 'ERROR_AFNOSUPPORT' , 'ERROR_INVAL' , 'ERROR_BADF' , 'ERROR_NOROUTETOHOST' , 'ERROR_NODEV' , 'ERROR_ADDRNOTAVAIL' , 'ERROR_ADDRINUSE' , 'SOCKET_ERRNO_LAST' ] , outer_class = root_module [ 'ns3::Socket' ] , import_from_module = 'ns.network' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::SocketType ▁ [enumeration] <encdom> module . add_enum ( 'SocketType' , [ 'NS3_SOCK_STREAM' , 'NS3_SOCK_SEQPACKET' , 'NS3_SOCK_DGRAM' , 'NS3_SOCK_RAW' ] , outer_class = root_module [ 'ns3::Socket' ] , import_from_module = 'ns.network' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::SocketPriority ▁ [enumeration] <encdom> module . add_enum ( 'SocketPriority' , [ 'NS3_PRIO_BESTEFFORT' , 'NS3_PRIO_FILLER' , 'NS3_PRIO_BULK' , 'NS3_PRIO_INTERACTIVE_BULK' , 'NS3_PRIO_INTERACTIVE' , 'NS3_PRIO_CONTROL' ] , outer_class = root_module [ 'ns3::Socket' ] , import_from_module = 'ns.network' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::Ipv6MulticastFilterMode ▁ [enumeration] <encdom> module . add_enum ( 'Ipv6MulticastFilterMode' , [ 'INCLUDE' , 'EXCLUDE' ] , outer_class = root_module [ 'ns3::Socket' ] , import_from_module = 'ns.network' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpTosTag ▁ [class] <encdom> module . add_class ( 'SocketIpTosTag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Tag' ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpTtlTag ▁ [class] <encdom> module . add_class ( 'SocketIpTtlTag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Tag' ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpv6HopLimitTag ▁ [class] <encdom> module . add_class ( 'SocketIpv6HopLimitTag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Tag' ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpv6TclassTag ▁ [class] <encdom> module . add_class ( 'SocketIpv6TclassTag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Tag' ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketPriorityTag ▁ [class] <encdom> module . add_class ( 'SocketPriorityTag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Tag' ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketSetDontFragmentTag ▁ [class] <encdom> module . add_class ( 'SocketSetDontFragmentTag' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Tag' ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time ▁ [class] <encdom> module . add_class ( 'Time' , import_from_module = 'ns.core' ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Unit ▁ [enumeration] <encdom> module . add_enum ( 'Unit' , [ 'Y' , 'D' , 'H' , 'MIN' , 'S' , 'MS' , 'US' , 'NS' , 'PS' , 'FS' , 'LAST' ] , outer_class = root_module [ 'ns3::Time' ] , import_from_module = 'ns.core' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Time ▁ )' , u'ns3::Time::TracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Time ▁ )*' , u'ns3::Time::TracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Time ▁ )&' , u'ns3::Time::TracedCallback&' ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time ▁ [class] <encdom> root_module [ 'ns3::Time' ] . implicitly_converts_to ( root_module [ 'ns3::int64x64_t' ] ) <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ ns3::TraceSourceAccessor ▁ [class] <encdom> module . add_class ( 'TraceSourceAccessor' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ >' ] ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ ns3::Trailer ▁ [class] <encdom> module . add_class ( 'Trailer' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Chunk' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::TriangularRandomVariable ▁ [class] <encdom> module . add_class ( 'TriangularRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::UniformRandomVariable ▁ [class] <encdom> module . add_class ( 'UniformRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::WeibullRandomVariable ▁ [class] <encdom> module . add_class ( 'WeibullRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ZetaRandomVariable ▁ [class] <encdom> module . add_class ( 'ZetaRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ZipfRandomVariable ▁ [class] <encdom> module . add_class ( 'ZipfRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeAccessor ▁ [class] <encdom> module . add_class ( 'AttributeAccessor' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ >' ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeChecker ▁ [class] <encdom> module . add_class ( 'AttributeChecker' , allow_subclassing = False , automatic_type_narrowing = True , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ >' ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeValue ▁ [class] <encdom> module . add_class ( 'AttributeValue' , allow_subclassing = False , automatic_type_narrowing = True , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ >' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackChecker ▁ [class] <encdom> module . add_class ( 'CallbackChecker' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImplBase ▁ [class] <encdom> module . add_class ( 'CallbackImplBase' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ >' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackValue ▁ [class] <encdom> module . add_class ( 'CallbackValue' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ConstantRandomVariable ▁ [class] <encdom> module . add_class ( 'ConstantRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::DeterministicRandomVariable ▁ [class] <encdom> module . add_class ( 'DeterministicRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::EmpiricalRandomVariable ▁ [class] <encdom> module . add_class ( 'EmpiricalRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeAccessor ▁ [class] <encdom> module . add_class ( 'EmptyAttributeAccessor' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeAccessor' ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeChecker ▁ [class] <encdom> module . add_class ( 'EmptyAttributeChecker' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeValue ▁ [class] <encdom> module . add_class ( 'EmptyAttributeValue' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ErlangRandomVariable ▁ [class] <encdom> module . add_class ( 'ErlangRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ ns3::EventImpl ▁ [class] <encdom> module . add_class ( 'EventImpl' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ >' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ExponentialRandomVariable ▁ [class] <encdom> module . add_class ( 'ExponentialRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::GammaRandomVariable ▁ [class] <encdom> module . add_class ( 'GammaRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4 ▁ [class] <encdom> module . add_class ( 'Ipv4' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::Object' ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressChecker ▁ [class] <encdom> module . add_class ( 'Ipv4AddressChecker' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressValue ▁ [class] <encdom> module . add_class ( 'Ipv4AddressValue' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskChecker ▁ [class] <encdom> module . add_class ( 'Ipv4MaskChecker' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskValue ▁ [class] <encdom> module . add_class ( 'Ipv4MaskValue' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4MulticastRoute ▁ [class] <encdom> module . add_class ( 'Ipv4MulticastRoute' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> ▁ >' ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Route ▁ [class] <encdom> module . add_class ( 'Ipv4Route' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4Route> ▁ >' ] ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingProtocol ▁ [class] <encdom> module . add_class ( 'Ipv4RoutingProtocol' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::Object' ] ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::Ipv4RoutingProtocol::UnicastForwardCallback' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::Ipv4RoutingProtocol::UnicastForwardCallback*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::Ipv4RoutingProtocol::UnicastForwardCallback&' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::Ipv4RoutingProtocol::MulticastForwardCallback' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::Ipv4RoutingProtocol::MulticastForwardCallback*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::Ipv4RoutingProtocol::MulticastForwardCallback&' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::Ipv4RoutingProtocol::LocalDeliverCallback' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::Ipv4RoutingProtocol::LocalDeliverCallback*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::Ipv4RoutingProtocol::LocalDeliverCallback&' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::Ipv4RoutingProtocol::ErrorCallback' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::Ipv4RoutingProtocol::ErrorCallback*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::Ipv4RoutingProtocol::ErrorCallback&' ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4StaticRouting ▁ [class] <encdom> module . add_class ( 'Ipv4StaticRouting' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::Ipv4RoutingProtocol' ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressChecker ▁ [class] <encdom> module . add_class ( 'Ipv6AddressChecker' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressValue ▁ [class] <encdom> module . add_class ( 'Ipv6AddressValue' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixChecker ▁ [class] <encdom> module . add_class ( 'Ipv6PrefixChecker' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixValue ▁ [class] <encdom> module . add_class ( 'Ipv6PrefixValue' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::LogNormalRandomVariable ▁ [class] <encdom> module . add_class ( 'LogNormalRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressChecker ▁ [class] <encdom> module . add_class ( 'Mac48AddressChecker' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressValue ▁ [class] <encdom> module . add_class ( 'Mac48AddressValue' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::NetDevice ▁ [class] <encdom> module . add_class ( 'NetDevice' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Object' ] ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::NetDevice::PacketType ▁ [enumeration] <encdom> module . add_enum ( 'PacketType' , [ 'PACKET_HOST' , 'NS3_PACKET_HOST' , 'PACKET_BROADCAST' , 'NS3_PACKET_BROADCAST' , 'PACKET_MULTICAST' , 'NS3_PACKET_MULTICAST' , 'PACKET_OTHERHOST' , 'NS3_PACKET_OTHERHOST' ] , outer_class = root_module [ 'ns3::NetDevice' ] , import_from_module = 'ns.network' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ▁ )' , u'ns3::NetDevice::LinkChangeTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ▁ )*' , u'ns3::NetDevice::LinkChangeTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ▁ )&' , u'ns3::NetDevice::LinkChangeTracedCallback&' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::NetDevice::ReceiveCallback' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::NetDevice::ReceiveCallback*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::NetDevice::ReceiveCallback&' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::NetDevice::PromiscReceiveCallback' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::NetDevice::PromiscReceiveCallback*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::NetDevice::PromiscReceiveCallback&' ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ ns3::NixVector ▁ [class] <encdom> module . add_class ( 'NixVector' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ >' ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Node ▁ [class] <encdom> module . add_class ( 'Node' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::Object' ] ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::Node::ProtocolHandler' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::Node::ProtocolHandler*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::Node::ProtocolHandler&' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , u'ns3::Node::DeviceAdditionListener' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >*' , u'ns3::Node::DeviceAdditionListener*' ) <newline> typehandlers . add_type_alias ( u'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >&' , u'ns3::Node::DeviceAdditionListener&' ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::NormalRandomVariable ▁ [class] <encdom> module . add_class ( 'NormalRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryChecker ▁ [class] <encdom> module . add_class ( 'ObjectFactoryChecker' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryValue ▁ [class] <encdom> module . add_class ( 'ObjectFactoryValue' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ output-stream-wrapper.h ▁ (module ▁'network'): ▁ ns3::OutputStreamWrapper ▁ [class] <encdom> module . add_class ( 'OutputStreamWrapper' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::OutputStreamWrapper> ▁ >' ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Packet ▁ [class] <encdom> module . add_class ( 'Packet' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Packet> ▁ >' ] ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ > ▁ )' , u'ns3::Packet::TracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ > ▁ )*' , u'ns3::Packet::TracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ > ▁ )&' , u'ns3::Packet::TracedCallback&' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Address ▁ const ▁ & ▁ )' , u'ns3::Packet::AddressTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Address ▁ const ▁ & ▁ )*' , u'ns3::Packet::AddressTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Address ▁ const ▁ & ▁ )&' , u'ns3::Packet::AddressTracedCallback&' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ > ▁ const, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ & ▁ )' , u'ns3::Packet::TwoAddressTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ > ▁ const, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ & ▁ )*' , u'ns3::Packet::TwoAddressTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ > ▁ const, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ & ▁ )&' , u'ns3::Packet::TwoAddressTracedCallback&' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Mac48Address ▁ )' , u'ns3::Packet::Mac48AddressTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Mac48Address ▁ )*' , u'ns3::Packet::Mac48AddressTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Mac48Address ▁ )&' , u'ns3::Packet::Mac48AddressTracedCallback&' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ uint32_t, ▁ uint32_t ▁ )' , u'ns3::Packet::SizeTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ uint32_t, ▁ uint32_t ▁ )*' , u'ns3::Packet::SizeTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ uint32_t, ▁ uint32_t ▁ )&' , u'ns3::Packet::SizeTracedCallback&' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ double ▁ )' , u'ns3::Packet::SinrTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ double ▁ )*' , u'ns3::Packet::SinrTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ double ▁ )&' , u'ns3::Packet::SinrTracedCallback&' ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ParetoRandomVariable ▁ [class] <encdom> module . add_class ( 'ParetoRandomVariable' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::RandomVariableStream' ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeValue ▁ [class] <encdom> module . add_class ( 'TimeValue' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdChecker ▁ [class] <encdom> module . add_class ( 'TypeIdChecker' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdValue ▁ [class] <encdom> module . add_class ( 'TypeIdValue' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressChecker ▁ [class] <encdom> module . add_class ( 'AddressChecker' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeChecker' ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressValue ▁ [class] <encdom> module . add_class ( 'AddressValue' , import_from_module = 'ns.network' , parent = root_module [ 'ns3::AttributeValue' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'bool' , 'ns3::Ptr<ns3::Socket>' , 'const ▁ ns3::Address ▁ &' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'ns3::ObjectBase ▁ *' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'const ▁ ns3::olsr::PacketHeader ▁ &' , 'const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'ns3::Ptr<ns3::NetDevice>' , 'ns3::Ptr<const ▁ ns3::Packet>' , 'unsigned ▁ short' , 'const ▁ ns3::Address ▁ &' , 'const ▁ ns3::Address ▁ &' , 'ns3::NetDevice::PacketType' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'ns3::Ptr<ns3::NetDevice>' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'ns3::Ptr<ns3::Socket>' , 'const ▁ ns3::Address ▁ &' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'ns3::Ptr<ns3::Socket>' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'ns3::Ptr<ns3::Socket>' , 'unsigned ▁ int' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ [class] <encdom> module . add_class ( 'CallbackImpl' , import_from_module = 'ns.core' , template_parameters = [ 'void' , 'unsigned ▁ int' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' , 'ns3::empty' ] , parent = root_module [ 'ns3::CallbackImplBase' ] ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4ListRouting ▁ [class] <encdom> module . add_class ( 'Ipv4ListRouting' , import_from_module = 'ns.internet' , parent = root_module [ 'ns3::Ipv4RoutingProtocol' ] ) <newline> module . add_container ( 'std::vector< ▁ ns3::Ipv6Address ▁ >' , 'ns3::Ipv6Address' , container_type = u'vector' ) <newline> module . add_container ( 'std::map< ▁ unsigned ▁ int, ▁ unsigned ▁ int ▁ >' , ( 'unsigned ▁ int' , 'unsigned ▁ int' ) , container_type = u'map' ) <newline> module . add_container ( 'std::vector< ▁ unsigned ▁ int ▁ >' , 'unsigned ▁ int' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::MessageHeader ▁ >' , 'ns3::olsr::MessageHeader' , container_type = u'vector' ) <newline>  # # ▁ Register ▁ a ▁ nested ▁ module ▁ for ▁ the ▁ namespace ▁ FatalImpl <encdom> nested_module = module . add_cpp_namespace ( 'FatalImpl' ) <newline> register_types_ns3_FatalImpl ( nested_module ) <newline>  # # ▁ Register ▁ a ▁ nested ▁ module ▁ for ▁ the ▁ namespace ▁ Hash <encdom> nested_module = module . add_cpp_namespace ( 'Hash' ) <newline> register_types_ns3_Hash ( nested_module ) <newline>  # # ▁ Register ▁ a ▁ nested ▁ module ▁ for ▁ the ▁ namespace ▁ TracedValueCallback <encdom> nested_module = module . add_cpp_namespace ( 'TracedValueCallback' ) <newline> register_types_ns3_TracedValueCallback ( nested_module ) <newline>  # # ▁ Register ▁ a ▁ nested ▁ module ▁ for ▁ the ▁ namespace ▁ olsr <encdom> nested_module = module . add_cpp_namespace ( 'olsr' ) <newline> register_types_ns3_olsr ( nested_module ) <newline>  # # ▁ Register ▁ a ▁ nested ▁ module ▁ for ▁ the ▁ namespace ▁ tests <encdom> nested_module = module . add_cpp_namespace ( 'tests' ) <newline> register_types_ns3_tests ( nested_module ) <newline> <dedent> def register_types_ns3_FatalImpl ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline> <dedent> def register_types_ns3_Hash ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Implementation ▁ [class] <encdom> module . add_class ( 'Implementation' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::SimpleRefCount< ▁ ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ >' ] ) <newline> typehandlers . add_type_alias ( u'uint32_t ▁ ( ▁ * ▁ ) ▁ ( ▁ char ▁ const ▁ *, ▁ std::size_t ▁ const ▁ )' , u'ns3::Hash::Hash32Function_ptr' ) <newline> typehandlers . add_type_alias ( u'uint32_t ▁ ( ▁ * ▁ ) ▁ ( ▁ char ▁ const ▁ *, ▁ std::size_t ▁ const ▁ )*' , u'ns3::Hash::Hash32Function_ptr*' ) <newline> typehandlers . add_type_alias ( u'uint32_t ▁ ( ▁ * ▁ ) ▁ ( ▁ char ▁ const ▁ *, ▁ std::size_t ▁ const ▁ )&' , u'ns3::Hash::Hash32Function_ptr&' ) <newline> typehandlers . add_type_alias ( u'uint64_t ▁ ( ▁ * ▁ ) ▁ ( ▁ char ▁ const ▁ *, ▁ std::size_t ▁ const ▁ )' , u'ns3::Hash::Hash64Function_ptr' ) <newline> typehandlers . add_type_alias ( u'uint64_t ▁ ( ▁ * ▁ ) ▁ ( ▁ char ▁ const ▁ *, ▁ std::size_t ▁ const ▁ )*' , u'ns3::Hash::Hash64Function_ptr*' ) <newline> typehandlers . add_type_alias ( u'uint64_t ▁ ( ▁ * ▁ ) ▁ ( ▁ char ▁ const ▁ *, ▁ std::size_t ▁ const ▁ )&' , u'ns3::Hash::Hash64Function_ptr&' ) <newline>  # # ▁ Register ▁ a ▁ nested ▁ module ▁ for ▁ the ▁ namespace ▁ Function <encdom> nested_module = module . add_cpp_namespace ( 'Function' ) <newline> register_types_ns3_Hash_Function ( nested_module ) <newline> <dedent> def register_types_ns3_Hash_Function ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline>  # # ▁ hash-fnv.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Fnv1a ▁ [class] <encdom> module . add_class ( 'Fnv1a' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::Hash::Implementation' ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Hash32 ▁ [class] <encdom> module . add_class ( 'Hash32' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::Hash::Implementation' ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Hash64 ▁ [class] <encdom> module . add_class ( 'Hash64' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::Hash::Implementation' ] ) <newline>  # # ▁ hash-murmur3.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Murmur3 ▁ [class] <encdom> module . add_class ( 'Murmur3' , import_from_module = 'ns.core' , parent = root_module [ 'ns3::Hash::Implementation' ] ) <newline> <dedent> def register_types_ns3_TracedValueCallback ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Time, ▁ ns3::Time ▁ )' , u'ns3::TracedValueCallback::Time' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Time, ▁ ns3::Time ▁ )*' , u'ns3::TracedValueCallback::Time*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::Time, ▁ ns3::Time ▁ )&' , u'ns3::TracedValueCallback::Time&' ) <newline> <dedent> def register_types_ns3_olsr ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::Association ▁ [struct] <encdom> module . add_class ( 'Association' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple ▁ [struct] <encdom> module . add_class ( 'AssociationTuple' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple ▁ [struct] <encdom> module . add_class ( 'DuplicateTuple' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple ▁ [struct] <encdom> module . add_class ( 'IfaceAssocTuple' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple ▁ [struct] <encdom> module . add_class ( 'LinkTuple' ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader ▁ [class] <encdom> module . add_class ( 'MessageHeader' , parent = root_module [ 'ns3::Header' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::MessageType ▁ [enumeration] <encdom> module . add_enum ( 'MessageType' , [ 'HELLO_MESSAGE' , 'TC_MESSAGE' , 'MID_MESSAGE' , 'HNA_MESSAGE' ] , outer_class = root_module [ 'ns3::olsr::MessageHeader' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello ▁ [struct] <encdom> module . add_class ( 'Hello' , outer_class = root_module [ 'ns3::olsr::MessageHeader' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::LinkMessage ▁ [struct] <encdom> module . add_class ( 'LinkMessage' , outer_class = root_module [ 'ns3::olsr::MessageHeader::Hello' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna ▁ [struct] <encdom> module . add_class ( 'Hna' , outer_class = root_module [ 'ns3::olsr::MessageHeader' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Association ▁ [struct] <encdom> module . add_class ( 'Association' , outer_class = root_module [ 'ns3::olsr::MessageHeader::Hna' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Mid ▁ [struct] <encdom> module . add_class ( 'Mid' , outer_class = root_module [ 'ns3::olsr::MessageHeader' ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc ▁ [struct] <encdom> module . add_class ( 'Tc' , outer_class = root_module [ 'ns3::olsr::MessageHeader' ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorTuple ▁ [struct] <encdom> module . add_class ( 'MprSelectorTuple' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple ▁ [struct] <encdom> module . add_class ( 'NeighborTuple' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple::Status ▁ [enumeration] <encdom> module . add_enum ( 'Status' , [ 'STATUS_NOT_SYM' , 'STATUS_SYM' ] , outer_class = root_module [ 'ns3::olsr::NeighborTuple' ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::OlsrState ▁ [class] <encdom> module . add_class ( 'OlsrState' ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::PacketHeader ▁ [class] <encdom> module . add_class ( 'PacketHeader' , parent = root_module [ 'ns3::Header' ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingProtocol ▁ [class] <encdom> module . add_class ( 'RoutingProtocol' , parent = root_module [ 'ns3::Ipv4RoutingProtocol' ] ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::olsr::PacketHeader ▁ const ▁ &, ▁ ns3::olsr::MessageList ▁ const ▁ & ▁ )' , u'ns3::olsr::RoutingProtocol::PacketTxRxTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::olsr::PacketHeader ▁ const ▁ &, ▁ ns3::olsr::MessageList ▁ const ▁ & ▁ )*' , u'ns3::olsr::RoutingProtocol::PacketTxRxTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ ns3::olsr::PacketHeader ▁ const ▁ &, ▁ ns3::olsr::MessageList ▁ const ▁ & ▁ )&' , u'ns3::olsr::RoutingProtocol::PacketTxRxTracedCallback&' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ uint32_t ▁ )' , u'ns3::olsr::RoutingProtocol::TableChangeTracedCallback' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ uint32_t ▁ )*' , u'ns3::olsr::RoutingProtocol::TableChangeTracedCallback*' ) <newline> typehandlers . add_type_alias ( u'void ▁ ( ▁ * ▁ ) ▁ ( ▁ uint32_t ▁ )&' , u'ns3::olsr::RoutingProtocol::TableChangeTracedCallback&' ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry ▁ [struct] <encdom> module . add_class ( 'RoutingTableEntry' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple ▁ [struct] <encdom> module . add_class ( 'TopologyTuple' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple ▁ [struct] <encdom> module . add_class ( 'TwoHopNeighborTuple' ) <newline> module . add_container ( 'std::vector< ▁ ns3::Ipv4Address ▁ >' , 'ns3::Ipv4Address' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::MessageHeader::Hello::LinkMessage ▁ >' , 'ns3::olsr::MessageHeader::Hello::LinkMessage' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::MessageHeader::Hna::Association ▁ >' , 'ns3::olsr::MessageHeader::Hna::Association' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::MprSelectorTuple ▁ >' , 'ns3::olsr::MprSelectorTuple' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::NeighborTuple ▁ >' , 'ns3::olsr::NeighborTuple' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::TwoHopNeighborTuple ▁ >' , 'ns3::olsr::TwoHopNeighborTuple' , container_type = u'vector' ) <newline> module . add_container ( 'ns3::olsr::MprSet' , 'ns3::Ipv4Address' , container_type = u'set' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::LinkTuple ▁ >' , 'ns3::olsr::LinkTuple' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::TopologyTuple ▁ >' , 'ns3::olsr::TopologyTuple' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::IfaceAssocTuple ▁ >' , 'ns3::olsr::IfaceAssocTuple' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::AssociationTuple ▁ >' , 'ns3::olsr::AssociationTuple' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::Association ▁ >' , 'ns3::olsr::Association' , container_type = u'vector' ) <newline> module . add_container ( 'std::vector< ▁ ns3::olsr::RoutingTableEntry ▁ >' , 'ns3::olsr::RoutingTableEntry' , container_type = u'vector' ) <newline> module . add_container ( 'std::set< ▁ unsigned ▁ int ▁ >' , 'unsigned ▁ int' , container_type = u'set' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::MessageHeader ▁ >' , u'ns3::olsr::MessageList' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::MessageHeader ▁ >*' , u'ns3::olsr::MessageList*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::MessageHeader ▁ >&' , u'ns3::olsr::MessageList&' ) <newline> typehandlers . add_type_alias ( u'std::set< ▁ ns3::Ipv4Address ▁ >' , u'ns3::olsr::MprSet' ) <newline> typehandlers . add_type_alias ( u'std::set< ▁ ns3::Ipv4Address ▁ >*' , u'ns3::olsr::MprSet*' ) <newline> typehandlers . add_type_alias ( u'std::set< ▁ ns3::Ipv4Address ▁ >&' , u'ns3::olsr::MprSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::MprSelectorTuple ▁ >' , u'ns3::olsr::MprSelectorSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::MprSelectorTuple ▁ >*' , u'ns3::olsr::MprSelectorSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::MprSelectorTuple ▁ >&' , u'ns3::olsr::MprSelectorSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::LinkTuple ▁ >' , u'ns3::olsr::LinkSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::LinkTuple ▁ >*' , u'ns3::olsr::LinkSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::LinkTuple ▁ >&' , u'ns3::olsr::LinkSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::NeighborTuple ▁ >' , u'ns3::olsr::NeighborSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::NeighborTuple ▁ >*' , u'ns3::olsr::NeighborSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::NeighborTuple ▁ >&' , u'ns3::olsr::NeighborSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::TwoHopNeighborTuple ▁ >' , u'ns3::olsr::TwoHopNeighborSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::TwoHopNeighborTuple ▁ >*' , u'ns3::olsr::TwoHopNeighborSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::TwoHopNeighborTuple ▁ >&' , u'ns3::olsr::TwoHopNeighborSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::TopologyTuple ▁ >' , u'ns3::olsr::TopologySet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::TopologyTuple ▁ >*' , u'ns3::olsr::TopologySet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::TopologyTuple ▁ >&' , u'ns3::olsr::TopologySet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::DuplicateTuple ▁ >' , u'ns3::olsr::DuplicateSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::DuplicateTuple ▁ >*' , u'ns3::olsr::DuplicateSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::DuplicateTuple ▁ >&' , u'ns3::olsr::DuplicateSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::IfaceAssocTuple ▁ >' , u'ns3::olsr::IfaceAssocSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::IfaceAssocTuple ▁ >*' , u'ns3::olsr::IfaceAssocSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::IfaceAssocTuple ▁ >&' , u'ns3::olsr::IfaceAssocSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::AssociationTuple ▁ >' , u'ns3::olsr::AssociationSet' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::AssociationTuple ▁ >*' , u'ns3::olsr::AssociationSet*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::AssociationTuple ▁ >&' , u'ns3::olsr::AssociationSet&' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::Association ▁ >' , u'ns3::olsr::Associations' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::Association ▁ >*' , u'ns3::olsr::Associations*' ) <newline> typehandlers . add_type_alias ( u'std::vector< ▁ ns3::olsr::Association ▁ >&' , u'ns3::olsr::Associations&' ) <newline> <dedent> def register_types_ns3_tests ( module ) : <newline> <indent> root_module = module . get_root ( ) <newline> <dedent> def register_methods ( root_module ) : <newline> <indent> register_Ns3Address_methods ( root_module , root_module [ 'ns3::Address' ] ) <newline> register_Ns3AttributeConstructionList_methods ( root_module , root_module [ 'ns3::AttributeConstructionList' ] ) <newline> register_Ns3AttributeConstructionListItem_methods ( root_module , root_module [ 'ns3::AttributeConstructionList::Item' ] ) <newline> register_Ns3Buffer_methods ( root_module , root_module [ 'ns3::Buffer' ] ) <newline> register_Ns3BufferIterator_methods ( root_module , root_module [ 'ns3::Buffer::Iterator' ] ) <newline> register_Ns3ByteTagIterator_methods ( root_module , root_module [ 'ns3::ByteTagIterator' ] ) <newline> register_Ns3ByteTagIteratorItem_methods ( root_module , root_module [ 'ns3::ByteTagIterator::Item' ] ) <newline> register_Ns3ByteTagList_methods ( root_module , root_module [ 'ns3::ByteTagList' ] ) <newline> register_Ns3ByteTagListIterator_methods ( root_module , root_module [ 'ns3::ByteTagList::Iterator' ] ) <newline> register_Ns3ByteTagListIteratorItem_methods ( root_module , root_module [ 'ns3::ByteTagList::Iterator::Item' ] ) <newline> register_Ns3CallbackBase_methods ( root_module , root_module [ 'ns3::CallbackBase' ] ) <newline> register_Ns3DefaultDeleter__Ns3AttributeAccessor_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::AttributeAccessor ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3AttributeChecker_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::AttributeChecker ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3AttributeValue_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::AttributeValue ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3CallbackImplBase_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::CallbackImplBase ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3EventImpl_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::EventImpl ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3HashImplementation_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::Hash::Implementation ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3NixVector_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::NixVector ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3Packet_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::Packet ▁ >' ] ) <newline> register_Ns3DefaultDeleter__Ns3TraceSourceAccessor_methods ( root_module , root_module [ 'ns3::DefaultDeleter< ▁ ns3::TraceSourceAccessor ▁ >' ] ) <newline> register_Ns3EventGarbageCollector_methods ( root_module , root_module [ 'ns3::EventGarbageCollector' ] ) <newline> register_Ns3EventId_methods ( root_module , root_module [ 'ns3::EventId' ] ) <newline> register_Ns3Hasher_methods ( root_module , root_module [ 'ns3::Hasher' ] ) <newline> register_Ns3Inet6SocketAddress_methods ( root_module , root_module [ 'ns3::Inet6SocketAddress' ] ) <newline> register_Ns3InetSocketAddress_methods ( root_module , root_module [ 'ns3::InetSocketAddress' ] ) <newline> register_Ns3IntToType__0_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 0 ▁ >' ] ) <newline> register_Ns3IntToType__1_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 1 ▁ >' ] ) <newline> register_Ns3IntToType__2_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 2 ▁ >' ] ) <newline> register_Ns3IntToType__3_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 3 ▁ >' ] ) <newline> register_Ns3IntToType__4_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 4 ▁ >' ] ) <newline> register_Ns3IntToType__5_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 5 ▁ >' ] ) <newline> register_Ns3IntToType__6_methods ( root_module , root_module [ 'ns3::IntToType< ▁ 6 ▁ >' ] ) <newline> register_Ns3Ipv4Address_methods ( root_module , root_module [ 'ns3::Ipv4Address' ] ) <newline> register_Ns3Ipv4InterfaceAddress_methods ( root_module , root_module [ 'ns3::Ipv4InterfaceAddress' ] ) <newline> register_Ns3Ipv4Mask_methods ( root_module , root_module [ 'ns3::Ipv4Mask' ] ) <newline> register_Ns3Ipv4RoutingHelper_methods ( root_module , root_module [ 'ns3::Ipv4RoutingHelper' ] ) <newline> register_Ns3Ipv6Address_methods ( root_module , root_module [ 'ns3::Ipv6Address' ] ) <newline> register_Ns3Ipv6Prefix_methods ( root_module , root_module [ 'ns3::Ipv6Prefix' ] ) <newline> register_Ns3Mac48Address_methods ( root_module , root_module [ 'ns3::Mac48Address' ] ) <newline> register_Ns3Mac8Address_methods ( root_module , root_module [ 'ns3::Mac8Address' ] ) <newline> register_Ns3NodeContainer_methods ( root_module , root_module [ 'ns3::NodeContainer' ] ) <newline> register_Ns3NonCopyable_methods ( root_module , root_module [ 'ns3::NonCopyable' ] ) <newline> register_Ns3ObjectBase_methods ( root_module , root_module [ 'ns3::ObjectBase' ] ) <newline> register_Ns3ObjectDeleter_methods ( root_module , root_module [ 'ns3::ObjectDeleter' ] ) <newline> register_Ns3ObjectFactory_methods ( root_module , root_module [ 'ns3::ObjectFactory' ] ) <newline> register_Ns3OlsrHelper_methods ( root_module , root_module [ 'ns3::OlsrHelper' ] ) <newline> register_Ns3PacketMetadata_methods ( root_module , root_module [ 'ns3::PacketMetadata' ] ) <newline> register_Ns3PacketMetadataItem_methods ( root_module , root_module [ 'ns3::PacketMetadata::Item' ] ) <newline> register_Ns3PacketMetadataItemIterator_methods ( root_module , root_module [ 'ns3::PacketMetadata::ItemIterator' ] ) <newline> register_Ns3PacketTagIterator_methods ( root_module , root_module [ 'ns3::PacketTagIterator' ] ) <newline> register_Ns3PacketTagIteratorItem_methods ( root_module , root_module [ 'ns3::PacketTagIterator::Item' ] ) <newline> register_Ns3PacketTagList_methods ( root_module , root_module [ 'ns3::PacketTagList' ] ) <newline> register_Ns3PacketTagListTagData_methods ( root_module , root_module [ 'ns3::PacketTagList::TagData' ] ) <newline> register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter ▁ >' ] ) <newline> register_Ns3Simulator_methods ( root_module , root_module [ 'ns3::Simulator' ] ) <newline> register_Ns3SystemWallClockMs_methods ( root_module , root_module [ 'ns3::SystemWallClockMs' ] ) <newline> register_Ns3Tag_methods ( root_module , root_module [ 'ns3::Tag' ] ) <newline> register_Ns3TagBuffer_methods ( root_module , root_module [ 'ns3::TagBuffer' ] ) <newline> register_Ns3TimeWithUnit_methods ( root_module , root_module [ 'ns3::TimeWithUnit' ] ) <newline> register_Ns3Timer_methods ( root_module , root_module [ 'ns3::Timer' ] ) <newline> register_Ns3TimerImpl_methods ( root_module , root_module [ 'ns3::TimerImpl' ] ) <newline> register_Ns3TypeId_methods ( root_module , root_module [ 'ns3::TypeId' ] ) <newline> register_Ns3TypeIdAttributeInformation_methods ( root_module , root_module [ 'ns3::TypeId::AttributeInformation' ] ) <newline> register_Ns3TypeIdTraceSourceInformation_methods ( root_module , root_module [ 'ns3::TypeId::TraceSourceInformation' ] ) <newline> register_Ns3Empty_methods ( root_module , root_module [ 'ns3::empty' ] ) <newline> register_Ns3Int64x64_t_methods ( root_module , root_module [ 'ns3::int64x64_t' ] ) <newline> register_Ns3Chunk_methods ( root_module , root_module [ 'ns3::Chunk' ] ) <newline> register_Ns3Header_methods ( root_module , root_module [ 'ns3::Header' ] ) <newline> register_Ns3Ipv4Header_methods ( root_module , root_module [ 'ns3::Ipv4Header' ] ) <newline> register_Ns3Object_methods ( root_module , root_module [ 'ns3::Object' ] ) <newline> register_Ns3ObjectAggregateIterator_methods ( root_module , root_module [ 'ns3::Object::AggregateIterator' ] ) <newline> register_Ns3RandomVariableStream_methods ( root_module , root_module [ 'ns3::RandomVariableStream' ] ) <newline> register_Ns3SequentialRandomVariable_methods ( root_module , root_module [ 'ns3::SequentialRandomVariable' ] ) <newline> register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3HashImplementation_Ns3Empty_Ns3DefaultDeleter__lt__ns3HashImplementation__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4Route> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::OutputStreamWrapper> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Packet> ▁ >' ] ) <newline> register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods ( root_module , root_module [ 'ns3::SimpleRefCount< ▁ ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ >' ] ) <newline> register_Ns3Socket_methods ( root_module , root_module [ 'ns3::Socket' ] ) <newline> register_Ns3SocketIpTosTag_methods ( root_module , root_module [ 'ns3::SocketIpTosTag' ] ) <newline> register_Ns3SocketIpTtlTag_methods ( root_module , root_module [ 'ns3::SocketIpTtlTag' ] ) <newline> register_Ns3SocketIpv6HopLimitTag_methods ( root_module , root_module [ 'ns3::SocketIpv6HopLimitTag' ] ) <newline> register_Ns3SocketIpv6TclassTag_methods ( root_module , root_module [ 'ns3::SocketIpv6TclassTag' ] ) <newline> register_Ns3SocketPriorityTag_methods ( root_module , root_module [ 'ns3::SocketPriorityTag' ] ) <newline> register_Ns3SocketSetDontFragmentTag_methods ( root_module , root_module [ 'ns3::SocketSetDontFragmentTag' ] ) <newline> register_Ns3Time_methods ( root_module , root_module [ 'ns3::Time' ] ) <newline> register_Ns3TraceSourceAccessor_methods ( root_module , root_module [ 'ns3::TraceSourceAccessor' ] ) <newline> register_Ns3Trailer_methods ( root_module , root_module [ 'ns3::Trailer' ] ) <newline> register_Ns3TriangularRandomVariable_methods ( root_module , root_module [ 'ns3::TriangularRandomVariable' ] ) <newline> register_Ns3UniformRandomVariable_methods ( root_module , root_module [ 'ns3::UniformRandomVariable' ] ) <newline> register_Ns3WeibullRandomVariable_methods ( root_module , root_module [ 'ns3::WeibullRandomVariable' ] ) <newline> register_Ns3ZetaRandomVariable_methods ( root_module , root_module [ 'ns3::ZetaRandomVariable' ] ) <newline> register_Ns3ZipfRandomVariable_methods ( root_module , root_module [ 'ns3::ZipfRandomVariable' ] ) <newline> register_Ns3AttributeAccessor_methods ( root_module , root_module [ 'ns3::AttributeAccessor' ] ) <newline> register_Ns3AttributeChecker_methods ( root_module , root_module [ 'ns3::AttributeChecker' ] ) <newline> register_Ns3AttributeValue_methods ( root_module , root_module [ 'ns3::AttributeValue' ] ) <newline> register_Ns3CallbackChecker_methods ( root_module , root_module [ 'ns3::CallbackChecker' ] ) <newline> register_Ns3CallbackImplBase_methods ( root_module , root_module [ 'ns3::CallbackImplBase' ] ) <newline> register_Ns3CallbackValue_methods ( root_module , root_module [ 'ns3::CallbackValue' ] ) <newline> register_Ns3ConstantRandomVariable_methods ( root_module , root_module [ 'ns3::ConstantRandomVariable' ] ) <newline> register_Ns3DeterministicRandomVariable_methods ( root_module , root_module [ 'ns3::DeterministicRandomVariable' ] ) <newline> register_Ns3EmpiricalRandomVariable_methods ( root_module , root_module [ 'ns3::EmpiricalRandomVariable' ] ) <newline> register_Ns3EmptyAttributeAccessor_methods ( root_module , root_module [ 'ns3::EmptyAttributeAccessor' ] ) <newline> register_Ns3EmptyAttributeChecker_methods ( root_module , root_module [ 'ns3::EmptyAttributeChecker' ] ) <newline> register_Ns3EmptyAttributeValue_methods ( root_module , root_module [ 'ns3::EmptyAttributeValue' ] ) <newline> register_Ns3ErlangRandomVariable_methods ( root_module , root_module [ 'ns3::ErlangRandomVariable' ] ) <newline> register_Ns3EventImpl_methods ( root_module , root_module [ 'ns3::EventImpl' ] ) <newline> register_Ns3ExponentialRandomVariable_methods ( root_module , root_module [ 'ns3::ExponentialRandomVariable' ] ) <newline> register_Ns3GammaRandomVariable_methods ( root_module , root_module [ 'ns3::GammaRandomVariable' ] ) <newline> register_Ns3Ipv4_methods ( root_module , root_module [ 'ns3::Ipv4' ] ) <newline> register_Ns3Ipv4AddressChecker_methods ( root_module , root_module [ 'ns3::Ipv4AddressChecker' ] ) <newline> register_Ns3Ipv4AddressValue_methods ( root_module , root_module [ 'ns3::Ipv4AddressValue' ] ) <newline> register_Ns3Ipv4MaskChecker_methods ( root_module , root_module [ 'ns3::Ipv4MaskChecker' ] ) <newline> register_Ns3Ipv4MaskValue_methods ( root_module , root_module [ 'ns3::Ipv4MaskValue' ] ) <newline> register_Ns3Ipv4MulticastRoute_methods ( root_module , root_module [ 'ns3::Ipv4MulticastRoute' ] ) <newline> register_Ns3Ipv4Route_methods ( root_module , root_module [ 'ns3::Ipv4Route' ] ) <newline> register_Ns3Ipv4RoutingProtocol_methods ( root_module , root_module [ 'ns3::Ipv4RoutingProtocol' ] ) <newline> register_Ns3Ipv4StaticRouting_methods ( root_module , root_module [ 'ns3::Ipv4StaticRouting' ] ) <newline> register_Ns3Ipv6AddressChecker_methods ( root_module , root_module [ 'ns3::Ipv6AddressChecker' ] ) <newline> register_Ns3Ipv6AddressValue_methods ( root_module , root_module [ 'ns3::Ipv6AddressValue' ] ) <newline> register_Ns3Ipv6PrefixChecker_methods ( root_module , root_module [ 'ns3::Ipv6PrefixChecker' ] ) <newline> register_Ns3Ipv6PrefixValue_methods ( root_module , root_module [ 'ns3::Ipv6PrefixValue' ] ) <newline> register_Ns3LogNormalRandomVariable_methods ( root_module , root_module [ 'ns3::LogNormalRandomVariable' ] ) <newline> register_Ns3Mac48AddressChecker_methods ( root_module , root_module [ 'ns3::Mac48AddressChecker' ] ) <newline> register_Ns3Mac48AddressValue_methods ( root_module , root_module [ 'ns3::Mac48AddressValue' ] ) <newline> register_Ns3NetDevice_methods ( root_module , root_module [ 'ns3::NetDevice' ] ) <newline> register_Ns3NixVector_methods ( root_module , root_module [ 'ns3::NixVector' ] ) <newline> register_Ns3Node_methods ( root_module , root_module [ 'ns3::Node' ] ) <newline> register_Ns3NormalRandomVariable_methods ( root_module , root_module [ 'ns3::NormalRandomVariable' ] ) <newline> register_Ns3ObjectFactoryChecker_methods ( root_module , root_module [ 'ns3::ObjectFactoryChecker' ] ) <newline> register_Ns3ObjectFactoryValue_methods ( root_module , root_module [ 'ns3::ObjectFactoryValue' ] ) <newline> register_Ns3OutputStreamWrapper_methods ( root_module , root_module [ 'ns3::OutputStreamWrapper' ] ) <newline> register_Ns3Packet_methods ( root_module , root_module [ 'ns3::Packet' ] ) <newline> register_Ns3ParetoRandomVariable_methods ( root_module , root_module [ 'ns3::ParetoRandomVariable' ] ) <newline> register_Ns3TimeValue_methods ( root_module , root_module [ 'ns3::TimeValue' ] ) <newline> register_Ns3TypeIdChecker_methods ( root_module , root_module [ 'ns3::TypeIdChecker' ] ) <newline> register_Ns3TypeIdValue_methods ( root_module , root_module [ 'ns3::TypeIdValue' ] ) <newline> register_Ns3AddressChecker_methods ( root_module , root_module [ 'ns3::AddressChecker' ] ) <newline> register_Ns3AddressValue_methods ( root_module , root_module [ 'ns3::AddressValue' ] ) <newline> register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Ns3ObjectBase___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Const_ns3OlsrPacketHeader___amp___Const_stdVector__lt__ns3OlsrMessageHeader__stdAllocator__lt__ns3OlsrMessageHeader__gt_____gt_____amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3CallbackImpl__Void_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , root_module [ 'ns3::CallbackImpl< ▁ void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' ] ) <newline> register_Ns3Ipv4ListRouting_methods ( root_module , root_module [ 'ns3::Ipv4ListRouting' ] ) <newline> register_Ns3HashImplementation_methods ( root_module , root_module [ 'ns3::Hash::Implementation' ] ) <newline> register_Ns3HashFunctionFnv1a_methods ( root_module , root_module [ 'ns3::Hash::Function::Fnv1a' ] ) <newline> register_Ns3HashFunctionHash32_methods ( root_module , root_module [ 'ns3::Hash::Function::Hash32' ] ) <newline> register_Ns3HashFunctionHash64_methods ( root_module , root_module [ 'ns3::Hash::Function::Hash64' ] ) <newline> register_Ns3HashFunctionMurmur3_methods ( root_module , root_module [ 'ns3::Hash::Function::Murmur3' ] ) <newline> register_Ns3OlsrAssociation_methods ( root_module , root_module [ 'ns3::olsr::Association' ] ) <newline> register_Ns3OlsrAssociationTuple_methods ( root_module , root_module [ 'ns3::olsr::AssociationTuple' ] ) <newline> register_Ns3OlsrDuplicateTuple_methods ( root_module , root_module [ 'ns3::olsr::DuplicateTuple' ] ) <newline> register_Ns3OlsrIfaceAssocTuple_methods ( root_module , root_module [ 'ns3::olsr::IfaceAssocTuple' ] ) <newline> register_Ns3OlsrLinkTuple_methods ( root_module , root_module [ 'ns3::olsr::LinkTuple' ] ) <newline> register_Ns3OlsrMessageHeader_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader' ] ) <newline> register_Ns3OlsrMessageHeaderHello_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader::Hello' ] ) <newline> register_Ns3OlsrMessageHeaderHelloLinkMessage_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader::Hello::LinkMessage' ] ) <newline> register_Ns3OlsrMessageHeaderHna_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader::Hna' ] ) <newline> register_Ns3OlsrMessageHeaderHnaAssociation_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader::Hna::Association' ] ) <newline> register_Ns3OlsrMessageHeaderMid_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader::Mid' ] ) <newline> register_Ns3OlsrMessageHeaderTc_methods ( root_module , root_module [ 'ns3::olsr::MessageHeader::Tc' ] ) <newline> register_Ns3OlsrMprSelectorTuple_methods ( root_module , root_module [ 'ns3::olsr::MprSelectorTuple' ] ) <newline> register_Ns3OlsrNeighborTuple_methods ( root_module , root_module [ 'ns3::olsr::NeighborTuple' ] ) <newline> register_Ns3OlsrOlsrState_methods ( root_module , root_module [ 'ns3::olsr::OlsrState' ] ) <newline> register_Ns3OlsrPacketHeader_methods ( root_module , root_module [ 'ns3::olsr::PacketHeader' ] ) <newline> register_Ns3OlsrRoutingProtocol_methods ( root_module , root_module [ 'ns3::olsr::RoutingProtocol' ] ) <newline> register_Ns3OlsrRoutingTableEntry_methods ( root_module , root_module [ 'ns3::olsr::RoutingTableEntry' ] ) <newline> register_Ns3OlsrTopologyTuple_methods ( root_module , root_module [ 'ns3::olsr::TopologyTuple' ] ) <newline> register_Ns3OlsrTwoHopNeighborTuple_methods ( root_module , root_module [ 'ns3::olsr::TwoHopNeighborTuple' ] ) <newline> return <newline> <dedent> def register_Ns3Address_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Address::Address() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Address::Address(uint8_t ▁ type, ▁ uint8_t ▁ const ▁ * ▁ buffer, ▁ uint8_t ▁ len) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t' , 'type' ) , param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint8_t' , 'len' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Address::Address(ns3::Address ▁ const ▁ & ▁ address) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Address::CheckCompatible(uint8_t ▁ type, ▁ uint8_t ▁ len) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CheckCompatible' , 'bool' , [ param ( 'uint8_t' , 'type' ) , param ( 'uint8_t' , 'len' ) ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Address::CopyAllFrom(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint8_t ▁ len) ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyAllFrom' , 'uint32_t' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint8_t' , 'len' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Address::CopyAllTo(uint8_t ▁ * ▁ buffer, ▁ uint8_t ▁ len) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyAllTo' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint8_t' , 'len' ) ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Address::CopyFrom(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint8_t ▁ len) ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyFrom' , 'uint32_t' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint8_t' , 'len' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Address::CopyTo(uint8_t ▁ * ▁ buffer) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyTo' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Address::Deserialize(ns3::TagBuffer ▁ buffer) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'buffer' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Address::GetLength() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLength' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Address::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Address::IsInvalid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsInvalid' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Address::IsMatchingType(uint8_t ▁ type) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'uint8_t' , 'type' ) ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ static ▁ uint8_t ▁ ns3::Address::Register() ▁ [member ▁ function] <encdom> cls . add_method ( 'Register' , 'uint8_t' , [ ] , is_static = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Address::Serialize(ns3::TagBuffer ▁ buffer) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'buffer' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3AttributeConstructionList_methods ( root_module , cls ) : <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::AttributeConstructionList(ns3::AttributeConstructionList ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::AttributeConstructionList ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::AttributeConstructionList() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ void ▁ ns3::AttributeConstructionList::Add(std::string ▁ name, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker, ▁ ns3::Ptr<ns3::AttributeValue> ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'void' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , 'value' ) ] ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::CIterator ▁ ns3::AttributeConstructionList::Begin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Begin' , 'ns3::AttributeConstructionList::CIterator' , [ ] , is_const = True ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::CIterator ▁ ns3::AttributeConstructionList::End() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'End' , 'ns3::AttributeConstructionList::CIterator' , [ ] , is_const = True ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::AttributeConstructionList::Find(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Find' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3AttributeConstructionListItem_methods ( root_module , cls ) : <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::Item::Item() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::Item::Item(ns3::AttributeConstructionList::Item ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::AttributeConstructionList::Item ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::Item::checker ▁ [variable] <encdom> cls . add_instance_attribute ( 'checker' , 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , is_const = False ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::Item::name ▁ [variable] <encdom> cls . add_instance_attribute ( 'name' , 'std::string' , is_const = False ) <newline>  # # ▁ attribute-construction-list.h ▁ (module ▁'core'): ▁ ns3::AttributeConstructionList::Item::value ▁ [variable] <encdom> cls . add_instance_attribute ( 'value' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3Buffer_methods ( root_module , cls ) : <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Buffer(ns3::Buffer ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Buffer ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Buffer() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Buffer(uint32_t ▁ dataSize) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint32_t' , 'dataSize' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Buffer(uint32_t ▁ dataSize, ▁ bool ▁ initialize) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint32_t' , 'dataSize' ) , param ( 'bool' , 'initialize' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::AddAtEnd(uint32_t ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtEnd' , 'void' , [ param ( 'uint32_t' , 'end' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::AddAtEnd(ns3::Buffer ▁ const ▁ & ▁ o) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtEnd' , 'void' , [ param ( 'ns3::Buffer ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::AddAtStart(uint32_t ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtStart' , 'void' , [ param ( 'uint32_t' , 'start' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Iterator ▁ ns3::Buffer::Begin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Begin' , 'ns3::Buffer::Iterator' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::CopyData(std::ostream ▁ * ▁ os, ▁ uint32_t ▁ size) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyData' , 'void' , [ param ( 'std::ostream ▁ *' , 'os' ) , param ( 'uint32_t' , 'size' ) ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::CopyData(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyData' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer ▁ ns3::Buffer::CreateFragment(uint32_t ▁ start, ▁ uint32_t ▁ length) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CreateFragment' , 'ns3::Buffer' , [ param ( 'uint32_t' , 'start' ) , param ( 'uint32_t' , 'length' ) ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Deserialize(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Iterator ▁ ns3::Buffer::End() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'End' , 'ns3::Buffer::Iterator' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::GetSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint8_t ▁ const ▁ * ▁ ns3::Buffer::PeekData() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekData' , 'uint8_t ▁ const ▁ *' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::RemoveAtEnd(uint32_t ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAtEnd' , 'void' , [ param ( 'uint32_t' , 'end' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::RemoveAtStart(uint32_t ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAtStart' , 'void' , [ param ( 'uint32_t' , 'start' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Serialize(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ maxSize) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'maxSize' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3BufferIterator_methods ( root_module , cls ) : <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Iterator::Iterator(ns3::Buffer::Iterator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Buffer::Iterator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ ns3::Buffer::Iterator::Iterator() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Buffer::Iterator::CalculateIpChecksum(uint16_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'CalculateIpChecksum' , 'uint16_t' , [ param ( 'uint16_t' , 'size' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Buffer::Iterator::CalculateIpChecksum(uint16_t ▁ size, ▁ uint32_t ▁ initialChecksum) ▁ [member ▁ function] <encdom> cls . add_method ( 'CalculateIpChecksum' , 'uint16_t' , [ param ( 'uint16_t' , 'size' ) , param ( 'uint32_t' , 'initialChecksum' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Iterator::GetDistanceFrom(ns3::Buffer::Iterator ▁ const ▁ & ▁ o) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDistanceFrom' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator ▁ const ▁ &' , 'o' ) ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Iterator::GetRemainingSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRemainingSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Iterator::GetSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Buffer::Iterator::IsEnd() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEnd' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Buffer::Iterator::IsStart() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsStart' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Next() ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'void' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Next(uint32_t ▁ delta) ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'void' , [ param ( 'uint32_t' , 'delta' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Buffer::Iterator::PeekU8() ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekU8' , 'uint8_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Prev() ▁ [member ▁ function] <encdom> cls . add_method ( 'Prev' , 'void' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Prev(uint32_t ▁ delta) ▁ [member ▁ function] <encdom> cls . add_method ( 'Prev' , 'void' , [ param ( 'uint32_t' , 'delta' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Read(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Read' , 'void' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Read(ns3::Buffer::Iterator ▁ start, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Read' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Buffer::Iterator::ReadLsbtohU16() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadLsbtohU16' , 'uint16_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Iterator::ReadLsbtohU32() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadLsbtohU32' , 'uint32_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint64_t ▁ ns3::Buffer::Iterator::ReadLsbtohU64() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadLsbtohU64' , 'uint64_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Buffer::Iterator::ReadNtohU16() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadNtohU16' , 'uint16_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Iterator::ReadNtohU32() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadNtohU32' , 'uint32_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint64_t ▁ ns3::Buffer::Iterator::ReadNtohU64() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadNtohU64' , 'uint64_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Buffer::Iterator::ReadU16() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU16' , 'uint16_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Buffer::Iterator::ReadU32() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU32' , 'uint32_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint64_t ▁ ns3::Buffer::Iterator::ReadU64() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU64' , 'uint64_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Buffer::Iterator::ReadU8() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU8' , 'uint8_t' , [ ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Write(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Write' , 'void' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::Write(ns3::Buffer::Iterator ▁ start, ▁ ns3::Buffer::Iterator ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'Write' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'ns3::Buffer::Iterator' , 'end' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteHtolsbU16(uint16_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteHtolsbU16' , 'void' , [ param ( 'uint16_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteHtolsbU32(uint32_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteHtolsbU32' , 'void' , [ param ( 'uint32_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteHtolsbU64(uint64_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteHtolsbU64' , 'void' , [ param ( 'uint64_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteHtonU16(uint16_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteHtonU16' , 'void' , [ param ( 'uint16_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteHtonU32(uint32_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteHtonU32' , 'void' , [ param ( 'uint32_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteHtonU64(uint64_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteHtonU64' , 'void' , [ param ( 'uint64_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteU16(uint16_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU16' , 'void' , [ param ( 'uint16_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteU32(uint32_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU32' , 'void' , [ param ( 'uint32_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteU64(uint64_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU64' , 'void' , [ param ( 'uint64_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteU8(uint8_t ▁ data) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU8' , 'void' , [ param ( 'uint8_t' , 'data' ) ] ) <newline>  # # ▁ buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Buffer::Iterator::WriteU8(uint8_t ▁ data, ▁ uint32_t ▁ len) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU8' , 'void' , [ param ( 'uint8_t' , 'data' ) , param ( 'uint32_t' , 'len' ) ] ) <newline> return <newline> <dedent> def register_Ns3ByteTagIterator_methods ( root_module , cls ) : <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::ByteTagIterator::ByteTagIterator(ns3::ByteTagIterator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::ByteTagIterator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ bool ▁ ns3::ByteTagIterator::HasNext() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasNext' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::ByteTagIterator::Item ▁ ns3::ByteTagIterator::Next() ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'ns3::ByteTagIterator::Item' , [ ] ) <newline> return <newline> <dedent> def register_Ns3ByteTagIteratorItem_methods ( root_module , cls ) : <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::ByteTagIterator::Item::Item(ns3::ByteTagIterator::Item ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::ByteTagIterator::Item ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::ByteTagIterator::Item::GetEnd() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetEnd' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::ByteTagIterator::Item::GetStart() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetStart' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::ByteTagIterator::Item::GetTag(ns3::Tag ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTag' , 'void' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::ByteTagIterator::Item::GetTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3ByteTagList_methods ( root_module , cls ) : <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::ByteTagList() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::ByteTagList(ns3::ByteTagList ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ByteTagList ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::TagBuffer ▁ ns3::ByteTagList::Add(ns3::TypeId ▁ tid, ▁ uint32_t ▁ bufferSize, ▁ int32_t ▁ start, ▁ int32_t ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'ns3::TagBuffer' , [ param ( 'ns3::TypeId' , 'tid' ) , param ( 'uint32_t' , 'bufferSize' ) , param ( 'int32_t' , 'start' ) , param ( 'int32_t' , 'end' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::ByteTagList::Add(ns3::ByteTagList ▁ const ▁ & ▁ o) ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'void' , [ param ( 'ns3::ByteTagList ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::ByteTagList::AddAtEnd(int32_t ▁ appendOffset) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtEnd' , 'void' , [ param ( 'int32_t' , 'appendOffset' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::ByteTagList::AddAtStart(int32_t ▁ prependOffset) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtStart' , 'void' , [ param ( 'int32_t' , 'prependOffset' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::ByteTagList::Adjust(int32_t ▁ adjustment) ▁ [member ▁ function] <encdom> cls . add_method ( 'Adjust' , 'void' , [ param ( 'int32_t' , 'adjustment' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator ▁ ns3::ByteTagList::Begin(int32_t ▁ offsetStart, ▁ int32_t ▁ offsetEnd) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Begin' , 'ns3::ByteTagList::Iterator' , [ param ( 'int32_t' , 'offsetStart' ) , param ( 'int32_t' , 'offsetEnd' ) ] , is_const = True ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::ByteTagList::RemoveAll() ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAll' , 'void' , [ ] ) <newline> return <newline> <dedent> def register_Ns3ByteTagListIterator_methods ( root_module , cls ) : <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Iterator(ns3::ByteTagList::Iterator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::ByteTagList::Iterator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::ByteTagList::Iterator::GetOffsetStart() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOffsetStart' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ bool ▁ ns3::ByteTagList::Iterator::HasNext() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasNext' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item ▁ ns3::ByteTagList::Iterator::Next() ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'ns3::ByteTagList::Iterator::Item' , [ ] ) <newline> return <newline> <dedent> def register_Ns3ByteTagListIteratorItem_methods ( root_module , cls ) : <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::Item(ns3::ByteTagList::Iterator::Item ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::ByteTagList::Iterator::Item ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::Item(ns3::TagBuffer ▁ buf) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TagBuffer' , 'buf' ) ] ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::buf ▁ [variable] <encdom> cls . add_instance_attribute ( 'buf' , 'ns3::TagBuffer' , is_const = False ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::end ▁ [variable] <encdom> cls . add_instance_attribute ( 'end' , 'int32_t' , is_const = False ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::size ▁ [variable] <encdom> cls . add_instance_attribute ( 'size' , 'uint32_t' , is_const = False ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::start ▁ [variable] <encdom> cls . add_instance_attribute ( 'start' , 'int32_t' , is_const = False ) <newline>  # # ▁ byte-tag-list.h ▁ (module ▁'network'): ▁ ns3::ByteTagList::Iterator::Item::tid ▁ [variable] <encdom> cls . add_instance_attribute ( 'tid' , 'ns3::TypeId' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3CallbackBase_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackBase::CallbackBase(ns3::CallbackBase ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::CallbackBase ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackBase::CallbackBase() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::CallbackImplBase> ▁ ns3::CallbackBase::GetImpl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetImpl' , 'ns3::Ptr< ▁ ns3::CallbackImplBase ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackBase::CallbackBase(ns3::Ptr<ns3::CallbackImplBase> ▁ impl) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ptr< ▁ ns3::CallbackImplBase ▁ >' , 'impl' ) ] , visibility = 'protected' ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3AttributeAccessor_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeAccessor>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeAccessor>::DefaultDeleter(ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::AttributeAccessor ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::AttributeAccessor>::Delete(ns3::AttributeAccessor ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::AttributeAccessor ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3AttributeChecker_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeChecker>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeChecker>::DefaultDeleter(ns3::DefaultDeleter<ns3::AttributeChecker> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::AttributeChecker ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::AttributeChecker>::Delete(ns3::AttributeChecker ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::AttributeChecker ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3AttributeValue_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeValue>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::AttributeValue>::DefaultDeleter(ns3::DefaultDeleter<ns3::AttributeValue> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::AttributeValue ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::AttributeValue>::Delete(ns3::AttributeValue ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::AttributeValue ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3CallbackImplBase_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::CallbackImplBase>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::CallbackImplBase>::DefaultDeleter(ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::CallbackImplBase ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::CallbackImplBase>::Delete(ns3::CallbackImplBase ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::CallbackImplBase ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3EventImpl_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::EventImpl>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::EventImpl>::DefaultDeleter(ns3::DefaultDeleter<ns3::EventImpl> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::EventImpl ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::EventImpl>::Delete(ns3::EventImpl ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::EventImpl ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3HashImplementation_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::Hash::Implementation>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::Hash::Implementation>::DefaultDeleter(ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::Hash::Implementation ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::Hash::Implementation>::Delete(ns3::Hash::Implementation ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::Hash::Implementation ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3NixVector_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::NixVector>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::NixVector>::DefaultDeleter(ns3::DefaultDeleter<ns3::NixVector> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::NixVector ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::NixVector>::Delete(ns3::NixVector ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::NixVector ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3Packet_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::Packet>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::Packet>::DefaultDeleter(ns3::DefaultDeleter<ns3::Packet> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::Packet ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::Packet>::Delete(ns3::Packet ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::Packet ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3DefaultDeleter__Ns3TraceSourceAccessor_methods ( root_module , cls ) : <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor>::DefaultDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor>::DefaultDeleter(ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::DefaultDeleter< ▁ ns3::TraceSourceAccessor ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ default-deleter.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor>::Delete(ns3::TraceSourceAccessor ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::TraceSourceAccessor ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3EventGarbageCollector_methods ( root_module , cls ) : <newline>  # # ▁ event-garbage-collector.h ▁ (module ▁'core'): ▁ ns3::EventGarbageCollector::EventGarbageCollector() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ event-garbage-collector.h ▁ (module ▁'core'): ▁ void ▁ ns3::EventGarbageCollector::Track(ns3::EventId ▁ event) ▁ [member ▁ function] <encdom> cls . add_method ( 'Track' , 'void' , [ param ( 'ns3::EventId' , 'event' ) ] ) <newline>  # # ▁ event-garbage-collector.h ▁ (module ▁'core'): ▁ ns3::EventGarbageCollector::EventGarbageCollector(ns3::EventGarbageCollector ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::EventGarbageCollector ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3EventId_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ ns3::EventId::EventId(ns3::EventId ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::EventId ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ ns3::EventId::EventId() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ ns3::EventId::EventId(ns3::Ptr<ns3::EventImpl> ▁ const ▁ & ▁ impl, ▁ uint64_t ▁ ts, ▁ uint32_t ▁ context, ▁ uint32_t ▁ uid) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ptr< ▁ ns3::EventImpl ▁ > ▁ const ▁ &' , 'impl' ) , param ( 'uint64_t' , 'ts' ) , param ( 'uint32_t' , 'context' ) , param ( 'uint32_t' , 'uid' ) ] ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ void ▁ ns3::EventId::Cancel() ▁ [member ▁ function] <encdom> cls . add_method ( 'Cancel' , 'void' , [ ] ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::EventId::GetContext() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetContext' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::EventId::GetTs() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTs' , 'uint64_t' , [ ] , is_const = True ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::EventId::GetUid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetUid' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EventId::IsExpired() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsExpired' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EventId::IsRunning() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsRunning' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ event-id.h ▁ (module ▁'core'): ▁ ns3::EventImpl ▁ * ▁ ns3::EventId::PeekEventImpl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekEventImpl' , 'ns3::EventImpl ▁ *' , [ ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3Hasher_methods ( root_module , cls ) : <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ ns3::Hasher::Hasher(ns3::Hasher ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Hasher ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ ns3::Hasher::Hasher() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> ▁ hp) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ptr< ▁ ns3::Hash::Implementation ▁ >' , 'hp' ) ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hasher::GetHash32(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hasher::GetHash32(std::string ▁ const ▁ s) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'std::string ▁ const' , 's' ) ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::Hasher::GetHash64(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash64' , 'uint64_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::Hasher::GetHash64(std::string ▁ const ▁ s) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash64' , 'uint64_t' , [ param ( 'std::string ▁ const' , 's' ) ] ) <newline>  # # ▁ hash.h ▁ (module ▁'core'): ▁ ns3::Hasher ▁ & ▁ ns3::Hasher::clear() ▁ [member ▁ function] <encdom> cls . add_method ( 'clear' , 'ns3::Hasher ▁ &' , [ ] ) <newline> return <newline> <dedent> def register_Ns3Inet6SocketAddress_methods ( root_module , cls ) : <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress::Inet6SocketAddress(ns3::Inet6SocketAddress ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Inet6SocketAddress ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress::Inet6SocketAddress(ns3::Ipv6Address ▁ ipv6, ▁ uint16_t ▁ port) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Address' , 'ipv6' ) , param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress::Inet6SocketAddress(ns3::Ipv6Address ▁ ipv6) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Address' , 'ipv6' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress::Inet6SocketAddress(uint16_t ▁ port) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress::Inet6SocketAddress(char ▁ const ▁ * ▁ ipv6, ▁ uint16_t ▁ port) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'ipv6' ) , param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Inet6SocketAddress::Inet6SocketAddress(char ▁ const ▁ * ▁ ipv6) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'ipv6' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Inet6SocketAddress ▁ ns3::Inet6SocketAddress::ConvertFrom(ns3::Address ▁ const ▁ & ▁ addr) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConvertFrom' , 'ns3::Inet6SocketAddress' , [ param ( 'ns3::Address ▁ const ▁ &' , 'addr' ) ] , is_static = True ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address ▁ ns3::Inet6SocketAddress::GetIpv6() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpv6' , 'ns3::Ipv6Address' , [ ] , is_const = True ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Inet6SocketAddress::GetPort() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPort' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::Inet6SocketAddress::IsMatchingType(ns3::Address ▁ const ▁ & ▁ addr) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'addr' ) ] , is_static = True ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Inet6SocketAddress::SetIpv6(ns3::Ipv6Address ▁ ipv6) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv6' , 'void' , [ param ( 'ns3::Ipv6Address' , 'ipv6' ) ] ) <newline>  # # ▁ inet6-socket-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Inet6SocketAddress::SetPort(uint16_t ▁ port) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPort' , 'void' , [ param ( 'uint16_t' , 'port' ) ] ) <newline> return <newline> <dedent> def register_Ns3InetSocketAddress_methods ( root_module , cls ) : <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress::InetSocketAddress(ns3::InetSocketAddress ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::InetSocketAddress ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress::InetSocketAddress(ns3::Ipv4Address ▁ ipv4, ▁ uint16_t ▁ port) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Address' , 'ipv4' ) , param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress::InetSocketAddress(ns3::Ipv4Address ▁ ipv4) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Address' , 'ipv4' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress::InetSocketAddress(uint16_t ▁ port) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress::InetSocketAddress(char ▁ const ▁ * ▁ ipv4, ▁ uint16_t ▁ port) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'ipv4' ) , param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::InetSocketAddress::InetSocketAddress(char ▁ const ▁ * ▁ ipv4) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'ipv4' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::InetSocketAddress ▁ ns3::InetSocketAddress::ConvertFrom(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConvertFrom' , 'ns3::InetSocketAddress' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ ns3::InetSocketAddress::GetIpv4() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpv4' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::InetSocketAddress::GetPort() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPort' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::InetSocketAddress::GetTos() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTos' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::InetSocketAddress::IsMatchingType(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::InetSocketAddress::SetIpv4(ns3::Ipv4Address ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv4' , 'void' , [ param ( 'ns3::Ipv4Address' , 'address' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::InetSocketAddress::SetPort(uint16_t ▁ port) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPort' , 'void' , [ param ( 'uint16_t' , 'port' ) ] ) <newline>  # # ▁ inet-socket-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::InetSocketAddress::SetTos(uint8_t ▁ tos) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTos' , 'void' , [ param ( 'uint8_t' , 'tos' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__0_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<0>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<0>::IntToType(ns3::IntToType<0> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 0 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__1_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<1>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<1>::IntToType(ns3::IntToType<1> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 1 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__2_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<2>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<2>::IntToType(ns3::IntToType<2> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 2 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__3_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<3>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<3>::IntToType(ns3::IntToType<3> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 3 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__4_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<4>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<4>::IntToType(ns3::IntToType<4> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 4 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__5_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<5>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<5>::IntToType(ns3::IntToType<5> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 5 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3IntToType__6_methods ( root_module , cls ) : <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<6>::IntToType() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ int-to-type.h ▁ (module ▁'core'): ▁ ns3::IntToType<6>::IntToType(ns3::IntToType<6> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::IntToType< ▁ 6 ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4Address_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address::Ipv4Address(ns3::Ipv4Address ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address::Ipv4Address() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address::Ipv4Address(uint32_t ▁ address) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint32_t' , 'address' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address::Ipv4Address(char ▁ const ▁ * ▁ address) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'address' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::CombineMask(ns3::Ipv4Mask ▁ const ▁ & ▁ mask) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CombineMask' , 'ns3::Ipv4Address' , [ param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'mask' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::ConvertFrom(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConvertFrom' , 'ns3::Ipv4Address' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::Deserialize(uint8_t ▁ const ▁ * ▁ buf) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'ns3::Ipv4Address' , [ param ( 'uint8_t ▁ const ▁ *' , 'buf' ) ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Ipv4Address::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::GetAny() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAny' , 'ns3::Ipv4Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::GetBroadcast() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBroadcast' , 'ns3::Ipv4Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::GetLoopback() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLoopback' , 'ns3::Ipv4Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::GetSubnetDirectedBroadcast(ns3::Ipv4Mask ▁ const ▁ & ▁ mask) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSubnetDirectedBroadcast' , 'ns3::Ipv4Address' , [ param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'mask' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Address ▁ ns3::Ipv4Address::GetZero() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetZero' , 'ns3::Ipv4Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsAny() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsAny' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsBroadcast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsBroadcast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsEqual(ns3::Ipv4Address ▁ const ▁ & ▁ other) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEqual' , 'bool' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'other' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsLocalMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLocalMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsLocalhost() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLocalhost' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::Ipv4Address::IsMatchingType(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Address::IsSubnetDirectedBroadcast(ns3::Ipv4Mask ▁ const ▁ & ▁ mask) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsSubnetDirectedBroadcast' , 'bool' , [ param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'mask' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4Address::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4Address::Serialize(uint8_t ▁ * ▁ buf) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'uint8_t ▁ *' , 'buf' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4Address::Set(uint32_t ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'uint32_t' , 'address' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4Address::Set(char ▁ const ▁ * ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'char ▁ const ▁ *' , 'address' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4InterfaceAddress_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress::Ipv4InterfaceAddress() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress::Ipv4InterfaceAddress(ns3::Ipv4Address ▁ local, ▁ ns3::Ipv4Mask ▁ mask) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Address' , 'local' ) , param ( 'ns3::Ipv4Mask' , 'mask' ) ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress::Ipv4InterfaceAddress(ns3::Ipv4InterfaceAddress ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4InterfaceAddress ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4InterfaceAddress::GetBroadcast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBroadcast' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4InterfaceAddress::GetLocal() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLocal' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Mask ▁ ns3::Ipv4InterfaceAddress::GetMask() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMask' , 'ns3::Ipv4Mask' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e ▁ ns3::Ipv4InterfaceAddress::GetScope() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetScope' , 'ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4InterfaceAddress::IsSecondary() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsSecondary' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4InterfaceAddress::SetBroadcast(ns3::Ipv4Address ▁ broadcast) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetBroadcast' , 'void' , [ param ( 'ns3::Ipv4Address' , 'broadcast' ) ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4InterfaceAddress::SetLocal(ns3::Ipv4Address ▁ local) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetLocal' , 'void' , [ param ( 'ns3::Ipv4Address' , 'local' ) ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4InterfaceAddress::SetMask(ns3::Ipv4Mask ▁ mask) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMask' , 'void' , [ param ( 'ns3::Ipv4Mask' , 'mask' ) ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4InterfaceAddress::SetPrimary() ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPrimary' , 'void' , [ ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4InterfaceAddress::SetScope(ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e ▁ scope) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetScope' , 'void' , [ param ( 'ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e' , 'scope' ) ] ) <newline>  # # ▁ ipv4-interface-address.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4InterfaceAddress::SetSecondary() ▁ [member ▁ function] <encdom> cls . add_method ( 'SetSecondary' , 'void' , [ ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4Mask_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Mask::Ipv4Mask(ns3::Ipv4Mask ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Mask::Ipv4Mask() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Mask::Ipv4Mask(uint32_t ▁ mask) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint32_t' , 'mask' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Mask::Ipv4Mask(char ▁ const ▁ * ▁ mask) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'mask' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Ipv4Mask::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Ipv4Mask::GetInverse() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInverse' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Mask ▁ ns3::Ipv4Mask::GetLoopback() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLoopback' , 'ns3::Ipv4Mask' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Mask ▁ ns3::Ipv4Mask::GetOnes() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOnes' , 'ns3::Ipv4Mask' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::Ipv4Mask::GetPrefixLength() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPrefixLength' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv4Mask ▁ ns3::Ipv4Mask::GetZero() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetZero' , 'ns3::Ipv4Mask' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Mask::IsEqual(ns3::Ipv4Mask ▁ other) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEqual' , 'bool' , [ param ( 'ns3::Ipv4Mask' , 'other' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4Mask::IsMatch(ns3::Ipv4Address ▁ a, ▁ ns3::Ipv4Address ▁ b) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatch' , 'bool' , [ param ( 'ns3::Ipv4Address' , 'a' ) , param ( 'ns3::Ipv4Address' , 'b' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4Mask::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4Mask::Set(uint32_t ▁ mask) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'uint32_t' , 'mask' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4RoutingHelper_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingHelper::Ipv4RoutingHelper() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingHelper::Ipv4RoutingHelper(ns3::Ipv4RoutingHelper ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4RoutingHelper ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingHelper ▁ * ▁ ns3::Ipv4RoutingHelper::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ipv4RoutingHelper ▁ *' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Ipv4RoutingProtocol> ▁ ns3::Ipv4RoutingHelper::Create(ns3::Ptr<ns3::Node> ▁ node) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'ns3::Ptr< ▁ ns3::Ipv4RoutingProtocol ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintNeighborCacheAllAt(ns3::Time ▁ printTime, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintNeighborCacheAllAt' , 'void' , [ param ( 'ns3::Time' , 'printTime' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintNeighborCacheAllEvery(ns3::Time ▁ printInterval, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintNeighborCacheAllEvery' , 'void' , [ param ( 'ns3::Time' , 'printInterval' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintNeighborCacheAt(ns3::Time ▁ printTime, ▁ ns3::Ptr<ns3::Node> ▁ node, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintNeighborCacheAt' , 'void' , [ param ( 'ns3::Time' , 'printTime' ) , param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintNeighborCacheEvery(ns3::Time ▁ printInterval, ▁ ns3::Ptr<ns3::Node> ▁ node, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintNeighborCacheEvery' , 'void' , [ param ( 'ns3::Time' , 'printInterval' ) , param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintRoutingTableAllAt(ns3::Time ▁ printTime, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTableAllAt' , 'void' , [ param ( 'ns3::Time' , 'printTime' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintRoutingTableAllEvery(ns3::Time ▁ printInterval, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTableAllEvery' , 'void' , [ param ( 'ns3::Time' , 'printInterval' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintRoutingTableAt(ns3::Time ▁ printTime, ▁ ns3::Ptr<ns3::Node> ▁ node, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTableAt' , 'void' , [ param ( 'ns3::Time' , 'printTime' ) , param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_static = True ) <newline>  # # ▁ ipv4-routing-helper.h ▁ (module ▁'internet'): ▁ static ▁ void ▁ ns3::Ipv4RoutingHelper::PrintRoutingTableEvery(ns3::Time ▁ printInterval, ▁ ns3::Ptr<ns3::Node> ▁ node, ▁ ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTableEvery' , 'void' , [ param ( 'ns3::Time' , 'printInterval' ) , param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) , param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3Ipv6Address_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address::Ipv6Address() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address::Ipv6Address(char ▁ const ▁ * ▁ address) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'address' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address::Ipv6Address(uint8_t ▁ * ▁ address) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t ▁ *' , 'address' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address::Ipv6Address(ns3::Ipv6Address ▁ const ▁ & ▁ addr) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Address ▁ const ▁ &' , 'addr' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address::Ipv6Address(ns3::Ipv6Address ▁ const ▁ * ▁ addr) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Address ▁ const ▁ *' , 'addr' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::CombinePrefix(ns3::Ipv6Prefix ▁ const ▁ & ▁ prefix) ▁ [member ▁ function] <encdom> cls . add_method ( 'CombinePrefix' , 'ns3::Ipv6Address' , [ param ( 'ns3::Ipv6Prefix ▁ const ▁ &' , 'prefix' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::ConvertFrom(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConvertFrom' , 'ns3::Ipv6Address' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::Deserialize(uint8_t ▁ const ▁ * ▁ buf) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'ns3::Ipv6Address' , [ param ( 'uint8_t ▁ const ▁ *' , 'buf' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetAllHostsMulticast() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAllHostsMulticast' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetAllNodesMulticast() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAllNodesMulticast' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetAllRoutersMulticast() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAllRoutersMulticast' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetAny() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAny' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Address::GetBytes(uint8_t ▁ * ▁ buf) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBytes' , 'void' , [ param ( 'uint8_t ▁ *' , 'buf' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ ns3::Ipv6Address::GetIpv4MappedAddress() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpv4MappedAddress' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetLoopback() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLoopback' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetOnes() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOnes' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::GetZero() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetZero' , 'ns3::Ipv6Address' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsAllHostsMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsAllHostsMulticast' , 'bool' , [ ] , deprecated = True , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsAllNodesMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsAllNodesMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsAllRoutersMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsAllRoutersMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsAny() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsAny' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsDocumentation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsDocumentation' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsEqual(ns3::Ipv6Address ▁ const ▁ & ▁ other) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEqual' , 'bool' , [ param ( 'ns3::Ipv6Address ▁ const ▁ &' , 'other' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsIpv4MappedAddress() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsIpv4MappedAddress' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsLinkLocal() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLinkLocal' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsLinkLocalMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLinkLocalMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsLocalhost() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLocalhost' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::Ipv6Address::IsMatchingType(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Address::IsSolicitedMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsSolicitedMulticast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac16Address ▁ addr, ▁ ns3::Ipv6Address ▁ prefix) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac16Address' , 'addr' ) , param ( 'ns3::Ipv6Address' , 'prefix' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac48Address ▁ addr, ▁ ns3::Ipv6Address ▁ prefix) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac48Address' , 'addr' ) , param ( 'ns3::Ipv6Address' , 'prefix' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac64Address ▁ addr, ▁ ns3::Ipv6Address ▁ prefix) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac64Address' , 'addr' ) , param ( 'ns3::Ipv6Address' , 'prefix' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac8Address ▁ addr, ▁ ns3::Ipv6Address ▁ prefix) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac8Address' , 'addr' ) , param ( 'ns3::Ipv6Address' , 'prefix' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac16Address ▁ mac) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredLinkLocalAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac16Address' , 'mac' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac48Address ▁ mac) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredLinkLocalAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac48Address' , 'mac' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac64Address ▁ mac) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredLinkLocalAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac64Address' , 'mac' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac8Address ▁ mac) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeAutoconfiguredLinkLocalAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Mac8Address' , 'mac' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeIpv4MappedAddress(ns3::Ipv4Address ▁ addr) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeIpv4MappedAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Ipv4Address' , 'addr' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Address ▁ ns3::Ipv6Address::MakeSolicitedAddress(ns3::Ipv6Address ▁ addr) ▁ [member ▁ function] <encdom> cls . add_method ( 'MakeSolicitedAddress' , 'ns3::Ipv6Address' , [ param ( 'ns3::Ipv6Address' , 'addr' ) ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Address::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Address::Serialize(uint8_t ▁ * ▁ buf) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'uint8_t ▁ *' , 'buf' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Address::Set(char ▁ const ▁ * ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'char ▁ const ▁ *' , 'address' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Address::Set(uint8_t ▁ * ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'uint8_t ▁ *' , 'address' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv6Prefix_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix::Ipv6Prefix() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix::Ipv6Prefix(uint8_t ▁ * ▁ prefix) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t ▁ *' , 'prefix' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix::Ipv6Prefix(char ▁ const ▁ * ▁ prefix) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'prefix' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix::Ipv6Prefix(uint8_t ▁ prefix) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t' , 'prefix' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix::Ipv6Prefix(ns3::Ipv6Prefix ▁ const ▁ & ▁ prefix) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Prefix ▁ const ▁ &' , 'prefix' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix::Ipv6Prefix(ns3::Ipv6Prefix ▁ const ▁ * ▁ prefix) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Prefix ▁ const ▁ *' , 'prefix' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Prefix::GetBytes(uint8_t ▁ * ▁ buf) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBytes' , 'void' , [ param ( 'uint8_t ▁ *' , 'buf' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Prefix ▁ ns3::Ipv6Prefix::GetLoopback() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLoopback' , 'ns3::Ipv6Prefix' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Prefix ▁ ns3::Ipv6Prefix::GetOnes() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOnes' , 'ns3::Ipv6Prefix' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Ipv6Prefix::GetPrefixLength() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPrefixLength' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ipv6Prefix ▁ ns3::Ipv6Prefix::GetZero() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetZero' , 'ns3::Ipv6Prefix' , [ ] , is_static = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Prefix::IsEqual(ns3::Ipv6Prefix ▁ const ▁ & ▁ other) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEqual' , 'bool' , [ param ( 'ns3::Ipv6Prefix ▁ const ▁ &' , 'other' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6Prefix::IsMatch(ns3::Ipv6Address ▁ a, ▁ ns3::Ipv6Address ▁ b) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatch' , 'bool' , [ param ( 'ns3::Ipv6Address' , 'a' ) , param ( 'ns3::Ipv6Address' , 'b' ) ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6Prefix::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3Mac48Address_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48Address::Mac48Address(ns3::Mac48Address ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Mac48Address ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48Address::Mac48Address() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48Address::Mac48Address(char ▁ const ▁ * ▁ str) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'str' ) ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::Allocate() ▁ [member ▁ function] <encdom> cls . add_method ( 'Allocate' , 'ns3::Mac48Address' , [ ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::ConvertFrom(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConvertFrom' , 'ns3::Mac48Address' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Mac48Address::CopyFrom(uint8_t ▁ const ▁ * ▁ buffer) ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyFrom' , 'void' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Mac48Address::CopyTo(uint8_t ▁ * ▁ buffer) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyTo' , 'void' , [ param ( 'uint8_t ▁ *' , 'buffer' ) ] , is_const = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::GetBroadcast() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBroadcast' , 'ns3::Mac48Address' , [ ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::GetMulticast(ns3::Ipv4Address ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticast' , 'ns3::Mac48Address' , [ param ( 'ns3::Ipv4Address' , 'address' ) ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::GetMulticast(ns3::Ipv6Address ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticast' , 'ns3::Mac48Address' , [ param ( 'ns3::Ipv6Address' , 'address' ) ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::GetMulticast6Prefix() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticast6Prefix' , 'ns3::Mac48Address' , [ ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac48Address ▁ ns3::Mac48Address::GetMulticastPrefix() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticastPrefix' , 'ns3::Mac48Address' , [ ] , is_static = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Mac48Address::IsBroadcast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsBroadcast' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Mac48Address::IsGroup() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsGroup' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::Mac48Address::IsMatchingType(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3Mac8Address_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '<' ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ ns3::Mac8Address::Mac8Address(ns3::Mac8Address ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Mac8Address ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ ns3::Mac8Address::Mac8Address() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ ns3::Mac8Address::Mac8Address(uint8_t ▁ addr) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t' , 'addr' ) ] ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac8Address ▁ ns3::Mac8Address::Allocate() ▁ [member ▁ function] <encdom> cls . add_method ( 'Allocate' , 'ns3::Mac8Address' , [ ] , is_static = True ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac8Address ▁ ns3::Mac8Address::ConvertFrom(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConvertFrom' , 'ns3::Mac8Address' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Mac8Address::CopyFrom(uint8_t ▁ const ▁ * ▁ pBuffer) ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyFrom' , 'void' , [ param ( 'uint8_t ▁ const ▁ *' , 'pBuffer' ) ] ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Mac8Address::CopyTo(uint8_t ▁ * ▁ pBuffer) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyTo' , 'void' , [ param ( 'uint8_t ▁ *' , 'pBuffer' ) ] , is_const = True ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ static ▁ ns3::Mac8Address ▁ ns3::Mac8Address::GetBroadcast() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBroadcast' , 'ns3::Mac8Address' , [ ] , is_static = True ) <newline>  # # ▁ mac8-address.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::Mac8Address::IsMatchingType(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMatchingType' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3NodeContainer_methods ( root_module , cls ) : <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(ns3::NodeContainer ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::NodeContainer ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(ns3::Ptr<ns3::Node> ▁ node) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(std::string ▁ nodeName) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'std::string' , 'nodeName' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(ns3::NodeContainer ▁ const ▁ & ▁ a, ▁ ns3::NodeContainer ▁ const ▁ & ▁ b) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::NodeContainer ▁ const ▁ &' , 'a' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'b' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(ns3::NodeContainer ▁ const ▁ & ▁ a, ▁ ns3::NodeContainer ▁ const ▁ & ▁ b, ▁ ns3::NodeContainer ▁ const ▁ & ▁ c) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::NodeContainer ▁ const ▁ &' , 'a' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'b' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'c' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(ns3::NodeContainer ▁ const ▁ & ▁ a, ▁ ns3::NodeContainer ▁ const ▁ & ▁ b, ▁ ns3::NodeContainer ▁ const ▁ & ▁ c, ▁ ns3::NodeContainer ▁ const ▁ & ▁ d) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::NodeContainer ▁ const ▁ &' , 'a' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'b' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'c' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'd' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::NodeContainer(ns3::NodeContainer ▁ const ▁ & ▁ a, ▁ ns3::NodeContainer ▁ const ▁ & ▁ b, ▁ ns3::NodeContainer ▁ const ▁ & ▁ c, ▁ ns3::NodeContainer ▁ const ▁ & ▁ d, ▁ ns3::NodeContainer ▁ const ▁ & ▁ e) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::NodeContainer ▁ const ▁ &' , 'a' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'b' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'c' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'd' ) , param ( 'ns3::NodeContainer ▁ const ▁ &' , 'e' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ void ▁ ns3::NodeContainer::Add(ns3::NodeContainer ▁ other) ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'void' , [ param ( 'ns3::NodeContainer' , 'other' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ void ▁ ns3::NodeContainer::Add(ns3::Ptr<ns3::Node> ▁ node) ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ void ▁ ns3::NodeContainer::Add(std::string ▁ nodeName) ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'void' , [ param ( 'std::string' , 'nodeName' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::Iterator ▁ ns3::NodeContainer::Begin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Begin' , 'ns3::NodeContainer::Iterator' , [ ] , is_const = True ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NodeContainer::Contains(uint32_t ▁ id) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Contains' , 'bool' , [ param ( 'uint32_t' , 'id' ) ] , is_const = True ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ void ▁ ns3::NodeContainer::Create(uint32_t ▁ n) ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'void' , [ param ( 'uint32_t' , 'n' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ void ▁ ns3::NodeContainer::Create(uint32_t ▁ n, ▁ uint32_t ▁ systemId) ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'void' , [ param ( 'uint32_t' , 'n' ) , param ( 'uint32_t' , 'systemId' ) ] ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::NodeContainer::Iterator ▁ ns3::NodeContainer::End() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'End' , 'ns3::NodeContainer::Iterator' , [ ] , is_const = True ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Node> ▁ ns3::NodeContainer::Get(uint32_t ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Ptr< ▁ ns3::Node ▁ >' , [ param ( 'uint32_t' , 'i' ) ] , is_const = True ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ static ▁ ns3::NodeContainer ▁ ns3::NodeContainer::GetGlobal() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetGlobal' , 'ns3::NodeContainer' , [ ] , is_static = True ) <newline>  # # ▁ node-container.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NodeContainer::GetN() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetN' , 'uint32_t' , [ ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3NonCopyable_methods ( root_module , cls ) : <newline>  # # ▁ non-copyable.h ▁ (module ▁'core'): ▁ ns3::NonCopyable::NonCopyable() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] , visibility = 'protected' ) <newline> return <newline> <dedent> def register_Ns3ObjectBase_methods ( root_module , cls ) : <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ ns3::ObjectBase::ObjectBase() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ ns3::ObjectBase::ObjectBase(ns3::ObjectBase ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ObjectBase ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectBase::GetAttribute(std::string ▁ name, ▁ ns3::AttributeValue ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAttribute' , 'void' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::AttributeValue ▁ &' , 'value' ) ] , is_const = True ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectBase::GetAttributeFailSafe(std::string ▁ name, ▁ ns3::AttributeValue ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAttributeFailSafe' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::AttributeValue ▁ &' , 'value' ) ] , is_const = True ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::ObjectBase::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ObjectBase::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectBase::SetAttribute(std::string ▁ name, ▁ ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAttribute' , 'void' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectBase::SetAttributeFailSafe(std::string ▁ name, ▁ ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAttributeFailSafe' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectBase::TraceConnect(std::string ▁ name, ▁ std::string ▁ context, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ [member ▁ function] <encdom> cls . add_method ( 'TraceConnect' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'std::string' , 'context' ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectBase::TraceConnectWithoutContext(std::string ▁ name, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ [member ▁ function] <encdom> cls . add_method ( 'TraceConnectWithoutContext' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectBase::TraceDisconnect(std::string ▁ name, ▁ std::string ▁ context, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ [member ▁ function] <encdom> cls . add_method ( 'TraceDisconnect' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'std::string' , 'context' ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectBase::TraceDisconnectWithoutContext(std::string ▁ name, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ [member ▁ function] <encdom> cls . add_method ( 'TraceDisconnectWithoutContext' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectBase::ConstructSelf(ns3::AttributeConstructionList ▁ const ▁ & ▁ attributes) ▁ [member ▁ function] <encdom> cls . add_method ( 'ConstructSelf' , 'void' , [ param ( 'ns3::AttributeConstructionList ▁ const ▁ &' , 'attributes' ) ] , visibility = 'protected' ) <newline>  # # ▁ object-base.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectBase::NotifyConstructionCompleted() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyConstructionCompleted' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ObjectDeleter_methods ( root_module , cls ) : <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::ObjectDeleter::ObjectDeleter() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::ObjectDeleter::ObjectDeleter(ns3::ObjectDeleter ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ObjectDeleter ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::ObjectDeleter::Delete(ns3::Object ▁ * ▁ object) ▁ [member ▁ function] <encdom> cls . add_method ( 'Delete' , 'void' , [ param ( 'ns3::Object ▁ *' , 'object' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3ObjectFactory_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactory::ObjectFactory(ns3::ObjectFactory ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ObjectFactory ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactory::ObjectFactory() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactory::ObjectFactory(std::string ▁ typeId) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'std::string' , 'typeId' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::Object> ▁ ns3::ObjectFactory::Create() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'ns3::Ptr< ▁ ns3::Object ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::ObjectFactory::GetTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_const = True ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectFactory::Set(std::string ▁ name, ▁ ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectFactory::SetTypeId(ns3::TypeId ▁ tid) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTypeId' , 'void' , [ param ( 'ns3::TypeId' , 'tid' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectFactory::SetTypeId(char ▁ const ▁ * ▁ tid) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTypeId' , 'void' , [ param ( 'char ▁ const ▁ *' , 'tid' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectFactory::SetTypeId(std::string ▁ tid) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTypeId' , 'void' , [ param ( 'std::string' , 'tid' ) ] ) <newline> return <newline> <dedent> def register_Ns3OlsrHelper_methods ( root_module , cls ) : <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ ns3::OlsrHelper::OlsrHelper() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ ns3::OlsrHelper::OlsrHelper(ns3::OlsrHelper ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::OlsrHelper ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ ns3::OlsrHelper ▁ * ▁ ns3::OlsrHelper::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::OlsrHelper ▁ *' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::OlsrHelper::ExcludeInterface(ns3::Ptr<ns3::Node> ▁ node, ▁ uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'ExcludeInterface' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) , param ( 'uint32_t' , 'interface' ) ] ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ ns3::Ptr<ns3::Ipv4RoutingProtocol> ▁ ns3::OlsrHelper::Create(ns3::Ptr<ns3::Node> ▁ node) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'ns3::Ptr< ▁ ns3::Ipv4RoutingProtocol ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::OlsrHelper::Set(std::string ▁ name, ▁ ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ olsr-helper.h ▁ (module ▁'olsr'): ▁ int64_t ▁ ns3::OlsrHelper::AssignStreams(ns3::NodeContainer ▁ c, ▁ int64_t ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'AssignStreams' , 'int64_t' , [ param ( 'ns3::NodeContainer' , 'c' ) , param ( 'int64_t' , 'stream' ) ] ) <newline> return <newline> <dedent> def register_Ns3PacketMetadata_methods ( root_module , cls ) : <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::PacketMetadata(uint64_t ▁ uid, ▁ uint32_t ▁ size) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'uint64_t' , 'uid' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::PacketMetadata(ns3::PacketMetadata ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::PacketMetadata ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::AddAtEnd(ns3::PacketMetadata ▁ const ▁ & ▁ o) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtEnd' , 'void' , [ param ( 'ns3::PacketMetadata ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::AddHeader(ns3::Header ▁ const ▁ & ▁ header, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddHeader' , 'void' , [ param ( 'ns3::Header ▁ const ▁ &' , 'header' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::AddPaddingAtEnd(uint32_t ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddPaddingAtEnd' , 'void' , [ param ( 'uint32_t' , 'end' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::AddTrailer(ns3::Trailer ▁ const ▁ & ▁ trailer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddTrailer' , 'void' , [ param ( 'ns3::Trailer ▁ const ▁ &' , 'trailer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::ItemIterator ▁ ns3::PacketMetadata::BeginItem(ns3::Buffer ▁ buffer) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'BeginItem' , 'ns3::PacketMetadata::ItemIterator' , [ param ( 'ns3::Buffer' , 'buffer' ) ] , is_const = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata ▁ ns3::PacketMetadata::CreateFragment(uint32_t ▁ start, ▁ uint32_t ▁ end) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CreateFragment' , 'ns3::PacketMetadata' , [ param ( 'uint32_t' , 'start' ) , param ( 'uint32_t' , 'end' ) ] , is_const = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::PacketMetadata::Deserialize(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ static ▁ void ▁ ns3::PacketMetadata::Enable() ▁ [member ▁ function] <encdom> cls . add_method ( 'Enable' , 'void' , [ ] , is_static = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ static ▁ void ▁ ns3::PacketMetadata::EnableChecking() ▁ [member ▁ function] <encdom> cls . add_method ( 'EnableChecking' , 'void' , [ ] , is_static = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::PacketMetadata::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ uint64_t ▁ ns3::PacketMetadata::GetUid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetUid' , 'uint64_t' , [ ] , is_const = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::RemoveAtEnd(uint32_t ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAtEnd' , 'void' , [ param ( 'uint32_t' , 'end' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::RemoveAtStart(uint32_t ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAtStart' , 'void' , [ param ( 'uint32_t' , 'start' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::RemoveHeader(ns3::Header ▁ const ▁ & ▁ header, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveHeader' , 'void' , [ param ( 'ns3::Header ▁ const ▁ &' , 'header' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketMetadata::RemoveTrailer(ns3::Trailer ▁ const ▁ & ▁ trailer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveTrailer' , 'void' , [ param ( 'ns3::Trailer ▁ const ▁ &' , 'trailer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::PacketMetadata::Serialize(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ maxSize) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'maxSize' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3PacketMetadataItem_methods ( root_module , cls ) : <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::Item() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::Item(ns3::PacketMetadata::Item ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::PacketMetadata::Item ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::current ▁ [variable] <encdom> cls . add_instance_attribute ( 'current' , 'ns3::Buffer::Iterator' , is_const = False ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::currentSize ▁ [variable] <encdom> cls . add_instance_attribute ( 'currentSize' , 'uint32_t' , is_const = False ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::currentTrimedFromEnd ▁ [variable] <encdom> cls . add_instance_attribute ( 'currentTrimedFromEnd' , 'uint32_t' , is_const = False ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::currentTrimedFromStart ▁ [variable] <encdom> cls . add_instance_attribute ( 'currentTrimedFromStart' , 'uint32_t' , is_const = False ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::isFragment ▁ [variable] <encdom> cls . add_instance_attribute ( 'isFragment' , 'bool' , is_const = False ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::tid ▁ [variable] <encdom> cls . add_instance_attribute ( 'tid' , 'ns3::TypeId' , is_const = False ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item::type ▁ [variable] <encdom> cls . add_instance_attribute ( 'type' , 'ns3::PacketMetadata::Item::ItemType' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3PacketMetadataItemIterator_methods ( root_module , cls ) : <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::ItemIterator::ItemIterator(ns3::PacketMetadata::ItemIterator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::PacketMetadata::ItemIterator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::ItemIterator::ItemIterator(ns3::PacketMetadata ▁ const ▁ * ▁ metadata, ▁ ns3::Buffer ▁ buffer) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::PacketMetadata ▁ const ▁ *' , 'metadata' ) , param ( 'ns3::Buffer' , 'buffer' ) ] ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ bool ▁ ns3::PacketMetadata::ItemIterator::HasNext() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasNext' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ packet-metadata.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::Item ▁ ns3::PacketMetadata::ItemIterator::Next() ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'ns3::PacketMetadata::Item' , [ ] ) <newline> return <newline> <dedent> def register_Ns3PacketTagIterator_methods ( root_module , cls ) : <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketTagIterator::PacketTagIterator(ns3::PacketTagIterator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::PacketTagIterator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ bool ▁ ns3::PacketTagIterator::HasNext() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasNext' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketTagIterator::Item ▁ ns3::PacketTagIterator::Next() ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'ns3::PacketTagIterator::Item' , [ ] ) <newline> return <newline> <dedent> def register_Ns3PacketTagIteratorItem_methods ( root_module , cls ) : <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketTagIterator::Item::Item(ns3::PacketTagIterator::Item ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::PacketTagIterator::Item ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketTagIterator::Item::GetTag(ns3::Tag ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTag' , 'void' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::PacketTagIterator::Item::GetTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3PacketTagList_methods ( root_module , cls ) : <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::PacketTagList() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::PacketTagList(ns3::PacketTagList ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::PacketTagList ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketTagList::Add(ns3::Tag ▁ const ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Add' , 'void' , [ param ( 'ns3::Tag ▁ const ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData ▁ const ▁ * ▁ ns3::PacketTagList::Head() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Head' , 'ns3::PacketTagList::TagData ▁ const ▁ *' , [ ] , is_const = True ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ bool ▁ ns3::PacketTagList::Peek(ns3::Tag ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Peek' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ bool ▁ ns3::PacketTagList::Remove(ns3::Tag ▁ & ▁ tag) ▁ [member ▁ function] <encdom> cls . add_method ( 'Remove' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ void ▁ ns3::PacketTagList::RemoveAll() ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAll' , 'void' , [ ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ bool ▁ ns3::PacketTagList::Replace(ns3::Tag ▁ & ▁ tag) ▁ [member ▁ function] <encdom> cls . add_method ( 'Replace' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] ) <newline> return <newline> <dedent> def register_Ns3PacketTagListTagData_methods ( root_module , cls ) : <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::TagData() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::TagData(ns3::PacketTagList::TagData ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::PacketTagList::TagData ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::count ▁ [variable] <encdom> cls . add_instance_attribute ( 'count' , 'uint32_t' , is_const = False ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::data ▁ [variable] <encdom> cls . add_instance_attribute ( 'data' , 'uint8_t ▁ [ ▁ 1 ▁ ]' , is_const = False ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::next ▁ [variable] <encdom> cls . add_instance_attribute ( 'next' , 'ns3::PacketTagList::TagData ▁ *' , is_const = False ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::size ▁ [variable] <encdom> cls . add_instance_attribute ( 'size' , 'uint32_t' , is_const = False ) <newline>  # # ▁ packet-tag-list.h ▁ (module ▁'network'): ▁ ns3::PacketTagList::TagData::tid ▁ [variable] <encdom> cls . add_instance_attribute ( 'tid' , 'ns3::TypeId' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter>::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter>::SimpleRefCount(ns3::SimpleRefCount<ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter> ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::Object, ▁ ns3::ObjectBase, ▁ ns3::ObjectDeleter ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3Simulator_methods ( root_module , cls ) : <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ ns3::Simulator::Simulator(ns3::Simulator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Simulator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::Cancel(ns3::EventId ▁ const ▁ & ▁ id) ▁ [member ▁ function] <encdom> cls . add_method ( 'Cancel' , 'void' , [ param ( 'ns3::EventId ▁ const ▁ &' , 'id' ) ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::Destroy() ▁ [member ▁ function] <encdom> cls . add_method ( 'Destroy' , 'void' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ uint32_t ▁ ns3::Simulator::GetContext() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetContext' , 'uint32_t' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Simulator::GetDelayLeft(ns3::EventId ▁ const ▁ & ▁ id) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDelayLeft' , 'ns3::Time' , [ param ( 'ns3::EventId ▁ const ▁ &' , 'id' ) ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ ns3::Ptr<ns3::SimulatorImpl> ▁ ns3::Simulator::GetImplementation() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetImplementation' , 'ns3::Ptr< ▁ ns3::SimulatorImpl ▁ >' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Simulator::GetMaximumSimulationTime() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMaximumSimulationTime' , 'ns3::Time' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ uint32_t ▁ ns3::Simulator::GetSystemId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSystemId' , 'uint32_t' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ bool ▁ ns3::Simulator::IsExpired(ns3::EventId ▁ const ▁ & ▁ id) ▁ [member ▁ function] <encdom> cls . add_method ( 'IsExpired' , 'bool' , [ param ( 'ns3::EventId ▁ const ▁ &' , 'id' ) ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ bool ▁ ns3::Simulator::IsFinished() ▁ [member ▁ function] <encdom> cls . add_method ( 'IsFinished' , 'bool' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Simulator::Now() ▁ [member ▁ function] <encdom> cls . add_method ( 'Now' , 'ns3::Time' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::Remove(ns3::EventId ▁ const ▁ & ▁ id) ▁ [member ▁ function] <encdom> cls . add_method ( 'Remove' , 'void' , [ param ( 'ns3::EventId ▁ const ▁ &' , 'id' ) ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::SetImplementation(ns3::Ptr<ns3::SimulatorImpl> ▁ impl) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetImplementation' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::SimulatorImpl ▁ >' , 'impl' ) ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::SetScheduler(ns3::ObjectFactory ▁ schedulerFactory) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetScheduler' , 'void' , [ param ( 'ns3::ObjectFactory' , 'schedulerFactory' ) ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::Stop() ▁ [member ▁ function] <encdom> cls . add_method ( 'Stop' , 'void' , [ ] , is_static = True ) <newline>  # # ▁ simulator.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Simulator::Stop(ns3::Time ▁ const ▁ & ▁ delay) ▁ [member ▁ function] <encdom> cls . add_method ( 'Stop' , 'void' , [ param ( 'ns3::Time ▁ const ▁ &' , 'delay' ) ] , is_static = True ) <newline> return <newline> <dedent> def register_Ns3SystemWallClockMs_methods ( root_module , cls ) : <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ ns3::SystemWallClockMs::SystemWallClockMs(ns3::SystemWallClockMs ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SystemWallClockMs ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ ns3::SystemWallClockMs::SystemWallClockMs() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::SystemWallClockMs::End() ▁ [member ▁ function] <encdom> cls . add_method ( 'End' , 'int64_t' , [ ] ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::SystemWallClockMs::GetElapsedReal() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetElapsedReal' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::SystemWallClockMs::GetElapsedSystem() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetElapsedSystem' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::SystemWallClockMs::GetElapsedUser() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetElapsedUser' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ system-wall-clock-ms.h ▁ (module ▁'core'): ▁ void ▁ ns3::SystemWallClockMs::Start() ▁ [member ▁ function] <encdom> cls . add_method ( 'Start' , 'void' , [ ] ) <newline> return <newline> <dedent> def register_Ns3Tag_methods ( root_module , cls ) : <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ ns3::Tag::Tag() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ ns3::Tag::Tag(ns3::Tag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Tag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ void ▁ ns3::Tag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Tag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::Tag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ void ▁ ns3::Tag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ tag.h ▁ (module ▁'network'): ▁ void ▁ ns3::Tag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3TagBuffer_methods ( root_module , cls ) : <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ ns3::TagBuffer::TagBuffer(ns3::TagBuffer ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::TagBuffer ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ ns3::TagBuffer::TagBuffer(uint8_t ▁ * ▁ start, ▁ uint8_t ▁ * ▁ end) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t ▁ *' , 'start' ) , param ( 'uint8_t ▁ *' , 'end' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::CopyFrom(ns3::TagBuffer ▁ o) ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyFrom' , 'void' , [ param ( 'ns3::TagBuffer' , 'o' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::Read(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Read' , 'void' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ double ▁ ns3::TagBuffer::ReadDouble() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadDouble' , 'double' , [ ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::TagBuffer::ReadU16() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU16' , 'uint16_t' , [ ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::TagBuffer::ReadU32() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU32' , 'uint32_t' , [ ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ uint64_t ▁ ns3::TagBuffer::ReadU64() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU64' , 'uint64_t' , [ ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::TagBuffer::ReadU8() ▁ [member ▁ function] <encdom> cls . add_method ( 'ReadU8' , 'uint8_t' , [ ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::TrimAtEnd(uint32_t ▁ trim) ▁ [member ▁ function] <encdom> cls . add_method ( 'TrimAtEnd' , 'void' , [ param ( 'uint32_t' , 'trim' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::Write(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Write' , 'void' , [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::WriteDouble(double ▁ v) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteDouble' , 'void' , [ param ( 'double' , 'v' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::WriteU16(uint16_t ▁ v) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU16' , 'void' , [ param ( 'uint16_t' , 'v' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::WriteU32(uint32_t ▁ v) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU32' , 'void' , [ param ( 'uint32_t' , 'v' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::WriteU64(uint64_t ▁ v) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU64' , 'void' , [ param ( 'uint64_t' , 'v' ) ] ) <newline>  # # ▁ tag-buffer.h ▁ (module ▁'network'): ▁ void ▁ ns3::TagBuffer::WriteU8(uint8_t ▁ v) ▁ [member ▁ function] <encdom> cls . add_method ( 'WriteU8' , 'void' , [ param ( 'uint8_t' , 'v' ) ] ) <newline> return <newline> <dedent> def register_Ns3TimeWithUnit_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeWithUnit::TimeWithUnit(ns3::TimeWithUnit ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TimeWithUnit ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeWithUnit::TimeWithUnit(ns3::Time ▁ const ▁ time, ▁ ns3::Time::Unit ▁ const ▁ unit) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Time ▁ const' , 'time' ) , param ( 'ns3::Time::Unit ▁ const' , 'unit' ) ] ) <newline> return <newline> <dedent> def register_Ns3Timer_methods ( root_module , cls ) : <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer::Timer(ns3::Timer ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Timer ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer::Timer() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer::Timer(ns3::Timer::DestroyPolicy ▁ destroyPolicy) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Timer::DestroyPolicy' , 'destroyPolicy' ) ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::Cancel() ▁ [member ▁ function] <encdom> cls . add_method ( 'Cancel' , 'void' , [ ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Time ▁ ns3::Timer::GetDelay() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDelay' , 'ns3::Time' , [ ] , is_const = True ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Time ▁ ns3::Timer::GetDelayLeft() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDelayLeft' , 'ns3::Time' , [ ] , is_const = True ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ ns3::Timer::State ▁ ns3::Timer::GetState() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetState' , 'ns3::Timer::State' , [ ] , is_const = True ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Timer::IsExpired() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsExpired' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Timer::IsRunning() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsRunning' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Timer::IsSuspended() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsSuspended' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::Remove() ▁ [member ▁ function] <encdom> cls . add_method ( 'Remove' , 'void' , [ ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::Resume() ▁ [member ▁ function] <encdom> cls . add_method ( 'Resume' , 'void' , [ ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::Schedule() ▁ [member ▁ function] <encdom> cls . add_method ( 'Schedule' , 'void' , [ ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::Schedule(ns3::Time ▁ delay) ▁ [member ▁ function] <encdom> cls . add_method ( 'Schedule' , 'void' , [ param ( 'ns3::Time' , 'delay' ) ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::SetDelay(ns3::Time ▁ const ▁ & ▁ delay) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDelay' , 'void' , [ param ( 'ns3::Time ▁ const ▁ &' , 'delay' ) ] ) <newline>  # # ▁ timer.h ▁ (module ▁'core'): ▁ void ▁ ns3::Timer::Suspend() ▁ [member ▁ function] <encdom> cls . add_method ( 'Suspend' , 'void' , [ ] ) <newline> return <newline> <dedent> def register_Ns3TimerImpl_methods ( root_module , cls ) : <newline>  # # ▁ timer-impl.h ▁ (module ▁'core'): ▁ ns3::TimerImpl::TimerImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ timer-impl.h ▁ (module ▁'core'): ▁ ns3::TimerImpl::TimerImpl(ns3::TimerImpl ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TimerImpl ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ timer-impl.h ▁ (module ▁'core'): ▁ void ▁ ns3::TimerImpl::Invoke() ▁ [member ▁ function] <encdom> cls . add_method ( 'Invoke' , 'void' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ timer-impl.h ▁ (module ▁'core'): ▁ ns3::EventId ▁ ns3::TimerImpl::Schedule(ns3::Time ▁ const ▁ & ▁ delay) ▁ [member ▁ function] <encdom> cls . add_method ( 'Schedule' , 'ns3::EventId' , [ param ( 'ns3::Time ▁ const ▁ &' , 'delay' ) ] , is_pure_virtual = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3TypeId_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TypeId(char ▁ const ▁ * ▁ name) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'char ▁ const ▁ *' , 'name' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TypeId() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TypeId(ns3::TypeId ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TypeId ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::AddAttribute(std::string ▁ name, ▁ std::string ▁ help, ▁ ns3::AttributeValue ▁ const ▁ & ▁ initialValue, ▁ ns3::Ptr<const ▁ ns3::AttributeAccessor> ▁ accessor, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker, ▁ ns3::TypeId::SupportLevel ▁ supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, ▁ std::string ▁ const ▁ & ▁ supportMsg="") ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAttribute' , 'ns3::TypeId' , [ param ( 'std::string' , 'name' ) , param ( 'std::string' , 'help' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'initialValue' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeAccessor ▁ const ▁ >' , 'accessor' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) , param ( 'ns3::TypeId::SupportLevel' , 'supportLevel' , default_value = '::ns3::TypeId::SupportLevel::SUPPORTED' ) , param ( 'std::string ▁ const ▁ &' , 'supportMsg' , default_value = '""' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::AddAttribute(std::string ▁ name, ▁ std::string ▁ help, ▁ uint32_t ▁ flags, ▁ ns3::AttributeValue ▁ const ▁ & ▁ initialValue, ▁ ns3::Ptr<const ▁ ns3::AttributeAccessor> ▁ accessor, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker, ▁ ns3::TypeId::SupportLevel ▁ supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, ▁ std::string ▁ const ▁ & ▁ supportMsg="") ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAttribute' , 'ns3::TypeId' , [ param ( 'std::string' , 'name' ) , param ( 'std::string' , 'help' ) , param ( 'uint32_t' , 'flags' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'initialValue' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeAccessor ▁ const ▁ >' , 'accessor' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) , param ( 'ns3::TypeId::SupportLevel' , 'supportLevel' , default_value = '::ns3::TypeId::SupportLevel::SUPPORTED' ) , param ( 'std::string ▁ const ▁ &' , 'supportMsg' , default_value = '""' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::AddTraceSource(std::string ▁ name, ▁ std::string ▁ help, ▁ ns3::Ptr<const ▁ ns3::TraceSourceAccessor> ▁ accessor) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddTraceSource' , 'ns3::TypeId' , [ param ( 'std::string' , 'name' ) , param ( 'std::string' , 'help' ) , param ( 'ns3::Ptr< ▁ ns3::TraceSourceAccessor ▁ const ▁ >' , 'accessor' ) ] , deprecated = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::AddTraceSource(std::string ▁ name, ▁ std::string ▁ help, ▁ ns3::Ptr<const ▁ ns3::TraceSourceAccessor> ▁ accessor, ▁ std::string ▁ callback, ▁ ns3::TypeId::SupportLevel ▁ supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, ▁ std::string ▁ const ▁ & ▁ supportMsg="") ▁ [member ▁ function] <encdom> cls . add_method ( 'AddTraceSource' , 'ns3::TypeId' , [ param ( 'std::string' , 'name' ) , param ( 'std::string' , 'help' ) , param ( 'ns3::Ptr< ▁ ns3::TraceSourceAccessor ▁ const ▁ >' , 'accessor' ) , param ( 'std::string' , 'callback' ) , param ( 'ns3::TypeId::SupportLevel' , 'supportLevel' , default_value = '::ns3::TypeId::SupportLevel::SUPPORTED' ) , param ( 'std::string ▁ const ▁ &' , 'supportMsg' , default_value = '""' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation ▁ ns3::TypeId::GetAttribute(std::size_t ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAttribute' , 'ns3::TypeId::AttributeInformation' , [ param ( 'std::size_t' , 'i' ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::TypeId::GetAttributeFullName(std::size_t ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAttributeFullName' , 'std::string' , [ param ( 'std::size_t' , 'i' ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::size_t ▁ ns3::TypeId::GetAttributeN() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAttributeN' , 'std::size_t' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::Callback<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ ns3::TypeId::GetConstructor() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetConstructor' , 'ns3::Callback< ▁ ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::TypeId::GetGroupName() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetGroupName' , 'std::string' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::hash_t ▁ ns3::TypeId::GetHash() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash' , 'ns3::TypeId::hash_t' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::TypeId::GetName() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetName' , 'std::string' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::GetParent() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetParent' , 'ns3::TypeId' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::TypeId::GetRegistered(uint16_t ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRegistered' , 'ns3::TypeId' , [ param ( 'uint16_t' , 'i' ) ] , is_static = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ static ▁ uint16_t ▁ ns3::TypeId::GetRegisteredN() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRegisteredN' , 'uint16_t' , [ ] , is_static = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::size_t ▁ ns3::TypeId::GetSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSize' , 'std::size_t' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation ▁ ns3::TypeId::GetTraceSource(std::size_t ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTraceSource' , 'ns3::TypeId::TraceSourceInformation' , [ param ( 'std::size_t' , 'i' ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::size_t ▁ ns3::TypeId::GetTraceSourceN() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTraceSourceN' , 'std::size_t' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ uint16_t ▁ ns3::TypeId::GetUid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetUid' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeId::HasConstructor() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasConstructor' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeId::HasParent() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasParent' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::HideFromDocumentation() ▁ [member ▁ function] <encdom> cls . add_method ( 'HideFromDocumentation' , 'ns3::TypeId' , [ ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeId::IsChildOf(ns3::TypeId ▁ other) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsChildOf' , 'bool' , [ param ( 'ns3::TypeId' , 'other' ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeId::LookupAttributeByName(std::string ▁ name, ▁ ns3::TypeId::AttributeInformation ▁ * ▁ info) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'LookupAttributeByName' , 'bool' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::TypeId::AttributeInformation ▁ *' , 'info' , transfer_ownership = False ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::TypeId::LookupByHash(ns3::TypeId::hash_t ▁ hash) ▁ [member ▁ function] <encdom> cls . add_method ( 'LookupByHash' , 'ns3::TypeId' , [ param ( 'uint32_t' , 'hash' ) ] , is_static = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ static ▁ bool ▁ ns3::TypeId::LookupByHashFailSafe(ns3::TypeId::hash_t ▁ hash, ▁ ns3::TypeId ▁ * ▁ tid) ▁ [member ▁ function] <encdom> cls . add_method ( 'LookupByHashFailSafe' , 'bool' , [ param ( 'uint32_t' , 'hash' ) , param ( 'ns3::TypeId ▁ *' , 'tid' ) ] , is_static = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::TypeId::LookupByName(std::string ▁ name) ▁ [member ▁ function] <encdom> cls . add_method ( 'LookupByName' , 'ns3::TypeId' , [ param ( 'std::string' , 'name' ) ] , is_static = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::Ptr<const ▁ ns3::TraceSourceAccessor> ▁ ns3::TypeId::LookupTraceSourceByName(std::string ▁ name) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'LookupTraceSourceByName' , 'ns3::Ptr< ▁ ns3::TraceSourceAccessor ▁ const ▁ >' , [ param ( 'std::string' , 'name' ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::Ptr<const ▁ ns3::TraceSourceAccessor> ▁ ns3::TypeId::LookupTraceSourceByName(std::string ▁ name, ▁ ns3::TypeId::TraceSourceInformation ▁ * ▁ info) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'LookupTraceSourceByName' , 'ns3::Ptr< ▁ ns3::TraceSourceAccessor ▁ const ▁ >' , [ param ( 'std::string' , 'name' ) , param ( 'ns3::TypeId::TraceSourceInformation ▁ *' , 'info' ) ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeId::MustHideFromDocumentation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'MustHideFromDocumentation' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeId::SetAttributeInitialValue(std::size_t ▁ i, ▁ ns3::Ptr<const ▁ ns3::AttributeValue> ▁ initialValue) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAttributeInitialValue' , 'bool' , [ param ( 'std::size_t' , 'i' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeValue ▁ const ▁ >' , 'initialValue' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::SetGroupName(std::string ▁ groupName) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetGroupName' , 'ns3::TypeId' , [ param ( 'std::string' , 'groupName' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::SetParent(ns3::TypeId ▁ tid) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetParent' , 'ns3::TypeId' , [ param ( 'ns3::TypeId' , 'tid' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeId::SetSize(std::size_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetSize' , 'ns3::TypeId' , [ param ( 'std::size_t' , 'size' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ void ▁ ns3::TypeId::SetUid(uint16_t ▁ uid) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetUid' , 'void' , [ param ( 'uint16_t' , 'uid' ) ] ) <newline> return <newline> <dedent> def register_Ns3TypeIdAttributeInformation_methods ( root_module , cls ) : <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::AttributeInformation() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::AttributeInformation(ns3::TypeId::AttributeInformation ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TypeId::AttributeInformation ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::accessor ▁ [variable] <encdom> cls . add_instance_attribute ( 'accessor' , 'ns3::Ptr< ▁ ns3::AttributeAccessor ▁ const ▁ >' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::checker ▁ [variable] <encdom> cls . add_instance_attribute ( 'checker' , 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , is_const = False ) <newline> cls . add_instance_attribute ( 'flags' , 'uint32_t' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::help ▁ [variable] <encdom> cls . add_instance_attribute ( 'help' , 'std::string' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::initialValue ▁ [variable] <encdom> cls . add_instance_attribute ( 'initialValue' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ const ▁ >' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::name ▁ [variable] <encdom> cls . add_instance_attribute ( 'name' , 'std::string' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::originalInitialValue ▁ [variable] <encdom> cls . add_instance_attribute ( 'originalInitialValue' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ const ▁ >' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::supportLevel ▁ [variable] <encdom> cls . add_instance_attribute ( 'supportLevel' , 'ns3::TypeId::SupportLevel' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::AttributeInformation::supportMsg ▁ [variable] <encdom> cls . add_instance_attribute ( 'supportMsg' , 'std::string' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3TypeIdTraceSourceInformation_methods ( root_module , cls ) : <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::TraceSourceInformation() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::TraceSourceInformation(ns3::TypeId::TraceSourceInformation ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TypeId::TraceSourceInformation ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::accessor ▁ [variable] <encdom> cls . add_instance_attribute ( 'accessor' , 'ns3::Ptr< ▁ ns3::TraceSourceAccessor ▁ const ▁ >' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::callback ▁ [variable] <encdom> cls . add_instance_attribute ( 'callback' , 'std::string' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::help ▁ [variable] <encdom> cls . add_instance_attribute ( 'help' , 'std::string' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::name ▁ [variable] <encdom> cls . add_instance_attribute ( 'name' , 'std::string' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::supportLevel ▁ [variable] <encdom> cls . add_instance_attribute ( 'supportLevel' , 'ns3::TypeId::SupportLevel' , is_const = False ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId::TraceSourceInformation::supportMsg ▁ [variable] <encdom> cls . add_instance_attribute ( 'supportMsg' , 'std::string' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ empty.h ▁ (module ▁'core'): ▁ ns3::empty::empty() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ empty.h ▁ (module ▁'core'): ▁ ns3::empty::empty(ns3::empty ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::empty ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Int64x64_t_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_numeric_operator ( '+' , root_module [ 'ns3::int64x64_t' ] , root_module [ 'ns3::int64x64_t' ] , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_numeric_operator ( '-' , root_module [ 'ns3::int64x64_t' ] , root_module [ 'ns3::int64x64_t' ] , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_numeric_operator ( '*' , root_module [ 'ns3::int64x64_t' ] , root_module [ 'ns3::int64x64_t' ] , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_numeric_operator ( '/' , root_module [ 'ns3::int64x64_t' ] , root_module [ 'ns3::int64x64_t' ] , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<=' ) <newline> cls . add_binary_comparison_operator ( '>=' ) <newline> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline> cls . add_binary_comparison_operator ( '>' ) <newline> cls . add_inplace_numeric_operator ( '+=' , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_inplace_numeric_operator ( '-=' , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_inplace_numeric_operator ( '*=' , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_inplace_numeric_operator ( '/=' , param ( 'ns3::int64x64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_unary_numeric_operator ( '-' ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(double ▁ const ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'double ▁ const' , 'value' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(long ▁ double ▁ const ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ double ▁ const' , 'value' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(int ▁ const ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'int ▁ const' , 'v' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(long ▁ int ▁ const ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ int ▁ const' , 'v' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(long ▁ long ▁ int ▁ const ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ long ▁ int ▁ const' , 'v' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(unsigned ▁ int ▁ const ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'unsigned ▁ int ▁ const' , 'v' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(long ▁ unsigned ▁ int ▁ const ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ unsigned ▁ int ▁ const' , 'v' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(long ▁ long ▁ unsigned ▁ int ▁ const ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ long ▁ unsigned ▁ int ▁ const' , 'v' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(int64_t ▁ const ▁ hi, ▁ uint64_t ▁ const ▁ lo) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'int64_t ▁ const' , 'hi' ) , param ( 'uint64_t ▁ const' , 'lo' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::int64x64_t(ns3::int64x64_t ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::int64x64_t ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ double ▁ ns3::int64x64_t::GetDouble() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDouble' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::int64x64_t::GetHigh() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHigh' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::int64x64_t::GetLow() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLow' , 'uint64_t' , [ ] , is_const = True ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ static ▁ ns3::int64x64_t ▁ ns3::int64x64_t::Invert(uint64_t ▁ const ▁ v) ▁ [member ▁ function] <encdom> cls . add_method ( 'Invert' , 'ns3::int64x64_t' , [ param ( 'uint64_t ▁ const' , 'v' ) ] , is_static = True ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ void ▁ ns3::int64x64_t::MulByInvert(ns3::int64x64_t ▁ const ▁ & ▁ o) ▁ [member ▁ function] <encdom> cls . add_method ( 'MulByInvert' , 'void' , [ param ( 'ns3::int64x64_t ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ int64x64-128.h ▁ (module ▁'core'): ▁ ns3::int64x64_t::implementation ▁ [variable] <encdom> cls . add_static_attribute ( 'implementation' , 'ns3::int64x64_t::impl_type ▁ const' , is_const = True ) <newline> return <newline> <dedent> def register_Ns3Chunk_methods ( root_module , cls ) : <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ ns3::Chunk::Chunk() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ ns3::Chunk::Chunk(ns3::Chunk ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Chunk ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Chunk::Deserialize(ns3::Buffer::Iterator ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Chunk::Deserialize(ns3::Buffer::Iterator ▁ start, ▁ ns3::Buffer::Iterator ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'ns3::Buffer::Iterator' , 'end' ) ] , is_virtual = True ) <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::Chunk::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ chunk.h ▁ (module ▁'network'): ▁ void ▁ ns3::Chunk::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Header_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ ns3::Header::Header() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ ns3::Header::Header(ns3::Header ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Header ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Header::Deserialize(ns3::Buffer::Iterator ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Header::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::Header::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ void ▁ ns3::Header::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ header.h ▁ (module ▁'network'): ▁ void ▁ ns3::Header::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Ipv4Header_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header::Ipv4Header(ns3::Ipv4Header ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header::Ipv4Header() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4Header::Deserialize(ns3::Buffer::Iterator ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ std::string ▁ ns3::Ipv4Header::DscpTypeToString(ns3::Ipv4Header::DscpType ▁ dscp) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'DscpTypeToString' , 'std::string' , [ param ( 'ns3::Ipv4Header::DscpType' , 'dscp' ) ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ std::string ▁ ns3::Ipv4Header::EcnTypeToString(ns3::Ipv4Header::EcnType ▁ ecn) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'EcnTypeToString' , 'std::string' , [ param ( 'ns3::Ipv4Header::EcnType' , 'ecn' ) ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::EnableChecksum() ▁ [member ▁ function] <encdom> cls . add_method ( 'EnableChecksum' , 'void' , [ ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Header::GetDestination() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDestination' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header::DscpType ▁ ns3::Ipv4Header::GetDscp() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDscp' , 'ns3::Ipv4Header::DscpType' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Header::EcnType ▁ ns3::Ipv4Header::GetEcn() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetEcn' , 'ns3::Ipv4Header::EcnType' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint16_t ▁ ns3::Ipv4Header::GetFragmentOffset() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetFragmentOffset' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint16_t ▁ ns3::Ipv4Header::GetIdentification() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIdentification' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::TypeId ▁ ns3::Ipv4Header::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint16_t ▁ ns3::Ipv4Header::GetPayloadSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPayloadSize' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint8_t ▁ ns3::Ipv4Header::GetProtocol() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetProtocol' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4Header::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Header::GetSource() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSource' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint8_t ▁ ns3::Ipv4Header::GetTos() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTos' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ uint8_t ▁ ns3::Ipv4Header::GetTtl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTtl' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ static ▁ ns3::TypeId ▁ ns3::Ipv4Header::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4Header::IsChecksumOk() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsChecksumOk' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4Header::IsDontFragment() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsDontFragment' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4Header::IsLastFragment() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLastFragment' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetDestination(ns3::Ipv4Address ▁ destination) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDestination' , 'void' , [ param ( 'ns3::Ipv4Address' , 'destination' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetDontFragment() ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDontFragment' , 'void' , [ ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetDscp(ns3::Ipv4Header::DscpType ▁ dscp) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDscp' , 'void' , [ param ( 'ns3::Ipv4Header::DscpType' , 'dscp' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetEcn(ns3::Ipv4Header::EcnType ▁ ecn) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetEcn' , 'void' , [ param ( 'ns3::Ipv4Header::EcnType' , 'ecn' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetFragmentOffset(uint16_t ▁ offsetBytes) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetFragmentOffset' , 'void' , [ param ( 'uint16_t' , 'offsetBytes' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetIdentification(uint16_t ▁ identification) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIdentification' , 'void' , [ param ( 'uint16_t' , 'identification' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetLastFragment() ▁ [member ▁ function] <encdom> cls . add_method ( 'SetLastFragment' , 'void' , [ ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetMayFragment() ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMayFragment' , 'void' , [ ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetMoreFragments() ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMoreFragments' , 'void' , [ ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetPayloadSize(uint16_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPayloadSize' , 'void' , [ param ( 'uint16_t' , 'size' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetProtocol(uint8_t ▁ num) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetProtocol' , 'void' , [ param ( 'uint8_t' , 'num' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetSource(ns3::Ipv4Address ▁ source) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetSource' , 'void' , [ param ( 'ns3::Ipv4Address' , 'source' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetTos(uint8_t ▁ tos) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTos' , 'void' , [ param ( 'uint8_t' , 'tos' ) ] ) <newline>  # # ▁ ipv4-header.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Header::SetTtl(uint8_t ▁ ttl) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTtl' , 'void' , [ param ( 'uint8_t' , 'ttl' ) ] ) <newline> return <newline> <dedent> def register_Ns3Object_methods ( root_module , cls ) : <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object::Object() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ void ▁ ns3::Object::AggregateObject(ns3::Ptr<ns3::Object> ▁ other) ▁ [member ▁ function] <encdom> cls . add_method ( 'AggregateObject' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Object ▁ >' , 'other' ) ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ void ▁ ns3::Object::Dispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'Dispose' , 'void' , [ ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object::AggregateIterator ▁ ns3::Object::GetAggregateIterator() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAggregateIterator' , 'ns3::Object::AggregateIterator' , [ ] , is_const = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::Object::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::Object::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ void ▁ ns3::Object::Initialize() ▁ [member ▁ function] <encdom> cls . add_method ( 'Initialize' , 'void' , [ ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Object::IsInitialized() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsInitialized' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object::Object(ns3::Object ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Object ▁ const ▁ &' , 'o' ) ] , visibility = 'protected' ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ void ▁ ns3::Object::DoDispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoDispose' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ void ▁ ns3::Object::DoInitialize() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoInitialize' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ void ▁ ns3::Object::NotifyNewAggregate() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyNewAggregate' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ObjectAggregateIterator_methods ( root_module , cls ) : <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object::AggregateIterator::AggregateIterator(ns3::Object::AggregateIterator ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Object::AggregateIterator ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Object::AggregateIterator::AggregateIterator() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Object::AggregateIterator::HasNext() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasNext' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ object.h ▁ (module ▁'core'): ▁ ns3::Ptr<const ▁ ns3::Object> ▁ ns3::Object::AggregateIterator::Next() ▁ [member ▁ function] <encdom> cls . add_method ( 'Next' , 'ns3::Ptr< ▁ ns3::Object ▁ const ▁ >' , [ ] ) <newline> return <newline> <dedent> def register_Ns3RandomVariableStream_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::RandomVariableStream::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::RandomVariableStream::RandomVariableStream() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ void ▁ ns3::RandomVariableStream::SetStream(int64_t ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetStream' , 'void' , [ param ( 'int64_t' , 'stream' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::RandomVariableStream::GetStream() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetStream' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ void ▁ ns3::RandomVariableStream::SetAntithetic(bool ▁ isAntithetic) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAntithetic' , 'void' , [ param ( 'bool' , 'isAntithetic' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ bool ▁ ns3::RandomVariableStream::IsAntithetic() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsAntithetic' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::RandomVariableStream::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::RandomVariableStream::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::RngStream ▁ * ▁ ns3::RandomVariableStream::Peek() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Peek' , 'ns3::RngStream ▁ *' , [ ] , is_const = True , visibility = 'protected' ) <newline> return <newline> <dedent> def register_Ns3SequentialRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::SequentialRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::SequentialRandomVariable::SequentialRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::SequentialRandomVariable::GetMin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMin' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::SequentialRandomVariable::GetMax() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMax' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::RandomVariableStream> ▁ ns3::SequentialRandomVariable::GetIncrement() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIncrement' , 'ns3::Ptr< ▁ ns3::RandomVariableStream ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::SequentialRandomVariable::GetConsecutive() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetConsecutive' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::SequentialRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::SequentialRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeAccessor> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::AttributeAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::AttributeAccessor ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeChecker> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::AttributeChecker, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::AttributeChecker ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::AttributeValue> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::AttributeValue, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::AttributeValue ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::CallbackImplBase> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::CallbackImplBase, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::CallbackImplBase ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::EventImpl> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::EventImpl, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::EventImpl ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3HashImplementation_Ns3Empty_Ns3DefaultDeleter__lt__ns3HashImplementation__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Hash::Implementation> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::Hash::Implementation, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::Hash::Implementation ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::Ipv4MulticastRoute, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::Ipv4MulticastRoute ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4Route> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4Route> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Ipv4Route> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::Ipv4Route, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::Ipv4Route ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::NixVector> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::NixVector, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::NixVector ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::OutputStreamWrapper> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::OutputStreamWrapper> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::OutputStreamWrapper> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::OutputStreamWrapper, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::OutputStreamWrapper ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Packet> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Packet> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::Packet> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::Packet, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::Packet ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods ( root_module , cls ) : <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ >::SimpleRefCount() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ simple-ref-count.h ▁ (module ▁'core'): ▁ ns3::SimpleRefCount<ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ >::SimpleRefCount(ns3::SimpleRefCount<ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter<ns3::TraceSourceAccessor> ▁ > ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::SimpleRefCount< ▁ ns3::TraceSourceAccessor, ▁ ns3::empty, ▁ ns3::DefaultDeleter< ▁ ns3::TraceSourceAccessor ▁ > ▁ > ▁ const ▁ &' , 'o' ) ] ) <newline> return <newline> <dedent> def register_Ns3Socket_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::Socket(ns3::Socket ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Socket ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::Socket() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Bind(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Bind' , 'int' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Bind() ▁ [member ▁ function] <encdom> cls . add_method ( 'Bind' , 'int' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Bind6() ▁ [member ▁ function] <encdom> cls . add_method ( 'Bind6' , 'int' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::BindToNetDevice(ns3::Ptr<ns3::NetDevice> ▁ netdevice) ▁ [member ▁ function] <encdom> cls . add_method ( 'BindToNetDevice' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'netdevice' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Close() ▁ [member ▁ function] <encdom> cls . add_method ( 'Close' , 'int' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Connect(ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Connect' , 'int' , [ param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::Ptr<ns3::Socket> ▁ ns3::Socket::CreateSocket(ns3::Ptr<ns3::Node> ▁ node, ▁ ns3::TypeId ▁ tid) ▁ [member ▁ function] <encdom> cls . add_method ( 'CreateSocket' , 'ns3::Ptr< ▁ ns3::Socket ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) , param ( 'ns3::TypeId' , 'tid' ) ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::GetAllowBroadcast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAllowBroadcast' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::NetDevice> ▁ ns3::Socket::GetBoundNetDevice() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBoundNetDevice' , 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::SocketErrno ▁ ns3::Socket::GetErrno() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetErrno' , 'ns3::Socket::SocketErrno' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Socket::GetIpTos() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpTos' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Socket::GetIpTtl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpTtl' , 'uint8_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Socket::GetIpv6HopLimit() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpv6HopLimit' , 'uint8_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Socket::GetIpv6Tclass() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpv6Tclass' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Node> ▁ ns3::Socket::GetNode() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNode' , 'ns3::Ptr< ▁ ns3::Node ▁ >' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::GetPeerName(ns3::Address ▁ & ▁ address) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPeerName' , 'int' , [ param ( 'ns3::Address ▁ &' , 'address' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::Socket::GetPriority() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPriority' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Socket::GetRxAvailable() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRxAvailable' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::GetSockName(ns3::Address ▁ & ▁ address) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSockName' , 'int' , [ param ( 'ns3::Address ▁ &' , 'address' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Socket::SocketType ▁ ns3::Socket::GetSocketType() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSocketType' , 'ns3::Socket::SocketType' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Socket::GetTxAvailable() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTxAvailable' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::Socket::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ uint8_t ▁ ns3::Socket::IpTos2Priority(uint8_t ▁ ipTos) ▁ [member ▁ function] <encdom> cls . add_method ( 'IpTos2Priority' , 'uint8_t' , [ param ( 'uint8_t' , 'ipTos' ) ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::Ipv6JoinGroup(ns3::Ipv6Address ▁ address, ▁ ns3::Socket::Ipv6MulticastFilterMode ▁ filterMode, ▁ std::vector<ns3::Ipv6Address, ▁ std::allocator<ns3::Ipv6Address> ▁ > ▁ sourceAddresses) ▁ [member ▁ function] <encdom> cls . add_method ( 'Ipv6JoinGroup' , 'void' , [ param ( 'ns3::Ipv6Address' , 'address' ) , param ( 'ns3::Socket::Ipv6MulticastFilterMode' , 'filterMode' ) , param ( 'std::vector< ▁ ns3::Ipv6Address ▁ >' , 'sourceAddresses' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::Ipv6JoinGroup(ns3::Ipv6Address ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'Ipv6JoinGroup' , 'void' , [ param ( 'ns3::Ipv6Address' , 'address' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::Ipv6LeaveGroup() ▁ [member ▁ function] <encdom> cls . add_method ( 'Ipv6LeaveGroup' , 'void' , [ ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsIpRecvTos() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsIpRecvTos' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsIpRecvTtl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsIpRecvTtl' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsIpv6RecvHopLimit() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsIpv6RecvHopLimit' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsIpv6RecvTclass() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsIpv6RecvTclass' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsRecvPktInfo() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsRecvPktInfo' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Listen() ▁ [member ▁ function] <encdom> cls . add_method ( 'Listen' , 'int' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Packet> ▁ ns3::Socket::Recv(uint32_t ▁ maxSize, ▁ uint32_t ▁ flags) ▁ [member ▁ function] <encdom> cls . add_method ( 'Recv' , 'ns3::Ptr< ▁ ns3::Packet ▁ >' , [ param ( 'uint32_t' , 'maxSize' ) , param ( 'uint32_t' , 'flags' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Packet> ▁ ns3::Socket::Recv() ▁ [member ▁ function] <encdom> cls . add_method ( 'Recv' , 'ns3::Ptr< ▁ ns3::Packet ▁ >' , [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Recv(uint8_t ▁ * ▁ buf, ▁ uint32_t ▁ size, ▁ uint32_t ▁ flags) ▁ [member ▁ function] <encdom> cls . add_method ( 'Recv' , 'int' , [ param ( 'uint8_t ▁ *' , 'buf' ) , param ( 'uint32_t' , 'size' ) , param ( 'uint32_t' , 'flags' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Packet> ▁ ns3::Socket::RecvFrom(uint32_t ▁ maxSize, ▁ uint32_t ▁ flags, ▁ ns3::Address ▁ & ▁ fromAddress) ▁ [member ▁ function] <encdom> cls . add_method ( 'RecvFrom' , 'ns3::Ptr< ▁ ns3::Packet ▁ >' , [ param ( 'uint32_t' , 'maxSize' ) , param ( 'uint32_t' , 'flags' ) , param ( 'ns3::Address ▁ &' , 'fromAddress' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Packet> ▁ ns3::Socket::RecvFrom(ns3::Address ▁ & ▁ fromAddress) ▁ [member ▁ function] <encdom> cls . add_method ( 'RecvFrom' , 'ns3::Ptr< ▁ ns3::Packet ▁ >' , [ param ( 'ns3::Address ▁ &' , 'fromAddress' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::RecvFrom(uint8_t ▁ * ▁ buf, ▁ uint32_t ▁ size, ▁ uint32_t ▁ flags, ▁ ns3::Address ▁ & ▁ fromAddress) ▁ [member ▁ function] <encdom> cls . add_method ( 'RecvFrom' , 'int' , [ param ( 'uint8_t ▁ *' , 'buf' ) , param ( 'uint32_t' , 'size' ) , param ( 'uint32_t' , 'flags' ) , param ( 'ns3::Address ▁ &' , 'fromAddress' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Send(ns3::Ptr<ns3::Packet> ▁ p, ▁ uint32_t ▁ flags) ▁ [member ▁ function] <encdom> cls . add_method ( 'Send' , 'int' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) , param ( 'uint32_t' , 'flags' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Send(ns3::Ptr<ns3::Packet> ▁ p) ▁ [member ▁ function] <encdom> cls . add_method ( 'Send' , 'int' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::Send(uint8_t ▁ const ▁ * ▁ buf, ▁ uint32_t ▁ size, ▁ uint32_t ▁ flags) ▁ [member ▁ function] <encdom> cls . add_method ( 'Send' , 'int' , [ param ( 'uint8_t ▁ const ▁ *' , 'buf' ) , param ( 'uint32_t' , 'size' ) , param ( 'uint32_t' , 'flags' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::SendTo(ns3::Ptr<ns3::Packet> ▁ p, ▁ uint32_t ▁ flags, ▁ ns3::Address ▁ const ▁ & ▁ toAddress) ▁ [member ▁ function] <encdom> cls . add_method ( 'SendTo' , 'int' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) , param ( 'uint32_t' , 'flags' ) , param ( 'ns3::Address ▁ const ▁ &' , 'toAddress' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::SendTo(uint8_t ▁ const ▁ * ▁ buf, ▁ uint32_t ▁ size, ▁ uint32_t ▁ flags, ▁ ns3::Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'SendTo' , 'int' , [ param ( 'uint8_t ▁ const ▁ *' , 'buf' ) , param ( 'uint32_t' , 'size' ) , param ( 'uint32_t' , 'flags' ) , param ( 'ns3::Address ▁ const ▁ &' , 'address' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetAcceptCallback(ns3::Callback<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ connectionRequest, ▁ ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ newConnectionCreated) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAcceptCallback' , 'void' , [ param ( 'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'connectionRequest' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'newConnectionCreated' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::SetAllowBroadcast(bool ▁ allowBroadcast) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAllowBroadcast' , 'bool' , [ param ( 'bool' , 'allowBroadcast' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetCloseCallbacks(ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ normalClose, ▁ ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ errorClose) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetCloseCallbacks' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'normalClose' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'errorClose' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetConnectCallback(ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ connectionSucceeded, ▁ ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ connectionFailed) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetConnectCallback' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'connectionSucceeded' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'connectionFailed' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetDataSentCallback(ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ dataSent) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDataSentCallback' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'dataSent' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpRecvTos(bool ▁ ipv4RecvTos) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpRecvTos' , 'void' , [ param ( 'bool' , 'ipv4RecvTos' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpRecvTtl(bool ▁ ipv4RecvTtl) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpRecvTtl' , 'void' , [ param ( 'bool' , 'ipv4RecvTtl' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpTos(uint8_t ▁ ipTos) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpTos' , 'void' , [ param ( 'uint8_t' , 'ipTos' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpTtl(uint8_t ▁ ipTtl) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpTtl' , 'void' , [ param ( 'uint8_t' , 'ipTtl' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpv6HopLimit(uint8_t ▁ ipHopLimit) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv6HopLimit' , 'void' , [ param ( 'uint8_t' , 'ipHopLimit' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpv6RecvHopLimit(bool ▁ ipv6RecvHopLimit) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv6RecvHopLimit' , 'void' , [ param ( 'bool' , 'ipv6RecvHopLimit' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpv6RecvTclass(bool ▁ ipv6RecvTclass) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv6RecvTclass' , 'void' , [ param ( 'bool' , 'ipv6RecvTclass' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetIpv6Tclass(int ▁ ipTclass) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv6Tclass' , 'void' , [ param ( 'int' , 'ipTclass' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetPriority(uint8_t ▁ priority) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPriority' , 'void' , [ param ( 'uint8_t' , 'priority' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetRecvCallback(ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ arg0) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetRecvCallback' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetRecvPktInfo(bool ▁ flag) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetRecvPktInfo' , 'void' , [ param ( 'bool' , 'flag' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::SetSendCallback(ns3::Callback<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ sendCb) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetSendCallback' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'sendCb' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::ShutdownRecv() ▁ [member ▁ function] <encdom> cls . add_method ( 'ShutdownRecv' , 'int' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ int ▁ ns3::Socket::ShutdownSend() ▁ [member ▁ function] <encdom> cls . add_method ( 'ShutdownSend' , 'int' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::DoDispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoDispose' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsManualIpTtl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsManualIpTtl' , 'bool' , [ ] , is_const = True , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsManualIpv6HopLimit() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsManualIpv6HopLimit' , 'bool' , [ ] , is_const = True , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::IsManualIpv6Tclass() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsManualIpv6Tclass' , 'bool' , [ ] , is_const = True , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyConnectionFailed() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyConnectionFailed' , 'void' , [ ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Socket::NotifyConnectionRequest(ns3::Address ▁ const ▁ & ▁ from) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyConnectionRequest' , 'bool' , [ param ( 'ns3::Address ▁ const ▁ &' , 'from' ) ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyConnectionSucceeded() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyConnectionSucceeded' , 'void' , [ ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyDataRecv() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyDataRecv' , 'void' , [ ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyDataSent(uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyDataSent' , 'void' , [ param ( 'uint32_t' , 'size' ) ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyErrorClose() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyErrorClose' , 'void' , [ ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyNewConnectionCreated(ns3::Ptr<ns3::Socket> ▁ socket, ▁ ns3::Address ▁ const ▁ & ▁ from) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyNewConnectionCreated' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Socket ▁ >' , 'socket' ) , param ( 'ns3::Address ▁ const ▁ &' , 'from' ) ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifyNormalClose() ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyNormalClose' , 'void' , [ ] , visibility = 'protected' ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::Socket::NotifySend(uint32_t ▁ spaceAvailable) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifySend' , 'void' , [ param ( 'uint32_t' , 'spaceAvailable' ) ] , visibility = 'protected' ) <newline> return <newline> <dedent> def register_Ns3SocketIpTosTag_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpTosTag::SocketIpTosTag(ns3::SocketIpTosTag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SocketIpTosTag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpTosTag::SocketIpTosTag() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTosTag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::SocketIpTosTag::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::SocketIpTosTag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::SocketIpTosTag::GetTos() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTos' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::SocketIpTosTag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTosTag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTosTag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTosTag::SetTos(uint8_t ▁ tos) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTos' , 'void' , [ param ( 'uint8_t' , 'tos' ) ] ) <newline> return <newline> <dedent> def register_Ns3SocketIpTtlTag_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpTtlTag::SocketIpTtlTag(ns3::SocketIpTtlTag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SocketIpTtlTag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpTtlTag::SocketIpTtlTag() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTtlTag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::SocketIpTtlTag::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::SocketIpTtlTag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::SocketIpTtlTag::GetTtl() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTtl' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::SocketIpTtlTag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTtlTag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTtlTag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpTtlTag::SetTtl(uint8_t ▁ ttl) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTtl' , 'void' , [ param ( 'uint8_t' , 'ttl' ) ] ) <newline> return <newline> <dedent> def register_Ns3SocketIpv6HopLimitTag_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpv6HopLimitTag::SocketIpv6HopLimitTag(ns3::SocketIpv6HopLimitTag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SocketIpv6HopLimitTag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpv6HopLimitTag::SocketIpv6HopLimitTag() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6HopLimitTag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::SocketIpv6HopLimitTag::GetHopLimit() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHopLimit' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::SocketIpv6HopLimitTag::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::SocketIpv6HopLimitTag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::SocketIpv6HopLimitTag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6HopLimitTag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6HopLimitTag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6HopLimitTag::SetHopLimit(uint8_t ▁ hopLimit) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetHopLimit' , 'void' , [ param ( 'uint8_t' , 'hopLimit' ) ] ) <newline> return <newline> <dedent> def register_Ns3SocketIpv6TclassTag_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpv6TclassTag::SocketIpv6TclassTag(ns3::SocketIpv6TclassTag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SocketIpv6TclassTag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketIpv6TclassTag::SocketIpv6TclassTag() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6TclassTag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::SocketIpv6TclassTag::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::SocketIpv6TclassTag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::SocketIpv6TclassTag::GetTclass() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTclass' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::SocketIpv6TclassTag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6TclassTag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6TclassTag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketIpv6TclassTag::SetTclass(uint8_t ▁ tclass) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTclass' , 'void' , [ param ( 'uint8_t' , 'tclass' ) ] ) <newline> return <newline> <dedent> def register_Ns3SocketPriorityTag_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketPriorityTag::SocketPriorityTag(ns3::SocketPriorityTag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SocketPriorityTag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketPriorityTag::SocketPriorityTag() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketPriorityTag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::SocketPriorityTag::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint8_t ▁ ns3::SocketPriorityTag::GetPriority() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPriority' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::SocketPriorityTag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::SocketPriorityTag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketPriorityTag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketPriorityTag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketPriorityTag::SetPriority(uint8_t ▁ priority) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPriority' , 'void' , [ param ( 'uint8_t' , 'priority' ) ] ) <newline> return <newline> <dedent> def register_Ns3SocketSetDontFragmentTag_methods ( root_module , cls ) : <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketSetDontFragmentTag::SocketSetDontFragmentTag(ns3::SocketSetDontFragmentTag ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::SocketSetDontFragmentTag ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::SocketSetDontFragmentTag::SocketSetDontFragmentTag() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketSetDontFragmentTag::Deserialize(ns3::TagBuffer ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketSetDontFragmentTag::Disable() ▁ [member ▁ function] <encdom> cls . add_method ( 'Disable' , 'void' , [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketSetDontFragmentTag::Enable() ▁ [member ▁ function] <encdom> cls . add_method ( 'Enable' , 'void' , [ ] ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ ns3::TypeId ▁ ns3::SocketSetDontFragmentTag::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::SocketSetDontFragmentTag::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::SocketSetDontFragmentTag::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ bool ▁ ns3::SocketSetDontFragmentTag::IsEnabled() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEnabled' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketSetDontFragmentTag::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ socket.h ▁ (module ▁'network'): ▁ void ▁ ns3::SocketSetDontFragmentTag::Serialize(ns3::TagBuffer ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::TagBuffer' , 'i' ) ] , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Time_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_binary_comparison_operator ( '!=' ) <newline> cls . add_binary_comparison_operator ( '<=' ) <newline> cls . add_binary_comparison_operator ( '>=' ) <newline> cls . add_binary_comparison_operator ( '<' ) <newline> cls . add_binary_comparison_operator ( '>' ) <newline> cls . add_binary_numeric_operator ( '+' , root_module [ 'ns3::Time' ] , root_module [ 'ns3::Time' ] , param ( 'ns3::Time ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_numeric_operator ( '-' , root_module [ 'ns3::Time' ] , root_module [ 'ns3::Time' ] , param ( 'ns3::Time ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_numeric_operator ( '*' , root_module [ 'ns3::Time' ] , root_module [ 'ns3::Time' ] , param ( 'int64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_binary_numeric_operator ( '/' , root_module [ 'ns3::Time' ] , root_module [ 'ns3::Time' ] , param ( 'int64_t ▁ const ▁ &' , u'right' ) ) <newline> cls . add_inplace_numeric_operator ( '+=' , param ( 'ns3::Time ▁ const ▁ &' , u'right' ) ) <newline> cls . add_inplace_numeric_operator ( '-=' , param ( 'ns3::Time ▁ const ▁ &' , u'right' ) ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(ns3::Time ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Time ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(double ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'double' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(int ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'int' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(long ▁ int ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ int' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(long ▁ long ▁ int ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ long ▁ int' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(unsigned ▁ int ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'unsigned ▁ int' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(long ▁ unsigned ▁ int ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ unsigned ▁ int' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(long ▁ long ▁ unsigned ▁ int ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'long ▁ long ▁ unsigned ▁ int' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(ns3::int64x64_t ▁ const ▁ & ▁ v) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::int64x64_t ▁ const ▁ &' , 'v' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time::Time(std::string ▁ const ▁ & ▁ s) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'std::string ▁ const ▁ &' , 's' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeWithUnit ▁ ns3::Time::As(ns3::Time::Unit ▁ const ▁ unit) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'As' , 'ns3::TimeWithUnit' , [ param ( 'ns3::Time::Unit ▁ const' , 'unit' ) ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int ▁ ns3::Time::Compare(ns3::Time ▁ const ▁ & ▁ o) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Compare' , 'int' , [ param ( 'ns3::Time ▁ const ▁ &' , 'o' ) ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Time::From(ns3::int64x64_t ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'From' , 'ns3::Time' , [ param ( 'ns3::int64x64_t ▁ const ▁ &' , 'value' ) ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Time::From(ns3::int64x64_t ▁ const ▁ & ▁ value, ▁ ns3::Time::Unit ▁ unit) ▁ [member ▁ function] <encdom> cls . add_method ( 'From' , 'ns3::Time' , [ param ( 'ns3::int64x64_t ▁ const ▁ &' , 'value' ) , param ( 'ns3::Time::Unit' , 'unit' ) ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Time::FromDouble(double ▁ value, ▁ ns3::Time::Unit ▁ unit) ▁ [member ▁ function] <encdom> cls . add_method ( 'FromDouble' , 'ns3::Time' , [ param ( 'double' , 'value' ) , param ( 'ns3::Time::Unit' , 'unit' ) ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Time::FromInteger(uint64_t ▁ value, ▁ ns3::Time::Unit ▁ unit) ▁ [member ▁ function] <encdom> cls . add_method ( 'FromInteger' , 'ns3::Time' , [ param ( 'uint64_t' , 'value' ) , param ( 'ns3::Time::Unit' , 'unit' ) ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::GetDays() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDays' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::GetDouble() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDouble' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetFemtoSeconds() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetFemtoSeconds' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::GetHours() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHours' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetInteger() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetMicroSeconds() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMicroSeconds' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetMilliSeconds() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMilliSeconds' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::GetMinutes() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMinutes' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetNanoSeconds() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNanoSeconds' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetPicoSeconds() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPicoSeconds' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time::Unit ▁ ns3::Time::GetResolution() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetResolution' , 'ns3::Time::Unit' , [ ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::GetSeconds() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSeconds' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::GetTimeStep() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTimeStep' , 'int64_t' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::GetYears() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetYears' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Time::IsNegative() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsNegative' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Time::IsPositive() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsPositive' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Time::IsStrictlyNegative() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsStrictlyNegative' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Time::IsStrictlyPositive() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsStrictlyPositive' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ bool ▁ ns3::Time::IsZero() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsZero' , 'bool' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Time::Max() ▁ [member ▁ function] <encdom> cls . add_method ( 'Max' , 'ns3::Time' , [ ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ ns3::Time ▁ ns3::Time::Min() ▁ [member ▁ function] <encdom> cls . add_method ( 'Min' , 'ns3::Time' , [ ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ void ▁ ns3::Time::SetResolution(ns3::Time::Unit ▁ resolution) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetResolution' , 'void' , [ param ( 'ns3::Time::Unit' , 'resolution' ) ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ static ▁ bool ▁ ns3::Time::StaticInit() ▁ [member ▁ function] <encdom> cls . add_method ( 'StaticInit' , 'bool' , [ ] , is_static = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::int64x64_t ▁ ns3::Time::To(ns3::Time::Unit ▁ unit) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'To' , 'ns3::int64x64_t' , [ param ( 'ns3::Time::Unit' , 'unit' ) ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ double ▁ ns3::Time::ToDouble(ns3::Time::Unit ▁ unit) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'ToDouble' , 'double' , [ param ( 'ns3::Time::Unit' , 'unit' ) ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ int64_t ▁ ns3::Time::ToInteger(ns3::Time::Unit ▁ unit) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'ToInteger' , 'int64_t' , [ param ( 'ns3::Time::Unit' , 'unit' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3TraceSourceAccessor_methods ( root_module , cls ) : <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ ns3::TraceSourceAccessor::TraceSourceAccessor(ns3::TraceSourceAccessor ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::TraceSourceAccessor ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ ns3::TraceSourceAccessor::TraceSourceAccessor() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TraceSourceAccessor::Connect(ns3::ObjectBase ▁ * ▁ obj, ▁ std::string ▁ context, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Connect' , 'bool' , [ param ( 'ns3::ObjectBase ▁ *' , 'obj' , transfer_ownership = False ) , param ( 'std::string' , 'context' ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TraceSourceAccessor::ConnectWithoutContext(ns3::ObjectBase ▁ * ▁ obj, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'ConnectWithoutContext' , 'bool' , [ param ( 'ns3::ObjectBase ▁ *' , 'obj' , transfer_ownership = False ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TraceSourceAccessor::Disconnect(ns3::ObjectBase ▁ * ▁ obj, ▁ std::string ▁ context, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Disconnect' , 'bool' , [ param ( 'ns3::ObjectBase ▁ *' , 'obj' , transfer_ownership = False ) , param ( 'std::string' , 'context' ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ trace-source-accessor.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TraceSourceAccessor::DisconnectWithoutContext(ns3::ObjectBase ▁ * ▁ obj, ▁ ns3::CallbackBase ▁ const ▁ & ▁ cb) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'DisconnectWithoutContext' , 'bool' , [ param ( 'ns3::ObjectBase ▁ *' , 'obj' , transfer_ownership = False ) , param ( 'ns3::CallbackBase ▁ const ▁ &' , 'cb' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Trailer_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ ns3::Trailer::Trailer() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ ns3::Trailer::Trailer(ns3::Trailer ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Trailer ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Trailer::Deserialize(ns3::Buffer::Iterator ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'end' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Trailer::Deserialize(ns3::Buffer::Iterator ▁ start, ▁ ns3::Buffer::Iterator ▁ end) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'ns3::Buffer::Iterator' , 'end' ) ] , is_virtual = True ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Trailer::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::Trailer::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Trailer::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ trailer.h ▁ (module ▁'network'): ▁ void ▁ ns3::Trailer::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3TriangularRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::TriangularRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::TriangularRandomVariable::TriangularRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::TriangularRandomVariable::GetMean() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMean' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::TriangularRandomVariable::GetMin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMin' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::TriangularRandomVariable::GetMax() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMax' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::TriangularRandomVariable::GetValue(double ▁ mean, ▁ double ▁ min, ▁ double ▁ max) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'mean' ) , param ( 'double' , 'min' ) , param ( 'double' , 'max' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::TriangularRandomVariable::GetInteger(uint32_t ▁ mean, ▁ uint32_t ▁ min, ▁ uint32_t ▁ max) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'mean' ) , param ( 'uint32_t' , 'min' ) , param ( 'uint32_t' , 'max' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::TriangularRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::TriangularRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3UniformRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::UniformRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::UniformRandomVariable::UniformRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::UniformRandomVariable::GetMin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMin' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::UniformRandomVariable::GetMax() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMax' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::UniformRandomVariable::GetValue(double ▁ min, ▁ double ▁ max) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'min' ) , param ( 'double' , 'max' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::UniformRandomVariable::GetInteger(uint32_t ▁ min, ▁ uint32_t ▁ max) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'min' ) , param ( 'uint32_t' , 'max' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::UniformRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::UniformRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3WeibullRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::WeibullRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::WeibullRandomVariable::WeibullRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::WeibullRandomVariable::GetScale() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetScale' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::WeibullRandomVariable::GetShape() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetShape' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::WeibullRandomVariable::GetBound() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBound' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::WeibullRandomVariable::GetValue(double ▁ scale, ▁ double ▁ shape, ▁ double ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'scale' ) , param ( 'double' , 'shape' ) , param ( 'double' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::WeibullRandomVariable::GetInteger(uint32_t ▁ scale, ▁ uint32_t ▁ shape, ▁ uint32_t ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'scale' ) , param ( 'uint32_t' , 'shape' ) , param ( 'uint32_t' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::WeibullRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::WeibullRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ZetaRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ZetaRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ZetaRandomVariable::ZetaRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ZetaRandomVariable::GetAlpha() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAlpha' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ZetaRandomVariable::GetValue(double ▁ alpha) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'alpha' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ZetaRandomVariable::GetInteger(uint32_t ▁ alpha) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'alpha' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ZetaRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ZetaRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ZipfRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ZipfRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ZipfRandomVariable::ZipfRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ZipfRandomVariable::GetN() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetN' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ZipfRandomVariable::GetAlpha() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAlpha' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ZipfRandomVariable::GetValue(uint32_t ▁ n, ▁ double ▁ alpha) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'uint32_t' , 'n' ) , param ( 'double' , 'alpha' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ZipfRandomVariable::GetInteger(uint32_t ▁ n, ▁ uint32_t ▁ alpha) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'n' ) , param ( 'uint32_t' , 'alpha' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ZipfRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ZipfRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3AttributeAccessor_methods ( root_module , cls ) : <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeAccessor::AttributeAccessor(ns3::AttributeAccessor ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::AttributeAccessor ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeAccessor::AttributeAccessor() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeAccessor::Get(ns3::ObjectBase ▁ const ▁ * ▁ object, ▁ ns3::AttributeValue ▁ & ▁ attribute) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'bool' , [ param ( 'ns3::ObjectBase ▁ const ▁ *' , 'object' ) , param ( 'ns3::AttributeValue ▁ &' , 'attribute' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeAccessor::HasGetter() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasGetter' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeAccessor::HasSetter() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasSetter' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeAccessor::Set(ns3::ObjectBase ▁ * ▁ object, ▁ ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'bool' , [ param ( 'ns3::ObjectBase ▁ *' , 'object' , transfer_ownership = False ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3AttributeChecker_methods ( root_module , cls ) : <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeChecker::AttributeChecker(ns3::AttributeChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::AttributeChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeChecker::AttributeChecker() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeChecker::Check(ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Check' , 'bool' , [ param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeChecker::Copy(ns3::AttributeValue ▁ const ▁ & ▁ source, ▁ ns3::AttributeValue ▁ & ▁ destination) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'bool' , [ param ( 'ns3::AttributeValue ▁ const ▁ &' , 'source' ) , param ( 'ns3::AttributeValue ▁ &' , 'destination' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::AttributeChecker::Create() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::AttributeChecker::CreateValidValue(ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CreateValidValue' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] , is_const = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::AttributeChecker::GetUnderlyingTypeInformation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetUnderlyingTypeInformation' , 'std::string' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::AttributeChecker::GetValueTypeName() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValueTypeName' , 'std::string' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeChecker::HasUnderlyingTypeInformation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasUnderlyingTypeInformation' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3AttributeValue_methods ( root_module , cls ) : <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeValue::AttributeValue(ns3::AttributeValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::AttributeValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::AttributeValue::AttributeValue() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::AttributeValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::AttributeValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::AttributeValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3CallbackChecker_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackChecker::CallbackChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackChecker::CallbackChecker(ns3::CallbackChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3CallbackImplBase_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImplBase::CallbackImplBase() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImplBase::CallbackImplBase(ns3::CallbackImplBase ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImplBase ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImplBase::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ bool ▁ ns3::CallbackImplBase::IsEqual(ns3::Ptr<const ▁ ns3::CallbackImplBase> ▁ other) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsEqual' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::CallbackImplBase ▁ const ▁ >' , 'other' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::Demangle(std::string ▁ const ▁ & ▁ mangled) ▁ [member ▁ function] <encdom> cls . add_method ( 'Demangle' , 'std::string' , [ param ( 'std::string ▁ const ▁ &' , 'mangled' ) ] , is_static = True , visibility = 'protected' ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::ObjectBase*' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'void' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::Ptr<ns3::NetDevice> ▁ ' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::Ptr<ns3::Packet ▁ const> ▁ ' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'unsigned ▁ short' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::Address ▁ const&' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::NetDevice::PacketType' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::Ptr<ns3::Socket> ▁ ' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'bool' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'unsigned ▁ int' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'ns3::olsr::PacketHeader ▁ const&' ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImplBase::GetCppTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetCppTypeid' , 'std::string' , [ ] , is_static = True , visibility = 'protected' , template_parameters = [ u'std::vector<ns3::olsr::MessageHeader' , u' ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ const&' ] ) <newline> return <newline> <dedent> def register_Ns3CallbackValue_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackValue::CallbackValue(ns3::CallbackValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::CallbackValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackValue::CallbackValue() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackValue::CallbackValue(ns3::CallbackBase ▁ const ▁ & ▁ base) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackBase ▁ const ▁ &' , 'base' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::CallbackValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ bool ▁ ns3::CallbackValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackValue::Set(ns3::CallbackBase ▁ base) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::CallbackBase' , 'base' ) ] ) <newline> return <newline> <dedent> def register_Ns3ConstantRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ConstantRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ConstantRandomVariable::ConstantRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ConstantRandomVariable::GetConstant() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetConstant' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ConstantRandomVariable::GetValue(double ▁ constant) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'constant' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ConstantRandomVariable::GetInteger(uint32_t ▁ constant) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'constant' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ConstantRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ConstantRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3DeterministicRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::DeterministicRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::DeterministicRandomVariable::DeterministicRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ void ▁ ns3::DeterministicRandomVariable::SetValueArray(double ▁ * ▁ values, ▁ std::size_t ▁ length) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetValueArray' , 'void' , [ param ( 'double ▁ *' , 'values' ) , param ( 'std::size_t' , 'length' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::DeterministicRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::DeterministicRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3EmpiricalRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::EmpiricalRandomVariable::EmpiricalRandomVariable() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ void ▁ ns3::EmpiricalRandomVariable::CDF(double ▁ v, ▁ double ▁ c) ▁ [member ▁ function] <encdom> cls . add_method ( 'CDF' , 'void' , [ param ( 'double' , 'v' ) , param ( 'double' , 'c' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::EmpiricalRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::EmpiricalRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::EmpiricalRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::EmpiricalRandomVariable::Interpolate(double ▁ c1, ▁ double ▁ c2, ▁ double ▁ v1, ▁ double ▁ v2, ▁ double ▁ r) ▁ [member ▁ function] <encdom> cls . add_method ( 'Interpolate' , 'double' , [ param ( 'double' , 'c1' ) , param ( 'double' , 'c2' ) , param ( 'double' , 'v1' ) , param ( 'double' , 'v2' ) , param ( 'double' , 'r' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ void ▁ ns3::EmpiricalRandomVariable::Validate() ▁ [member ▁ function] <encdom> cls . add_method ( 'Validate' , 'void' , [ ] , visibility = 'private' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3EmptyAttributeAccessor_methods ( root_module , cls ) : <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeAccessor::EmptyAttributeAccessor(ns3::EmptyAttributeAccessor ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::EmptyAttributeAccessor ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeAccessor::EmptyAttributeAccessor() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeAccessor::Get(ns3::ObjectBase ▁ const ▁ * ▁ object, ▁ ns3::AttributeValue ▁ & ▁ attribute) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'bool' , [ param ( 'ns3::ObjectBase ▁ const ▁ *' , 'object' ) , param ( 'ns3::AttributeValue ▁ &' , 'attribute' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeAccessor::HasGetter() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasGetter' , 'bool' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeAccessor::HasSetter() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasSetter' , 'bool' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeAccessor::Set(ns3::ObjectBase ▁ * ▁ object, ▁ ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'bool' , [ param ( 'ns3::ObjectBase ▁ *' , 'object' ) , param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3EmptyAttributeChecker_methods ( root_module , cls ) : <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeChecker::EmptyAttributeChecker(ns3::EmptyAttributeChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::EmptyAttributeChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeChecker::EmptyAttributeChecker() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeChecker::Check(ns3::AttributeValue ▁ const ▁ & ▁ value) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Check' , 'bool' , [ param ( 'ns3::AttributeValue ▁ const ▁ &' , 'value' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeChecker::Copy(ns3::AttributeValue ▁ const ▁ & ▁ source, ▁ ns3::AttributeValue ▁ & ▁ destination) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'bool' , [ param ( 'ns3::AttributeValue ▁ const ▁ &' , 'source' ) , param ( 'ns3::AttributeValue ▁ &' , 'destination' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::EmptyAttributeChecker::Create() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Create' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::EmptyAttributeChecker::GetUnderlyingTypeInformation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetUnderlyingTypeInformation' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::EmptyAttributeChecker::GetValueTypeName() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValueTypeName' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeChecker::HasUnderlyingTypeInformation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'HasUnderlyingTypeInformation' , 'bool' , [ ] , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3EmptyAttributeValue_methods ( root_module , cls ) : <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeValue::EmptyAttributeValue(ns3::EmptyAttributeValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::EmptyAttributeValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::EmptyAttributeValue::EmptyAttributeValue() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::EmptyAttributeValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EmptyAttributeValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ attribute.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::EmptyAttributeValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , visibility = 'private' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ErlangRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ErlangRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ErlangRandomVariable::ErlangRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ErlangRandomVariable::GetK() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetK' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ErlangRandomVariable::GetLambda() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLambda' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ErlangRandomVariable::GetValue(uint32_t ▁ k, ▁ double ▁ lambda) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'uint32_t' , 'k' ) , param ( 'double' , 'lambda' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ErlangRandomVariable::GetInteger(uint32_t ▁ k, ▁ uint32_t ▁ lambda) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'k' ) , param ( 'uint32_t' , 'lambda' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ErlangRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ErlangRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3EventImpl_methods ( root_module , cls ) : <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ ns3::EventImpl::EventImpl(ns3::EventImpl ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::EventImpl ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ ns3::EventImpl::EventImpl() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ void ▁ ns3::EventImpl::Cancel() ▁ [member ▁ function] <encdom> cls . add_method ( 'Cancel' , 'void' , [ ] ) <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ void ▁ ns3::EventImpl::Invoke() ▁ [member ▁ function] <encdom> cls . add_method ( 'Invoke' , 'void' , [ ] ) <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ bool ▁ ns3::EventImpl::IsCancelled() ▁ [member ▁ function] <encdom> cls . add_method ( 'IsCancelled' , 'bool' , [ ] ) <newline>  # # ▁ event-impl.h ▁ (module ▁'core'): ▁ void ▁ ns3::EventImpl::Notify() ▁ [member ▁ function] <encdom> cls . add_method ( 'Notify' , 'void' , [ ] , is_pure_virtual = True , visibility = 'protected' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ExponentialRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ExponentialRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ExponentialRandomVariable::ExponentialRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ExponentialRandomVariable::GetMean() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMean' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ExponentialRandomVariable::GetBound() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBound' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ExponentialRandomVariable::GetValue(double ▁ mean, ▁ double ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'mean' ) , param ( 'double' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ExponentialRandomVariable::GetInteger(uint32_t ▁ mean, ▁ uint32_t ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'mean' ) , param ( 'uint32_t' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ExponentialRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ExponentialRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3GammaRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::GammaRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::GammaRandomVariable::GammaRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::GammaRandomVariable::GetAlpha() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAlpha' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::GammaRandomVariable::GetBeta() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBeta' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::GammaRandomVariable::GetValue(double ▁ alpha, ▁ double ▁ beta) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'alpha' ) , param ( 'double' , 'beta' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::GammaRandomVariable::GetInteger(uint32_t ▁ alpha, ▁ uint32_t ▁ beta) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'alpha' ) , param ( 'uint32_t' , 'beta' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::GammaRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::GammaRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Ipv4_methods ( root_module , cls ) : <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4::Ipv4(ns3::Ipv4 ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Ipv4 ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4::Ipv4() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::AddAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAddress' , 'bool' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4::AddInterface(ns3::Ptr<ns3::NetDevice> ▁ device) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddInterface' , 'uint32_t' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'device' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Socket> ▁ ns3::Ipv4::CreateRawSocket() ▁ [member ▁ function] <encdom> cls . add_method ( 'CreateRawSocket' , 'ns3::Ptr< ▁ ns3::Socket ▁ >' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::DeleteRawSocket(ns3::Ptr<ns3::Socket> ▁ socket) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeleteRawSocket' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Socket ▁ >' , 'socket' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4InterfaceAddress ▁ ns3::Ipv4::GetAddress(uint32_t ▁ interface, ▁ uint32_t ▁ addressIndex) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAddress' , 'ns3::Ipv4InterfaceAddress' , [ param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'addressIndex' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ int32_t ▁ ns3::Ipv4::GetInterfaceForAddress(ns3::Ipv4Address ▁ address) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInterfaceForAddress' , 'int32_t' , [ param ( 'ns3::Ipv4Address' , 'address' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ int32_t ▁ ns3::Ipv4::GetInterfaceForDevice(ns3::Ptr<const ▁ ns3::NetDevice> ▁ device) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInterfaceForDevice' , 'int32_t' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ const ▁ >' , 'device' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ int32_t ▁ ns3::Ipv4::GetInterfaceForPrefix(ns3::Ipv4Address ▁ address, ▁ ns3::Ipv4Mask ▁ mask) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInterfaceForPrefix' , 'int32_t' , [ param ( 'ns3::Ipv4Address' , 'address' ) , param ( 'ns3::Ipv4Mask' , 'mask' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ uint16_t ▁ ns3::Ipv4::GetMetric(uint32_t ▁ interface) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMetric' , 'uint16_t' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ uint16_t ▁ ns3::Ipv4::GetMtu(uint32_t ▁ interface) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMtu' , 'uint16_t' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4::GetNAddresses(uint32_t ▁ interface) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNAddresses' , 'uint32_t' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4::GetNInterfaces() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNInterfaces' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::NetDevice> ▁ ns3::Ipv4::GetNetDevice(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNetDevice' , 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::IpL4Protocol> ▁ ns3::Ipv4::GetProtocol(int ▁ protocolNumber) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetProtocol' , 'ns3::Ptr< ▁ ns3::IpL4Protocol ▁ >' , [ param ( 'int' , 'protocolNumber' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::IpL4Protocol> ▁ ns3::Ipv4::GetProtocol(int ▁ protocolNumber, ▁ int32_t ▁ interfaceIndex) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetProtocol' , 'ns3::Ptr< ▁ ns3::IpL4Protocol ▁ >' , [ param ( 'int' , 'protocolNumber' ) , param ( 'int32_t' , 'interfaceIndex' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Ipv4RoutingProtocol> ▁ ns3::Ipv4::GetRoutingProtocol() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRoutingProtocol' , 'ns3::Ptr< ▁ ns3::Ipv4RoutingProtocol ▁ >' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ static ▁ ns3::TypeId ▁ ns3::Ipv4::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::Insert(ns3::Ptr<ns3::IpL4Protocol> ▁ protocol) ▁ [member ▁ function] <encdom> cls . add_method ( 'Insert' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::IpL4Protocol ▁ >' , 'protocol' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::Insert(ns3::Ptr<ns3::IpL4Protocol> ▁ protocol, ▁ uint32_t ▁ interfaceIndex) ▁ [member ▁ function] <encdom> cls . add_method ( 'Insert' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::IpL4Protocol ▁ >' , 'protocol' ) , param ( 'uint32_t' , 'interfaceIndex' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::IsDestinationAddress(ns3::Ipv4Address ▁ address, ▁ uint32_t ▁ iif) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsDestinationAddress' , 'bool' , [ param ( 'ns3::Ipv4Address' , 'address' ) , param ( 'uint32_t' , 'iif' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::IsForwarding(uint32_t ▁ interface) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsForwarding' , 'bool' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::IsUp(uint32_t ▁ interface) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsUp' , 'bool' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::Remove(ns3::Ptr<ns3::IpL4Protocol> ▁ protocol) ▁ [member ▁ function] <encdom> cls . add_method ( 'Remove' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::IpL4Protocol ▁ >' , 'protocol' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::Remove(ns3::Ptr<ns3::IpL4Protocol> ▁ protocol, ▁ uint32_t ▁ interfaceIndex) ▁ [member ▁ function] <encdom> cls . add_method ( 'Remove' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::IpL4Protocol ▁ >' , 'protocol' ) , param ( 'uint32_t' , 'interfaceIndex' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::RemoveAddress(uint32_t ▁ interface, ▁ uint32_t ▁ addressIndex) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAddress' , 'bool' , [ param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'addressIndex' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::RemoveAddress(uint32_t ▁ interface, ▁ ns3::Ipv4Address ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAddress' , 'bool' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4Address' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4::SelectSourceAddress(ns3::Ptr<const ▁ ns3::NetDevice> ▁ device, ▁ ns3::Ipv4Address ▁ dst, ▁ ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e ▁ scope) ▁ [member ▁ function] <encdom> cls . add_method ( 'SelectSourceAddress' , 'ns3::Ipv4Address' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ const ▁ >' , 'device' ) , param ( 'ns3::Ipv4Address' , 'dst' ) , param ( 'ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e' , 'scope' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::Send(ns3::Ptr<ns3::Packet> ▁ packet, ▁ ns3::Ipv4Address ▁ source, ▁ ns3::Ipv4Address ▁ destination, ▁ uint8_t ▁ protocol, ▁ ns3::Ptr<ns3::Ipv4Route> ▁ route) ▁ [member ▁ function] <encdom> cls . add_method ( 'Send' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'packet' ) , param ( 'ns3::Ipv4Address' , 'source' ) , param ( 'ns3::Ipv4Address' , 'destination' ) , param ( 'uint8_t' , 'protocol' ) , param ( 'ns3::Ptr< ▁ ns3::Ipv4Route ▁ >' , 'route' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SendWithHeader(ns3::Ptr<ns3::Packet> ▁ packet, ▁ ns3::Ipv4Header ▁ ipHeader, ▁ ns3::Ptr<ns3::Ipv4Route> ▁ route) ▁ [member ▁ function] <encdom> cls . add_method ( 'SendWithHeader' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'packet' ) , param ( 'ns3::Ipv4Header' , 'ipHeader' ) , param ( 'ns3::Ptr< ▁ ns3::Ipv4Route ▁ >' , 'route' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetDown(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDown' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetForwarding(uint32_t ▁ interface, ▁ bool ▁ val) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetForwarding' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'bool' , 'val' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetMetric(uint32_t ▁ interface, ▁ uint16_t ▁ metric) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMetric' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'uint16_t' , 'metric' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetRoutingProtocol(ns3::Ptr<ns3::Ipv4RoutingProtocol> ▁ routingProtocol) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetRoutingProtocol' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4RoutingProtocol ▁ >' , 'routingProtocol' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetUp(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetUp' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4::SourceAddressSelection(uint32_t ▁ interface, ▁ ns3::Ipv4Address ▁ dest) ▁ [member ▁ function] <encdom> cls . add_method ( 'SourceAddressSelection' , 'ns3::Ipv4Address' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4Address' , 'dest' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ ns3::Ipv4::IF_ANY ▁ [variable] <encdom> cls . add_static_attribute ( 'IF_ANY' , 'uint32_t ▁ const' , is_const = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::GetIpForward() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIpForward' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4::GetWeakEsModel() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetWeakEsModel' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetIpForward(bool ▁ forward) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpForward' , 'void' , [ param ( 'bool' , 'forward' ) ] , is_pure_virtual = True , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ ipv4.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4::SetWeakEsModel(bool ▁ model) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetWeakEsModel' , 'void' , [ param ( 'bool' , 'model' ) ] , is_pure_virtual = True , visibility = 'private' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Ipv4AddressChecker_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressChecker::Ipv4AddressChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressChecker::Ipv4AddressChecker(ns3::Ipv4AddressChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4AddressChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4AddressValue_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressValue::Ipv4AddressValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressValue::Ipv4AddressValue(ns3::Ipv4Address ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4AddressValue::Ipv4AddressValue(ns3::Ipv4AddressValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4AddressValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::Ipv4AddressValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4AddressValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4AddressValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::Ipv4AddressValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4AddressValue::Set(ns3::Ipv4Address ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4MaskChecker_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskChecker::Ipv4MaskChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskChecker::Ipv4MaskChecker(ns3::Ipv4MaskChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4MaskChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4MaskValue_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskValue::Ipv4MaskValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskValue::Ipv4MaskValue(ns3::Ipv4Mask ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4MaskValue::Ipv4MaskValue(ns3::Ipv4MaskValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4MaskValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::Ipv4MaskValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv4MaskValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ ns3::Ipv4Mask ▁ ns3::Ipv4MaskValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Ipv4Mask' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::Ipv4MaskValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv4MaskValue::Set(ns3::Ipv4Mask ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4MulticastRoute_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4MulticastRoute::Ipv4MulticastRoute(ns3::Ipv4MulticastRoute ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Ipv4MulticastRoute ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4MulticastRoute::Ipv4MulticastRoute() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4MulticastRoute::GetGroup() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetGroup' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4MulticastRoute::GetOrigin() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOrigin' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ std::map<unsigned ▁ int, ▁ unsigned ▁ int, ▁ std::less<unsigned ▁ int>, ▁ std::allocator<std::pair<const ▁ unsigned ▁ int, ▁ unsigned ▁ int> ▁ > ▁ > ▁ ns3::Ipv4MulticastRoute::GetOutputTtlMap() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOutputTtlMap' , 'std::map< ▁ unsigned ▁ int, ▁ unsigned ▁ int ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4MulticastRoute::GetParent() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetParent' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4MulticastRoute::SetGroup(ns3::Ipv4Address ▁ const ▁ group) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetGroup' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const' , 'group' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4MulticastRoute::SetOrigin(ns3::Ipv4Address ▁ const ▁ origin) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetOrigin' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const' , 'origin' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4MulticastRoute::SetOutputTtl(uint32_t ▁ oif, ▁ uint32_t ▁ ttl) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetOutputTtl' , 'void' , [ param ( 'uint32_t' , 'oif' ) , param ( 'uint32_t' , 'ttl' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4MulticastRoute::SetParent(uint32_t ▁ iif) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetParent' , 'void' , [ param ( 'uint32_t' , 'iif' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4MulticastRoute::MAX_INTERFACES ▁ [variable] <encdom> cls . add_static_attribute ( 'MAX_INTERFACES' , 'uint32_t ▁ const' , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4MulticastRoute::MAX_TTL ▁ [variable] <encdom> cls . add_static_attribute ( 'MAX_TTL' , 'uint32_t ▁ const' , is_const = True ) <newline> return <newline> <dedent> def register_Ns3Ipv4Route_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Route::Ipv4Route(ns3::Ipv4Route ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4Route ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Route::Ipv4Route() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Route::GetDestination() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDestination' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Route::GetGateway() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetGateway' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::NetDevice> ▁ ns3::Ipv4Route::GetOutputDevice() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOutputDevice' , 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ ns3::Ipv4Address ▁ ns3::Ipv4Route::GetSource() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSource' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Route::SetDestination(ns3::Ipv4Address ▁ dest) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDestination' , 'void' , [ param ( 'ns3::Ipv4Address' , 'dest' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Route::SetGateway(ns3::Ipv4Address ▁ gw) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetGateway' , 'void' , [ param ( 'ns3::Ipv4Address' , 'gw' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Route::SetOutputDevice(ns3::Ptr<ns3::NetDevice> ▁ outputDevice) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetOutputDevice' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'outputDevice' ) ] ) <newline>  # # ▁ ipv4-route.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4Route::SetSource(ns3::Ipv4Address ▁ src) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetSource' , 'void' , [ param ( 'ns3::Ipv4Address' , 'src' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv4RoutingProtocol_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingProtocol::Ipv4RoutingProtocol() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingProtocol::Ipv4RoutingProtocol(ns3::Ipv4RoutingProtocol ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv4RoutingProtocol ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ static ▁ ns3::TypeId ▁ ns3::Ipv4RoutingProtocol::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4RoutingProtocol::NotifyAddAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyAddAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4RoutingProtocol::NotifyInterfaceDown(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceDown' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4RoutingProtocol::NotifyInterfaceUp(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceUp' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4RoutingProtocol::NotifyRemoveAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyRemoveAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4RoutingProtocol::PrintRoutingTable(ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTable' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4RoutingProtocol::RouteInput(ns3::Ptr<const ▁ ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<const ▁ ns3::NetDevice> ▁ idev, ▁ ns3::Ipv4RoutingProtocol::UnicastForwardCallback ▁ ucb, ▁ ns3::Ipv4RoutingProtocol::MulticastForwardCallback ▁ mcb, ▁ ns3::Ipv4RoutingProtocol::LocalDeliverCallback ▁ lcb, ▁ ns3::Ipv4RoutingProtocol::ErrorCallback ▁ ecb) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteInput' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ const ▁ >' , 'idev' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ucb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'mcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'lcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ecb' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Ipv4Route> ▁ ns3::Ipv4RoutingProtocol::RouteOutput(ns3::Ptr<ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<ns3::NetDevice> ▁ oif, ▁ ns3::Socket::SocketErrno ▁ & ▁ sockerr) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteOutput' , 'ns3::Ptr< ▁ ns3::Ipv4Route ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'oif' ) , param ( 'ns3::Socket::SocketErrno ▁ &' , 'sockerr' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ ipv4-routing-protocol.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4RoutingProtocol::SetIpv4(ns3::Ptr<ns3::Ipv4> ▁ ipv4) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv4' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4 ▁ >' , 'ipv4' ) ] , is_pure_virtual = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Ipv4StaticRouting_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4StaticRouting::Ipv4StaticRouting(ns3::Ipv4StaticRouting ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Ipv4StaticRouting ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4StaticRouting::Ipv4StaticRouting() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::AddHostRouteTo(ns3::Ipv4Address ▁ dest, ▁ ns3::Ipv4Address ▁ nextHop, ▁ uint32_t ▁ interface, ▁ uint32_t ▁ metric=0) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddHostRouteTo' , 'void' , [ param ( 'ns3::Ipv4Address' , 'dest' ) , param ( 'ns3::Ipv4Address' , 'nextHop' ) , param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'metric' , default_value = '0' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::AddHostRouteTo(ns3::Ipv4Address ▁ dest, ▁ uint32_t ▁ interface, ▁ uint32_t ▁ metric=0) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddHostRouteTo' , 'void' , [ param ( 'ns3::Ipv4Address' , 'dest' ) , param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'metric' , default_value = '0' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::AddMulticastRoute(ns3::Ipv4Address ▁ origin, ▁ ns3::Ipv4Address ▁ group, ▁ uint32_t ▁ inputInterface, ▁ std::vector<unsigned ▁ int, ▁ std::allocator<unsigned ▁ int> ▁ > ▁ outputInterfaces) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddMulticastRoute' , 'void' , [ param ( 'ns3::Ipv4Address' , 'origin' ) , param ( 'ns3::Ipv4Address' , 'group' ) , param ( 'uint32_t' , 'inputInterface' ) , param ( 'std::vector< ▁ unsigned ▁ int ▁ >' , 'outputInterfaces' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::AddNetworkRouteTo(ns3::Ipv4Address ▁ network, ▁ ns3::Ipv4Mask ▁ networkMask, ▁ ns3::Ipv4Address ▁ nextHop, ▁ uint32_t ▁ interface, ▁ uint32_t ▁ metric=0) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddNetworkRouteTo' , 'void' , [ param ( 'ns3::Ipv4Address' , 'network' ) , param ( 'ns3::Ipv4Mask' , 'networkMask' ) , param ( 'ns3::Ipv4Address' , 'nextHop' ) , param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'metric' , default_value = '0' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::AddNetworkRouteTo(ns3::Ipv4Address ▁ network, ▁ ns3::Ipv4Mask ▁ networkMask, ▁ uint32_t ▁ interface, ▁ uint32_t ▁ metric=0) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddNetworkRouteTo' , 'void' , [ param ( 'ns3::Ipv4Address' , 'network' ) , param ( 'ns3::Ipv4Mask' , 'networkMask' ) , param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'metric' , default_value = '0' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingTableEntry ▁ ns3::Ipv4StaticRouting::GetDefaultRoute() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDefaultRoute' , 'ns3::Ipv4RoutingTableEntry' , [ ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4StaticRouting::GetMetric(uint32_t ▁ index) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMetric' , 'uint32_t' , [ param ( 'uint32_t' , 'index' ) ] , is_const = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4MulticastRoutingTableEntry ▁ ns3::Ipv4StaticRouting::GetMulticastRoute(uint32_t ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticastRoute' , 'ns3::Ipv4MulticastRoutingTableEntry' , [ param ( 'uint32_t' , 'i' ) ] , is_const = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4StaticRouting::GetNMulticastRoutes() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNMulticastRoutes' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4StaticRouting::GetNRoutes() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNRoutes' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4RoutingTableEntry ▁ ns3::Ipv4StaticRouting::GetRoute(uint32_t ▁ i) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRoute' , 'ns3::Ipv4RoutingTableEntry' , [ param ( 'uint32_t' , 'i' ) ] , is_const = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ static ▁ ns3::TypeId ▁ ns3::Ipv4StaticRouting::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::NotifyAddAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyAddAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::NotifyInterfaceDown(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceDown' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::NotifyInterfaceUp(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceUp' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::NotifyRemoveAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyRemoveAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::PrintRoutingTable(ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTable' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4StaticRouting::RemoveMulticastRoute(ns3::Ipv4Address ▁ origin, ▁ ns3::Ipv4Address ▁ group, ▁ uint32_t ▁ inputInterface) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveMulticastRoute' , 'bool' , [ param ( 'ns3::Ipv4Address' , 'origin' ) , param ( 'ns3::Ipv4Address' , 'group' ) , param ( 'uint32_t' , 'inputInterface' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::RemoveMulticastRoute(uint32_t ▁ index) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveMulticastRoute' , 'void' , [ param ( 'uint32_t' , 'index' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::RemoveRoute(uint32_t ▁ i) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveRoute' , 'void' , [ param ( 'uint32_t' , 'i' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4StaticRouting::RouteInput(ns3::Ptr<const ▁ ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<const ▁ ns3::NetDevice> ▁ idev, ▁ ns3::Ipv4RoutingProtocol::UnicastForwardCallback ▁ ucb, ▁ ns3::Ipv4RoutingProtocol::MulticastForwardCallback ▁ mcb, ▁ ns3::Ipv4RoutingProtocol::LocalDeliverCallback ▁ lcb, ▁ ns3::Ipv4RoutingProtocol::ErrorCallback ▁ ecb) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteInput' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ const ▁ >' , 'idev' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ucb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'mcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'lcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ecb' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Ipv4Route> ▁ ns3::Ipv4StaticRouting::RouteOutput(ns3::Ptr<ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<ns3::NetDevice> ▁ oif, ▁ ns3::Socket::SocketErrno ▁ & ▁ sockerr) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteOutput' , 'ns3::Ptr< ▁ ns3::Ipv4Route ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'oif' ) , param ( 'ns3::Socket::SocketErrno ▁ &' , 'sockerr' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::SetDefaultMulticastRoute(uint32_t ▁ outputInterface) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDefaultMulticastRoute' , 'void' , [ param ( 'uint32_t' , 'outputInterface' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::SetDefaultRoute(ns3::Ipv4Address ▁ nextHop, ▁ uint32_t ▁ interface, ▁ uint32_t ▁ metric=0) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetDefaultRoute' , 'void' , [ param ( 'ns3::Ipv4Address' , 'nextHop' ) , param ( 'uint32_t' , 'interface' ) , param ( 'uint32_t' , 'metric' , default_value = '0' ) ] ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::SetIpv4(ns3::Ptr<ns3::Ipv4> ▁ ipv4) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv4' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4 ▁ >' , 'ipv4' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-static-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4StaticRouting::DoDispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoDispose' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Ipv6AddressChecker_methods ( root_module , cls ) : <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressChecker::Ipv6AddressChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressChecker::Ipv6AddressChecker(ns3::Ipv6AddressChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6AddressChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv6AddressValue_methods ( root_module , cls ) : <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressValue::Ipv6AddressValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressValue::Ipv6AddressValue(ns3::Ipv6Address ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Address ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6AddressValue::Ipv6AddressValue(ns3::Ipv6AddressValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6AddressValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::Ipv6AddressValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6AddressValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Address ▁ ns3::Ipv6AddressValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Ipv6Address' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::Ipv6AddressValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6AddressValue::Set(ns3::Ipv6Address ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Ipv6Address ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv6PrefixChecker_methods ( root_module , cls ) : <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixChecker::Ipv6PrefixChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixChecker::Ipv6PrefixChecker(ns3::Ipv6PrefixChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6PrefixChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Ipv6PrefixValue_methods ( root_module , cls ) : <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixValue::Ipv6PrefixValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixValue::Ipv6PrefixValue(ns3::Ipv6Prefix ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6Prefix ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6PrefixValue::Ipv6PrefixValue(ns3::Ipv6PrefixValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Ipv6PrefixValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::Ipv6PrefixValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Ipv6PrefixValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ ns3::Ipv6Prefix ▁ ns3::Ipv6PrefixValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Ipv6Prefix' , [ ] , is_const = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::Ipv6PrefixValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv6-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Ipv6PrefixValue::Set(ns3::Ipv6Prefix ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Ipv6Prefix ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3LogNormalRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::LogNormalRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::LogNormalRandomVariable::LogNormalRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::LogNormalRandomVariable::GetMu() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMu' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::LogNormalRandomVariable::GetSigma() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSigma' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::LogNormalRandomVariable::GetValue(double ▁ mu, ▁ double ▁ sigma) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'mu' ) , param ( 'double' , 'sigma' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::LogNormalRandomVariable::GetInteger(uint32_t ▁ mu, ▁ uint32_t ▁ sigma) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'mu' ) , param ( 'uint32_t' , 'sigma' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::LogNormalRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::LogNormalRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3Mac48AddressChecker_methods ( root_module , cls ) : <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressChecker::Mac48AddressChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressChecker::Mac48AddressChecker(ns3::Mac48AddressChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Mac48AddressChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3Mac48AddressValue_methods ( root_module , cls ) : <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressValue::Mac48AddressValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressValue::Mac48AddressValue(ns3::Mac48Address ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Mac48Address ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48AddressValue::Mac48AddressValue(ns3::Mac48AddressValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Mac48AddressValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::Mac48AddressValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Mac48AddressValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ ns3::Mac48Address ▁ ns3::Mac48AddressValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Mac48Address' , [ ] , is_const = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::Mac48AddressValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ mac48-address.h ▁ (module ▁'network'): ▁ void ▁ ns3::Mac48AddressValue::Set(ns3::Mac48Address ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Mac48Address ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3NetDevice_methods ( root_module , cls ) : <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::NetDevice::NetDevice() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::NetDevice::NetDevice(ns3::NetDevice ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::NetDevice ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ void ▁ ns3::NetDevice::AddLinkChangeCallback(ns3::Callback<void, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ callback) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddLinkChangeCallback' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'callback' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::Address ▁ ns3::NetDevice::GetAddress() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAddress' , 'ns3::Address' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::Address ▁ ns3::NetDevice::GetBroadcast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBroadcast' , 'ns3::Address' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Channel> ▁ ns3::NetDevice::GetChannel() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetChannel' , 'ns3::Ptr< ▁ ns3::Channel ▁ >' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NetDevice::GetIfIndex() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIfIndex' , 'uint32_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ uint16_t ▁ ns3::NetDevice::GetMtu() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMtu' , 'uint16_t' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::Address ▁ ns3::NetDevice::GetMulticast(ns3::Ipv4Address ▁ multicastGroup) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticast' , 'ns3::Address' , [ param ( 'ns3::Ipv4Address' , 'multicastGroup' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::Address ▁ ns3::NetDevice::GetMulticast(ns3::Ipv6Address ▁ addr) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMulticast' , 'ns3::Address' , [ param ( 'ns3::Ipv6Address' , 'addr' ) ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Node> ▁ ns3::NetDevice::GetNode() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNode' , 'ns3::Ptr< ▁ ns3::Node ▁ >' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::NetDevice::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::IsBridge() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsBridge' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::IsBroadcast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsBroadcast' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::IsLinkUp() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsLinkUp' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::IsMulticast() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsMulticast' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::IsPointToPoint() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'IsPointToPoint' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::NeedsArp() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'NeedsArp' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::Send(ns3::Ptr<ns3::Packet> ▁ packet, ▁ ns3::Address ▁ const ▁ & ▁ dest, ▁ uint16_t ▁ protocolNumber) ▁ [member ▁ function] <encdom> cls . add_method ( 'Send' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'packet' ) , param ( 'ns3::Address ▁ const ▁ &' , 'dest' ) , param ( 'uint16_t' , 'protocolNumber' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::SendFrom(ns3::Ptr<ns3::Packet> ▁ packet, ▁ ns3::Address ▁ const ▁ & ▁ source, ▁ ns3::Address ▁ const ▁ & ▁ dest, ▁ uint16_t ▁ protocolNumber) ▁ [member ▁ function] <encdom> cls . add_method ( 'SendFrom' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'packet' ) , param ( 'ns3::Address ▁ const ▁ &' , 'source' ) , param ( 'ns3::Address ▁ const ▁ &' , 'dest' ) , param ( 'uint16_t' , 'protocolNumber' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ void ▁ ns3::NetDevice::SetAddress(ns3::Address ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetAddress' , 'void' , [ param ( 'ns3::Address' , 'address' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ void ▁ ns3::NetDevice::SetIfIndex(uint32_t ▁ const ▁ index) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIfIndex' , 'void' , [ param ( 'uint32_t ▁ const' , 'index' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::SetMtu(uint16_t ▁ const ▁ mtu) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMtu' , 'bool' , [ param ( 'uint16_t ▁ const' , 'mtu' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ void ▁ ns3::NetDevice::SetNode(ns3::Ptr<ns3::Node> ▁ node) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetNode' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Node ▁ >' , 'node' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ void ▁ ns3::NetDevice::SetPromiscReceiveCallback(ns3::NetDevice::PromiscReceiveCallback ▁ cb) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPromiscReceiveCallback' , 'void' , [ param ( 'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'cb' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ void ▁ ns3::NetDevice::SetReceiveCallback(ns3::NetDevice::ReceiveCallback ▁ cb) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetReceiveCallback' , 'void' , [ param ( 'ns3::Callback< ▁ bool, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'cb' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ net-device.h ▁ (module ▁'network'): ▁ bool ▁ ns3::NetDevice::SupportsSendFrom() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SupportsSendFrom' , 'bool' , [ ] , is_pure_virtual = True , is_const = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3NixVector_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ ns3::NixVector::NixVector() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ ns3::NixVector::NixVector(ns3::NixVector ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::NixVector ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ void ▁ ns3::NixVector::AddNeighborIndex(uint32_t ▁ newBits, ▁ uint32_t ▁ numberOfBits) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddNeighborIndex' , 'void' , [ param ( 'uint32_t' , 'newBits' ) , param ( 'uint32_t' , 'numberOfBits' ) ] ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NixVector::BitCount(uint32_t ▁ numberOfNeighbors) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'BitCount' , 'uint32_t' , [ param ( 'uint32_t' , 'numberOfNeighbors' ) ] , is_const = True ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::NixVector> ▁ ns3::NixVector::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::NixVector ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NixVector::Deserialize(uint32_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'uint32_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NixVector::ExtractNeighborIndex(uint32_t ▁ numberOfBits) ▁ [member ▁ function] <encdom> cls . add_method ( 'ExtractNeighborIndex' , 'uint32_t' , [ param ( 'uint32_t' , 'numberOfBits' ) ] ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NixVector::GetRemainingBits() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRemainingBits' , 'uint32_t' , [ ] ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NixVector::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ nix-vector.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::NixVector::Serialize(uint32_t ▁ * ▁ buffer, ▁ uint32_t ▁ maxSize) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'uint32_t' , [ param ( 'uint32_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'maxSize' ) ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3Node_methods ( root_module , cls ) : <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Node::Node(ns3::Node ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Node ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Node::Node() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Node::Node(uint32_t ▁ systemId) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint32_t' , 'systemId' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Node::AddApplication(ns3::Ptr<ns3::Application> ▁ application) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddApplication' , 'uint32_t' , [ param ( 'ns3::Ptr< ▁ ns3::Application ▁ >' , 'application' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Node::AddDevice(ns3::Ptr<ns3::NetDevice> ▁ device) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddDevice' , 'uint32_t' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'device' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ static ▁ bool ▁ ns3::Node::ChecksumEnabled() ▁ [member ▁ function] <encdom> cls . add_method ( 'ChecksumEnabled' , 'bool' , [ ] , is_static = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Application> ▁ ns3::Node::GetApplication(uint32_t ▁ index) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetApplication' , 'ns3::Ptr< ▁ ns3::Application ▁ >' , [ param ( 'uint32_t' , 'index' ) ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::NetDevice> ▁ ns3::Node::GetDevice(uint32_t ▁ index) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetDevice' , 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , [ param ( 'uint32_t' , 'index' ) ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Node::GetId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetId' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ ns3::Time ▁ ns3::Node::GetLocalTime() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLocalTime' , 'ns3::Time' , [ ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Node::GetNApplications() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNApplications' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Node::GetNDevices() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNDevices' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Node::GetSystemId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSystemId' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ static ▁ ns3::TypeId ▁ ns3::Node::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ void ▁ ns3::Node::RegisterDeviceAdditionListener(ns3::Node::DeviceAdditionListener ▁ listener) ▁ [member ▁ function] <encdom> cls . add_method ( 'RegisterDeviceAdditionListener' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'listener' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ void ▁ ns3::Node::RegisterProtocolHandler(ns3::Node::ProtocolHandler ▁ handler, ▁ uint16_t ▁ protocolType, ▁ ns3::Ptr<ns3::NetDevice> ▁ device, ▁ bool ▁ promiscuous=false) ▁ [member ▁ function] <encdom> cls . add_method ( 'RegisterProtocolHandler' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'handler' ) , param ( 'uint16_t' , 'protocolType' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'device' ) , param ( 'bool' , 'promiscuous' , default_value = 'false' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ void ▁ ns3::Node::UnregisterDeviceAdditionListener(ns3::Node::DeviceAdditionListener ▁ listener) ▁ [member ▁ function] <encdom> cls . add_method ( 'UnregisterDeviceAdditionListener' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'listener' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ void ▁ ns3::Node::UnregisterProtocolHandler(ns3::Node::ProtocolHandler ▁ handler) ▁ [member ▁ function] <encdom> cls . add_method ( 'UnregisterProtocolHandler' , 'void' , [ param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'handler' ) ] ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ void ▁ ns3::Node::DoDispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoDispose' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline>  # # ▁ node.h ▁ (module ▁'network'): ▁ void ▁ ns3::Node::DoInitialize() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoInitialize' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3NormalRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::NormalRandomVariable::INFINITE_VALUE ▁ [variable] <encdom> <indent> cls . add_static_attribute ( 'INFINITE_VALUE' , 'double ▁ const' , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::NormalRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::NormalRandomVariable::NormalRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::NormalRandomVariable::GetMean() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMean' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::NormalRandomVariable::GetVariance() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetVariance' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::NormalRandomVariable::GetBound() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBound' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::NormalRandomVariable::GetValue(double ▁ mean, ▁ double ▁ variance, ▁ double ▁ bound=ns3::NormalRandomVariable::INFINITE_VALUE) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'mean' ) , param ( 'double' , 'variance' ) , param ( 'double' , 'bound' , default_value = 'ns3::NormalRandomVariable::INFINITE_VALUE' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::NormalRandomVariable::GetInteger(uint32_t ▁ mean, ▁ uint32_t ▁ variance, ▁ uint32_t ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'mean' ) , param ( 'uint32_t' , 'variance' ) , param ( 'uint32_t' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::NormalRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::NormalRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3ObjectFactoryChecker_methods ( root_module , cls ) : <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryChecker::ObjectFactoryChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryChecker::ObjectFactoryChecker(ns3::ObjectFactoryChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ObjectFactoryChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3ObjectFactoryValue_methods ( root_module , cls ) : <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryValue::ObjectFactoryValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryValue::ObjectFactoryValue(ns3::ObjectFactory ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ObjectFactory ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactoryValue::ObjectFactoryValue(ns3::ObjectFactoryValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::ObjectFactoryValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::ObjectFactoryValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ bool ▁ ns3::ObjectFactoryValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ ns3::ObjectFactory ▁ ns3::ObjectFactoryValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::ObjectFactory' , [ ] , is_const = True ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::ObjectFactoryValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ object-factory.h ▁ (module ▁'core'): ▁ void ▁ ns3::ObjectFactoryValue::Set(ns3::ObjectFactory ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::ObjectFactory ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3OutputStreamWrapper_methods ( root_module , cls ) : <newline>  # # ▁ output-stream-wrapper.h ▁ (module ▁'network'): ▁ ns3::OutputStreamWrapper::OutputStreamWrapper(ns3::OutputStreamWrapper ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::OutputStreamWrapper ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ output-stream-wrapper.h ▁ (module ▁'network'): ▁ ns3::OutputStreamWrapper::OutputStreamWrapper(std::string ▁ filename, ▁ std::ios_base::openmode ▁ filemode) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'std::string' , 'filename' ) , param ( 'std::ios_base::openmode' , 'filemode' ) ] ) <newline>  # # ▁ output-stream-wrapper.h ▁ (module ▁'network'): ▁ ns3::OutputStreamWrapper::OutputStreamWrapper(std::ostream ▁ * ▁ os) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'std::ostream ▁ *' , 'os' ) ] ) <newline>  # # ▁ output-stream-wrapper.h ▁ (module ▁'network'): ▁ std::ostream ▁ * ▁ ns3::OutputStreamWrapper::GetStream() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetStream' , 'std::ostream ▁ *' , [ ] ) <newline> return <newline> <dedent> def register_Ns3Packet_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Packet::Packet() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Packet::Packet(ns3::Packet ▁ const ▁ & ▁ o) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Packet ▁ const ▁ &' , 'o' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Packet::Packet(uint32_t ▁ size) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Packet::Packet(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size, ▁ bool ▁ magic) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) , param ( 'bool' , 'magic' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Packet::Packet(uint8_t ▁ const ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'uint8_t ▁ const ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::AddAtEnd(ns3::Ptr<const ▁ ns3::Packet> ▁ packet) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddAtEnd' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >' , 'packet' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::AddByteTag(ns3::Tag ▁ const ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'AddByteTag' , 'void' , [ param ( 'ns3::Tag ▁ const ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::AddHeader(ns3::Header ▁ const ▁ & ▁ header) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddHeader' , 'void' , [ param ( 'ns3::Header ▁ const ▁ &' , 'header' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::AddPacketTag(ns3::Tag ▁ const ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'AddPacketTag' , 'void' , [ param ( 'ns3::Tag ▁ const ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::AddPaddingAtEnd(uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddPaddingAtEnd' , 'void' , [ param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::AddTrailer(ns3::Trailer ▁ const ▁ & ▁ trailer) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddTrailer' , 'void' , [ param ( 'ns3::Trailer ▁ const ▁ &' , 'trailer' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketMetadata::ItemIterator ▁ ns3::Packet::BeginItem() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'BeginItem' , 'ns3::PacketMetadata::ItemIterator' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Packet> ▁ ns3::Packet::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::Packet ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::CopyData(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ size) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyData' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'size' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::CopyData(std::ostream ▁ * ▁ os, ▁ uint32_t ▁ size) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CopyData' , 'void' , [ param ( 'std::ostream ▁ *' , 'os' ) , param ( 'uint32_t' , 'size' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::Packet> ▁ ns3::Packet::CreateFragment(uint32_t ▁ start, ▁ uint32_t ▁ length) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'CreateFragment' , 'ns3::Ptr< ▁ ns3::Packet ▁ >' , [ param ( 'uint32_t' , 'start' ) , param ( 'uint32_t' , 'length' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ static ▁ void ▁ ns3::Packet::EnableChecking() ▁ [member ▁ function] <encdom> cls . add_method ( 'EnableChecking' , 'void' , [ ] , is_static = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ static ▁ void ▁ ns3::Packet::EnablePrinting() ▁ [member ▁ function] <encdom> cls . add_method ( 'EnablePrinting' , 'void' , [ ] , is_static = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Packet::FindFirstMatchingByteTag(ns3::Tag ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'FindFirstMatchingByteTag' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::ByteTagIterator ▁ ns3::Packet::GetByteTagIterator() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetByteTagIterator' , 'ns3::ByteTagIterator' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::NixVector> ▁ ns3::Packet::GetNixVector() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNixVector' , 'ns3::Ptr< ▁ ns3::NixVector ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ ns3::PacketTagIterator ▁ ns3::Packet::GetPacketTagIterator() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPacketTagIterator' , 'ns3::PacketTagIterator' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::GetSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint64_t ▁ ns3::Packet::GetUid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetUid' , 'uint64_t' , [ ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::PeekHeader(ns3::Header ▁ & ▁ header) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekHeader' , 'uint32_t' , [ param ( 'ns3::Header ▁ &' , 'header' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::PeekHeader(ns3::Header ▁ & ▁ header, ▁ uint32_t ▁ size) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekHeader' , 'uint32_t' , [ param ( 'ns3::Header ▁ &' , 'header' ) , param ( 'uint32_t' , 'size' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Packet::PeekPacketTag(ns3::Tag ▁ & ▁ tag) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekPacketTag' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::PeekTrailer(ns3::Trailer ▁ & ▁ trailer) ▁ [member ▁ function] <encdom> cls . add_method ( 'PeekTrailer' , 'uint32_t' , [ param ( 'ns3::Trailer ▁ &' , 'trailer' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::PrintByteTags(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintByteTags' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::PrintPacketTags(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintPacketTags' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::RemoveAllByteTags() ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAllByteTags' , 'void' , [ ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::RemoveAllPacketTags() ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAllPacketTags' , 'void' , [ ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::RemoveAtEnd(uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAtEnd' , 'void' , [ param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::RemoveAtStart(uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveAtStart' , 'void' , [ param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::RemoveHeader(ns3::Header ▁ & ▁ header) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveHeader' , 'uint32_t' , [ param ( 'ns3::Header ▁ &' , 'header' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::RemoveHeader(ns3::Header ▁ & ▁ header, ▁ uint32_t ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveHeader' , 'uint32_t' , [ param ( 'ns3::Header ▁ &' , 'header' ) , param ( 'uint32_t' , 'size' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Packet::RemovePacketTag(ns3::Tag ▁ & ▁ tag) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemovePacketTag' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::RemoveTrailer(ns3::Trailer ▁ & ▁ trailer) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveTrailer' , 'uint32_t' , [ param ( 'ns3::Trailer ▁ &' , 'trailer' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ bool ▁ ns3::Packet::ReplacePacketTag(ns3::Tag ▁ & ▁ tag) ▁ [member ▁ function] <encdom> cls . add_method ( 'ReplacePacketTag' , 'bool' , [ param ( 'ns3::Tag ▁ &' , 'tag' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ uint32_t ▁ ns3::Packet::Serialize(uint8_t ▁ * ▁ buffer, ▁ uint32_t ▁ maxSize) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'uint32_t' , [ param ( 'uint8_t ▁ *' , 'buffer' ) , param ( 'uint32_t' , 'maxSize' ) ] , is_const = True ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ void ▁ ns3::Packet::SetNixVector(ns3::Ptr<ns3::NixVector> ▁ nixVector) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetNixVector' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::NixVector ▁ >' , 'nixVector' ) ] ) <newline>  # # ▁ packet.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::Packet::ToString() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'ToString' , 'std::string' , [ ] , is_const = True ) <newline> return <newline> <dedent> def register_Ns3ParetoRandomVariable_methods ( root_module , cls ) : <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ static ▁ ns3::TypeId ▁ ns3::ParetoRandomVariable::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ ns3::ParetoRandomVariable::ParetoRandomVariable() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ParetoRandomVariable::GetMean() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMean' , 'double' , [ ] , deprecated = True , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ParetoRandomVariable::GetScale() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetScale' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ParetoRandomVariable::GetShape() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetShape' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ParetoRandomVariable::GetBound() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetBound' , 'double' , [ ] , is_const = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ParetoRandomVariable::GetValue(double ▁ scale, ▁ double ▁ shape, ▁ double ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ param ( 'double' , 'scale' ) , param ( 'double' , 'shape' ) , param ( 'double' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ParetoRandomVariable::GetInteger(uint32_t ▁ scale, ▁ uint32_t ▁ shape, ▁ uint32_t ▁ bound) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ param ( 'uint32_t' , 'scale' ) , param ( 'uint32_t' , 'shape' ) , param ( 'uint32_t' , 'bound' ) ] ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ double ▁ ns3::ParetoRandomVariable::GetValue() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetValue' , 'double' , [ ] , is_virtual = True ) <newline>  # # ▁ random-variable-stream.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::ParetoRandomVariable::GetInteger() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInteger' , 'uint32_t' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3TimeValue_methods ( root_module , cls ) : <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeValue::TimeValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeValue::TimeValue(ns3::Time ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Time ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::TimeValue::TimeValue(ns3::TimeValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TimeValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::TimeValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TimeValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ ns3::Time ▁ ns3::TimeValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Time' , [ ] , is_const = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::TimeValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ nstime.h ▁ (module ▁'core'): ▁ void ▁ ns3::TimeValue::Set(ns3::Time ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Time ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3TypeIdChecker_methods ( root_module , cls ) : <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdChecker::TypeIdChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdChecker::TypeIdChecker(ns3::TypeIdChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TypeIdChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3TypeIdValue_methods ( root_module , cls ) : <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdValue::TypeIdValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdValue::TypeIdValue(ns3::TypeId ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TypeId ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeIdValue::TypeIdValue(ns3::TypeIdValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::TypeIdValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::TypeIdValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ bool ▁ ns3::TypeIdValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ ns3::TypeId ▁ ns3::TypeIdValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::TypeId' , [ ] , is_const = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::TypeIdValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ type-id.h ▁ (module ▁'core'): ▁ void ▁ ns3::TypeIdValue::Set(ns3::TypeId ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::TypeId ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3AddressChecker_methods ( root_module , cls ) : <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressChecker::AddressChecker() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressChecker::AddressChecker(ns3::AddressChecker ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::AddressChecker ▁ const ▁ &' , 'arg0' ) ] ) <newline> return <newline> <dedent> def register_Ns3AddressValue_methods ( root_module , cls ) : <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressValue::AddressValue() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressValue::AddressValue(ns3::Address ▁ const ▁ & ▁ value) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Address ▁ const ▁ &' , 'value' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::AddressValue::AddressValue(ns3::AddressValue ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::AddressValue ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Ptr<ns3::AttributeValue> ▁ ns3::AddressValue::Copy() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Copy' , 'ns3::Ptr< ▁ ns3::AttributeValue ▁ >' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ bool ▁ ns3::AddressValue::DeserializeFromString(std::string ▁ value, ▁ ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ [member ▁ function] <encdom> cls . add_method ( 'DeserializeFromString' , 'bool' , [ param ( 'std::string' , 'value' ) , param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_virtual = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ ns3::Address ▁ ns3::AddressValue::Get() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Get' , 'ns3::Address' , [ ] , is_const = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ std::string ▁ ns3::AddressValue::SerializeToString(ns3::Ptr<const ▁ ns3::AttributeChecker> ▁ checker) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'SerializeToString' , 'std::string' , [ param ( 'ns3::Ptr< ▁ ns3::AttributeChecker ▁ const ▁ >' , 'checker' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ address.h ▁ (module ▁'network'): ▁ void ▁ ns3::AddressValue::Set(ns3::Address ▁ const ▁ & ▁ value) ▁ [member ▁ function] <encdom> cls . add_method ( 'Set' , 'void' , [ param ( 'ns3::Address ▁ const ▁ &' , 'value' ) ] ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ bool, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ bool ▁ ns3::CallbackImpl<bool, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::Ptr<ns3::Socket> ▁ arg0, ▁ ns3::Address ▁ const ▁ & ▁ arg1) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Socket ▁ >' , 'arg0' ) , param ( 'ns3::Address ▁ const ▁ &' , 'arg1' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Ns3ObjectBase___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::ObjectBase ▁ * ▁ ns3::CallbackImpl<ns3::ObjectBase ▁ *, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()() ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'ns3::ObjectBase ▁ *' , [ ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Const_ns3OlsrPacketHeader___amp___Const_stdVector__lt__ns3OlsrMessageHeader__stdAllocator__lt__ns3OlsrMessageHeader__gt_____gt_____amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ ns3::olsr::PacketHeader ▁ const ▁ &, ▁ std::vector< ▁ ns3::olsr::MessageHeader, ▁ std::allocator< ▁ ns3::olsr::MessageHeader ▁ > ▁ > ▁ const, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ const ▁ ns3::olsr::PacketHeader ▁ &, ▁ const ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::olsr::PacketHeader ▁ const ▁ & ▁ arg0, ▁ std::vector<ns3::olsr::MessageHeader, ▁ std::allocator<ns3::olsr::MessageHeader> ▁ > ▁ const ▁ & ▁ arg1) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'ns3::olsr::PacketHeader ▁ const ▁ &' , 'arg0' ) , param ( 'std::vector< ▁ ns3::olsr::MessageHeader ▁ > ▁ const ▁ &' , 'arg1' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> cls . add_copy_constructor ( ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ unsigned ▁ short, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::Ptr<const ▁ ns3::Packet>, ▁ unsigned ▁ short, ▁ const ▁ ns3::Address ▁ &, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::NetDevice::PacketType, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::Ptr<ns3::NetDevice> ▁ arg0, ▁ ns3::Ptr<const ▁ ns3::Packet> ▁ arg1, ▁ short ▁ unsigned ▁ int ▁ arg2, ▁ ns3::Address ▁ const ▁ & ▁ arg3, ▁ ns3::Address ▁ const ▁ & ▁ arg4, ▁ ns3::NetDevice::PacketType ▁ arg5) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'arg0' ) , param ( 'ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >' , 'arg1' ) , param ( 'short ▁ unsigned ▁ int' , 'arg2' ) , param ( 'ns3::Address ▁ const ▁ &' , 'arg3' ) , param ( 'ns3::Address ▁ const ▁ &' , 'arg4' ) , param ( 'ns3::NetDevice::PacketType' , 'arg5' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr< ▁ ns3::NetDevice ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::NetDevice>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::Ptr<ns3::NetDevice> ▁ arg0) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'arg0' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::Address ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ const ▁ ns3::Address ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::Ptr<ns3::Socket> ▁ arg0, ▁ ns3::Address ▁ const ▁ & ▁ arg1) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Socket ▁ >' , 'arg0' ) , param ( 'ns3::Address ▁ const ▁ &' , 'arg1' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::Ptr<ns3::Socket> ▁ arg0) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Socket ▁ >' , 'arg0' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ ns3::Ptr< ▁ ns3::Socket ▁ >, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ ns3::Ptr<ns3::Socket>, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(ns3::Ptr<ns3::Socket> ▁ arg0, ▁ unsigned ▁ int ▁ arg1) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Socket ▁ >' , 'arg0' ) , param ( 'unsigned ▁ int' , 'arg1' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3CallbackImpl__Void_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods ( root_module , cls ) : <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty> ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::CallbackImpl< ▁ void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ > ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ static ▁ std::string ▁ ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::DoGetTypeid() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoGetTypeid' , 'std::string' , [ ] , is_static = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ std::string ▁ ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::GetTypeid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeid' , 'std::string' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ callback.h ▁ (module ▁'core'): ▁ void ▁ ns3::CallbackImpl<void, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty>::operator()(unsigned ▁ int ▁ arg0) ▁ [member ▁ operator] <encdom> cls . add_method ( 'operator()' , 'void' , [ param ( 'unsigned ▁ int' , 'arg0' ) ] , is_pure_virtual = True , is_virtual = True , custom_name = u'__call__' ) <newline> return <newline> <dedent> def register_Ns3Ipv4ListRouting_methods ( root_module , cls ) : <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4ListRouting::Ipv4ListRouting(ns3::Ipv4ListRouting ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Ipv4ListRouting ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ ns3::Ipv4ListRouting::Ipv4ListRouting() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::AddRoutingProtocol(ns3::Ptr<ns3::Ipv4RoutingProtocol> ▁ routingProtocol, ▁ int16_t ▁ priority) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddRoutingProtocol' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4RoutingProtocol ▁ >' , 'routingProtocol' ) , param ( 'int16_t' , 'priority' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ uint32_t ▁ ns3::Ipv4ListRouting::GetNRoutingProtocols() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNRoutingProtocols' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Ipv4RoutingProtocol> ▁ ns3::Ipv4ListRouting::GetRoutingProtocol(uint32_t ▁ index, ▁ int16_t ▁ & ▁ priority) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRoutingProtocol' , 'ns3::Ptr< ▁ ns3::Ipv4RoutingProtocol ▁ >' , [ param ( 'uint32_t' , 'index' ) , param ( 'int16_t ▁ &' , 'priority' , direction = 2 ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ static ▁ ns3::TypeId ▁ ns3::Ipv4ListRouting::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::NotifyAddAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyAddAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::NotifyInterfaceDown(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceDown' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::NotifyInterfaceUp(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceUp' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::NotifyRemoveAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyRemoveAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::PrintRoutingTable(ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTable' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ bool ▁ ns3::Ipv4ListRouting::RouteInput(ns3::Ptr<const ▁ ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<const ▁ ns3::NetDevice> ▁ idev, ▁ ns3::Ipv4RoutingProtocol::UnicastForwardCallback ▁ ucb, ▁ ns3::Ipv4RoutingProtocol::MulticastForwardCallback ▁ mcb, ▁ ns3::Ipv4RoutingProtocol::LocalDeliverCallback ▁ lcb, ▁ ns3::Ipv4RoutingProtocol::ErrorCallback ▁ ecb) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteInput' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ const ▁ >' , 'idev' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ucb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'mcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'lcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ecb' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ ns3::Ptr<ns3::Ipv4Route> ▁ ns3::Ipv4ListRouting::RouteOutput(ns3::Ptr<ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<ns3::NetDevice> ▁ oif, ▁ ns3::Socket::SocketErrno ▁ & ▁ sockerr) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteOutput' , 'ns3::Ptr< ▁ ns3::Ipv4Route ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'oif' ) , param ( 'ns3::Socket::SocketErrno ▁ &' , 'sockerr' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::SetIpv4(ns3::Ptr<ns3::Ipv4> ▁ ipv4) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv4' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4 ▁ >' , 'ipv4' ) ] , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::DoDispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoDispose' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline>  # # ▁ ipv4-list-routing.h ▁ (module ▁'internet'): ▁ void ▁ ns3::Ipv4ListRouting::DoInitialize() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoInitialize' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3HashImplementation_methods ( root_module , cls ) : <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Implementation::Implementation(ns3::Hash::Implementation ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Hash::Implementation ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Implementation::Implementation() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hash::Implementation::GetHash32(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_pure_virtual = True , is_virtual = True ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::Hash::Implementation::GetHash64(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash64' , 'uint64_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ void ▁ ns3::Hash::Implementation::clear() ▁ [member ▁ function] <encdom> cls . add_method ( 'clear' , 'void' , [ ] , is_pure_virtual = True , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3HashFunctionFnv1a_methods ( root_module , cls ) : <newline>  # # ▁ hash-fnv.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Fnv1a::Fnv1a(ns3::Hash::Function::Fnv1a ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Hash::Function::Fnv1a ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ hash-fnv.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Fnv1a::Fnv1a() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ hash-fnv.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hash::Function::Fnv1a::GetHash32(char ▁ const ▁ * ▁ buffer, ▁ size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-fnv.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::Hash::Function::Fnv1a::GetHash64(char ▁ const ▁ * ▁ buffer, ▁ size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash64' , 'uint64_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-fnv.h ▁ (module ▁'core'): ▁ void ▁ ns3::Hash::Function::Fnv1a::clear() ▁ [member ▁ function] <encdom> cls . add_method ( 'clear' , 'void' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3HashFunctionHash32_methods ( root_module , cls ) : <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Function::Hash32 ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Hash::Function::Hash32 ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr ▁ hp) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Hash::Hash32Function_ptr' , 'hp' ) ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hash::Function::Hash32::GetHash32(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ void ▁ ns3::Hash::Function::Hash32::clear() ▁ [member ▁ function] <encdom> cls . add_method ( 'clear' , 'void' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3HashFunctionHash64_methods ( root_module , cls ) : <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Function::Hash64 ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Hash::Function::Hash64 ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr ▁ hp) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::Hash::Hash64Function_ptr' , 'hp' ) ] ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hash::Function::Hash64::GetHash32(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::Hash::Function::Hash64::GetHash64(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash64' , 'uint64_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-function.h ▁ (module ▁'core'): ▁ void ▁ ns3::Hash::Function::Hash64::clear() ▁ [member ▁ function] <encdom> cls . add_method ( 'clear' , 'void' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3HashFunctionMurmur3_methods ( root_module , cls ) : <newline>  # # ▁ hash-murmur3.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Murmur3::Murmur3(ns3::Hash::Function::Murmur3 ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::Hash::Function::Murmur3 ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ hash-murmur3.h ▁ (module ▁'core'): ▁ ns3::Hash::Function::Murmur3::Murmur3() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ hash-murmur3.h ▁ (module ▁'core'): ▁ uint32_t ▁ ns3::Hash::Function::Murmur3::GetHash32(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash32' , 'uint32_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-murmur3.h ▁ (module ▁'core'): ▁ uint64_t ▁ ns3::Hash::Function::Murmur3::GetHash64(char ▁ const ▁ * ▁ buffer, ▁ std::size_t ▁ const ▁ size) ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHash64' , 'uint64_t' , [ param ( 'char ▁ const ▁ *' , 'buffer' ) , param ( 'std::size_t ▁ const' , 'size' ) ] , is_virtual = True ) <newline>  # # ▁ hash-murmur3.h ▁ (module ▁'core'): ▁ void ▁ ns3::Hash::Function::Murmur3::clear() ▁ [member ▁ function] <encdom> cls . add_method ( 'clear' , 'void' , [ ] , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3OlsrAssociation_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::Association::Association() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::Association::Association(ns3::olsr::Association ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::Association ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::Association::netmask ▁ [variable] <encdom> cls . add_instance_attribute ( 'netmask' , 'ns3::Ipv4Mask' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::Association::networkAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'networkAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrAssociationTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple::AssociationTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple::AssociationTuple(ns3::olsr::AssociationTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::AssociationTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple::expirationTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'expirationTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple::gatewayAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'gatewayAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple::netmask ▁ [variable] <encdom> cls . add_instance_attribute ( 'netmask' , 'ns3::Ipv4Mask' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple::networkAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'networkAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrDuplicateTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::DuplicateTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::DuplicateTuple(ns3::olsr::DuplicateTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::DuplicateTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::address ▁ [variable] <encdom> cls . add_instance_attribute ( 'address' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::expirationTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'expirationTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::ifaceList ▁ [variable] <encdom> cls . add_instance_attribute ( 'ifaceList' , 'std::vector< ▁ ns3::Ipv4Address ▁ >' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::retransmitted ▁ [variable] <encdom> cls . add_instance_attribute ( 'retransmitted' , 'bool' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple::sequenceNumber ▁ [variable] <encdom> cls . add_instance_attribute ( 'sequenceNumber' , 'uint16_t' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrIfaceAssocTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple::IfaceAssocTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple::IfaceAssocTuple(ns3::olsr::IfaceAssocTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::IfaceAssocTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple::ifaceAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'ifaceAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple::mainAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'mainAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple::time ▁ [variable] <encdom> cls . add_instance_attribute ( 'time' , 'ns3::Time' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrLinkTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::LinkTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::LinkTuple(ns3::olsr::LinkTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::LinkTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::asymTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'asymTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::localIfaceAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'localIfaceAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::neighborIfaceAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'neighborIfaceAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::symTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'symTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple::time ▁ [variable] <encdom> cls . add_instance_attribute ( 'time' , 'ns3::Time' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeader_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::MessageHeader(ns3::olsr::MessageHeader ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::MessageHeader() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Deserialize(ns3::Buffer::Iterator ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello ▁ & ▁ ns3::olsr::MessageHeader::GetHello() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHello' , 'ns3::olsr::MessageHeader::Hello ▁ &' , [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello ▁ const ▁ & ▁ ns3::olsr::MessageHeader::GetHello() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHello' , 'ns3::olsr::MessageHeader::Hello ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna ▁ & ▁ ns3::olsr::MessageHeader::GetHna() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHna' , 'ns3::olsr::MessageHeader::Hna ▁ &' , [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna ▁ const ▁ & ▁ ns3::olsr::MessageHeader::GetHna() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHna' , 'ns3::olsr::MessageHeader::Hna ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint8_t ▁ ns3::olsr::MessageHeader::GetHopCount() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHopCount' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::TypeId ▁ ns3::olsr::MessageHeader::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint16_t ▁ ns3::olsr::MessageHeader::GetMessageSequenceNumber() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMessageSequenceNumber' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::MessageType ▁ ns3::olsr::MessageHeader::GetMessageType() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMessageType' , 'ns3::olsr::MessageHeader::MessageType' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Mid ▁ & ▁ ns3::olsr::MessageHeader::GetMid() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMid' , 'ns3::olsr::MessageHeader::Mid ▁ &' , [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Mid ▁ const ▁ & ▁ ns3::olsr::MessageHeader::GetMid() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMid' , 'ns3::olsr::MessageHeader::Mid ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::Ipv4Address ▁ ns3::olsr::MessageHeader::GetOriginatorAddress() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetOriginatorAddress' , 'ns3::Ipv4Address' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc ▁ & ▁ ns3::olsr::MessageHeader::GetTc() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTc' , 'ns3::olsr::MessageHeader::Tc ▁ &' , [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc ▁ const ▁ & ▁ ns3::olsr::MessageHeader::GetTc() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTc' , 'ns3::olsr::MessageHeader::Tc ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint8_t ▁ ns3::olsr::MessageHeader::GetTimeToLive() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTimeToLive' , 'uint8_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ static ▁ ns3::TypeId ▁ ns3::olsr::MessageHeader::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::Time ▁ ns3::olsr::MessageHeader::GetVTime() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetVTime' , 'ns3::Time' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::SetHopCount(uint8_t ▁ hopCount) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetHopCount' , 'void' , [ param ( 'uint8_t' , 'hopCount' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::SetMessageSequenceNumber(uint16_t ▁ messageSequenceNumber) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMessageSequenceNumber' , 'void' , [ param ( 'uint16_t' , 'messageSequenceNumber' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::SetMessageType(ns3::olsr::MessageHeader::MessageType ▁ messageType) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMessageType' , 'void' , [ param ( 'ns3::olsr::MessageHeader::MessageType' , 'messageType' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::SetOriginatorAddress(ns3::Ipv4Address ▁ originatorAddress) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetOriginatorAddress' , 'void' , [ param ( 'ns3::Ipv4Address' , 'originatorAddress' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::SetTimeToLive(uint8_t ▁ timeToLive) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetTimeToLive' , 'void' , [ param ( 'uint8_t' , 'timeToLive' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::SetVTime(ns3::Time ▁ time) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetVTime' , 'void' , [ param ( 'ns3::Time' , 'time' ) ] ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeaderHello_methods ( root_module , cls ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::Hello() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::Hello(ns3::olsr::MessageHeader::Hello ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader::Hello ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Hello::Deserialize(ns3::Buffer::Iterator ▁ start, ▁ uint32_t ▁ messageSize) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'uint32_t' , 'messageSize' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::Time ▁ ns3::olsr::MessageHeader::Hello::GetHTime() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetHTime' , 'ns3::Time' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Hello::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Hello::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Hello::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Hello::SetHTime(ns3::Time ▁ time) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetHTime' , 'void' , [ param ( 'ns3::Time' , 'time' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::hTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'hTime' , 'uint8_t' , is_const = False ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::linkMessages ▁ [variable] <encdom> cls . add_instance_attribute ( 'linkMessages' , 'std::vector< ▁ ns3::olsr::MessageHeader::Hello::LinkMessage ▁ >' , is_const = False ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::willingness ▁ [variable] <encdom> cls . add_instance_attribute ( 'willingness' , 'uint8_t' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeaderHelloLinkMessage_methods ( root_module , cls ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::LinkMessage::LinkMessage() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::LinkMessage::LinkMessage(ns3::olsr::MessageHeader::Hello::LinkMessage ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader::Hello::LinkMessage ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::LinkMessage::linkCode ▁ [variable] <encdom> cls . add_instance_attribute ( 'linkCode' , 'uint8_t' , is_const = False ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hello::LinkMessage::neighborInterfaceAddresses ▁ [variable] <encdom> cls . add_instance_attribute ( 'neighborInterfaceAddresses' , 'std::vector< ▁ ns3::Ipv4Address ▁ >' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeaderHna_methods ( root_module , cls ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Hna() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Hna(ns3::olsr::MessageHeader::Hna ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader::Hna ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Hna::Deserialize(ns3::Buffer::Iterator ▁ start, ▁ uint32_t ▁ messageSize) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'uint32_t' , 'messageSize' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Hna::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Hna::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Hna::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::associations ▁ [variable] <encdom> cls . add_instance_attribute ( 'associations' , 'std::vector< ▁ ns3::olsr::MessageHeader::Hna::Association ▁ >' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeaderHnaAssociation_methods ( root_module , cls ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Association::Association() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Association::Association(ns3::olsr::MessageHeader::Hna::Association ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader::Hna::Association ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Association::address ▁ [variable] <encdom> cls . add_instance_attribute ( 'address' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Hna::Association::mask ▁ [variable] <encdom> cls . add_instance_attribute ( 'mask' , 'ns3::Ipv4Mask' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeaderMid_methods ( root_module , cls ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Mid::Mid() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Mid::Mid(ns3::olsr::MessageHeader::Mid ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader::Mid ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Mid::Deserialize(ns3::Buffer::Iterator ▁ start, ▁ uint32_t ▁ messageSize) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'uint32_t' , 'messageSize' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Mid::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Mid::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Mid::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Mid::interfaceAddresses ▁ [variable] <encdom> cls . add_instance_attribute ( 'interfaceAddresses' , 'std::vector< ▁ ns3::Ipv4Address ▁ >' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMessageHeaderTc_methods ( root_module , cls ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc::Tc() ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc::Tc(ns3::olsr::MessageHeader::Tc ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MessageHeader::Tc ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Tc::Deserialize(ns3::Buffer::Iterator ▁ start, ▁ uint32_t ▁ messageSize) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) , param ( 'uint32_t' , 'messageSize' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::MessageHeader::Tc::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Tc::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::MessageHeader::Tc::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc::ansn ▁ [variable] <encdom> cls . add_instance_attribute ( 'ansn' , 'uint16_t' , is_const = False ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MessageHeader::Tc::neighborAddresses ▁ [variable] <encdom> cls . add_instance_attribute ( 'neighborAddresses' , 'std::vector< ▁ ns3::Ipv4Address ▁ >' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrMprSelectorTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorTuple::MprSelectorTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorTuple::MprSelectorTuple(ns3::olsr::MprSelectorTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::MprSelectorTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorTuple::expirationTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'expirationTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorTuple::mainAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'mainAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrNeighborTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple::NeighborTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple::NeighborTuple(ns3::olsr::NeighborTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::NeighborTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple::neighborMainAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'neighborMainAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple::status ▁ [variable] <encdom> cls . add_instance_attribute ( 'status' , 'ns3::olsr::NeighborTuple::Status' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple::willingness ▁ [variable] <encdom> cls . add_instance_attribute ( 'willingness' , 'uint8_t' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrOlsrState_methods ( root_module , cls ) : <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::OlsrState::OlsrState(ns3::olsr::OlsrState ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::olsr::OlsrState ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::OlsrState::OlsrState() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseAssociation(ns3::olsr::Association ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseAssociation' , 'void' , [ param ( 'ns3::olsr::Association ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseAssociationTuple(ns3::olsr::AssociationTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseAssociationTuple' , 'void' , [ param ( 'ns3::olsr::AssociationTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseDuplicateTuple(ns3::olsr::DuplicateTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseDuplicateTuple' , 'void' , [ param ( 'ns3::olsr::DuplicateTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseIfaceAssocTuple(ns3::olsr::IfaceAssocTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseIfaceAssocTuple' , 'void' , [ param ( 'ns3::olsr::IfaceAssocTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseLinkTuple(ns3::olsr::LinkTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseLinkTuple' , 'void' , [ param ( 'ns3::olsr::LinkTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseMprSelectorTuple(ns3::olsr::MprSelectorTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseMprSelectorTuple' , 'void' , [ param ( 'ns3::olsr::MprSelectorTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseMprSelectorTuples(ns3::Ipv4Address ▁ const ▁ & ▁ mainAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseMprSelectorTuples' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'mainAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseNeighborTuple(ns3::olsr::NeighborTuple ▁ const ▁ & ▁ neighborTuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseNeighborTuple' , 'void' , [ param ( 'ns3::olsr::NeighborTuple ▁ const ▁ &' , 'neighborTuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseNeighborTuple(ns3::Ipv4Address ▁ const ▁ & ▁ mainAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseNeighborTuple' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'mainAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseOlderTopologyTuples(ns3::Ipv4Address ▁ const ▁ & ▁ lastAddr, ▁ uint16_t ▁ ansn) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseOlderTopologyTuples' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'lastAddr' ) , param ( 'uint16_t' , 'ansn' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseTopologyTuple(ns3::olsr::TopologyTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseTopologyTuple' , 'void' , [ param ( 'ns3::olsr::TopologyTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseTwoHopNeighborTuple(ns3::olsr::TwoHopNeighborTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseTwoHopNeighborTuple' , 'void' , [ param ( 'ns3::olsr::TwoHopNeighborTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseTwoHopNeighborTuples(ns3::Ipv4Address ▁ const ▁ & ▁ neighbor) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseTwoHopNeighborTuples' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'neighbor' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::EraseTwoHopNeighborTuples(ns3::Ipv4Address ▁ const ▁ & ▁ neighbor, ▁ ns3::Ipv4Address ▁ const ▁ & ▁ twoHopNeighbor) ▁ [member ▁ function] <encdom> cls . add_method ( 'EraseTwoHopNeighborTuples' , 'void' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'neighbor' ) , param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'twoHopNeighbor' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationTuple ▁ * ▁ ns3::olsr::OlsrState::FindAssociationTuple(ns3::Ipv4Address ▁ const ▁ & ▁ gatewayAddr, ▁ ns3::Ipv4Address ▁ const ▁ & ▁ networkAddr, ▁ ns3::Ipv4Mask ▁ const ▁ & ▁ netmask) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindAssociationTuple' , 'ns3::olsr::AssociationTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'gatewayAddr' ) , param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'networkAddr' ) , param ( 'ns3::Ipv4Mask ▁ const ▁ &' , 'netmask' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::DuplicateTuple ▁ * ▁ ns3::olsr::OlsrState::FindDuplicateTuple(ns3::Ipv4Address ▁ const ▁ & ▁ address, ▁ uint16_t ▁ sequenceNumber) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindDuplicateTuple' , 'ns3::olsr::DuplicateTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'address' ) , param ( 'uint16_t' , 'sequenceNumber' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple ▁ * ▁ ns3::olsr::OlsrState::FindIfaceAssocTuple(ns3::Ipv4Address ▁ const ▁ & ▁ ifaceAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindIfaceAssocTuple' , 'ns3::olsr::IfaceAssocTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'ifaceAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocTuple ▁ const ▁ * ▁ ns3::olsr::OlsrState::FindIfaceAssocTuple(ns3::Ipv4Address ▁ const ▁ & ▁ ifaceAddr) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'FindIfaceAssocTuple' , 'ns3::olsr::IfaceAssocTuple ▁ const ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'ifaceAddr' ) ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple ▁ * ▁ ns3::olsr::OlsrState::FindLinkTuple(ns3::Ipv4Address ▁ const ▁ & ▁ ifaceAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindLinkTuple' , 'ns3::olsr::LinkTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'ifaceAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ bool ▁ ns3::olsr::OlsrState::FindMprAddress(ns3::Ipv4Address ▁ const ▁ & ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindMprAddress' , 'bool' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'address' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorTuple ▁ * ▁ ns3::olsr::OlsrState::FindMprSelectorTuple(ns3::Ipv4Address ▁ const ▁ & ▁ mainAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindMprSelectorTuple' , 'ns3::olsr::MprSelectorTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'mainAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ std::vector<ns3::Ipv4Address, ▁ std::allocator<ns3::Ipv4Address> ▁ > ▁ ns3::olsr::OlsrState::FindNeighborInterfaces(ns3::Ipv4Address ▁ const ▁ & ▁ neighborMainAddr) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'FindNeighborInterfaces' , 'std::vector< ▁ ns3::Ipv4Address ▁ >' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'neighborMainAddr' ) ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple ▁ * ▁ ns3::olsr::OlsrState::FindNeighborTuple(ns3::Ipv4Address ▁ const ▁ & ▁ mainAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindNeighborTuple' , 'ns3::olsr::NeighborTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'mainAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple ▁ * ▁ ns3::olsr::OlsrState::FindNeighborTuple(ns3::Ipv4Address ▁ const ▁ & ▁ mainAddr, ▁ uint8_t ▁ willingness) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindNeighborTuple' , 'ns3::olsr::NeighborTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'mainAddr' ) , param ( 'uint8_t' , 'willingness' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple ▁ * ▁ ns3::olsr::OlsrState::FindNewerTopologyTuple(ns3::Ipv4Address ▁ const ▁ & ▁ lastAddr, ▁ uint16_t ▁ ansn) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindNewerTopologyTuple' , 'ns3::olsr::TopologyTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'lastAddr' ) , param ( 'uint16_t' , 'ansn' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple ▁ * ▁ ns3::olsr::OlsrState::FindSymLinkTuple(ns3::Ipv4Address ▁ const ▁ & ▁ ifaceAddr, ▁ ns3::Time ▁ time) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindSymLinkTuple' , 'ns3::olsr::LinkTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'ifaceAddr' ) , param ( 'ns3::Time' , 'time' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborTuple ▁ const ▁ * ▁ ns3::olsr::OlsrState::FindSymNeighborTuple(ns3::Ipv4Address ▁ const ▁ & ▁ mainAddr) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'FindSymNeighborTuple' , 'ns3::olsr::NeighborTuple ▁ const ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'mainAddr' ) ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple ▁ * ▁ ns3::olsr::OlsrState::FindTopologyTuple(ns3::Ipv4Address ▁ const ▁ & ▁ destAddr, ▁ ns3::Ipv4Address ▁ const ▁ & ▁ lastAddr) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindTopologyTuple' , 'ns3::olsr::TopologyTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'destAddr' ) , param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'lastAddr' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple ▁ * ▁ ns3::olsr::OlsrState::FindTwoHopNeighborTuple(ns3::Ipv4Address ▁ const ▁ & ▁ neighbor, ▁ ns3::Ipv4Address ▁ const ▁ & ▁ twoHopNeighbor) ▁ [member ▁ function] <encdom> cls . add_method ( 'FindTwoHopNeighborTuple' , 'ns3::olsr::TwoHopNeighborTuple ▁ *' , [ param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'neighbor' ) , param ( 'ns3::Ipv4Address ▁ const ▁ &' , 'twoHopNeighbor' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::AssociationSet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetAssociationSet() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAssociationSet' , 'ns3::olsr::AssociationSet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::Associations ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetAssociations() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetAssociations' , 'ns3::olsr::Associations ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocSet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetIfaceAssocSet() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIfaceAssocSet' , 'ns3::olsr::IfaceAssocSet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::IfaceAssocSet ▁ & ▁ ns3::olsr::OlsrState::GetIfaceAssocSetMutable() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetIfaceAssocSetMutable' , 'ns3::olsr::IfaceAssocSet ▁ &' , [ ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkSet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetLinks() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetLinks' , 'ns3::olsr::LinkSet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSelectorSet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetMprSelectors() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMprSelectors' , 'ns3::olsr::MprSelectorSet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::MprSet ▁ ns3::olsr::OlsrState::GetMprSet() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetMprSet' , 'ns3::olsr::MprSet' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborSet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetNeighbors() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNeighbors' , 'ns3::olsr::NeighborSet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::NeighborSet ▁ & ▁ ns3::olsr::OlsrState::GetNeighbors() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetNeighbors' , 'ns3::olsr::NeighborSet ▁ &' , [ ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologySet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetTopologySet() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTopologySet' , 'ns3::olsr::TopologySet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborSet ▁ const ▁ & ▁ ns3::olsr::OlsrState::GetTwoHopNeighbors() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTwoHopNeighbors' , 'ns3::olsr::TwoHopNeighborSet ▁ const ▁ &' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborSet ▁ & ▁ ns3::olsr::OlsrState::GetTwoHopNeighbors() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTwoHopNeighbors' , 'ns3::olsr::TwoHopNeighborSet ▁ &' , [ ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertAssociation(ns3::olsr::Association ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertAssociation' , 'void' , [ param ( 'ns3::olsr::Association ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertAssociationTuple(ns3::olsr::AssociationTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertAssociationTuple' , 'void' , [ param ( 'ns3::olsr::AssociationTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertDuplicateTuple(ns3::olsr::DuplicateTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertDuplicateTuple' , 'void' , [ param ( 'ns3::olsr::DuplicateTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertIfaceAssocTuple(ns3::olsr::IfaceAssocTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertIfaceAssocTuple' , 'void' , [ param ( 'ns3::olsr::IfaceAssocTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ ns3::olsr::LinkTuple ▁ & ▁ ns3::olsr::OlsrState::InsertLinkTuple(ns3::olsr::LinkTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertLinkTuple' , 'ns3::olsr::LinkTuple ▁ &' , [ param ( 'ns3::olsr::LinkTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertMprSelectorTuple(ns3::olsr::MprSelectorTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertMprSelectorTuple' , 'void' , [ param ( 'ns3::olsr::MprSelectorTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertNeighborTuple(ns3::olsr::NeighborTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertNeighborTuple' , 'void' , [ param ( 'ns3::olsr::NeighborTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertTopologyTuple(ns3::olsr::TopologyTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertTopologyTuple' , 'void' , [ param ( 'ns3::olsr::TopologyTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::InsertTwoHopNeighborTuple(ns3::olsr::TwoHopNeighborTuple ▁ const ▁ & ▁ tuple) ▁ [member ▁ function] <encdom> cls . add_method ( 'InsertTwoHopNeighborTuple' , 'void' , [ param ( 'ns3::olsr::TwoHopNeighborTuple ▁ const ▁ &' , 'tuple' ) ] ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ std::string ▁ ns3::olsr::OlsrState::PrintMprSelectorSet() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintMprSelectorSet' , 'std::string' , [ ] , is_const = True ) <newline>  # # ▁ olsr-state.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::OlsrState::SetMprSet(ns3::olsr::MprSet ▁ mprSet) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMprSet' , 'void' , [ param ( 'std::set< ▁ ns3::Ipv4Address ▁ >' , 'mprSet' ) ] ) <newline> return <newline> <dedent> def register_Ns3OlsrPacketHeader_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::PacketHeader::PacketHeader(ns3::olsr::PacketHeader ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::PacketHeader ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::olsr::PacketHeader::PacketHeader() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::PacketHeader::Deserialize(ns3::Buffer::Iterator ▁ start) ▁ [member ▁ function] <encdom> cls . add_method ( 'Deserialize' , 'uint32_t' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ ns3::TypeId ▁ ns3::olsr::PacketHeader::GetInstanceTypeId() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInstanceTypeId' , 'ns3::TypeId' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint16_t ▁ ns3::olsr::PacketHeader::GetPacketLength() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPacketLength' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint16_t ▁ ns3::olsr::PacketHeader::GetPacketSequenceNumber() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetPacketSequenceNumber' , 'uint16_t' , [ ] , is_const = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint32_t ▁ ns3::olsr::PacketHeader::GetSerializedSize() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetSerializedSize' , 'uint32_t' , [ ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ static ▁ ns3::TypeId ▁ ns3::olsr::PacketHeader::GetTypeId() ▁ [member ▁ function] <encdom> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::PacketHeader::Print(std::ostream ▁ & ▁ os) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Print' , 'void' , [ param ( 'std::ostream ▁ &' , 'os' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::PacketHeader::Serialize(ns3::Buffer::Iterator ▁ start) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'Serialize' , 'void' , [ param ( 'ns3::Buffer::Iterator' , 'start' ) ] , is_const = True , is_virtual = True ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::PacketHeader::SetPacketLength(uint16_t ▁ length) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPacketLength' , 'void' , [ param ( 'uint16_t' , 'length' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::PacketHeader::SetPacketSequenceNumber(uint16_t ▁ seqnum) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetPacketSequenceNumber' , 'void' , [ param ( 'uint16_t' , 'seqnum' ) ] ) <newline> return <newline> <dedent> def register_Ns3OlsrRoutingProtocol_methods ( root_module , cls ) : <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ static ▁ ns3::TypeId ▁ ns3::olsr::RoutingProtocol::GetTypeId() ▁ [member ▁ function] <encdom> <indent> cls . add_method ( 'GetTypeId' , 'ns3::TypeId' , [ ] , is_static = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingProtocol::RoutingProtocol() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::SetMainInterface(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetMainInterface' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::Dump() ▁ [member ▁ function] <encdom> cls . add_method ( 'Dump' , 'void' , [ ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ std::vector<ns3::olsr::RoutingTableEntry, ▁ std::allocator<ns3::olsr::RoutingTableEntry> ▁ > ▁ ns3::olsr::RoutingProtocol::GetRoutingTableEntries() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRoutingTableEntries' , 'std::vector< ▁ ns3::olsr::RoutingTableEntry ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ int64_t ▁ ns3::olsr::RoutingProtocol::AssignStreams(int64_t ▁ stream) ▁ [member ▁ function] <encdom> cls . add_method ( 'AssignStreams' , 'int64_t' , [ param ( 'int64_t' , 'stream' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ std::set<unsigned ▁ int, ▁ std::less<unsigned ▁ int>, ▁ std::allocator<unsigned ▁ int> ▁ > ▁ ns3::olsr::RoutingProtocol::GetInterfaceExclusions() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetInterfaceExclusions' , 'std::set< ▁ unsigned ▁ int ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::SetInterfaceExclusions(std::set<unsigned ▁ int, ▁ std::less<unsigned ▁ int>, ▁ std::allocator<unsigned ▁ int> ▁ > ▁ exceptions) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetInterfaceExclusions' , 'void' , [ param ( 'std::set< ▁ unsigned ▁ int ▁ >' , 'exceptions' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::AddHostNetworkAssociation(ns3::Ipv4Address ▁ networkAddr, ▁ ns3::Ipv4Mask ▁ netmask) ▁ [member ▁ function] <encdom> cls . add_method ( 'AddHostNetworkAssociation' , 'void' , [ param ( 'ns3::Ipv4Address' , 'networkAddr' ) , param ( 'ns3::Ipv4Mask' , 'netmask' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::RemoveHostNetworkAssociation(ns3::Ipv4Address ▁ networkAddr, ▁ ns3::Ipv4Mask ▁ netmask) ▁ [member ▁ function] <encdom> cls . add_method ( 'RemoveHostNetworkAssociation' , 'void' , [ param ( 'ns3::Ipv4Address' , 'networkAddr' ) , param ( 'ns3::Ipv4Mask' , 'netmask' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::SetRoutingTableAssociation(ns3::Ptr<ns3::Ipv4StaticRouting> ▁ routingTable) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetRoutingTableAssociation' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4StaticRouting ▁ >' , 'routingTable' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::Ptr<const ▁ ns3::Ipv4StaticRouting> ▁ ns3::olsr::RoutingProtocol::GetRoutingTableAssociation() ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'GetRoutingTableAssociation' , 'ns3::Ptr< ▁ ns3::Ipv4StaticRouting ▁ const ▁ >' , [ ] , is_const = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingProtocol::RoutingProtocol(ns3::olsr::RoutingProtocol ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::RoutingProtocol ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::DoInitialize() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoInitialize' , 'void' , [ ] , visibility = 'protected' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::Ptr<ns3::Ipv4Route> ▁ ns3::olsr::RoutingProtocol::RouteOutput(ns3::Ptr<ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<ns3::NetDevice> ▁ oif, ▁ ns3::Socket::SocketErrno ▁ & ▁ sockerr) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteOutput' , 'ns3::Ptr< ▁ ns3::Ipv4Route ▁ >' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ >' , 'oif' ) , param ( 'ns3::Socket::SocketErrno ▁ &' , 'sockerr' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ bool ▁ ns3::olsr::RoutingProtocol::RouteInput(ns3::Ptr<const ▁ ns3::Packet> ▁ p, ▁ ns3::Ipv4Header ▁ const ▁ & ▁ header, ▁ ns3::Ptr<const ▁ ns3::NetDevice> ▁ idev, ▁ ns3::Ipv4RoutingProtocol::UnicastForwardCallback ▁ ucb, ▁ ns3::Ipv4RoutingProtocol::MulticastForwardCallback ▁ mcb, ▁ ns3::Ipv4RoutingProtocol::LocalDeliverCallback ▁ lcb, ▁ ns3::Ipv4RoutingProtocol::ErrorCallback ▁ ecb) ▁ [member ▁ function] <encdom> cls . add_method ( 'RouteInput' , 'bool' , [ param ( 'ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >' , 'p' ) , param ( 'ns3::Ipv4Header ▁ const ▁ &' , 'header' ) , param ( 'ns3::Ptr< ▁ ns3::NetDevice ▁ const ▁ >' , 'idev' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4Route ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ucb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Ipv4MulticastRoute ▁ >, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'mcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ unsigned ▁ int, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'lcb' ) , param ( 'ns3::Callback< ▁ void, ▁ ns3::Ptr< ▁ ns3::Packet ▁ const ▁ >, ▁ ns3::Ipv4Header ▁ const ▁ &, ▁ ns3::Socket::SocketErrno, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty, ▁ ns3::empty ▁ >' , 'ecb' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::NotifyInterfaceUp(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceUp' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::NotifyInterfaceDown(uint32_t ▁ interface) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyInterfaceDown' , 'void' , [ param ( 'uint32_t' , 'interface' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::NotifyAddAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyAddAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::NotifyRemoveAddress(uint32_t ▁ interface, ▁ ns3::Ipv4InterfaceAddress ▁ address) ▁ [member ▁ function] <encdom> cls . add_method ( 'NotifyRemoveAddress' , 'void' , [ param ( 'uint32_t' , 'interface' ) , param ( 'ns3::Ipv4InterfaceAddress' , 'address' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::SetIpv4(ns3::Ptr<ns3::Ipv4> ▁ ipv4) ▁ [member ▁ function] <encdom> cls . add_method ( 'SetIpv4' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::Ipv4 ▁ >' , 'ipv4' ) ] , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::PrintRoutingTable(ns3::Ptr<ns3::OutputStreamWrapper> ▁ stream, ▁ ns3::Time::Unit ▁ unit=::ns3::Time::Unit::S) ▁ const ▁ [member ▁ function] <encdom> cls . add_method ( 'PrintRoutingTable' , 'void' , [ param ( 'ns3::Ptr< ▁ ns3::OutputStreamWrapper ▁ >' , 'stream' ) , param ( 'ns3::Time::Unit' , 'unit' , default_value = '::ns3::Time::Unit::S' ) ] , is_const = True , visibility = 'private' , is_virtual = True ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ void ▁ ns3::olsr::RoutingProtocol::DoDispose() ▁ [member ▁ function] <encdom> cls . add_method ( 'DoDispose' , 'void' , [ ] , visibility = 'private' , is_virtual = True ) <newline> return <newline> <dedent> def register_Ns3OlsrRoutingTableEntry_methods ( root_module , cls ) : <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry::RoutingTableEntry(ns3::olsr::RoutingTableEntry ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> <indent> cls . add_constructor ( [ param ( 'ns3::olsr::RoutingTableEntry ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry::RoutingTableEntry() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry::destAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'destAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry::distance ▁ [variable] <encdom> cls . add_instance_attribute ( 'distance' , 'uint32_t' , is_const = False ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry::interface ▁ [variable] <encdom> cls . add_instance_attribute ( 'interface' , 'uint32_t' , is_const = False ) <newline>  # # ▁ olsr-routing-protocol.h ▁ (module ▁'olsr'): ▁ ns3::olsr::RoutingTableEntry::nextAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'nextAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrTopologyTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_binary_comparison_operator ( '==' ) <newline> cls . add_output_stream_operator ( ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple::TopologyTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple::TopologyTuple(ns3::olsr::TopologyTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::TopologyTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple::destAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'destAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple::expirationTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'expirationTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple::lastAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'lastAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TopologyTuple::sequenceNumber ▁ [variable] <encdom> cls . add_instance_attribute ( 'sequenceNumber' , 'uint16_t' , is_const = False ) <newline> return <newline> <dedent> def register_Ns3OlsrTwoHopNeighborTuple_methods ( root_module , cls ) : <newline> <indent> cls . add_output_stream_operator ( ) <newline> cls . add_binary_comparison_operator ( '==' ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple::TwoHopNeighborTuple() ▁ [constructor] <encdom> cls . add_constructor ( [ ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple::TwoHopNeighborTuple(ns3::olsr::TwoHopNeighborTuple ▁ const ▁ & ▁ arg0) ▁ [constructor] <encdom> cls . add_constructor ( [ param ( 'ns3::olsr::TwoHopNeighborTuple ▁ const ▁ &' , 'arg0' ) ] ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple::expirationTime ▁ [variable] <encdom> cls . add_instance_attribute ( 'expirationTime' , 'ns3::Time' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple::neighborMainAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'neighborMainAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline>  # # ▁ olsr-repositories.h ▁ (module ▁'olsr'): ▁ ns3::olsr::TwoHopNeighborTuple::twoHopNeighborAddr ▁ [variable] <encdom> cls . add_instance_attribute ( 'twoHopNeighborAddr' , 'ns3::Ipv4Address' , is_const = False ) <newline> return <newline> <dedent> def register_functions ( root_module ) : <newline> <indent> module = root_module <newline> register_functions_ns3_FatalImpl ( module . add_cpp_namespace ( 'FatalImpl' ) , root_module ) <newline> register_functions_ns3_Hash ( module . add_cpp_namespace ( 'Hash' ) , root_module ) <newline> register_functions_ns3_TracedValueCallback ( module . add_cpp_namespace ( 'TracedValueCallback' ) , root_module ) <newline> register_functions_ns3_olsr ( module . add_cpp_namespace ( 'olsr' ) , root_module ) <newline> register_functions_ns3_tests ( module . add_cpp_namespace ( 'tests' ) , root_module ) <newline> return <newline> <dedent> def register_functions_ns3_FatalImpl ( module , root_module ) : <newline> <indent> return <newline> <dedent> def register_functions_ns3_Hash ( module , root_module ) : <newline> <indent> register_functions_ns3_Hash_Function ( module . add_cpp_namespace ( 'Function' ) , root_module ) <newline> return <newline> <dedent> def register_functions_ns3_Hash_Function ( module , root_module ) : <newline> <indent> return <newline> <dedent> def register_functions_ns3_TracedValueCallback ( module , root_module ) : <newline> <indent> return <newline> <dedent> def register_functions_ns3_olsr ( module , root_module ) : <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ double ▁ ns3::olsr::EmfToSeconds(uint8_t ▁ emf) ▁ [free ▁ function] <encdom> <indent> module . add_function ( 'EmfToSeconds' , 'double' , [ param ( 'uint8_t' , 'emf' ) ] ) <newline>  # # ▁ olsr-header.h ▁ (module ▁'olsr'): ▁ uint8_t ▁ ns3::olsr::SecondsToEmf(double ▁ seconds) ▁ [free ▁ function] <encdom> module . add_function ( 'SecondsToEmf' , 'uint8_t' , [ param ( 'double' , 'seconds' ) ] ) <newline> return <newline> <dedent> def register_functions_ns3_tests ( module , root_module ) : <newline> <indent> return <newline> <dedent> def main ( ) : <newline> <indent> out = FileCodeSink ( sys . stdout ) <newline> root_module = module_init ( ) <newline> register_types ( root_module ) <newline> register_methods ( root_module ) <newline> register_functions ( root_module ) <newline> root_module . generate ( out ) <newline> <dedent> if __name__ == '__main__' : <newline> <indent> main ( ) <newline> <dedent>
 """ Base ▁ classes ▁ and ▁ utilities ▁ for ▁ readers ▁ and ▁ writers. <strnewline> <strnewline> Authors: <strnewline> <strnewline> * ▁ Brian ▁ Granger <strnewline> """  <newline>  # ▁ Copyright ▁ (C) ▁ 2008-2011 ▁ The ▁ IPython ▁ Development ▁ Team <encdom>  # ▁ Distributed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ BSD ▁ License. ▁ The ▁ full ▁ license ▁ is ▁ in <encdom>  # ▁ the ▁ file ▁ COPYING, ▁ distributed ▁ as ▁ part ▁ of ▁ this ▁ software. <encdom>  # ▁ Imports <encdom> from base64 import encodestring , decodestring <newline> import pprint <newline> from IPython . utils import py3compat <newline> from IPython . utils . py3compat import str_to_bytes , unicode_type , string_types <newline>  # ▁ Code <encdom> def restore_bytes ( nb ) : <newline> <indent>  """ Restore ▁ bytes ▁ of ▁ image ▁ data ▁ from ▁ unicode-only ▁ formats. <strnewline> ▁ <strnewline> ▁ Base64 ▁ encoding ▁ is ▁ handled ▁ elsewhere. ▁ Bytes ▁ objects ▁ in ▁ the ▁ notebook ▁ are <strnewline> ▁ always ▁ b64-encoded. ▁ We ▁ DO ▁ NOT ▁ encode/decode ▁ around ▁ file ▁ formats. <strnewline> ▁ <strnewline> ▁ Note: ▁ this ▁ is ▁ never ▁ used <strnewline> ▁ """  <newline> for ws in nb . worksheets : <newline> <indent> for cell in ws . cells : <newline> <indent> if cell . cell_type == 'code' : <newline> <indent> for output in cell . outputs : <newline> <indent> if 'png' in output : <newline> <indent> output . png = str_to_bytes ( output . png , 'ascii' ) <newline> <dedent> if 'jpeg' in output : <newline> <indent> output . jpeg = str_to_bytes ( output . jpeg , 'ascii' ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> return nb <newline>  # ▁ output ▁ keys ▁ that ▁ are ▁ likely ▁ to ▁ have ▁ multiline ▁ values <encdom> <dedent> _multiline_outputs = [ 'text' , 'html' , 'svg' , 'latex' , 'javascript' , 'json' ] <newline>  # ▁ FIXME: ▁ workaround ▁ for ▁ old ▁ splitlines() <encdom> def _join_lines ( lines ) : <newline> <indent>  """ join ▁ lines ▁ that ▁ have ▁ been ▁ written ▁ by ▁ splitlines() <strnewline> ▁ <strnewline> ▁ Has ▁ logic ▁ to ▁ protect ▁ against ▁ `splitlines()`, ▁ which <strnewline> ▁ should ▁ have ▁ been ▁ `splitlines(True)` <strnewline> ▁ """  <newline> if lines and lines [ 0 ] . endswith ( ( ' \n ' , '' ) ) : <newline>  # ▁ created ▁ by ▁ splitlines(True) <encdom> <indent> return u'' . join ( lines ) <newline> <dedent> else : <newline>  # ▁ created ▁ by ▁ splitlines() <encdom> <indent> return u' \n ' . join ( lines ) <newline> <dedent> <dedent> def rejoin_lines ( nb ) : <newline> <indent>  """ rejoin ▁ multiline ▁ text ▁ into ▁ strings <strnewline> ▁ <strnewline> ▁ For ▁ reversing ▁ effects ▁ of ▁ ``split_lines(nb)``. <strnewline> ▁ <strnewline> ▁ This ▁ only ▁ rejoins ▁ lines ▁ that ▁ have ▁ been ▁ split, ▁ so ▁ if ▁ text ▁ objects ▁ were ▁ not ▁ split <strnewline> ▁ they ▁ will ▁ pass ▁ through ▁ unchanged. <strnewline> ▁ <strnewline> ▁ Used ▁ when ▁ reading ▁ JSON ▁ files ▁ that ▁ may ▁ have ▁ been ▁ passed ▁ through ▁ split_lines. <strnewline> ▁ """  <newline> for ws in nb . worksheets : <newline> <indent> for cell in ws . cells : <newline> <indent> if cell . cell_type == 'code' : <newline> <indent> if 'input' in cell and isinstance ( cell . input , list ) : <newline> <indent> cell . input = _join_lines ( cell . input ) <newline> <dedent> for output in cell . outputs : <newline> <indent> for key in _multiline_outputs : <newline> <indent> item = output . get ( key , None ) <newline> if isinstance ( item , list ) : <newline> <indent> output [ key ] = _join_lines ( item ) <newline> <dedent> <dedent> <dedent> <dedent> else :  # ▁ text, ▁ heading ▁ cell <encdom> <newline> <indent> for key in [ 'source' , 'rendered' ] : <newline> <indent> item = cell . get ( key , None ) <newline> if isinstance ( item , list ) : <newline> <indent> cell [ key ] = _join_lines ( item ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> return nb <newline> <dedent> def split_lines ( nb ) : <newline> <indent>  """ split ▁ likely ▁ multiline ▁ text ▁ into ▁ lists ▁ of ▁ strings <strnewline> ▁ <strnewline> ▁ For ▁ file ▁ output ▁ more ▁ friendly ▁ to ▁ line-based ▁ VCS. ▁ ``rejoin_lines(nb)`` ▁ will <strnewline> ▁ reverse ▁ the ▁ effects ▁ of ▁ ``split_lines(nb)``. <strnewline> ▁ <strnewline> ▁ Used ▁ when ▁ writing ▁ JSON ▁ files. <strnewline> ▁ """  <newline> for ws in nb . worksheets : <newline> <indent> for cell in ws . cells : <newline> <indent> if cell . cell_type == 'code' : <newline> <indent> if 'input' in cell and isinstance ( cell . input , string_types ) : <newline> <indent> cell . input = cell . input . splitlines ( True ) <newline> <dedent> for output in cell . outputs : <newline> <indent> for key in _multiline_outputs : <newline> <indent> item = output . get ( key , None ) <newline> if isinstance ( item , string_types ) : <newline> <indent> output [ key ] = item . splitlines ( True ) <newline> <dedent> <dedent> <dedent> <dedent> else :  # ▁ text, ▁ heading ▁ cell <encdom> <newline> <indent> for key in [ 'source' , 'rendered' ] : <newline> <indent> item = cell . get ( key , None ) <newline> if isinstance ( item , string_types ) : <newline> <indent> cell [ key ] = item . splitlines ( True ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> return nb <newline>  # ▁ b64 ▁ encode/decode ▁ are ▁ never ▁ actually ▁ used, ▁ because ▁ all ▁ bytes ▁ objects ▁ in <encdom>  # ▁ the ▁ notebook ▁ are ▁ already ▁ b64-encoded, ▁ and ▁ we ▁ don't ▁ need/want ▁ to ▁ double-encode <encdom> <dedent> def base64_decode ( nb ) : <newline> <indent>  """ Restore ▁ all ▁ bytes ▁ objects ▁ in ▁ the ▁ notebook ▁ from ▁ base64-encoded ▁ strings. <strnewline> ▁ <strnewline> ▁ Note: ▁ This ▁ is ▁ never ▁ used <strnewline> ▁ """  <newline> for ws in nb . worksheets : <newline> <indent> for cell in ws . cells : <newline> <indent> if cell . cell_type == 'code' : <newline> <indent> for output in cell . outputs : <newline> <indent> if 'png' in output : <newline> <indent> if isinstance ( output . png , unicode_type ) : <newline> <indent> output . png = output . png . encode ( 'ascii' ) <newline> <dedent> output . png = decodestring ( output . png ) <newline> <dedent> if 'jpeg' in output : <newline> <indent> if isinstance ( output . jpeg , unicode_type ) : <newline> <indent> output . jpeg = output . jpeg . encode ( 'ascii' ) <newline> <dedent> output . jpeg = decodestring ( output . jpeg ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> return nb <newline> <dedent> def base64_encode ( nb ) : <newline> <indent>  """ Base64 ▁ encode ▁ all ▁ bytes ▁ objects ▁ in ▁ the ▁ notebook. <strnewline> ▁ <strnewline> ▁ These ▁ will ▁ be ▁ b64-encoded ▁ unicode ▁ strings <strnewline> ▁ <strnewline> ▁ Note: ▁ This ▁ is ▁ never ▁ used <strnewline> ▁ """  <newline> for ws in nb . worksheets : <newline> <indent> for cell in ws . cells : <newline> <indent> if cell . cell_type == 'code' : <newline> <indent> for output in cell . outputs : <newline> <indent> if 'png' in output : <newline> <indent> output . png = encodestring ( output . png ) . decode ( 'ascii' ) <newline> <dedent> if 'jpeg' in output : <newline> <indent> output . jpeg = encodestring ( output . jpeg ) . decode ( 'ascii' ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> return nb <newline> <dedent> class NotebookReader ( object ) : <newline> <indent>  """ A ▁ class ▁ for ▁ reading ▁ notebooks. """  <newline> def reads ( self , s , ** kwargs ) : <newline> <indent>  """ Read ▁ a ▁ notebook ▁ from ▁ a ▁ string. """  <newline> raise NotImplementedError ( "loads ▁ must ▁ be ▁ implemented ▁ in ▁ a ▁ subclass" ) <newline> <dedent> def read ( self , fp , ** kwargs ) : <newline> <indent>  """ Read ▁ a ▁ notebook ▁ from ▁ a ▁ file ▁ like ▁ object """  <newline> nbs = fp . read ( ) <newline> if not py3compat . PY3 and not isinstance ( nbs , unicode_type ) : <newline> <indent> nbs = py3compat . str_to_unicode ( nbs ) <newline> <dedent> return self . reads ( nbs , ** kwargs ) <newline> <dedent> <dedent> class NotebookWriter ( object ) : <newline> <indent>  """ A ▁ class ▁ for ▁ writing ▁ notebooks. """  <newline> def writes ( self , nb , ** kwargs ) : <newline> <indent>  """ Write ▁ a ▁ notebook ▁ to ▁ a ▁ string. """  <newline> raise NotImplementedError ( "loads ▁ must ▁ be ▁ implemented ▁ in ▁ a ▁ subclass" ) <newline> <dedent> def write ( self , nb , fp , ** kwargs ) : <newline> <indent>  """ Write ▁ a ▁ notebook ▁ to ▁ a ▁ file ▁ like ▁ object """  <newline> nbs = self . writes ( nb , ** kwargs ) <newline> if not py3compat . PY3 and not isinstance ( nbs , unicode_type ) : <newline>  # ▁ this ▁ branch ▁ is ▁ likely ▁ only ▁ taken ▁ for ▁ JSON ▁ on ▁ Python ▁ 2 <encdom> <indent> nbs = py3compat . str_to_unicode ( nbs ) <newline> <dedent> return fp . write ( nbs ) <newline> <dedent> <dedent>
 # ▁ Copyright ▁ (c) ▁ 2013, ▁ Web ▁ Notes ▁ Technologies ▁ Pvt. ▁ Ltd. ▁ and ▁ Contributors <encdom>  # ▁ License: ▁ GNU ▁ General ▁ Public ▁ License ▁ v3. ▁ See ▁ license.txt <encdom> from __future__ import unicode_literals <newline> import webnotes <newline> from webnotes . utils import flt , fmt_money , getdate <newline> from webnotes import _ <newline> class DocType : <newline> <indent> def __init__ ( self , d , dl ) : <newline> <indent> self . doc , self . doclist = d , dl <newline> <dedent> def validate ( self ) : <newline> <indent> self . check_mandatory ( ) <newline> self . pl_must_have_cost_center ( ) <newline> self . validate_posting_date ( ) <newline> self . check_pl_account ( ) <newline> self . validate_cost_center ( ) <newline> <dedent> def on_update_with_args ( self , adv_adj , update_outstanding = 'Yes' ) : <newline> <indent> self . validate_account_details ( adv_adj ) <newline> validate_frozen_account ( self . doc . account , adv_adj ) <newline> check_freezing_date ( self . doc . posting_date , adv_adj ) <newline> check_negative_balance ( self . doc . account , adv_adj ) <newline>  # ▁ Update ▁ outstanding ▁ amt ▁ on ▁ against ▁ voucher <encdom> if self . doc . against_voucher and self . doc . against_voucher_type != "POS" and update_outstanding == 'Yes' : <newline> <indent> update_outstanding_amt ( self . doc . account , self . doc . against_voucher_type , self . doc . against_voucher ) <newline> <dedent> <dedent> def check_mandatory ( self ) : <newline> <indent> mandatory = [ 'account' , 'remarks' , 'voucher_type' , 'voucher_no' , 'fiscal_year' , 'company' ] <newline> for k in mandatory : <newline> <indent> if not self . doc . fields . get ( k ) : <newline> <indent> webnotes . throw ( k + _ ( " ▁ is ▁ mandatory ▁ for ▁ GL ▁ Entry" ) ) <newline>  # ▁ Zero ▁ value ▁ transaction ▁ is ▁ not ▁ allowed <encdom> <dedent> <dedent> if not ( flt ( self . doc . debit ) or flt ( self . doc . credit ) ) : <newline> <indent> webnotes . throw ( _ ( "GL ▁ Entry: ▁ Debit ▁ or ▁ Credit ▁ amount ▁ is ▁ mandatory ▁ for ▁ " ) + self . doc . account ) <newline> <dedent> <dedent> def pl_must_have_cost_center ( self ) : <newline> <indent> if webnotes . conn . get_value ( "Account" , self . doc . account , "is_pl_account" ) == "Yes" : <newline> <indent> if not self . doc . cost_center and self . doc . voucher_type != 'Period ▁ Closing ▁ Voucher' : <newline> <indent> webnotes . throw ( _ ( "Cost ▁ Center ▁ must ▁ be ▁ specified ▁ for ▁ PL ▁ Account: ▁ " ) + self . doc . account ) <newline> <dedent> <dedent> elif self . doc . cost_center : <newline> <indent> self . doc . cost_center = None <newline> <dedent> <dedent> def validate_posting_date ( self ) : <newline> <indent> from accounts . utils import validate_fiscal_year <newline> validate_fiscal_year ( self . doc . posting_date , self . doc . fiscal_year , "Posting ▁ Date" ) <newline> <dedent> def check_pl_account ( self ) : <newline> <indent> if self . doc . is_opening == 'Yes' and webnotes . conn . get_value ( "Account" , self . doc . account , "is_pl_account" ) == "Yes" : <newline> <indent> webnotes . throw ( _ ( "For ▁ opening ▁ balance ▁ entry ▁ account ▁ can ▁ not ▁ be ▁ a ▁ PL ▁ account" ) ) <newline> <dedent> <dedent> def validate_account_details ( self , adv_adj ) : <newline> <indent>  """ Account ▁ must ▁ be ▁ ledger, ▁ active ▁ and ▁ not ▁ freezed """  <newline> ret = webnotes . conn . sql (  """ select ▁ group_or_ledger, ▁ docstatus, ▁ company ▁ <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> from ▁ tabAccount ▁ where ▁ name=%s """  , self . doc . account , as_dict = 1 ) [ 0 ] <newline> if ret . group_or_ledger == 'Group' : <newline> <indent> webnotes . throw ( _ ( "Account" ) + ": ▁ " + self . doc . account + _ ( " ▁ is ▁ not ▁ a ▁ ledger" ) ) <newline> <dedent> if ret . docstatus == 2 : <newline> <indent> webnotes . throw ( _ ( "Account" ) + ": ▁ " + self . doc . account + _ ( " ▁ is ▁ not ▁ active" ) ) <newline> <dedent> if ret . company != self . doc . company : <newline> <indent> webnotes . throw ( _ ( "Account" ) + ": ▁ " + self . doc . account + _ ( " ▁ does ▁ not ▁ belong ▁ to ▁ the ▁ company" ) + ": ▁ " + self . doc . company ) <newline> <dedent> <dedent> def validate_cost_center ( self ) : <newline> <indent> if not hasattr ( self , "cost_center_company" ) : <newline> <indent> self . cost_center_company = { } <newline> <dedent> def _get_cost_center_company ( ) : <newline> <indent> if not self . cost_center_company . get ( self . doc . cost_center ) : <newline> <indent> self . cost_center_company [ self . doc . cost_center ] = webnotes . conn . get_value ( "Cost ▁ Center" , self . doc . cost_center , "company" ) <newline> <dedent> return self . cost_center_company [ self . doc . cost_center ] <newline> <dedent> if self . doc . cost_center and _get_cost_center_company ( ) != self . doc . company : <newline> <indent> webnotes . throw ( _ ( "Cost ▁ Center" ) + ": ▁ " + self . doc . cost_center + _ ( " ▁ does ▁ not ▁ belong ▁ to ▁ the ▁ company" ) + ": ▁ " + self . doc . company ) <newline> <dedent> <dedent> <dedent> def check_negative_balance ( account , adv_adj = False ) : <newline> <indent> if not adv_adj and account : <newline> <indent> account_details = webnotes . conn . get_value ( "Account" , account , [ "allow_negative_balance" , "debit_or_credit" ] , as_dict = True ) <newline> if not account_details [ "allow_negative_balance" ] : <newline> <indent> balance = webnotes . conn . sql (  """ select ▁ sum(debit) ▁ - ▁ sum(credit) ▁ from ▁ `tabGL ▁ Entry` ▁ <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> <tabsymbol> where ▁ account ▁ = ▁ %s """  , account ) <newline> balance = account_details [ "debit_or_credit" ] == "Debit" and flt ( balance [ 0 ] [ 0 ] ) or - 1 * flt ( balance [ 0 ] [ 0 ] ) <newline> if flt ( balance ) < 0 : <newline> <indent> webnotes . throw ( _ ( "Negative ▁ balance ▁ is ▁ not ▁ allowed ▁ for ▁ account ▁ " ) + account ) <newline> <dedent> <dedent> <dedent> <dedent> def check_freezing_date ( posting_date , adv_adj = False ) : <newline> <indent>  """ <strnewline> <tabsymbol> <tabsymbol> Nobody ▁ can ▁ do ▁ GL ▁ Entries ▁ where ▁ posting ▁ date ▁ is ▁ before ▁ freezing ▁ date ▁ <strnewline> <tabsymbol> <tabsymbol> except ▁ authorized ▁ person <strnewline> <tabsymbol> """  <newline> if not adv_adj : <newline> <indent> acc_frozen_upto = webnotes . conn . get_value ( 'Accounts ▁ Settings' , None , 'acc_frozen_upto' ) <newline> if acc_frozen_upto : <newline> <indent> bde_auth_role = webnotes . conn . get_value ( 'Accounts ▁ Settings' , None , 'bde_auth_role' ) <newline> if getdate ( posting_date ) <= getdate ( acc_frozen_upto ) and not bde_auth_role in webnotes . user . get_roles ( ) : <newline> <indent> webnotes . throw ( _ ( "You ▁ are ▁ not ▁ authorized ▁ to ▁ do/modify ▁ back ▁ dated ▁ entries ▁ before ▁ " ) + getdate ( acc_frozen_upto ) . strftime ( '%d-%m-%Y' ) ) <newline> <dedent> <dedent> <dedent> <dedent> def update_outstanding_amt ( account , against_voucher_type , against_voucher , on_cancel = False ) : <newline>  # ▁ get ▁ final ▁ outstanding ▁ amt <encdom> <indent> bal = flt ( webnotes . conn . sql (  """ select ▁ sum(ifnull(debit, ▁ 0)) ▁ - ▁ sum(ifnull(credit, ▁ 0)) ▁ <strnewline> <tabsymbol> <tabsymbol> from ▁ `tabGL ▁ Entry` ▁ <strnewline> <tabsymbol> <tabsymbol> where ▁ against_voucher_type=%s ▁ and ▁ against_voucher=%s ▁ and ▁ account ▁ = ▁ %s """  , ( against_voucher_type , against_voucher , account ) ) [ 0 ] [ 0 ] or 0.0 ) <newline> if against_voucher_type == 'Purchase ▁ Invoice' : <newline> <indent> bal = - bal <newline> <dedent> elif against_voucher_type == "Journal ▁ Voucher" : <newline> <indent> against_voucher_amount = flt ( webnotes . conn . sql (  """ <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> select ▁ sum(ifnull(debit, ▁ 0)) ▁ - ▁ sum(ifnull(credit, ▁ 0)) <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> from ▁ `tabGL ▁ Entry` ▁ where ▁ voucher_type ▁ = ▁'Journal ▁ Voucher' ▁ and ▁ voucher_no ▁ = ▁ %s <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> and ▁ account ▁ = ▁ %s ▁ and ▁ ifnull(against_voucher, ▁'') ▁ = ▁'' """  , ( against_voucher , account ) ) [ 0 ] [ 0 ] ) <newline> bal = against_voucher_amount + bal <newline> if against_voucher_amount < 0 : <newline> <indent> bal = - bal <newline>  # ▁ Validation ▁ : ▁ Outstanding ▁ can ▁ not ▁ be ▁ negative <encdom> <dedent> <dedent> if bal < 0 and not on_cancel : <newline> <indent> webnotes . throw ( _ ( "Outstanding ▁ for ▁ Voucher ▁ " ) + against_voucher + _ ( " ▁ will ▁ become ▁ " ) + fmt_money ( bal ) + _ ( ". ▁ Outstanding ▁ cannot ▁ be ▁ less ▁ than ▁ zero. ▁ \ <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> ▁ <tabsymbol> Please ▁ match ▁ exact ▁ outstanding." ) ) <newline>  # ▁ Update ▁ outstanding ▁ amt ▁ on ▁ against ▁ voucher <encdom> <dedent> if against_voucher_type in [ "Sales ▁ Invoice" , "Purchase ▁ Invoice" ] : <newline> <indent> webnotes . conn . sql ( "update ▁ `tab%s` ▁ set ▁ outstanding_amount=%s ▁ where ▁ name='%s'" % ( against_voucher_type , bal , against_voucher ) ) <newline> <dedent> <dedent> def validate_frozen_account ( account , adv_adj = None ) : <newline> <indent> frozen_account = webnotes . conn . get_value ( "Account" , account , "freeze_account" ) <newline> if frozen_account == 'Yes' and not adv_adj : <newline> <indent> frozen_accounts_modifier = webnotes . conn . get_value ( 'Accounts ▁ Settings' , None , 'frozen_accounts_modifier' ) <newline> if not frozen_accounts_modifier : <newline> <indent> webnotes . throw ( account + _ ( " ▁ is ▁ a ▁ frozen ▁ account. ▁ \ <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> <tabsymbol> Either ▁ make ▁ the ▁ account ▁ active ▁ or ▁ assign ▁ role ▁ in ▁ Accounts ▁ Settings ▁ \ <strnewline> <tabsymbol> <tabsymbol> <tabsymbol> <tabsymbol> who ▁ can ▁ create ▁ / ▁ modify ▁ entries ▁ against ▁ this ▁ account" ) ) <newline> <dedent> elif frozen_accounts_modifier not in webnotes . user . get_roles ( ) : <newline> <indent> webnotes . throw ( account + _ ( " ▁ is ▁ a ▁ frozen ▁ account. ▁ " ) + _ ( "To ▁ create ▁ / ▁ edit ▁ transactions ▁ against ▁ this ▁ account, ▁ you ▁ need ▁ role" ) + ": ▁ " + frozen_accounts_modifier ) <newline> <dedent> <dedent> <dedent>
from greet import greet <newline> def niam ( args ) : <newline> <indent> return greet ( args ) <newline> <dedent>
 # ▁ Copyright ▁ Jonathan ▁ Hartley ▁ 2013. ▁ BSD ▁ 3-Clause ▁ license, ▁ see ▁ LICENSE ▁ file. <encdom>  # ▁ from ▁ winbase.h <encdom> STDOUT = - 11 <newline> STDERR = - 12 <newline> try : <newline> <indent> from ctypes import windll <newline> from ctypes import wintypes <newline> <dedent> except ImportError : <newline> <indent> windll = None <newline> SetConsoleTextAttribute = lambda * _ : None <newline> <dedent> else : <newline> <indent> from ctypes import ( byref , Structure , c_char , c_short , c_int , c_uint32 , c_ushort , c_void_p , POINTER ) <newline> class CONSOLE_SCREEN_BUFFER_INFO ( Structure ) : <newline> <indent>  """ struct ▁ in ▁ wincon.h. """  <newline> _fields_ = [ ( "dwSize" , wintypes . _COORD ) , ( "dwCursorPosition" , wintypes . _COORD ) , ( "wAttributes" , wintypes . WORD ) , ( "srWindow" , wintypes . SMALL_RECT ) , ( "dwMaximumWindowSize" , wintypes . _COORD ) , ] <newline> def __str__ ( self ) : <newline> <indent> return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % ( self . dwSize . Y , self . dwSize . X , self . dwCursorPosition . Y , self . dwCursorPosition . X , self . wAttributes , self . srWindow . Top , self . srWindow . Left , self . srWindow . Bottom , self . srWindow . Right , self . dwMaximumWindowSize . Y , self . dwMaximumWindowSize . X ) <newline> <dedent> <dedent> _GetStdHandle = windll . kernel32 . GetStdHandle <newline> _GetStdHandle . argtypes = [ wintypes . DWORD , ] <newline> _GetStdHandle . restype = wintypes . HANDLE <newline> _GetConsoleScreenBufferInfo = windll . kernel32 . GetConsoleScreenBufferInfo <newline> _GetConsoleScreenBufferInfo . argtypes = [ wintypes . HANDLE , c_void_p ,  # POINTER(CONSOLE_SCREEN_BUFFER_INFO), <encdom> ] <newline> _GetConsoleScreenBufferInfo . restype = wintypes . BOOL <newline> _SetConsoleTextAttribute = windll . kernel32 . SetConsoleTextAttribute <newline> _SetConsoleTextAttribute . argtypes = [ wintypes . HANDLE , wintypes . WORD , ] <newline> _SetConsoleTextAttribute . restype = wintypes . BOOL <newline> _SetConsoleCursorPosition = windll . kernel32 . SetConsoleCursorPosition <newline> _SetConsoleCursorPosition . argtypes = [ wintypes . HANDLE , c_int ,  # wintypes._COORD, <encdom> ] <newline> _SetConsoleCursorPosition . restype = wintypes . BOOL <newline> _FillConsoleOutputCharacterA = windll . kernel32 . FillConsoleOutputCharacterA <newline> _FillConsoleOutputCharacterA . argtypes = [ wintypes . HANDLE , c_char , wintypes . DWORD , wintypes . _COORD , POINTER ( wintypes . DWORD ) , ] <newline> _FillConsoleOutputCharacterA . restype = wintypes . BOOL <newline> _FillConsoleOutputAttribute = windll . kernel32 . FillConsoleOutputAttribute <newline> _FillConsoleOutputAttribute . argtypes = [ wintypes . HANDLE , wintypes . WORD , wintypes . DWORD , c_int ,  # wintypes._COORD, <encdom> POINTER ( wintypes . DWORD ) , ] <newline> _FillConsoleOutputAttribute . restype = wintypes . BOOL <newline> handles = { STDOUT : _GetStdHandle ( STDOUT ) , STDERR : _GetStdHandle ( STDERR ) , } <newline> def GetConsoleScreenBufferInfo ( stream_id = STDOUT ) : <newline> <indent> handle = handles [ stream_id ] <newline> csbi = CONSOLE_SCREEN_BUFFER_INFO ( ) <newline> success = _GetConsoleScreenBufferInfo ( handle , byref ( csbi ) ) <newline> return csbi <newline> <dedent> def SetConsoleTextAttribute ( stream_id , attrs ) : <newline> <indent> handle = handles [ stream_id ] <newline> return _SetConsoleTextAttribute ( handle , attrs ) <newline> <dedent> def SetConsoleCursorPosition ( stream_id , position ) : <newline> <indent> position = wintypes . _COORD ( * position ) <newline>  # ▁ If ▁ the ▁ position ▁ is ▁ out ▁ of ▁ range, ▁ do ▁ nothing. <encdom> if position . Y <= 0 or position . X <= 0 : <newline> <indent> return <newline>  # ▁ Adjust ▁ for ▁ Windows' ▁ SetConsoleCursorPosition: <encdom>  # ▁ 1. ▁ being ▁ 0-based, ▁ while ▁ ANSI ▁ is ▁ 1-based. <encdom>  # ▁ 2. ▁ expecting ▁ (x,y), ▁ while ▁ ANSI ▁ uses ▁ (y,x). <encdom> <dedent> adjusted_position = wintypes . _COORD ( position . Y - 1 , position . X - 1 ) <newline>  # ▁ Adjust ▁ for ▁ viewport's ▁ scroll ▁ position <encdom> sr = GetConsoleScreenBufferInfo ( STDOUT ) . srWindow <newline> adjusted_position . Y += sr . Top <newline> adjusted_position . X += sr . Left <newline>  # ▁ Resume ▁ normal ▁ processing <encdom> handle = handles [ stream_id ] <newline> return _SetConsoleCursorPosition ( handle , adjusted_position ) <newline> <dedent> def FillConsoleOutputCharacter ( stream_id , char , length , start ) : <newline> <indent> handle = handles [ stream_id ] <newline> char = c_char ( char ) <newline> length = wintypes . DWORD ( length ) <newline> num_written = wintypes . DWORD ( 0 ) <newline>  # ▁ Note ▁ that ▁ this ▁ is ▁ hard-coded ▁ for ▁ ANSI ▁ (vs ▁ wide) ▁ bytes. <encdom> success = _FillConsoleOutputCharacterA ( handle , char , length , start , byref ( num_written ) ) <newline> return num_written . value <newline> <dedent> def FillConsoleOutputAttribute ( stream_id , attr , length , start ) : <newline> <indent>  ''' ▁ FillConsoleOutputAttribute( ▁ hConsole, ▁ csbi.wAttributes, ▁ dwConSize, ▁ coordScreen, ▁ &cCharsWritten ▁ ) '''  <newline> handle = handles [ stream_id ] <newline> attribute = wintypes . WORD ( attr ) <newline> length = wintypes . DWORD ( length ) <newline> num_written = wintypes . DWORD ( 0 ) <newline>  # ▁ Note ▁ that ▁ this ▁ is ▁ hard-coded ▁ for ▁ ANSI ▁ (vs ▁ wide) ▁ bytes. <encdom> return _FillConsoleOutputAttribute ( handle , attribute , length , start , byref ( num_written ) ) <newline> <dedent> <dedent>
 # !/usr/bin/env ▁ python <encdom>  # ▁ Copyright ▁ 2015 ▁ clowwindy <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); ▁ you ▁ may <encdom>  # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. ▁ You ▁ may ▁ obtain <encdom>  # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, ▁ WITHOUT <encdom>  # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. ▁ See ▁ the <encdom>  # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations <encdom>  # ▁ under ▁ the ▁ License. <encdom> from __future__ import absolute_import , division , print_function , with_statement <newline> from ctypes import c_char_p , c_int , c_long , byref , create_string_buffer , c_void_p <newline> from shadowsocks import common <newline> from shadowsocks . crypto import util <newline> __all__ = [ 'ciphers' ] <newline> libcrypto = None <newline> loaded = False <newline> buf_size = 2048 <newline> def load_openssl ( ) : <newline> <indent> global loaded , libcrypto , buf <newline> libcrypto = util . find_library ( ( 'crypto' , 'eay32' ) , 'EVP_get_cipherbyname' , 'libcrypto' ) <newline> if libcrypto is None : <newline> <indent> raise Exception ( 'libcrypto(OpenSSL) ▁ not ▁ found' ) <newline> <dedent> libcrypto . EVP_get_cipherbyname . restype = c_void_p <newline> libcrypto . EVP_CIPHER_CTX_new . restype = c_void_p <newline> libcrypto . EVP_CipherInit_ex . argtypes = ( c_void_p , c_void_p , c_char_p , c_char_p , c_char_p , c_int ) <newline> libcrypto . EVP_CipherUpdate . argtypes = ( c_void_p , c_void_p , c_void_p , c_char_p , c_int ) <newline> libcrypto . EVP_CIPHER_CTX_cleanup . argtypes = ( c_void_p , ) <newline> libcrypto . EVP_CIPHER_CTX_free . argtypes = ( c_void_p , ) <newline> if hasattr ( libcrypto , 'OpenSSL_add_all_ciphers' ) : <newline> <indent> libcrypto . OpenSSL_add_all_ciphers ( ) <newline> <dedent> buf = create_string_buffer ( buf_size ) <newline> loaded = True <newline> <dedent> def load_cipher ( cipher_name ) : <newline> <indent> func_name = 'EVP_' + cipher_name . replace ( '-' , '_' ) <newline> if bytes != str : <newline> <indent> func_name = str ( func_name , 'utf-8' ) <newline> <dedent> cipher = getattr ( libcrypto , func_name , None ) <newline> if cipher : <newline> <indent> cipher . restype = c_void_p <newline> return cipher ( ) <newline> <dedent> return None <newline> <dedent> class OpenSSLCrypto ( object ) : <newline> <indent> def __init__ ( self , cipher_name , key , iv , op ) : <newline> <indent> self . _ctx = None <newline> if not loaded : <newline> <indent> load_openssl ( ) <newline> <dedent> cipher_name = common . to_bytes ( cipher_name ) <newline> cipher = libcrypto . EVP_get_cipherbyname ( cipher_name ) <newline> if not cipher : <newline> <indent> cipher = load_cipher ( cipher_name ) <newline> <dedent> if not cipher : <newline> <indent> raise Exception ( 'cipher ▁ %s ▁ not ▁ found ▁ in ▁ libcrypto' % cipher_name ) <newline> <dedent> key_ptr = c_char_p ( key ) <newline> iv_ptr = c_char_p ( iv ) <newline> self . _ctx = libcrypto . EVP_CIPHER_CTX_new ( ) <newline> if not self . _ctx : <newline> <indent> raise Exception ( 'can ▁ not ▁ create ▁ cipher ▁ context' ) <newline> <dedent> r = libcrypto . EVP_CipherInit_ex ( self . _ctx , cipher , None , key_ptr , iv_ptr , c_int ( op ) ) <newline> if not r : <newline> <indent> self . clean ( ) <newline> raise Exception ( 'can ▁ not ▁ initialize ▁ cipher ▁ context' ) <newline> <dedent> <dedent> def update ( self , data ) : <newline> <indent> global buf_size , buf <newline> cipher_out_len = c_long ( 0 ) <newline> l = len ( data ) <newline> if buf_size < l : <newline> <indent> buf_size = l * 2 <newline> buf = create_string_buffer ( buf_size ) <newline> <dedent> libcrypto . EVP_CipherUpdate ( self . _ctx , byref ( buf ) , byref ( cipher_out_len ) , c_char_p ( data ) , l ) <newline>  # ▁ buf ▁ is ▁ copied ▁ to ▁ a ▁ str ▁ object ▁ when ▁ we ▁ access ▁ buf.raw <encdom> return buf . raw [ : cipher_out_len . value ] <newline> <dedent> def __del__ ( self ) : <newline> <indent> self . clean ( ) <newline> <dedent> def clean ( self ) : <newline> <indent> if self . _ctx : <newline> <indent> libcrypto . EVP_CIPHER_CTX_cleanup ( self . _ctx ) <newline> libcrypto . EVP_CIPHER_CTX_free ( self . _ctx ) <newline> <dedent> <dedent> <dedent> ciphers = { 'aes-128-cfb' : ( 16 , 16 , OpenSSLCrypto ) , 'aes-192-cfb' : ( 24 , 16 , OpenSSLCrypto ) , 'aes-256-cfb' : ( 32 , 16 , OpenSSLCrypto ) , 'aes-128-ofb' : ( 16 , 16 , OpenSSLCrypto ) , 'aes-192-ofb' : ( 24 , 16 , OpenSSLCrypto ) , 'aes-256-ofb' : ( 32 , 16 , OpenSSLCrypto ) , 'aes-128-ctr' : ( 16 , 16 , OpenSSLCrypto ) , 'aes-192-ctr' : ( 24 , 16 , OpenSSLCrypto ) , 'aes-256-ctr' : ( 32 , 16 , OpenSSLCrypto ) , 'aes-128-cfb8' : ( 16 , 16 , OpenSSLCrypto ) , 'aes-192-cfb8' : ( 24 , 16 , OpenSSLCrypto ) , 'aes-256-cfb8' : ( 32 , 16 , OpenSSLCrypto ) , 'aes-128-cfb1' : ( 16 , 16 , OpenSSLCrypto ) , 'aes-192-cfb1' : ( 24 , 16 , OpenSSLCrypto ) , 'aes-256-cfb1' : ( 32 , 16 , OpenSSLCrypto ) , 'bf-cfb' : ( 16 , 8 , OpenSSLCrypto ) , 'camellia-128-cfb' : ( 16 , 16 , OpenSSLCrypto ) , 'camellia-192-cfb' : ( 24 , 16 , OpenSSLCrypto ) , 'camellia-256-cfb' : ( 32 , 16 , OpenSSLCrypto ) , 'cast5-cfb' : ( 16 , 8 , OpenSSLCrypto ) , 'des-cfb' : ( 8 , 8 , OpenSSLCrypto ) , 'idea-cfb' : ( 16 , 8 , OpenSSLCrypto ) , 'rc2-cfb' : ( 16 , 8 , OpenSSLCrypto ) , 'rc4' : ( 16 , 0 , OpenSSLCrypto ) , 'seed-cfb' : ( 16 , 16 , OpenSSLCrypto ) , } <newline> def run_method ( method ) : <newline> <indent> cipher = OpenSSLCrypto ( method , b'k' * 32 , b'i' * 16 , 1 ) <newline> decipher = OpenSSLCrypto ( method , b'k' * 32 , b'i' * 16 , 0 ) <newline> util . run_cipher ( cipher , decipher ) <newline> <dedent> def test_aes_128_cfb ( ) : <newline> <indent> run_method ( 'aes-128-cfb' ) <newline> <dedent> def test_aes_256_cfb ( ) : <newline> <indent> run_method ( 'aes-256-cfb' ) <newline> <dedent> def test_aes_128_cfb8 ( ) : <newline> <indent> run_method ( 'aes-128-cfb8' ) <newline> <dedent> def test_aes_256_ofb ( ) : <newline> <indent> run_method ( 'aes-256-ofb' ) <newline> <dedent> def test_aes_256_ctr ( ) : <newline> <indent> run_method ( 'aes-256-ctr' ) <newline> <dedent> def test_bf_cfb ( ) : <newline> <indent> run_method ( 'bf-cfb' ) <newline> <dedent> def test_rc4 ( ) : <newline> <indent> run_method ( 'rc4' ) <newline> <dedent> if __name__ == '__main__' : <newline> <indent> test_aes_128_cfb ( ) <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom> from __future__ import unicode_literals <newline> from django . db import models , migrations <newline> class Migration ( migrations . Migration ) : <newline> <indent> dependencies = [ ( 'exercise' , '0021_auto_20160905_1335' ) , ] <newline> operations = [ migrations . AlterField ( model_name = 'baseexercise' , name = 'difficulty' , field = models . CharField ( blank = True , max_length = 32 ) , preserve_default = True , ) , ] <newline> <dedent>
 """ distutils.spawn <strnewline> <strnewline> Provides ▁ the ▁'spawn()' ▁ function, ▁ a ▁ front-end ▁ to ▁ various ▁ platform- <strnewline> specific ▁ functions ▁ for ▁ launching ▁ another ▁ program ▁ in ▁ a ▁ sub-process. <strnewline> Also ▁ provides ▁ the ▁'find_executable()' ▁ to ▁ search ▁ the ▁ path ▁ for ▁ a ▁ given <strnewline> executable ▁ name. <strnewline> """  <newline>  # ▁ This ▁ module ▁ should ▁ be ▁ kept ▁ compatible ▁ with ▁ Python ▁ 2.1. <encdom> __revision__ = "$Id: ▁ spawn.py ▁ 37828 ▁ 2004-11-10 ▁ 22:23:15Z ▁ loewis ▁ $" <newline> import sys , os , string <newline> from distutils . errors import * <newline> from distutils import log <newline> def spawn ( cmd , search_path = 1 , verbose = 0 , dry_run = 0 ) : <newline> <indent>  """ Run ▁ another ▁ program, ▁ specified ▁ as ▁ a ▁ command ▁ list ▁'cmd', ▁ in ▁ a ▁ new <strnewline> ▁ process. ▁'cmd' ▁ is ▁ just ▁ the ▁ argument ▁ list ▁ for ▁ the ▁ new ▁ process, ▁ ie. <strnewline> ▁ cmd[0] ▁ is ▁ the ▁ program ▁ to ▁ run ▁ and ▁ cmd[1:] ▁ are ▁ the ▁ rest ▁ of ▁ its ▁ arguments. <strnewline> ▁ There ▁ is ▁ no ▁ way ▁ to ▁ run ▁ a ▁ program ▁ with ▁ a ▁ name ▁ different ▁ from ▁ that ▁ of ▁ its <strnewline> ▁ executable. <strnewline> <strnewline> ▁ If ▁'search_path' ▁ is ▁ true ▁ (the ▁ default), ▁ the ▁ system's ▁ executable <strnewline> ▁ search ▁ path ▁ will ▁ be ▁ used ▁ to ▁ find ▁ the ▁ program; ▁ otherwise, ▁ cmd[0] <strnewline> ▁ must ▁ be ▁ the ▁ exact ▁ path ▁ to ▁ the ▁ executable. ▁ If ▁'dry_run' ▁ is ▁ true, <strnewline> ▁ the ▁ command ▁ will ▁ not ▁ actually ▁ be ▁ run. <strnewline> <strnewline> ▁ Raise ▁ DistutilsExecError ▁ if ▁ running ▁ the ▁ program ▁ fails ▁ in ▁ any ▁ way; ▁ just <strnewline> ▁ return ▁ on ▁ success. <strnewline> ▁ """  <newline> if os . name == 'posix' : <newline> <indent> _spawn_posix ( cmd , search_path , dry_run = dry_run ) <newline> <dedent> elif os . name == 'nt' : <newline> <indent> _spawn_nt ( cmd , search_path , dry_run = dry_run ) <newline> <dedent> elif os . name == 'os2' : <newline> <indent> _spawn_os2 ( cmd , search_path , dry_run = dry_run ) <newline> <dedent> elif os . name == 'java' : <newline> <indent> _spawn_java ( cmd , search_path , dry_run = dry_run ) <newline> <dedent> else : <newline> <indent> raise DistutilsPlatformError , "don't ▁ know ▁ how ▁ to ▁ spawn ▁ programs ▁ on ▁ platform ▁'%s'" % os . name <newline>  # ▁ spawn ▁ () <encdom> <dedent> <dedent> def _nt_quote_args ( args ) : <newline> <indent>  """ Quote ▁ command-line ▁ arguments ▁ for ▁ DOS/Windows ▁ conventions: ▁ just <strnewline> ▁ wraps ▁ every ▁ argument ▁ which ▁ contains ▁ blanks ▁ in ▁ double ▁ quotes, ▁ and <strnewline> ▁ returns ▁ a ▁ new ▁ argument ▁ list. <strnewline> ▁ """  <newline>  # ▁ XXX ▁ this ▁ doesn't ▁ seem ▁ very ▁ robust ▁ to ▁ me ▁ -- ▁ but ▁ if ▁ the ▁ Windows ▁ guys <encdom>  # ▁ say ▁ it'll ▁ work, ▁ I ▁ guess ▁ I'll ▁ have ▁ to ▁ accept ▁ it. ▁ (What ▁ if ▁ an ▁ arg <encdom>  # ▁ contains ▁ quotes? ▁ What ▁ other ▁ magic ▁ characters, ▁ other ▁ than ▁ spaces, <encdom>  # ▁ have ▁ to ▁ be ▁ escaped? ▁ Is ▁ there ▁ an ▁ escaping ▁ mechanism ▁ other ▁ than <encdom>  # ▁ quoting?) <encdom> for i in range ( len ( args ) ) : <newline> <indent> if string . find ( args [ i ] , ' ▁ ' ) != - 1 : <newline> <indent> args [ i ] = '"%s"' % args [ i ] <newline> <dedent> <dedent> return args <newline> <dedent> def _spawn_nt ( cmd , search_path = 1 , verbose = 0 , dry_run = 0 ) : <newline> <indent> executable = cmd [ 0 ] <newline> cmd = _nt_quote_args ( cmd ) <newline> if search_path : <newline>  # ▁ either ▁ we ▁ find ▁ one ▁ or ▁ it ▁ stays ▁ the ▁ same <encdom> <indent> executable = find_executable ( executable ) or executable <newline> <dedent> log . info ( string . join ( [ executable ] + cmd [ 1 : ] , ' ▁ ' ) ) <newline> if not dry_run : <newline>  # ▁ spawn ▁ for ▁ NT ▁ requires ▁ a ▁ full ▁ path ▁ to ▁ the ▁ .exe <encdom> <indent> try : <newline> <indent> rc = os . spawnv ( os . P_WAIT , executable , cmd ) <newline> <dedent> except OSError , exc : <newline>  # ▁ this ▁ seems ▁ to ▁ happen ▁ when ▁ the ▁ command ▁ isn't ▁ found <encdom> <indent> raise DistutilsExecError , "command ▁'%s' ▁ failed: ▁ %s" % ( cmd [ 0 ] , exc [ - 1 ] ) <newline> <dedent> if rc != 0 : <newline>  # ▁ and ▁ this ▁ reflects ▁ the ▁ command ▁ running ▁ but ▁ failing <encdom> <indent> raise DistutilsExecError , "command ▁'%s' ▁ failed ▁ with ▁ exit ▁ status ▁ %d" % ( cmd [ 0 ] , rc ) <newline> <dedent> <dedent> <dedent> def _spawn_os2 ( cmd , search_path = 1 , verbose = 0 , dry_run = 0 ) : <newline> <indent> executable = cmd [ 0 ] <newline>  # cmd ▁ = ▁ _nt_quote_args(cmd) <encdom> if search_path : <newline>  # ▁ either ▁ we ▁ find ▁ one ▁ or ▁ it ▁ stays ▁ the ▁ same <encdom> <indent> executable = find_executable ( executable ) or executable <newline> <dedent> log . info ( string . join ( [ executable ] + cmd [ 1 : ] , ' ▁ ' ) ) <newline> if not dry_run : <newline>  # ▁ spawnv ▁ for ▁ OS/2 ▁ EMX ▁ requires ▁ a ▁ full ▁ path ▁ to ▁ the ▁ .exe <encdom> <indent> try : <newline> <indent> rc = os . spawnv ( os . P_WAIT , executable , cmd ) <newline> <dedent> except OSError , exc : <newline>  # ▁ this ▁ seems ▁ to ▁ happen ▁ when ▁ the ▁ command ▁ isn't ▁ found <encdom> <indent> raise DistutilsExecError , "command ▁'%s' ▁ failed: ▁ %s" % ( cmd [ 0 ] , exc [ - 1 ] ) <newline> <dedent> if rc != 0 : <newline>  # ▁ and ▁ this ▁ reflects ▁ the ▁ command ▁ running ▁ but ▁ failing <encdom> <indent> print "command ▁'%s' ▁ failed ▁ with ▁ exit ▁ status ▁ %d" % ( cmd [ 0 ] , rc ) <newline> raise DistutilsExecError , "command ▁'%s' ▁ failed ▁ with ▁ exit ▁ status ▁ %d" % ( cmd [ 0 ] , rc ) <newline> <dedent> <dedent> <dedent> def _spawn_posix ( cmd , search_path = 1 , verbose = 0 , dry_run = 0 ) : <newline> <indent> log . info ( string . join ( cmd , ' ▁ ' ) ) <newline> if dry_run : <newline> <indent> return <newline> <dedent> exec_fn = search_path and os . execvp or os . execv <newline> pid = os . fork ( ) <newline> if pid == 0 :  # ▁ in ▁ the ▁ child <encdom> <newline> <indent> try : <newline>  # print ▁"cmd[0] ▁ =", ▁ cmd[0] <encdom>  # print ▁"cmd ▁ =", ▁ cmd <encdom> <indent> exec_fn ( cmd [ 0 ] , cmd ) <newline> <dedent> except OSError , e : <newline> <indent> sys . stderr . write ( "unable ▁ to ▁ execute ▁ %s: ▁ %s \n " % ( cmd [ 0 ] , e . strerror ) ) <newline> os . _exit ( 1 ) <newline> <dedent> sys . stderr . write ( "unable ▁ to ▁ execute ▁ %s ▁ for ▁ unknown ▁ reasons" % cmd [ 0 ] ) <newline> os . _exit ( 1 ) <newline> <dedent> else :  # ▁ in ▁ the ▁ parent <encdom> <newline>  # ▁ Loop ▁ until ▁ the ▁ child ▁ either ▁ exits ▁ or ▁ is ▁ terminated ▁ by ▁ a ▁ signal <encdom>  # ▁ (ie. ▁ keep ▁ waiting ▁ if ▁ it's ▁ merely ▁ stopped) <encdom> <indent> while 1 : <newline> <indent> try : <newline> <indent> ( pid , status ) = os . waitpid ( pid , 0 ) <newline> <dedent> except OSError , exc : <newline> <indent> import errno <newline> if exc . errno == errno . EINTR : <newline> <indent> continue <newline> <dedent> raise DistutilsExecError , "command ▁'%s' ▁ failed: ▁ %s" % ( cmd [ 0 ] , exc [ - 1 ] ) <newline> <dedent> if os . WIFSIGNALED ( status ) : <newline> <indent> raise DistutilsExecError , "command ▁'%s' ▁ terminated ▁ by ▁ signal ▁ %d" % ( cmd [ 0 ] , os . WTERMSIG ( status ) ) <newline> <dedent> elif os . WIFEXITED ( status ) : <newline> <indent> exit_status = os . WEXITSTATUS ( status ) <newline> if exit_status == 0 : <newline> <indent> return  # ▁ hey, ▁ it ▁ succeeded! <encdom> <newline> <dedent> else : <newline> <indent> raise DistutilsExecError , "command ▁'%s' ▁ failed ▁ with ▁ exit ▁ status ▁ %d" % ( cmd [ 0 ] , exit_status ) <newline> <dedent> <dedent> elif os . WIFSTOPPED ( status ) : <newline> <indent> continue <newline> <dedent> else : <newline> <indent> raise DistutilsExecError , "unknown ▁ error ▁ executing ▁'%s': ▁ termination ▁ status ▁ %d" % ( cmd [ 0 ] , status ) <newline>  # ▁ _spawn_posix ▁ () <encdom> <dedent> <dedent> <dedent> <dedent> def _spawn_java ( cmd , search_path = 1 , verbose = 0 , dry_run = 0 ) : <newline> <indent> executable = cmd [ 0 ] <newline> cmd = ' ▁ ' . join ( _nt_quote_args ( cmd ) ) <newline> log . info ( cmd ) <newline> if not dry_run : <newline> <indent> try : <newline> <indent> rc = os . system ( cmd ) >> 8 <newline> <dedent> except OSError , exc : <newline>  # ▁ this ▁ seems ▁ to ▁ happen ▁ when ▁ the ▁ command ▁ isn't ▁ found <encdom> <indent> raise DistutilsExecError , "command ▁'%s' ▁ failed: ▁ %s" % ( executable , exc [ - 1 ] ) <newline> <dedent> if rc != 0 : <newline>  # ▁ and ▁ this ▁ reflects ▁ the ▁ command ▁ running ▁ but ▁ failing <encdom> <indent> print "command ▁'%s' ▁ failed ▁ with ▁ exit ▁ status ▁ %d" % ( executable , rc ) <newline> raise DistutilsExecError , "command ▁'%s' ▁ failed ▁ with ▁ exit ▁ status ▁ %d" % ( executable , rc ) <newline> <dedent> <dedent> <dedent> def find_executable ( executable , path = None ) : <newline> <indent>  """ Try ▁ to ▁ find ▁'executable' ▁ in ▁ the ▁ directories ▁ listed ▁ in ▁'path' ▁ (a <strnewline> ▁ string ▁ listing ▁ directories ▁ separated ▁ by ▁'os.pathsep'; ▁ defaults ▁ to <strnewline> ▁ os.environ['PATH']). ▁ Returns ▁ the ▁ complete ▁ filename ▁ or ▁ None ▁ if ▁ not <strnewline> ▁ found. <strnewline> ▁ """  <newline> if path is None : <newline> <indent> path = os . environ [ 'PATH' ] <newline> <dedent> paths = string . split ( path , os . pathsep ) <newline> ( base , ext ) = os . path . splitext ( executable ) <newline> if ( sys . platform == 'win32' or os . name == 'os2' ) and ( ext != '.exe' ) : <newline> <indent> executable = executable + '.exe' <newline> <dedent> if not os . path . isfile ( executable ) : <newline> <indent> for p in paths : <newline> <indent> f = os . path . join ( p , executable ) <newline> if os . path . isfile ( f ) : <newline>  # ▁ the ▁ file ▁ exists, ▁ we ▁ have ▁ a ▁ shot ▁ at ▁ spawn ▁ working <encdom> <indent> return f <newline> <dedent> <dedent> return None <newline> <dedent> else : <newline> <indent> return executable <newline>  # ▁ find_executable() <encdom> <dedent> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ Provides ▁ the ▁ core ▁ classes ▁ and ▁ functions ▁ for ▁ VizAlerts <encdom> import os <newline> import re <newline> import csv <newline> import copy <newline> import threading <newline> import datetime <newline> import time <newline> from PyPDF2 import PdfFileReader , PdfFileMerger <newline> from collections import OrderedDict <newline> from os . path import abspath , basename , expanduser <newline> from operator import itemgetter <newline> import posixpath <newline> import uuid <newline> from Queue import Queue <newline>  # ▁ import ▁ local ▁ modules <encdom> import config <newline> import log <newline> import tabhttp <newline> import emailaction <newline> import smsaction <newline>  # ▁ reserved ▁ strings ▁ for ▁ Advanced ▁ Alerts ▁ embedding <encdom> IMAGE_PLACEHOLDER = u'VIZ_IMAGE()' <newline> PDF_PLACEHOLDER = u'VIZ_PDF()' <newline> CSV_PLACEHOLDER = u'VIZ_CSV()' <newline> TWB_PLACEHOLDER = u'VIZ_TWB()' <newline> DEFAULT_FOOTER = u'VIZALERTS_FOOTER()'  # ▁ special ▁ string ▁ for ▁ embedding ▁ the ▁ default ▁ footer ▁ in ▁ an ▁ Advanced ▁ Alert <encdom> <newline> VIZLINK_PLACEHOLDER = u'VIZ_LINK()'  # ▁ special ▁ string ▁ for ▁ embedding ▁ HTML ▁ links ▁ in ▁ Advanced ▁ Alert <encdom> <newline>  # ▁ reserved ▁ strings ▁ for ▁ Advanced ▁ Alerts ▁ arguments <encdom> EXPORTFILENAME_ARGUMENT = u'filename' <newline> MERGEPDF_ARGUMENT = u'mergepdf' <newline> VIZLINK_ARGUMENT = u'vizlink' <newline> RAWLINK_ARGUMENT = u'rawlink' <newline> ARGUMENT_DELIMITER = u'|' <newline>  # ▁ reserved ▁ strings ▁ for ▁ Action ▁ Field ▁ names ▁ (used ▁ as ▁ keys) <encdom>  # ▁ General ▁ use ▁ fields <encdom> GENERAL_SORTORDER_FIELDKEY = u'Consolidated ▁ Sort' <newline> CONSOLIDATE_LINES_FIELDKEY = u'Consolidate ▁ Lines' <newline>  # ▁ Email ▁ Action ▁ fields <encdom> EMAIL_ACTION_FIELDKEY = u'Email ▁ Action' <newline> EMAIL_TO_FIELDKEY = u'Email ▁ To' <newline> EMAIL_FROM_FIELDKEY = u'Email ▁ From' <newline> EMAIL_CC_FIELDKEY = u'Email ▁ CC' <newline> EMAIL_BCC_FIELDKEY = u'Email ▁ BCC' <newline> EMAIL_SUBJECT_FIELDKEY = u'Email ▁ Subject' <newline> EMAIL_BODY_FIELDKEY = u'Email ▁ Body' <newline> EMAIL_ATTACHMENT_FIELDKEY = u'Email ▁ Attachment' <newline> EMAIL_HEADER_FIELDKEY = u'Email ▁ Header' <newline> EMAIL_FOOTER_FIELDKEY = u'Email ▁ Footer' <newline>  # ▁ SMS ▁ Action ▁ fields <encdom> SMS_ACTION_FIELDKEY = u'SMS ▁ Action' <newline> SMS_TO_FIELDKEY = u'SMS ▁ To' <newline> SMS_MESSAGE_FIELDKEY = u'SMS ▁ Message' <newline> SMS_HEADER_FIELDKEY = u'SMS ▁ Header' <newline> SMS_FOOTER_FIELDKEY = u'SMS ▁ Footer' <newline>  # ▁ reserved ▁ strings ▁ for ▁ Action ▁ Types <encdom> GENERAL_ACTION_TYPE = u'General' <newline> EMAIL_ACTION_TYPE = u'Email' <newline> SMS_ACTION_TYPE = u'SMS' <newline>  # ▁ reserved ▁ strings ▁ for ▁ alert_types <encdom> SIMPLE_ALERT = u'simple' <newline> ADVANCED_ALERT = u'advanced' <newline>  # ▁ appended ▁ to ▁ the ▁ bottom ▁ of ▁ all ▁ user-facing ▁ emails, ▁ unless ▁ overidden <encdom>  # ▁ expecting ▁ bodyfooter.format(subscriber_email, ▁ subcriber_sysname, ▁ vizurl, ▁ viewname) <encdom> bodyfooter = u'<br><br><font ▁ size="2"><i>This ▁ VizAlerts ▁ email ▁ generated ▁ on ▁ behalf ▁ of ▁ ' u'<a ▁ href="mailto:{}">{}</a>, ▁ from ▁ view ▁ <a ▁ href="{}">{}</a></i></font>' <newline>  # ▁ appended ▁ under ▁ the ▁ bodyfooter, ▁ but ▁ only ▁ for ▁ Simple ▁ Alerts <encdom>  # ▁ expecting ▁ unsubscribe_footer.format(subscriptionsurl) <encdom> unsubscribe_footer = u'<br><font ▁ size="2"><i><a ▁ href="{}">Manage ▁ my ▁ subscription ▁ settings</a></i></font>' <newline>  # ▁ code ▁ from ▁ https://github.com/mitsuhiko/flask/blob/50dc2403526c5c5c67577767b05eb81e8fab0877/flask/helpers.py # L80 <encdom>  # ▁ what ▁ separators ▁ does ▁ this ▁ operating ▁ system ▁ provide ▁ that ▁ are ▁ not ▁ a ▁ slash? <encdom>  # ▁ used ▁ in ▁ VizAlerts ▁ for ▁ verifying ▁ custom ▁ filenames ▁ and ▁ paths ▁ for ▁ appended ▁ attachments ▁ and ▁ exported ▁ attachments <encdom> _os_alt_seps = list ( sep for sep in [ os . path . sep , os . path . altsep ] if sep not in ( None , '/' , '\\' ) ) <newline> class UnicodeCsvReader ( object ) : <newline> <indent>  """ Code ▁ from ▁ http://stackoverflow.com/questions/1846135/general-unicode-utf-8-support-for-csv-files-in-python-2-6 """  <newline> def __init__ ( self , f , encoding = "utf-8" , ** kwargs ) : <newline> <indent> self . csv_reader = csv . reader ( f , delimiter = str ( config . configs [ 'data.coldelimiter' ] ) , ** kwargs ) <newline> self . encoding = encoding <newline> <dedent> def __iter__ ( self ) : <newline> <indent> return self <newline> <dedent> def next ( self ) : <newline>  # ▁ read ▁ and ▁ split ▁ the ▁ csv ▁ row ▁ into ▁ fields <encdom> <indent> row = self . csv_reader . next ( ) <newline>  # ▁ now ▁ decode <encdom> return [ unicode ( cell , self . encoding ) for cell in row ] <newline> <dedent> @ property <newline> def line_num ( self ) : <newline> <indent> return self . csv_reader . line_num <newline> <dedent> <dedent> class UnicodeDictReader ( csv . DictReader ) : <newline> <indent>  """ Returns ▁ a ▁ DictReader ▁ that ▁ supports ▁ Unicode """  <newline>  """ Code ▁ from ▁ http://stackoverflow.com/questions/1846135/general-unicode-utf-8-support-for-csv-files-in-python-2-6 """  <newline> def __init__ ( self , f , encoding = "utf-8" , fieldnames = None , ** kwds ) : <newline> <indent> csv . DictReader . __init__ ( self , f , fieldnames = fieldnames , ** kwds ) <newline> self . reader = UnicodeCsvReader ( f , encoding = encoding , ** kwds ) <newline> <dedent> <dedent> class ActionField : <newline> <indent>  """ Represents ▁ a ▁ mapping ▁ of ▁ a ▁ field ▁ found ▁ in ▁ a ▁ trigger ▁ CSV ▁ to ▁ an ▁ action ▁ property """  <newline> def __init__ ( self , name , action_type , is_required , is_action_flag , pattern , default_value = None ) : <newline> <indent> self . name = name <newline> self . action_type = action_type <newline> self . is_required = is_required  # ▁"if ▁ performing ▁ this ▁ action_type, ▁ is ▁ this ▁ field ▁ required ▁ to ▁ do ▁ it?" <encdom> <newline> self . is_action_flag = is_action_flag <newline> self . pattern = pattern <newline> self . field_name = None  # ▁ no ▁ field ▁ name ▁ until ▁ we ▁ validate <encdom> <newline> self . default_value = default_value  # ▁ if ▁ a ▁ field ▁ is ▁ required ▁ information, ▁ but ▁ was ▁ NOT ▁ used ▁ in ▁ the ▁ viz, ▁ <encdom> <newline>  # ▁ then ▁ use ▁ default ▁ values ▁ we ▁ populate ▁ from ▁ the ▁ user ▁ data, ▁ if ▁ possible <encdom> self . match_list = [ ] <newline> self . error_list = [ ] <newline> <dedent> def get_user_facing_fieldname ( self ) : <newline> <indent> field_name = u'{} ▁ {}' <newline> if self . is_required : <newline> <indent> return field_name . format ( self . name , u'*' ) <newline> <dedent> else : <newline> <indent> return field_name . format ( self . name , u'~' ) <newline> <dedent> <dedent> def get_value_from_dict ( self , dict ) : <newline>  # ▁ Retrieve ▁ the ▁ field ▁ value ▁ from ▁ a ▁ dictionary, ▁ or ▁ the ▁ default ▁ value <encdom> <indent> if self . field_name : <newline> <indent> if dict . has_key ( self . field_name ) : <newline> <indent> return dict [ self . field_name ] <newline> <dedent> else : <newline> <indent> errormessage = u'Could ▁ not ▁ retrieve ▁ value ▁ for ▁ field ▁ {} ▁ from ▁ row ▁ {}' . format ( self . field_name , dict ) <newline> raise UserWarning ( errormessage ) <newline> <dedent> <dedent> elif self . default_value : <newline> <indent> return self . default_value <newline> <dedent> else : <newline> <indent> errormessage = u'Could ▁ not ▁ retrieve ▁ value ▁ for ▁ field ▁ {}, ▁ no ▁ matches ▁ were ▁ found ▁ ' 'and ▁ no ▁ default ▁ value ▁ available' . format ( self . field_name ) <newline> raise UserWarning ( errormessage ) <newline> <dedent> <dedent> def has_match ( self ) : <newline> <indent> if len ( self . match_list ) > 0 : <newline> <indent> return True <newline> <dedent> else : <newline> <indent> return False <newline> <dedent> <dedent> def has_errors ( self ) : <newline> <indent> if len ( self . error_list ) > 0 : <newline> <indent> return True <newline> <dedent> else : <newline> <indent> return False <newline> <dedent> <dedent> <dedent> class TaskType ( object ) : <newline> <indent>  """ Enumerates ▁ the ▁ allowed ▁ types ▁ a ▁ Task ▁ may ▁ be """  <newline> SEND_EMAIL = 'send_email' <newline> SEND_SMS = 'send_sms' <newline>  # ▁ GET_CONTENT_REFERENCE ▁ = ▁'get_content_reference' <encdom>  # ▁ VALIDATE_TRIGGER_DATA ▁ = ▁'validate_trigger_data' <encdom> <dedent> class Task : <newline> <indent>  """ Represents ▁ a ▁ task ▁ within ▁ an ▁ Alert ▁ to ▁ be ▁ executed. ▁ It ▁ need ▁ not ▁ be ▁ an ▁ actual ▁ alert ▁ Action """  <newline> def __init__ ( self , alert , task_type , task_instance ) : <newline> <indent> self . alert = alert <newline> self . task_type = task_type  # ▁ the ▁ type ▁ of ▁ task ▁ to ▁ be ▁ executed, ▁ represented ▁ as ▁ an ▁ instance ▁ of ▁ the ▁ TaskType ▁ class <encdom> <newline> self . task_instance = task_instance  # ▁ the ▁ instance ▁ of ▁ the ▁ task ▁ to ▁ be ▁ executed <encdom> <newline>  # ▁ task ▁ content <encdom> self . task_input_value = None <newline>  # ▁ execution ▁ configs <encdom>  # ▁ execution ▁ attempt ▁ information <encdom> self . task_uuid = unicode ( uuid . uuid4 ( ) ) <newline> self . task_attempt_number = 0  # ▁ REVISIT: ▁ should ▁ use ▁ retry ▁ count ▁ from ▁ vizalert ▁ parent <encdom> <newline> self . task_started_at = None <newline> self . task_completed_at = None <newline> self . task_succeeded = None <newline> self . error_list = [ ] <newline>  # ▁ output ▁ information <encdom> self . task_output_content_type = None <newline> self . task_output_destination = None <newline> self . task_output_name = None  # ▁ string ▁ representing ▁ whatever ▁ tasks' ▁ output ▁ was--email ▁ subject, ▁ or ▁ filename <encdom> <newline> self . task_output_rowcount = None <newline> self . task_output_size_b = None <newline> self . task_output_text = None <newline> self . task_thread_id = None <newline> <dedent> def execute_task ( self ) : <newline> <indent> self . task_started_at = datetime . datetime . now ( ) <newline> log . logger . debug ( u'starting ▁ task ▁ execution ▁ for ▁ task ▁ {}' . format ( self . task_uuid ) ) <newline> try : <newline> <indent> if self . task_type == TaskType . SEND_EMAIL : <newline> <indent> log . logger . debug ( u'Task ▁ is ▁ type ▁ email, ▁ sending ▁ now' ) <newline> emailaction . send_email ( self . task_instance ) <newline> log . logger . debug ( u'Task ▁ completed' ) <newline> <dedent> elif self . task_type == TaskType . SEND_SMS : <newline> <indent> log . logger . debug ( u'Task ▁ is ▁ type ▁ SMS, ▁ sending ▁ now' ) <newline> smsaction . send_sms ( self . task_instance ) <newline> <dedent> else : <newline> <indent> raise UserWarning ( u'Task ▁ Type ▁"{}" ▁ is ▁ invalid' . format ( self . task_type ) ) <newline> <dedent> log . logger . debug ( u'Writing ▁ Task ▁ completion ▁ state ▁ info' ) <newline> self . task_succeeded = True <newline> self . task_completed_at = datetime . datetime . now ( ) <newline> return <newline> <dedent> except Exception as e : <newline> <indent> self . task_succeeded = False <newline> self . task_completed_at = datetime . datetime . now ( ) <newline> log . logger . error ( u'Could ▁ not ▁ execute ▁ task ▁ {}: ▁ {}' . format ( self . task_uuid , e . message ) ) <newline> raise e <newline> <dedent> <dedent> def has_errors ( self ) : <newline> <indent> if len ( self . error_list ) > 0 : <newline> <indent> return True <newline> <dedent> else : <newline> <indent> return False <newline>  # ▁ stub ▁ for ▁ the ▁ Content ▁ Reference ▁ class ▁ to ▁ come ▁ someday <encdom> <dedent> <dedent> <dedent>  """ <strnewline> class ▁ ContentReference: <strnewline> ▁ Represents ▁ a ▁ special ▁ text ▁ string ▁ embedded ▁ in ▁ the ▁ trigger ▁ data ▁ of ▁ a ▁ vizalert <strnewline> ▁ which, ▁ after ▁ processing, ▁ results ▁ in ▁ a ▁ single ▁ file <strnewline> <strnewline> ▁ def ▁ __init__(self, ▁ name, ▁ reference_type, ▁ pattern): <strnewline> ▁ # ▁ VIZ_PDF(workbook/view?filter|arg1=2|arg2) <strnewline> ▁ self.name ▁ = ▁ name <strnewline> ▁ self.pattern ▁ = ▁ pattern <strnewline> ▁ self.reference_type ▁ = ▁ reference_type ▁ # ▁ Where ▁ the ▁ content ▁ comes ▁ from: ▁ VIZ, ▁ FILE, ▁ etc <strnewline> ▁ self.view_url_suffix ▁ = ▁'' <strnewline> ▁ self.filepath ▁ = ▁'' <strnewline> ▁ self.argument_list ▁ = ▁ [] ▁ # ▁ list ▁ of ▁ key-value ▁ pairs <strnewline> ▁ self.error_list ▁ = ▁ [] <strnewline> <strnewline> ▁ def ▁ has_errors(self): <strnewline> ▁ if ▁ len(self.error_list) ▁ > ▁ 0: <strnewline> ▁ return ▁ True <strnewline> ▁ else: <strnewline> ▁ return ▁ False <strnewline> """  <newline> class TaskWorker ( threading . Thread ) : <newline> <indent>  """ Class ▁ to ▁ enable ▁ multi-threaded ▁ processing ▁ of ▁ Tasks ▁ within ▁ an ▁ Alert """  <newline> def __init__ ( self , thread_name , task_queue ) : <newline> <indent> threading . Thread . __init__ ( self , name = thread_name ) <newline> self . queue = task_queue <newline> self . thread_name = thread_name <newline> <dedent> def run ( self ) : <newline>  # ▁ loop ▁ infinitely, ▁ breaking ▁ when ▁ the ▁ queue ▁ is ▁ out ▁ of ▁ work ▁ (should ▁ add ▁ a ▁ timeout!) <encdom> <indent> while 1 == 1 : <newline> <indent> if self . queue . qsize ( ) == 0 : <newline> <indent> return <newline> <dedent> else : <newline>  # ▁ Get ▁ the ▁ work ▁ from ▁ the ▁ queue ▁ and ▁ expand ▁ the ▁ tuple <encdom> <indent> task = self . queue . get ( ) <newline> log . logger . debug ( u'Thread ▁ {} ▁ is ▁ processing ▁ task_id ▁ {}, ▁ from ▁ subscription_id ▁ {}, ▁ view_id ▁ {}, ▁ ' u'site_name ▁ {}, ▁ customized_view_id ▁ {}, ▁ ' u'view_name ▁ {}' . format ( self . thread_name , task . task_uuid , task . alert . subscription_id , task . alert . view_id , task . alert . site_name , task . alert . customized_view_id , task . alert . view_name ) ) <newline>  # ▁ process ▁ the ▁ alert <encdom> try : <newline> <indent> task . execute_task ( ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Unable ▁ to ▁ process ▁ task ▁ {} ▁ from ▁ alert ▁ {}, ▁ error: ▁ {}' . format ( task . task_uuid , task . alert . view_name , e . message ) <newline> log . logger . error ( errormessage ) <newline> task . alert . error_list . append ( errormessage ) <newline> task . alert . alert_failure ( ) <newline> continue <newline> <dedent> <dedent> <dedent> <dedent> <dedent> class VizAlert : <newline> <indent>  """ Standard ▁ class ▁ representing ▁ a ▁ VizAlert """  <newline> def __init__ ( self , view_url_suffix , site_name , subscriber_sysname , subscriber_domain , subscriber_email = u'' , view_name = u'' ) : <newline> <indent> self . view_url_suffix = view_url_suffix <newline> self . site_name = site_name <newline> self . subscriber_domain = subscriber_domain <newline> self . subscriber_sysname = subscriber_sysname <newline> self . subscriber_email = subscriber_email <newline> self . view_name = view_name <newline> self . alert_uuid = unicode ( uuid . uuid4 ( ) ) <newline>  # ▁ general ▁ config <encdom> self . data_retrieval_tries = 2 <newline> self . force_refresh = True <newline> self . notify_subscriber_on_failure = True <newline> self . viz_data_maxrows = 1000 <newline> self . viz_png_height = 1500 <newline> self . viz_png_width = 1500 <newline> self . timeout_s = 60 <newline> self . task_thread_count = 1 <newline> self . task_thread_names = [ ] <newline>  # ▁ email ▁ action ▁ config <encdom> self . action_enabled_email = 0 <newline> self . allowed_from_address = u'' <newline> self . allowed_recipient_addresses = u'' <newline>  # ▁ sms ▁ action ▁ config <encdom> self . action_enabled_sms = 0 <newline> self . allowed_recipient_numbers = u'' <newline> self . from_number = u'' <newline> self . phone_country_code = '' <newline>  # ▁ alert ▁ metadata <encdom> self . alert_type = SIMPLE_ALERT <newline> self . is_test = False <newline> self . is_triggered_by_refresh = False <newline> self . customized_view_id = - 1 <newline> self . owner_email = u'' <newline> self . owner_friendly_name = u'' <newline> self . owner_sysname = u'' <newline> self . project_id = - 1 <newline> self . project_name = u'' <newline> self . ran_last_at = u'' <newline> self . run_next_at = u'' <newline> self . schedule_frequency = u'' <newline> self . schedule_id = - 1 <newline> self . schedule_name = u'' <newline> self . priority = - 1 <newline> self . schedule_type = - 1 <newline> self . site_id = - 1 <newline> self . subscriber_license = u'' <newline> self . subscriber_user_id = - 1 <newline> self . subscription_id = - 1 <newline> self . view_id = - 1 <newline> self . view_owner_id = - 1 <newline> self . workbook_id = u'' <newline> self . workbook_repository_url = u'' <newline>  # ▁ alert ▁ state ▁ information <encdom> self . trigger_data_file = u'' <newline> self . trigger_data = [ ] <newline> self . trigger_data_rowcount = 0 <newline> self . unique_trigger_data = [ ] <newline> self . action_field_dict = { } <newline> self . task_queue = Queue ( )  # ▁ the ▁ tasks ▁ to ▁ execute ▁ for ▁ this ▁ alert <encdom> <newline> self . task_threads = [ ]  # ▁ the ▁ names ▁ of ▁ all ▁ the ▁ threads ▁ spun ▁ up ▁ to ▁ process ▁ tasks ▁ generated ▁ by ▁ this ▁ alert <encdom> <newline> self . error_list = [ ]  # ▁ list ▁ of ▁ errors ▁ encountered ▁ processing ▁ the ▁ vizalert <encdom> <newline>  # ▁ add ▁ all ▁ possible ▁ alert ▁ fields ▁ to ▁ the ▁ new ▁ VizAlert ▁ instance ▁ (should ▁ this ▁ live ▁ somewhere ▁ else?) <encdom>  # ▁ General <encdom>  # ▁ consolidated ▁ and ▁ sort ▁ have ▁ backwards-compatible ▁ options ▁ for ▁ v1.x <encdom> self . action_field_dict [ GENERAL_SORTORDER_FIELDKEY ] = ActionField ( GENERAL_SORTORDER_FIELDKEY , GENERAL_ACTION_TYPE , False , False , u'.*Consolidated.Sort|.*Sort.Order' ) <newline> self . action_field_dict [ CONSOLIDATE_LINES_FIELDKEY ] = ActionField ( CONSOLIDATE_LINES_FIELDKEY , GENERAL_ACTION_TYPE , False , False , u'.*Consolidate.Lines|.*Email.Consolidate' ) <newline>  # ▁ Email ▁ Action ▁ fields <encdom> self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] = ActionField ( EMAIL_ACTION_FIELDKEY , EMAIL_ACTION_TYPE , True , True , u' ▁ ?Email.Action' ) <newline> self . action_field_dict [ EMAIL_SUBJECT_FIELDKEY ] = ActionField ( EMAIL_SUBJECT_FIELDKEY , EMAIL_ACTION_TYPE , True , False , u' ▁ ?Email.Subject' , u'Alert ▁ triggered ▁ for ▁ {}' . format ( self . view_name ) ) <newline> self . action_field_dict [ EMAIL_TO_FIELDKEY ] = ActionField ( EMAIL_TO_FIELDKEY , EMAIL_ACTION_TYPE , True , False , u' ▁ ?Email.To' , self . subscriber_email ) <newline> self . action_field_dict [ EMAIL_FROM_FIELDKEY ] = ActionField ( EMAIL_FROM_FIELDKEY , EMAIL_ACTION_TYPE , False , False , u' ▁ ?Email.From' , config . configs [ 'smtp.address.from' ] ) <newline> self . action_field_dict [ EMAIL_CC_FIELDKEY ] = ActionField ( EMAIL_CC_FIELDKEY , EMAIL_ACTION_TYPE , False , False , u' ▁ ?Email.CC' ) <newline> self . action_field_dict [ EMAIL_BCC_FIELDKEY ] = ActionField ( EMAIL_BCC_FIELDKEY , EMAIL_ACTION_TYPE , False , False , u' ▁ ?Email.BCC' ) <newline> self . action_field_dict [ EMAIL_BODY_FIELDKEY ] = ActionField ( EMAIL_BODY_FIELDKEY , EMAIL_ACTION_TYPE , True , False , u' ▁ ?Email.Body' , 'VIZ_IMAGE(|vizlink)' ) <newline> self . action_field_dict [ EMAIL_HEADER_FIELDKEY ] = ActionField ( EMAIL_HEADER_FIELDKEY , EMAIL_ACTION_TYPE , False , False , u' ▁ ?Email.Header' ) <newline> self . action_field_dict [ EMAIL_FOOTER_FIELDKEY ] = ActionField ( EMAIL_FOOTER_FIELDKEY , EMAIL_ACTION_TYPE , False , False , u' ▁ ?Email.Footer' ) <newline> self . action_field_dict [ EMAIL_ATTACHMENT_FIELDKEY ] = ActionField ( EMAIL_ATTACHMENT_FIELDKEY , EMAIL_ACTION_TYPE , False , False , u' ▁ ?Email.Attachment' ) <newline>  # ▁ SMS ▁ Action ▁ fields <encdom> self . action_field_dict [ SMS_ACTION_FIELDKEY ] = ActionField ( SMS_ACTION_FIELDKEY , SMS_ACTION_TYPE , True , True , u' ▁ ?SMS.Action' ) <newline> self . action_field_dict [ SMS_TO_FIELDKEY ] = ActionField ( SMS_TO_FIELDKEY , SMS_ACTION_TYPE , True , False , u' ▁ ?SMS.To' ) <newline> self . action_field_dict [ SMS_MESSAGE_FIELDKEY ] = ActionField ( SMS_MESSAGE_FIELDKEY , SMS_ACTION_TYPE , True , False , u' ▁ ?SMS.Message' ) <newline> self . action_field_dict [ SMS_HEADER_FIELDKEY ] = ActionField ( SMS_HEADER_FIELDKEY , SMS_ACTION_TYPE , False , False , u' ▁ ?SMS.Header' ) <newline> self . action_field_dict [ SMS_FOOTER_FIELDKEY ] = ActionField ( SMS_FOOTER_FIELDKEY , SMS_ACTION_TYPE , False , False , u' ▁ ?SMS.Footer' ) <newline> <dedent> def get_action_flag_field ( self , action_type ) : <newline> <indent>  """ Return ▁ the ▁ appropriate ▁ action ▁ field ▁ representing ▁ an ▁ action ▁ flag ▁ based ▁ on ▁ the ▁ type <strnewline> ▁ Note ▁ that ▁ no ▁ validation ▁ is ▁ done ▁ here ▁ """  <newline> for action_field_name , action_field in self . action_field_dict . iteritems ( ) : <newline> <indent> if self . action_field_dict [ action_field_name ] . action_type == action_type and self . action_field_dict [ action_field_name ] . is_action_flag : <newline> <indent> return action_field_name <newline> <dedent> <dedent> <dedent> def get_view_url ( self , customviewurlsuffix = None ) : <newline> <indent>  """ Construct ▁ the ▁ full ▁ URL ▁ of ▁ the ▁ trigger ▁ view ▁ for ▁ this ▁ VizAlert <strnewline> ▁ customviewurlsuffix ▁ is ▁ for ▁ generating ▁ URLs ▁ for ▁ other ▁ vizzes ▁ for ▁ content ▁ references """  <newline> httpprefix = u'http://' <newline> if config . configs [ 'server.ssl' ] : <newline> <indent> httpprefix = u'https://' <newline>  # ▁ this ▁ logic ▁ should ▁ be ▁ removed--empty ▁ string ▁ should ▁ be ▁ passed ▁ in ▁ from ▁ SQL <encdom> <dedent> sitename = unicode ( self . site_name ) . replace ( 'Default' , '' ) <newline> if not customviewurlsuffix : <newline> <indent> customviewurlsuffix = self . view_url_suffix <newline>  # ▁ (omitting ▁ hash ▁ preserves ▁ 8.x ▁ functionality) <encdom> <dedent> if sitename == '' : <newline> <indent> vizurl = httpprefix + config . configs [ 'server' ] + u'/views/' + customviewurlsuffix <newline> <dedent> else : <newline> <indent> vizurl = httpprefix + config . configs [ 'server' ] + u'/t/' + sitename + u'/views/' + customviewurlsuffix <newline> <dedent> return vizurl <newline> <dedent> def get_footer ( self ) : <newline> <indent>  """ Get ▁ the ▁ footer ▁ text ▁ for ▁ an ▁ email ▁ alert """  <newline> httpprefix = u'http://' <newline> if config . configs [ 'server.ssl' ] : <newline> <indent> httpprefix = u'https://' <newline> <dedent> footer = u'<br><br><font ▁ size="2"><i>This ▁ VizAlerts ▁ email ▁ generated ▁ on ▁ behalf ▁ of ▁ <a ▁ href="mailto:{}">{}</a>, ▁ ' u'from ▁ view ▁ <a ▁ href="{}">' u'{}</a></i></font>' . format ( self . subscriber_email , self . subscriber_sysname , self . get_view_url ( ) , self . view_name ) <newline> if self . alert_type == SIMPLE_ALERT : <newline> <indent> managesuburlv8 = httpprefix + config . configs [ 'server' ] + u'/users/' + self . subscriber_sysname <newline> managesuburlv9 = httpprefix + config . configs [ 'server' ] + u'/ # /user/' <newline> if self . subscriber_domain : <newline> <indent> managesuburlv9 = managesuburlv9 + self . subscriber_domain + u'/' + self . subscriber_sysname + u'/subscriptions' <newline> <dedent> else : <newline> <indent> managesuburlv9 = managesuburlv9 + u'local/' + self . subscriber_sysname + u'/subscriptions' <newline> <dedent> managesublink = u'<br><font ▁ size="2"><i><a ▁ href="{}">Manage ▁ my ▁ subscription ▁ settings</a></i></font>' <newline> if config . configs [ 'server.version' ] == 8 : <newline> <indent> footer += managesublink . format ( managesuburlv8 ) <newline> <dedent> if config . configs [ 'server.version' ] in [ 9 , 10 ] : <newline> <indent> footer += managesublink . format ( managesuburlv9 ) <newline> <dedent> <dedent> return footer <newline> <dedent> def download_trigger_data ( self ) : <newline> <indent>  """ ▁ Exports ▁ the ▁ CSV ▁ data ▁ for ▁ a ▁ VizAlert ▁ and ▁ reads ▁ it ▁ into ▁ a ▁ list ▁ of ▁ dicts <strnewline> ▁ Returns ▁ a ▁ filepath ▁ to ▁ the ▁ CSV ▁ """  <newline>  # ▁ export ▁ the ▁ CSV ▁ to ▁ a ▁ local ▁ file <encdom> try : <newline> <indent> self . trigger_data_file = tabhttp . export_view ( self . view_url_suffix , self . site_name , self . timeout_s , self . data_retrieval_tries , self . force_refresh , tabhttp . Format . CSV , self . viz_png_width , self . viz_png_height , self . subscriber_sysname , self . subscriber_domain ) <newline>  # ▁ read ▁ all ▁ rows ▁ into ▁ the ▁ trigger_data ▁ class ▁ member ▁ for ▁ later ▁ use <encdom> reader = self . read_trigger_data ( ) <newline> rowcount = 0 <newline> for row in reader : <newline> <indent> if rowcount > self . viz_data_maxrows : <newline> <indent> errormessage = u'Maximum ▁ rows ▁ of ▁ {} ▁ exceeded.' . format ( self . viz_data_maxrows ) <newline> self . error_list . append ( errormessage ) <newline> log . logger . error ( errormessage ) <newline> break <newline>  # ▁ read ▁ data ▁ in ▁ anyway <encdom> <dedent> self . trigger_data . append ( row ) <newline> rowcount += 1 <newline>  # ▁ set ▁ the ▁ rowcount ▁ value ▁ in ▁ the ▁ alert ▁ itself <encdom> <dedent> self . trigger_data_rowcount = rowcount <newline> <dedent> except Exception as e : <newline> <indent> log . logger . error ( e ) <newline> self . error_list . append ( e . message ) <newline> return <newline> <dedent> <dedent> def read_trigger_data ( self ) : <newline> <indent>  """ ▁ Returns ▁ a ▁ CSV ▁ reader ▁ to ▁ read ▁ the ▁ trigger ▁ data ▁ file ▁ downloaded ▁ for ▁ the ▁ alert <strnewline> ▁ Requests ▁ for ▁ the ▁ data ▁ itself ▁ should ▁ use ▁ the ▁ trigger_data ▁ list ▁ member ▁ to ▁ avoid ▁ multiple ▁ reads ▁ """  <newline> try : <newline> <indent> f = open ( self . trigger_data_file , 'rU' ) <newline> return UnicodeDictReader ( f ) <newline> <dedent> except Exception as e : <newline> <indent> log . logger . error ( u'Error ▁ accessing ▁ {} ▁ while ▁ getting ▁ processing ▁ alert ▁ {}: ▁ {}' . format ( self . trigger_data_file , self . view_url_suffix , e ) ) <newline> raise e <newline> <dedent> <dedent> def parse_action_fields ( self ) : <newline> <indent>  """ Parse ▁ the ▁ trigger ▁ data ▁ and ▁ map ▁ field ▁ names ▁ to ▁ VizAlert ▁ action ▁ fields <strnewline> ▁ Returns ▁ a ▁ list ▁ of ▁ dicts ▁ containing ▁ any ▁ errors ▁ found """  <newline> log . logger . debug ( u'Parsing ▁ action ▁ fields' ) <newline> field_error_list = [ ] <newline> rownum = 1  # ▁ fields ▁ are ▁ always ▁ in ▁ the ▁ first ▁ row ▁ of ▁ a ▁ csv <encdom> <newline> try : <newline>  # ▁ go ▁ through ▁ all ▁ possible ▁ fields ▁ and ▁ find ▁ matches <encdom> <indent> for key in self . action_field_dict : <newline> <indent> for field in self . read_trigger_data ( ) . fieldnames : <newline> <indent> if re . match ( self . action_field_dict [ key ] . pattern , field , re . IGNORECASE ) : <newline> <indent> log . logger . debug ( u'found ▁ field ▁ match! ▁ : ▁ {}' . format ( field ) ) <newline> self . action_field_dict [ key ] . match_list . append ( field )  # ▁ add ▁ the ▁ match ▁ we ▁ found <encdom> <newline> <dedent> <dedent> <dedent> log . logger . debug ( u'searching ▁ for ▁ action ▁ fields' ) <newline>  # ▁ collect ▁ all ▁ the ▁ action ▁ flags ▁ we ▁ found <encdom> action_flags = [ ] <newline> for i , found_flag in self . action_field_dict . iteritems ( ) : <newline> <indent> if found_flag . is_action_flag and found_flag . has_match ( ) : <newline> <indent> action_flags . append ( found_flag . name ) <newline>  # ▁ did ▁ we ▁ find ▁ at ▁ least ▁ one ▁ action ▁ flag? <encdom> <dedent> <dedent> if len ( action_flags ) > 0 : <newline> <indent> self . alert_type = ADVANCED_ALERT  # ▁ we ▁ know ▁ this ▁ is ▁ an ▁ advanced ▁ alert ▁ now <encdom> <newline> log . logger . debug ( u'Advanced ▁ alert ▁ detected' ) <newline>  # ▁ ensure ▁ the ▁ subscriber ▁ is ▁ the ▁ owner ▁ of ▁ the ▁ viz <encdom>  # ▁ we ▁ need ▁ to ▁ do ▁ this ▁ check ▁ straight ▁ away ▁ so ▁ we ▁ don't ▁ send ▁ any ▁ more ▁ info ▁ to ▁ the ▁ subscriber <encdom> if self . subscriber_sysname != self . owner_sysname : <newline> <indent> errormessage = u'You ▁ must ▁ be ▁ the ▁ owner ▁ of ▁ the ▁ workbook ▁ in ▁ order ▁ to ▁ use ▁ Advanced ▁ Alerts.<br><br>' u'Subscriber ▁ {} ▁ to ▁ advanced ▁ alert ▁ subscription_id ▁ {} ▁ is ▁ not ▁ the ▁ owner, ▁ {}' . format ( self . subscriber_sysname , self . subscription_id , self . owner_sysname ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> return [ ]  # ▁ provide ▁ no ▁ more ▁ info, ▁ and ▁ do ▁ no ▁ more ▁ work <encdom> <newline>  # ▁ check ▁ for ▁ issues ▁ in ▁ each ▁ of ▁ the ▁ fields <encdom> <dedent> for action_field in self . action_field_dict : <newline> <indent> action_flag = self . get_action_flag_field ( self . action_field_dict [ action_field ] . action_type ) <newline> if self . action_field_dict [ action_field ] . has_match ( ) : <newline>  # ▁ we're ▁ not ▁ allowed ▁ to ▁ perform ▁ these ▁ actions <encdom>  # ▁ email ▁ actions <encdom> <indent> if self . action_field_dict [ action_field ] . action_type == EMAIL_ACTION_TYPE and not self . action_enabled_email : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'Email ▁ actions ▁ are ▁ not ▁ allowed ▁ for ▁ this ▁ alert, ▁ per ▁ administrative ▁ settings' ) <newline>  # ▁ sms ▁ actions <encdom> <dedent> if self . action_field_dict [ action_field ] . action_type == SMS_ACTION_TYPE : <newline> <indent> if not config . configs [ 'smsaction.enable' ] : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'SMS ▁ actions ▁ are ▁ not ▁ enabled, ▁ per ▁ administrative ▁ settings' ) <newline> <dedent> elif not self . action_enabled_sms : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'SMS ▁ actions ▁ are ▁ not ▁ allowed ▁ for ▁ this ▁ alert, ▁ per ▁ administrative ▁ settings' ) <newline> <dedent> elif not smsaction . smsclient : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'SMS ▁ actions ▁ cannot ▁ be ▁ processed ▁ right ▁ now--no ▁ valid ▁ client. ▁ ' u'Please ▁ contact ▁ your ▁ administrator.' ) <newline>  # ▁ multiple ▁ matches ▁ are ▁ not ▁ allowed--we ▁ need ▁ to ▁ be ▁ sure ▁ which ▁ field ▁ to ▁ use ▁ for ▁ what <encdom> <dedent> <dedent> if len ( self . action_field_dict [ action_field ] . match_list ) > 1 : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'Multiple ▁ matches ▁ found ▁ for ▁ field ▁ {}. ▁ Found: ▁ ▁ {}' . format ( action_field , u'' . join ( self . action_field_dict [ action_field ] . match_list ) ) ) <newline>  # ▁ missing ▁ the ▁ action ▁ flag ▁ field ▁ (OK ▁ for ▁'General' ▁ fields) <encdom> <dedent> if not action_flag and self . action_field_dict [ action_field ] . action_type != GENERAL_ACTION_TYPE : <newline>  # ▁ we ▁ should ▁ never ▁ hit ▁ this, ▁ but ▁ OCD ▁ requires ▁ I ▁ check ▁ for ▁ it <encdom> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'VizAlerts ▁ has ▁ a ▁ bug; ▁ please ▁ contact ▁ the ▁ developers' ) <newline> <dedent> if action_flag : <newline> <indent> if not self . action_field_dict [ action_flag ] . has_match ( ) : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'Could ▁ not ▁ find ▁ action ▁ flag ▁ field ▁ {}, ▁ which ▁ is ▁ necessary ▁ for ▁ {} ▁ actions.' . format ( self . action_field_dict [ action_flag ] . get_user_facing_fieldname ( ) , self . action_field_dict [ action_field ] . action_type ) ) <newline>  # ▁ may ▁ not ▁ use ▁"Email ▁ Consolidate" ▁ field ▁ on ▁ both ▁ Email ▁ and ▁ SMS ▁ at ▁ the ▁ same ▁ time <encdom>  # ▁ Might ▁ revisit ▁ in ▁ the ▁ future, ▁ but ▁ for ▁ now ▁ it's ▁ too ▁ confusing ▁ to ▁ support ▁ in ▁ anything ▁ else <encdom> <dedent> if self . action_field_dict [ action_field ] . name == CONSOLIDATE_LINES_FIELDKEY and EMAIL_ACTION_FIELDKEY in action_flags and SMS_ACTION_FIELDKEY in action_flags : <newline> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'{} ▁ may ▁ not ▁ be ▁ used ▁ with ▁ both ▁ {} ▁ and ▁ {}' . format ( self . action_field_dict [ action_field ] . name , EMAIL_ACTION_FIELDKEY , SMS_ACTION_FIELDKEY ) ) <newline> <dedent> <dedent> <dedent> else :  # ▁ the ▁ field ▁ has ▁ no ▁ matches <encdom> <newline>  # ▁ check ▁ for ▁ missing ▁ fields ▁ that ▁ are ▁ required <encdom> <indent> if action_flag : <newline>  # ▁ remember, ▁'general' ▁ fields ▁ have ▁ don't ▁ have ▁ an ▁ action_flag <encdom> <indent> if self . action_field_dict [ action_flag ] . has_match ( ) and self . action_field_dict [ action_field ] . is_required and self . action_field_dict [ action_field ] . default_value is None : <newline>  # ▁ the ▁ action ▁ flag ▁ field ▁ was ▁ matched, ▁ which ▁ means <encdom>  # ▁ the ▁ author ▁ intends ▁ to ▁ use ▁ that ▁ action ▁ type ▁ in ▁ this ▁ alert <encdom>  # ▁ ...but ▁ we ▁ don't ▁ have ▁ a ▁ default ▁ value, ▁ so ▁ missing ▁ this ▁ field ▁ is ▁ a ▁ dealbreaker <encdom> <indent> self . action_field_dict [ action_field ] . error_list . append ( u'This ▁ is ▁ a ▁ required ▁ field ▁ for ▁ {} ▁ actions' . format ( self . action_field_dict [ action_field ] . action_type ) ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> log . logger . debug ( u'Retrieving ▁ all ▁ errors ▁ found ▁ in ▁ field ▁ parse ▁ operation' ) <newline>  # ▁ capture ▁ and ▁ return ▁ errors ▁ we ▁ found <encdom> for action_field in self . action_field_dict : <newline> <indent> for field_error in self . action_field_dict [ action_field ] . error_list : <newline> <indent> log . logger . debug ( u'Found ▁ error ▁ in ▁ field ▁ {}: ▁ {}' . format ( action_field , field_error ) ) <newline>  # ▁ add ▁ the ▁ error ▁ to ▁ the ▁ list <encdom> field_error_list . append ( { u'Row' : rownum , u'Field' : self . action_field_dict [ action_field ] . get_user_facing_fieldname ( ) , u'Value' : u'' . join ( self . action_field_dict [ action_field ] . match_list ) , u'Error' : field_error } ) <newline>  # ▁ assign ▁ final ▁ field ▁ names ▁ for ▁ all ▁ action ▁ fields ▁ that ▁ have ▁ no ▁ issues <encdom> <dedent> <dedent> for action_field in self . action_field_dict : <newline> <indent> if self . action_field_dict [ action_field ] . has_match ( ) and not self . action_field_dict [ action_field ] . has_errors ( ) : <newline> <indent> self . action_field_dict [ action_field ] . field_name = self . action_field_dict [ action_field ] . match_list [ 0 ] <newline>  # ▁ add ▁ the ▁ errors ▁ we ▁ found ▁ to ▁ the ▁ list ▁ for ▁ the ▁ VizAlert ▁ as ▁ a ▁ whole <encdom> <dedent> <dedent> self . error_list . extend ( field_error_list ) <newline> return field_error_list <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Error ▁ parsing ▁ trigger ▁ data ▁ fields: ▁ {}' . format ( e . message ) <newline> log . logger . debug ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise e <newline> <dedent> <dedent> def validate_trigger_data ( self ) : <newline> <indent>  """ Parse ▁ the ▁ trigger ▁ data ▁ and ▁ check ▁ for ▁ error ▁ conditions <strnewline> ▁ Returns ▁ a ▁ list ▁ of ▁ dicts ▁ containing ▁ any ▁ errors ▁ found """  <newline> trigger_data_errors = [ ] <newline>  # ▁ validate ▁ the ▁ simple ▁ alert ▁ scenario <encdom> if self . alert_type == SIMPLE_ALERT : <newline> <indent> log . logger . debug ( u'Validating ▁ as ▁ a ▁ simple ▁ alert' ) <newline>  # ▁ check ▁ for ▁ invalid ▁ email ▁ domains--just ▁ in ▁ case ▁ the ▁ user ▁ fudges ▁ their ▁ email ▁ in ▁ Tableau ▁ Server <encdom> subscriberemailerror = emailaction . address_is_invalid ( self . subscriber_email , self . allowed_recipient_addresses ) <newline> if subscriberemailerror : <newline> <indent> errormessage = u'VizAlerts ▁ was ▁ unable ▁ to ▁ process ▁ this ▁ alert, ▁ because ▁ it ▁ was ▁ ' u'unable ▁ to ▁ send ▁ email ▁ to ▁ address ▁ {}: ▁ {}' . format ( self . subscriber_email , subscriberemailerror ) <newline> log . logger . error ( errormessage ) <newline> trigger_data_errors . append ( subscriberemailerror ) <newline> <dedent> <dedent> elif self . alert_type == ADVANCED_ALERT : <newline>  # ▁ this ▁ is ▁ an ▁ advanced ▁ alert, ▁ so ▁ we ▁ need ▁ to ▁ process ▁ all ▁ the ▁ fields ▁ appropriately <encdom> <indent> log . logger . debug ( u'Validating ▁ as ▁ an ▁ advanced ▁ alert' ) <newline>  # ▁ Email ▁ action ▁ validations <encdom> if self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . has_match ( ) and not self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . has_errors ( ) : <newline>  # ▁ validate ▁ all ▁ From ▁ and ▁ Recipient ▁ addresses <encdom> <indent> log . logger . debug ( u'Validating ▁ email ▁ addresses' ) <newline> addresserrors = emailaction . validate_addresses ( self . trigger_data , self . allowed_from_address , self . allowed_recipient_addresses , self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] , self . action_field_dict [ EMAIL_TO_FIELDKEY ] , self . action_field_dict [ EMAIL_FROM_FIELDKEY ] , self . action_field_dict [ EMAIL_CC_FIELDKEY ] , self . action_field_dict [ EMAIL_BCC_FIELDKEY ] ) <newline> if addresserrors : <newline> <indent> errormessage = u'Invalid ▁ email ▁ addresses ▁ found: ▁ {}' . format ( addresserrors ) <newline> log . logger . error ( errormessage ) <newline> trigger_data_errors . extend ( addresserrors ) <newline>  # ▁ SMS ▁ action ▁ validations <encdom> <dedent> <dedent> if self . action_field_dict [ SMS_ACTION_FIELDKEY ] . has_match ( ) : <newline>  # ▁ validate ▁ all ▁ From ▁ and ▁ Recipient ▁ numbers <encdom> <indent> log . logger . debug ( u'Validating ▁ SMS ▁ numbers' ) <newline> numbererrors = smsaction . validate_smsnumbers ( self . trigger_data , self . action_field_dict [ SMS_TO_FIELDKEY ] . field_name , self . allowed_recipient_numbers , self . phone_country_code ) <newline> if numbererrors : <newline> <indent> errormessage = u'Invalid ▁ SMS ▁ numbers ▁ found: ▁ {}' . format ( numbererrors ) <newline> log . logger . error ( errormessage ) <newline> trigger_data_errors . extend ( numbererrors ) <newline>  # ▁ ADD ▁ CODE ▁ HERE ▁ TO ▁ DO ▁ UP-FRONT ▁ CONTENT ▁ REFERENCE ▁ VALIDATION <encdom>  # ▁ can't ▁ get ▁ to ▁ it ▁ just ▁ yet--this ▁ will ▁ need ▁ the ▁ content ▁ reference ▁ class <encdom> <dedent> <dedent> <dedent> else : <newline>  # ▁ it's ▁ not ▁ a ▁ simple ▁ alert, ▁ it's ▁ not ▁ advanced, ▁ then ▁ what ▁ is ▁ it? ▁ a ▁ bug, ▁ that's ▁ what. <encdom> <indent> trigger_data_errors . append ( u'VizAlerts ▁ has ▁ a ▁ bug; ▁ please ▁ contact ▁ the ▁ developers' ) <newline>  # ▁ add ▁ the ▁ errors ▁ we ▁ found ▁ to ▁ all ▁ errors ▁ in ▁ the ▁ VizAlert <encdom> <dedent> self . error_list . extend ( trigger_data_errors ) <newline>  # ▁ return ▁ the ▁ errors ▁ we ▁ found ▁ validating ▁ the ▁ trigger ▁ data <encdom> return trigger_data_errors <newline> <dedent> def execute_alert ( self ) : <newline> <indent>  """ Simple ▁ function ▁ to ▁ effectively ▁ run ▁ the ▁ entire ▁ VizAlert ▁ process: <strnewline> ▁ Get ▁ the ▁ CSV ▁ data ▁ from ▁ the ▁ alert ▁ trigger <strnewline> ▁ Parse ▁ and ▁ validate ▁ the ▁ fields <strnewline> ▁ Identify ▁ and ▁ download ▁ all ▁ content ▁ references <strnewline> ▁ Perform ▁ all ▁ actions ▁ as ▁ instructed ▁ by ▁ the ▁ alert ▁ """  <newline>  # ▁ do ▁ a ▁ bit ▁ of ▁ pre-validation ▁ first <encdom>  # ▁ check ▁ for ▁ unlicensed ▁ user <encdom> if self . subscriber_license == 'Unlicensed' : <newline> <indent> if self . subscriber_sysname == self . owner_sysname : <newline>  # ▁ if ▁ they ▁ are ▁ the ▁ owner, ▁ this ▁ may ▁ be ▁ an ▁ advanced ▁ alert, ▁ so ▁ we ▁ should ▁ notify ▁ the ▁ admin <encdom> <indent> errormessage = u'VizAlerts ▁ was ▁ unable ▁ to ▁ process ▁ this ▁ alert: ▁ User ▁ {} ▁ is ▁ unlicensed.' . format ( self . subscriber_sysname ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> self . alert_failure ( ) <newline> return <newline> <dedent> else : <newline>  # ▁ they're ▁ not ▁ the ▁ owner, ▁ so ▁ this ▁ is ▁ a ▁ simple ▁ alert. ▁ just ▁ ignore ▁ them ▁ and ▁ log ▁ that ▁ we ▁ did. <encdom> <indent> errormessage = u'Ignoring ▁ subscription_id ▁ {}: ▁ User ▁ {} ▁ is ▁ unlicensed.' . format ( self . subscription_id , self . subscriber_sysname ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> return <newline>  # ▁ if ▁ this ▁ is ▁ a ▁ test ▁ alert, ▁ and ▁ they're ▁ not ▁ the ▁ owner, ▁ tell ▁ them ▁ what's ▁ up <encdom> <dedent> <dedent> if self . is_test and self . subscriber_sysname != self . owner_sysname : <newline> <indent> errormessage = u'You ▁ must ▁ be ▁ the ▁ owner ▁ of ▁ the ▁ viz ▁ in ▁ order ▁ to ▁ test ▁ the ▁ alert.' <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> self . alert_failure ( ) <newline> return <newline>  # ▁ get ▁ the ▁ CSV ▁ data ▁ from ▁ the ▁ alert ▁ trigger <encdom> <dedent> log . logger . debug ( u'Starting ▁ to ▁ download ▁ trigger ▁ data' ) <newline> self . download_trigger_data ( ) <newline>  # ▁ were ▁ there ▁ any ▁ problems? ▁ if ▁ so, ▁ bail <encdom> if len ( self . error_list ) > 0 : <newline> <indent> self . alert_failure ( ) <newline> return <newline> <dedent> if self . trigger_data_rowcount == 0 : <newline> <indent> log . logger . info ( u'Nothing ▁ to ▁ do! ▁ No ▁ rows ▁ in ▁ trigger ▁ data ▁ from ▁ file ▁ {}' . format ( self . trigger_data_file ) ) <newline> <dedent> else : <newline> <indent> log . logger . debug ( u'Got ▁ trigger ▁ data, ▁ now ▁ parsing ▁ fields' ) <newline>  # ▁ parse ▁ and ▁ validate ▁ the ▁ fields <encdom> if self . trigger_data and len ( self . error_list ) == 0 : <newline> <indent> field_errors = self . parse_action_fields ( ) <newline>  # ▁ were ▁ there ▁ any ▁ problems? ▁ if ▁ so, ▁ bail <encdom> if len ( field_errors ) > 0 or len ( self . error_list ) > 0 : <newline> <indent> self . alert_failure ( ) <newline> return <newline> <dedent> log . logger . debug ( u'Validating ▁ trigger ▁ data' ) <newline> trigger_data_errors = [ ] <newline> trigger_data_errors = self . validate_trigger_data ( ) <newline> if len ( trigger_data_errors ) > 0 or len ( self . error_list ) > 0 : <newline> <indent> self . alert_failure ( ) <newline> return <newline> <dedent> log . logger . debug ( u'Performing ▁ alert ▁ actions' ) <newline>  # ▁ identify ▁ and ▁ download ▁ all ▁ content ▁ references <encdom>  # ▁ perform ▁ all ▁ actions ▁ as ▁ instructed ▁ by ▁ the ▁ alert <encdom>  # ▁ These ▁ two ▁ are ▁ in ▁ the ▁ same ▁ call ▁ right ▁ now, ▁ but ▁ should ▁ probably ▁ be ▁ separated <encdom> self . perform_actions ( ) <newline> log . logger . debug ( u'Processing ▁ {} ▁ alert ▁ tasks ▁ for ▁ alert ▁ {}' . format ( self . task_queue . qsize ( ) , self . alert_uuid ) ) <newline> try : <newline>  # ▁ spin ▁ up ▁ threads ▁ to ▁ process ▁ tasks <encdom> <indent> for index in range ( self . task_thread_count ) : <newline> <indent> log . logger . debug ( u'Spinning ▁ up ▁ task ▁ threads' ) <newline>  # ▁ get ▁ a ▁ unique ▁ thread ▁ name ▁ for ▁ the ▁ alert <encdom> thread_name = u'{}{}{}' . format ( self . alert_uuid , u'_' , unicode ( index ) ) <newline> log . logger . debug ( u'New ▁ thread ▁ name ▁ will ▁ be ▁ {}' . format ( thread_name ) ) <newline> task_worker = TaskWorker ( thread_name , self . task_queue ) <newline> log . logger . debug ( u'Starting ▁ task ▁ thread ▁ with ▁ name: ▁ {}' . format ( thread_name ) ) <newline> self . task_thread_names . append ( thread_name ) <newline> task_worker . start ( ) <newline>  # ▁ loop ▁ until ▁ work ▁ is ▁ done <encdom> <dedent> while 1 == 1 : <newline>  # ▁ test ▁ for ▁ completed ▁ task ▁ threads <encdom> <indent> completed_task_threads = set ( self . task_thread_names ) - set ( [ thread . name for thread in threading . enumerate ( ) ] ) <newline> log . logger . debug ( u'All ▁ threads: ▁ {}' . format ( threading . enumerate ( ) ) ) <newline>  # ▁ if ▁ the ▁ set ▁ of ▁ completed ▁ threads ▁ matches ▁ all ▁ the ▁ task ▁ threads ▁ we ▁ spun ▁ up, <encdom>  # ▁ that ▁ means ▁ we're ▁ done <encdom> if completed_task_threads == set ( self . task_thread_names ) : <newline> <indent> log . logger . debug ( u'Task ▁ threads ▁ have ▁ completed ▁ for ▁ alert ▁ {}. ▁ Returning.' . format ( self . alert_uuid ) ) <newline> return <newline> <dedent> task_sleep_time = 3  # ▁ REVISIT ▁ THIS <encdom> <newline> time . sleep ( task_sleep_time ) <newline> log . logger . debug ( u'Task ▁ threads ▁ still ▁ in ▁ progress ▁ for ▁ alert ▁ {}. ▁ Sleeping ▁ {} ▁ seconds' . format ( self . alert_uuid , task_sleep_time ) ) <newline> <dedent> <dedent> except Exception as e : <newline> <indent> log . logger . error ( u'Encountered ▁ error ▁ processing ▁ alert ▁ tasks ▁ for ▁ alert ▁ {}: ▁ {} ▁ ' . format ( self . alert_uuid , e . message ) ) <newline>  # ▁ REVISIT <encdom>  # ▁ check ▁ for ▁ any ▁ outstanding ▁ errors <encdom> <dedent> <dedent> else : <newline> <indent> self . alert_failure ( ) <newline> return <newline> <dedent> <dedent> <dedent> def perform_actions ( self ) : <newline> <indent>  """ Execute ▁ all ▁ the ▁ instructions ▁ as ▁ directed ▁ by ▁ the ▁ trigger ▁ data """  <newline> log . logger . debug ( u'Performing ▁ alert ▁ actions ▁ now' ) <newline>  # ▁ check ▁ for ▁ any ▁ errors ▁ we've ▁ detected ▁ so ▁ far <encdom> if len ( self . error_list ) > 0 : <newline> <indent> log . logger . debug ( u'Errors ▁ found ▁ in ▁ alert, ▁ aborting ▁ execution' ) <newline> self . alert_failure ( ) <newline> <dedent> else : <newline>  # ▁ please ▁ proceed, ▁ governor <encdom>  # ▁ Validate ▁ content ▁ references <encdom>  # ▁ (this ▁ needs ▁ to ▁ wait ▁ for ▁ a ▁ content ▁ reference ▁ class ▁ before ▁ implementing) <encdom>  # ▁ there ▁ could ▁ be ▁ multiple ▁ viz's ▁ (including ▁ PDF, ▁ CSV, ▁ TWB) ▁ for ▁ a ▁ single ▁ row ▁ in ▁ the ▁ CSV <encdom>  # ▁ return ▁ a ▁ list ▁ of ▁ all ▁ found ▁ content ▁ reference ▁ VIZ_*() ▁ strings <encdom>  # ▁ VIZ_*([optional ▁ custom ▁ view ▁ w/optional ▁ custom ▁ URL ▁ parameters]|[optional ▁ VizAlerts ▁ parameters]) <encdom>  # ▁ stored ▁ as ▁ a ▁ dict ▁ of ▁ dicts, ▁ the ▁ key ▁ is ▁ the ▁ content ▁ reference <encdom> <indent> vizcompleterefs = dict ( ) <newline>  # ▁ run ▁ the ▁ simple ▁ alert <encdom> if self . alert_type == SIMPLE_ALERT : <newline> <indent> try : <newline> <indent> log . logger . debug ( u'Processing ▁ as ▁ a ▁ simple ▁ alert' ) <newline>  # ▁ export ▁ the ▁ viz ▁ to ▁ a ▁ PNG ▁ file <encdom> imagepath = tabhttp . export_view ( self . view_url_suffix , self . site_name , self . timeout_s , self . data_retrieval_tries , self . force_refresh , tabhttp . Format . PNG , self . viz_png_width , self . viz_png_height , self . subscriber_sysname , self . subscriber_domain ) <newline>  # ▁ attachments ▁ are ▁ stored ▁ lists ▁ of ▁ dicts ▁ to ▁ handle ▁ Advanced ▁ Alerts <encdom> inlineattachments = [ { 'imagepath' : imagepath } ] <newline> appendattachments = [ { 'imagepath' : self . trigger_data_file } ] <newline>  # ▁ embed ▁ the ▁ viz ▁ image <encdom>  # ▁ inlineattachments ▁ = ▁ [csvpath, ▁ imagepath] <encdom> log . logger . info ( u'Sending ▁ simple ▁ alert ▁ email ▁ to ▁ user ▁ {}' . format ( self . subscriber_email ) ) <newline> body = u'<a ▁ href="{}"><img ▁ src="cid:{}"></a>' . format ( self . get_view_url ( ) , basename ( imagepath ) ) + bodyfooter . format ( self . subscriber_email , self . subscriber_sysname , self . get_view_url ( ) , self . view_name ) <newline> subject = unicode ( u'Alert ▁ triggered ▁ for ▁ {}' . format ( self . view_name ) ) <newline> try : <newline> <indent> email_instance = emailaction . Email ( config . configs [ 'smtp.address.from' ] , self . subscriber_email , subject , body , None , None , inlineattachments , appendattachments ) <newline>  # ▁ enqueue ▁ the ▁ task ▁ for ▁ later ▁ execution <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_EMAIL , email_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Could ▁ not ▁ send ▁ email, ▁ error: ▁ {}' . format ( e . message ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> self . alert_failure ( ) <newline> return <newline> <dedent> return <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Alert ▁ was ▁ triggered, ▁ but ▁ encountered ▁ a ▁ failure ▁ rendering ▁ data/image:<br> ▁ {}' . format ( e . message ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline>  # ▁ run ▁ the ▁ advanced ▁ alert <encdom> <dedent> <dedent> elif self . alert_type == ADVANCED_ALERT : <newline> <indent> log . logger . debug ( u'Processing ▁ as ▁ an ▁ advanced ▁ alert' ) <newline> try : <newline> <indent> vizcompleterefs = self . find_viz_refs ( self . trigger_data ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Alert ▁ was ▁ triggered, ▁ but ▁ encountered ▁ a ▁ failure ▁ getting ▁ data/image ▁ references' u':<br ▁ /> ▁ {}' . format ( e . message ) <newline> log . logger . error ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline>  # ▁ determine ▁ whether ▁ we're ▁ consolidating ▁ lines <encdom> <dedent> consolidate_lines_fieldname = self . action_field_dict [ CONSOLIDATE_LINES_FIELDKEY ] . field_name <newline>  # ▁ process ▁ emails <encdom> if self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Processing ▁ emails' ) <newline>  # ▁ eliminate ▁ duplicate ▁ rows ▁ and ▁ ensure ▁ proper ▁ sorting <encdom> data = self . get_unique_vizdata ( EMAIL_ACTION_TYPE ) <newline> rowcount_unique = len ( data ) <newline>  # ▁ get ▁ the ▁ field ▁ names ▁ we'll ▁ need <encdom> email_action_fieldname = self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . field_name <newline> email_to_fieldname = self . action_field_dict [ EMAIL_TO_FIELDKEY ] . field_name <newline> email_from_fieldname = self . action_field_dict [ EMAIL_FROM_FIELDKEY ] . field_name <newline> email_cc_fieldname = self . action_field_dict [ EMAIL_CC_FIELDKEY ] . field_name <newline> email_bcc_fieldname = self . action_field_dict [ EMAIL_BCC_FIELDKEY ] . field_name <newline> email_subject_fieldname = self . action_field_dict [ EMAIL_SUBJECT_FIELDKEY ] . field_name <newline> email_body_fieldname = self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . field_name <newline> email_header_fieldname = self . action_field_dict [ EMAIL_HEADER_FIELDKEY ] . field_name <newline>  # ▁ iterate ▁ through ▁ the ▁ rows ▁ and ▁ send ▁ emails ▁ accordingly <encdom> consolidate_email_ctr = 0 <newline> body = [ ]  # ▁ the ▁ entire ▁ body ▁ of ▁ the ▁ email <encdom> <newline> email_body_line = u''  # ▁ the ▁ current ▁ line ▁ of ▁ the ▁ email ▁ body <encdom> <newline> subject = u'' <newline> email_to = u'' <newline> email_from = u'' <newline> inlineattachments = [ ] <newline> appendattachments = [ ] <newline> email_instance = None <newline>  # ▁ Process ▁ each ▁ row ▁ of ▁ data <encdom> for i , row in enumerate ( data ) : <newline>  # ▁ author ▁ wants ▁ to ▁ send ▁ an ▁ email <encdom>  # ▁ use ▁ string ▁ value ▁ for ▁ maximum ▁ safety. ▁ all ▁ other ▁ values ▁ are ▁ ignored, ▁ currently <encdom> <indent> if row [ email_action_fieldname ] == '1' : <newline>  # ▁ make ▁ sure ▁ we ▁ set ▁ the ▁"from" ▁ address ▁ if ▁ the ▁ viz ▁ did ▁ not ▁ provide ▁ it <encdom> <indent> email_from = self . action_field_dict [ EMAIL_FROM_FIELDKEY ] . get_value_from_dict ( row ) <newline> log . logger . debug ( u'email_from ▁ is ▁ {}' . format ( email_from ) ) <newline>  # ▁ make ▁ sure ▁ we ▁ set ▁ the ▁"to" ▁ address ▁ if ▁ the ▁ viz ▁ did ▁ not ▁ provide ▁ it <encdom> email_to = self . action_field_dict [ EMAIL_TO_FIELDKEY ] . get_value_from_dict ( row ) <newline> log . logger . debug ( u'email_to ▁ is ▁ {}' . format ( email_to ) ) <newline>  # ▁ make ▁ sure ▁ we ▁ set ▁ the ▁ subject ▁ field ▁ if ▁ the ▁ viz ▁ did ▁ not ▁ provide ▁ it <encdom> subject = self . action_field_dict [ EMAIL_SUBJECT_FIELDKEY ] . get_value_from_dict ( row ) <newline> log . logger . debug ( u'subject ▁ is ▁ {}' . format ( subject ) ) <newline>  # ▁ make ▁ sure ▁ we ▁ set ▁ the ▁ body ▁ line ▁ if ▁ the ▁ viz ▁ did ▁ not ▁ provide ▁ it <encdom> email_body_line = self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . get_value_from_dict ( row ) <newline> log . logger . debug ( u'email_body_line ▁ is ▁ {}' . format ( email_body_line ) ) <newline>  # ▁ get ▁ the ▁ other ▁ recipient ▁ addresses <encdom> if email_cc_fieldname : <newline> <indent> email_cc = row [ email_cc_fieldname ] <newline> <dedent> else : <newline> <indent> email_cc = None <newline> <dedent> if email_bcc_fieldname : <newline> <indent> email_bcc = row [ email_bcc_fieldname ] <newline> <dedent> else : <newline> <indent> email_bcc = None <newline>  # ▁ Append ▁ header ▁ row, ▁ if ▁ provided ▁ -- ▁ but ▁ only ▁ if ▁ this ▁ is ▁ the ▁ first ▁ consolidation ▁ iteration <encdom>  # ▁ (for ▁ non-consoidated ▁ setting, ▁ each ▁ row ▁ will ▁ always ▁ be ▁ the ▁ first ▁ iteration) <encdom> <dedent> if email_header_fieldname and consolidate_email_ctr == 0 : <newline> <indent> log . logger . debug ( u'Appending ▁ body ▁ header' ) <newline> body . append ( row [ email_header_fieldname ] ) <newline>  # ▁ If ▁ rows ▁ are ▁ being ▁ consolidated, ▁ consolidate ▁ all ▁ with ▁ same ▁ recipients ▁ & ▁ subject <encdom> <dedent> if consolidate_lines_fieldname : <newline>  # ▁ could ▁ put ▁ a ▁ test ▁ in ▁ here ▁ for ▁ mixing ▁ consolidated ▁ and ▁ non-consolidated ▁ emails ▁ in <encdom>  # ▁ the ▁ same ▁ trigger ▁ view, ▁ would ▁ also ▁ need ▁ to ▁ check ▁ the ▁ sort ▁ in ▁ get_unique_vizdata <encdom> <indent> log . logger . debug ( u'Consolidate ▁ value ▁ is ▁ true, ▁ row ▁ index ▁ is ▁ {}, ▁ rowcount ▁ is ▁ {}' . format ( i , rowcount_unique ) ) <newline>  # ▁ test ▁ for ▁ end ▁ of ▁ iteration--if ▁ done, ▁ take ▁ what ▁ we ▁ have ▁ so ▁ far ▁ and ▁ send ▁ it <encdom> if i + 1 == rowcount_unique : <newline> <indent> log . logger . debug ( u'Last ▁ email ▁ in ▁ set ▁ reached, ▁ sending ▁ consolidated ▁ email' ) <newline> log . logger . info ( u'Sending ▁ email ▁ to ▁ {}, ▁ CC ▁ {}, ▁ BCC ▁ {}, ▁ subject ▁ {}' . format ( email_to , email_cc , email_bcc , subject ) ) <newline> try :  # ▁ remove ▁ this ▁ later?? <encdom> <newline> <indent> body , inlineattachments = self . append_body_and_inlineattachments ( body , inlineattachments , row , vizcompleterefs ) <newline> appendattachments = self . append_attachments ( appendattachments , row , vizcompleterefs ) <newline>  # ▁ send ▁ the ▁ email <encdom> email_instance = emailaction . Email ( email_from , email_to , subject , u'' . join ( body ) , email_cc , email_bcc , inlineattachments , appendattachments ) <newline> log . logger . debug ( u'This ▁ is ▁ the ▁ email ▁ to:{}' . format ( email_instance . toaddrs ) ) <newline> log . logger . debug ( u'This ▁ is ▁ the ▁ email ▁ from:{}' . format ( email_instance . fromaddr ) ) <newline>  # ▁ Enqueue ▁ the ▁ task ▁ for ▁ later ▁ execution <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_EMAIL , email_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Failed ▁ to ▁ send ▁ the ▁ email. ▁ Exception:<br> ▁ {}' . format ( e ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline>  # ▁ reset ▁ variables ▁ for ▁ next ▁ email <encdom> <dedent> body = [ ] <newline> inlineattachments = [ ] <newline> consolidate_email_ctr = 0 <newline> appendattachments = [ ] <newline> email_instance = None <newline> <dedent> else : <newline>  # ▁ This ▁ isn't ▁ the ▁ end, ▁ and ▁ we're ▁ consolidating ▁ rows, ▁ so ▁ test ▁ to ▁ see ▁ if ▁ the ▁ next ▁ row ▁ needs <encdom>  # ▁ to ▁ be ▁ a ▁ new ▁ email <encdom> <indent> this_row_recipients = [ ] <newline> next_row_recipients = [ ] <newline> this_row_recipients . append ( subject ) <newline> this_row_recipients . append ( email_to ) <newline> this_row_recipients . append ( email_from ) <newline>  # ▁ check ▁ if ▁ we're ▁ sending ▁ an ▁ email ▁ at ▁ all ▁ in ▁ the ▁ next ▁ row <encdom> next_row_email_action = data [ i + 1 ] [ email_action_fieldname ] <newline> if email_subject_fieldname : <newline> <indent> next_row_recipients . append ( data [ i + 1 ] [ email_subject_fieldname ] ) <newline> <dedent> else : <newline> <indent> next_row_recipients . append ( subject ) <newline> <dedent> if email_to_fieldname : <newline> <indent> next_row_recipients . append ( data [ i + 1 ] [ email_to_fieldname ] ) <newline> <dedent> else : <newline> <indent> next_row_recipients . append ( email_to ) <newline> <dedent> if email_from_fieldname : <newline> <indent> next_row_recipients . append ( data [ i + 1 ] [ email_from_fieldname ] ) <newline> <dedent> else : <newline> <indent> next_row_recipients . append ( email_from ) <newline> <dedent> if email_cc_fieldname : <newline> <indent> this_row_recipients . append ( email_cc ) <newline> next_row_recipients . append ( data [ i + 1 ] [ email_cc_fieldname ] ) <newline> <dedent> if email_bcc_fieldname : <newline> <indent> this_row_recipients . append ( email_bcc ) <newline> next_row_recipients . append ( data [ i + 1 ] [ email_bcc_fieldname ] ) <newline>  # ▁ Now ▁ compare ▁ the ▁ data ▁ from ▁ the ▁ rows <encdom> <dedent> if this_row_recipients == next_row_recipients and next_row_email_action : <newline> <indent> log . logger . debug ( u'Next ▁ row ▁ matches ▁ recips ▁ and ▁ subject, ▁ appending ▁ body ▁ & ▁ attachments' ) <newline> body . append ( email_body_line ) <newline> if self . action_field_dict [ EMAIL_ATTACHMENT_FIELDKEY ] . field_name and len ( row [ self . action_field_dict [ EMAIL_ATTACHMENT_FIELDKEY ] . field_name ] ) > 0 : <newline> <indent> appendattachments = self . append_attachments ( appendattachments , row , vizcompleterefs ) <newline> <dedent> consolidate_email_ctr += 1 <newline> <dedent> else : <newline> <indent> log . logger . debug ( u'Next ▁ row ▁ does ▁ not ▁ match ▁ recips ▁ and ▁ subject, ▁ sending ▁ consolidated ▁ email' ) <newline> log . logger . info ( u'Sending ▁ email ▁ to ▁ {}, ▁ CC ▁ {}, ▁ BCC ▁ {}, ▁ Subject ▁ {}' . format ( email_to , email_cc , email_bcc , subject ) ) <newline> body , inlineattachments = self . append_body_and_inlineattachments ( body , inlineattachments , row , vizcompleterefs ) <newline> appendattachments = self . append_attachments ( appendattachments , row , vizcompleterefs ) <newline>  # ▁ send ▁ the ▁ email <encdom> try : <newline> <indent> email_instance = emailaction . Email ( email_from , email_to , subject , u'' . join ( body ) , email_cc , email_bcc , inlineattachments , appendattachments ) <newline>  # ▁ Enqueue ▁ the ▁ task ▁ for ▁ later ▁ execution <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_EMAIL , email_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Failed ▁ to ▁ send ▁ the ▁ email. ▁ Exception:<br> ▁ {}' . format ( e ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline> <dedent> body = [ ] <newline> consolidate_email_ctr = 0 <newline> inlineattachments = [ ] <newline> appendattachments = [ ] <newline> email_instance = None <newline> <dedent> <dedent> <dedent> else : <newline>  # ▁ emails ▁ are ▁ not ▁ being ▁ consolidated, ▁ so ▁ send ▁ the ▁ email <encdom> <indent> log . logger . info ( u'Sending ▁ email ▁ to ▁ {}, ▁ CC ▁ {}, ▁ BCC ▁ {}, ▁ Subject ▁ {}' . format ( email_to , email_cc , email_bcc , subject ) ) <newline> body , inlineattachments = self . append_body_and_inlineattachments ( body , inlineattachments , row , vizcompleterefs ) <newline> appendattachments = self . append_attachments ( appendattachments , row , vizcompleterefs ) <newline> try : <newline> <indent> email_instance = emailaction . Email ( email_from , email_to , subject , u'' . join ( body ) , email_cc , email_bcc , inlineattachments , appendattachments ) <newline>  # ▁ Enqueue ▁ the ▁ task ▁ for ▁ later ▁ execution <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_EMAIL , email_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Failed ▁ to ▁ send ▁ the ▁ email. ▁ Exception:<br> ▁ {}' . format ( e ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline> <dedent> body = [ ] <newline> consolidate_email_ctr = 0 <newline> inlineattachments = [ ] <newline> appendattachments = [ ] <newline> email_instance = None <newline>  # ▁ we're ▁ not ▁ performing ▁ any ▁ actions ▁ this ▁ round. <encdom>  # ▁ Make ▁ sure ▁ we ▁ reset ▁ our ▁ variables ▁ again <encdom> <dedent> <dedent> else : <newline>  # ▁ reset ▁ variables ▁ for ▁ next ▁ email <encdom> <indent> body = [ ] <newline> inlineattachments = [ ] <newline> consolidate_email_ctr = 0 <newline> appendattachments = [ ] <newline> email_instance = None <newline>  # ▁ process ▁ sms ▁ messages <encdom> <dedent> <dedent> <dedent> if self . action_field_dict [ SMS_ACTION_FIELDKEY ] . field_name : <newline>  # ▁ eliminate ▁ duplicate ▁ rows ▁ and ▁ ensure ▁ proper ▁ sorting <encdom> <indent> data = self . get_unique_vizdata ( SMS_ACTION_TYPE ) <newline> rowcount_unique = len ( data ) <newline>  # ▁ get ▁ the ▁ field ▁ names ▁ we'll ▁ need <encdom> sms_action_fieldname = self . action_field_dict [ SMS_ACTION_FIELDKEY ] . field_name <newline> sms_to_fieldname = self . action_field_dict [ SMS_TO_FIELDKEY ] . field_name <newline> sms_message_fieldname = self . action_field_dict [ SMS_MESSAGE_FIELDKEY ] . field_name <newline> sms_header_fieldname = self . action_field_dict [ SMS_HEADER_FIELDKEY ] . field_name <newline> consolidate_sms_ctr = 0 <newline> sms_message = [ ]  # ▁ list ▁ to ▁ support ▁ future ▁ header, ▁ footer, ▁ and ▁ consolidate ▁ features <encdom> <newline>  # ▁ Process ▁ each ▁ row ▁ of ▁ data <encdom> for i , row in enumerate ( data ) : <newline>  # ▁ author ▁ wants ▁ to ▁ send ▁ an ▁ SMS <encdom>  # ▁ use ▁ string ▁ value ▁ for ▁ maximum ▁ safety. ▁ all ▁ other ▁ values ▁ are ▁ ignored, ▁ currently <encdom> <indent> if row [ sms_action_fieldname ] == '1' : <newline> <indent> sms_to = row [ sms_to_fieldname ] <newline> sms_from = self . from_number  # ▁ currently ▁ only ▁ supporting ▁ admin-set ▁ numbers <encdom> <newline>  # ▁ Append ▁ header ▁ row, ▁ if ▁ provided ▁ - ▁ only ▁ for ▁ the ▁ first ▁ consolidation ▁ iteration <encdom>  # ▁ if ▁ lines ▁ aren't ▁ being ▁ consolidated, ▁ each ▁ row ▁ will ▁ always ▁ be ▁ the ▁ first ▁ iteration <encdom> if sms_header_fieldname and consolidate_sms_ctr == 0 : <newline> <indent> sms_message . append ( row [ sms_header_fieldname ] ) <newline>  # ▁ If ▁ rows ▁ are ▁ being ▁ consolidated, ▁ consolidate ▁ the ▁ message ▁ text ▁ where ▁ it's ▁ being ▁ sent <encdom>  # ▁ to ▁ the ▁ same ▁ recipients <encdom> <dedent> if consolidate_lines_fieldname : <newline>  # ▁ could ▁ put ▁ a ▁ test ▁ in ▁ here ▁ for ▁ mixing ▁ consolidated ▁ and ▁ non-consolidated ▁ emails ▁ in <encdom>  # ▁ the ▁ same ▁ trigger ▁ view, ▁ would ▁ also ▁ need ▁ to ▁ check ▁ the ▁ sort ▁ in ▁ get_unique_vizdata <encdom> <indent> log . logger . debug ( u'Consolidate ▁ value ▁ is ▁ true, ▁ row ▁ index ▁ is ▁ {}, ▁ rowcount ▁ is ▁ {}' . format ( i , rowcount_unique ) ) <newline>  # ▁ test ▁ for ▁ end ▁ of ▁ iteration--if ▁ done, ▁ take ▁ what ▁ we ▁ have ▁ so ▁ far ▁ and ▁ send ▁ it <encdom> if i + 1 == rowcount_unique : <newline>  # ▁ finalize ▁ the ▁ message ▁ by ▁ adding ▁ any ▁ footers ▁ and ▁ replacing ▁ content ▁ references <encdom> <indent> sms_message = smsaction . sms_append_body ( sms_message , vizcompleterefs , row , self ) <newline> log . logger . debug ( u'Converting ▁ phone ▁ number ▁ list ▁ {} ▁ to ▁ E.164' . format ( sms_to ) ) <newline>  # ▁ make ▁ list ▁ of ▁ all ▁ SMS ▁ addresses ▁ - ▁ they ▁ already ▁ went ▁ through ▁ 1st ▁ validation <encdom> smsaddresses = smsaction . get_e164numbers ( sms_to , self . phone_country_code ) <newline> log . logger . info ( u'Sending ▁ SMS ▁ to ▁ {}, ▁ from ▁ {}, ▁ message: ▁ {}' . format ( smsaddresses , sms_from , u'' . join ( sms_message ) ) ) <newline>  # ▁ send ▁ the ▁ message(s) ▁ (multiple ▁ for ▁ multiple ▁ phone ▁ numbers) <encdom> for smsaddress in smsaddresses : <newline> <indent> try : <newline> <indent> sms_instance = smsaction . SMS ( sms_from , smsaddress , u'' . join ( sms_message ) ) <newline>  # ▁ enqueue ▁ the ▁ sms ▁ to ▁ be ▁ sent <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_SMS , sms_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> self . error_list . append ( u'Could ▁ not ▁ send ▁ SMS, ▁ error: ▁ {}' . format ( e . message ) ) <newline> self . alert_failure ( ) <newline> return <newline>  # ▁ reset ▁ variables ▁ for ▁ next ▁ email <encdom> <dedent> <dedent> sms_message = [ ] <newline> consolidate_sms_ctr = 0 <newline> <dedent> else : <newline>  # ▁ This ▁ isn't ▁ the ▁ end, ▁ and ▁ we're ▁ consolidating ▁ rows, ▁ so ▁ test ▁ to ▁ see <encdom>  # ▁ if ▁ the ▁ next ▁ row ▁ needs ▁ to ▁ be ▁ a ▁ new ▁ SMS <encdom> <indent> this_row_sms_recipients = [ ] <newline> next_row_sms_recipients = [ ] <newline> this_row_sms_recipients . append ( row [ sms_to_fieldname ] ) <newline>  # ▁ check ▁ if ▁ we're ▁ sending ▁ an ▁ email ▁ at ▁ all ▁ in ▁ the ▁ next ▁ row <encdom> next_row_sms_action = data [ i + 1 ] [ sms_action_fieldname ] <newline> next_row_sms_recipients . append ( data [ i + 1 ] [ sms_to_fieldname ] ) <newline>  # ▁ Now ▁ compare ▁ the ▁ data ▁ from ▁ the ▁ rows <encdom> if this_row_sms_recipients == next_row_sms_recipients and next_row_sms_action : <newline> <indent> log . logger . debug ( u'Next ▁ row ▁ matches ▁ recips ▁ and ▁ subject, ▁ appending ▁ message' ) <newline> sms_message . append ( row [ sms_message_fieldname ] ) <newline> consolidate_sms_ctr += 1 <newline> <dedent> else : <newline> <indent> log . logger . debug ( u'Next ▁ row ▁ does ▁ not ▁ match ▁ sms_to ▁ values, ▁ sending ▁ consolidated ▁ sms' ) <newline>  # ▁ append ▁ the ▁ body ▁ and ▁ footer <encdom> sms_message = smsaction . sms_append_body ( sms_message , vizcompleterefs , row , self ) <newline>  # ▁ make ▁ list ▁ of ▁ all ▁ SMS ▁ addresses ▁ - ▁ they ▁ already ▁ went ▁ through ▁ 1st ▁ validation <encdom> smsaddresses = smsaction . get_e164numbers ( sms_to , self . phone_country_code ) <newline> log . logger . info ( u'Sending ▁ SMS ▁ to ▁ {}, ▁ from ▁ {}, ▁ message: ▁ {}' . format ( smsaddresses , sms_from , u'' . join ( sms_message ) ) ) <newline>  # ▁ send ▁ the ▁ message(s) ▁ (multiple ▁ for ▁ multiple ▁ phone ▁ numbers) <encdom> for smsaddress in smsaddresses : <newline> <indent> try : <newline> <indent> sms_instance = smsaction . SMS ( sms_from , smsaddress , u'' . join ( sms_message ) ) <newline>  # ▁ enqueue ▁ the ▁ sms ▁ to ▁ be ▁ sent <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_SMS , sms_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> self . error_list . append ( u'Could ▁ not ▁ send ▁ SMS, ▁ error: ▁ {}' . format ( e . message ) ) <newline> self . alert_failure ( ) <newline> return <newline>  # ▁ reset ▁ the ▁ variables ▁ for ▁ the ▁ next ▁ message <encdom> <dedent> <dedent> sms_message = [ ] <newline> consolidate_sms_ctr = 0 <newline> <dedent> <dedent> <dedent> else : <newline>  # ▁ we're ▁ not ▁ consolidating, ▁ so ▁ just ▁ send ▁ the ▁ SMS <encdom>  # ▁ append ▁ the ▁ body ▁ and ▁ footer <encdom> <indent> sms_message = smsaction . sms_append_body ( sms_message , vizcompleterefs , row , self ) <newline>  # ▁ make ▁ list ▁ of ▁ all ▁ SMS ▁ addresses ▁ - ▁ they ▁ already ▁ went ▁ through ▁ 1st ▁ validation <encdom> smsaddresses = smsaction . get_e164numbers ( sms_to , self . phone_country_code ) <newline> log . logger . info ( u'Sending ▁ SMS ▁ to ▁ {}, ▁ from ▁ {}, ▁ message: ▁ {}' . format ( smsaddresses , sms_from , '' . join ( sms_message ) ) ) <newline>  # ▁ send ▁ the ▁ message(s) ▁ (multiple ▁ for ▁ multiple ▁ phone ▁ numbers) <encdom> for smsaddress in smsaddresses : <newline> <indent> try : <newline> <indent> sms_instance = smsaction . SMS ( sms_from , smsaddress , '' . join ( sms_message ) ) <newline>  # ▁ enqueue ▁ the ▁ sms ▁ to ▁ be ▁ sent <encdom> self . task_queue . put ( Task ( self , TaskType . SEND_SMS , sms_instance ) ) <newline> <dedent> except Exception as e : <newline> <indent> self . error_list . append ( u'Could ▁ not ▁ send ▁ SMS, ▁ error: ▁ {}' . format ( e . message ) ) <newline> self . alert_failure ( ) <newline> return <newline>  # ▁ reset ▁ the ▁ variables ▁ for ▁ the ▁ next ▁ message <encdom> <dedent> <dedent> sms_message = [ ] <newline> consolidate_sms_ctr = 0 <newline> <dedent> <dedent> <dedent> <dedent> <dedent> else : <newline> <indent> errormessage = u'Could ▁ not ▁ determine ▁ alert ▁ type, ▁ due ▁ to ▁ a ▁ bug ▁ in ▁ VizAlerts. ▁ ' u'Please ▁ contact ▁ the ▁ developers' <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline> <dedent> <dedent> <dedent> def find_viz_refs ( self , data ) : <newline> <indent>  """ ▁ Given ▁ the ▁ data ▁ this ▁ searches ▁ through ▁ the ▁ body, ▁ header, ▁ footer, ▁ and ▁ attachment ▁ for ▁ all ▁ references ▁ to ▁ vizzes ▁ to ▁ be ▁ downloaded, ▁ downloads ▁ only ▁ the ▁ distinct ▁ vizzes ▁ (to ▁ avoid ▁ duplicating ▁ downloads). <strnewline> <strnewline> ▁ Returns ▁ vizcompleterefs ▁ dictionary ▁ that ▁ contains ▁ a ▁ key ▁ of ▁ each ▁ distinct ▁ viz ▁ reference. ▁ The ▁ value ▁ is ▁ another ▁ dictionary ▁ with ▁ the ▁ following ▁ keys: <strnewline> ▁ vizref ▁ = ▁ the ▁ original ▁ viz ▁ reference ▁ string ▁ (the ▁ view_url_suffix) <strnewline> ▁ view_url_suffix ▁ = ▁ the ▁ workbook/viewname ▁ to ▁ be ▁ downloaded, ▁ plus ▁ any ▁ URL ▁ parameters ▁ the ▁ user ▁ has ▁ added <strnewline> ▁ formatstring ▁ = ▁ the ▁ format ▁ of ▁ the ▁ destination ▁ file, ▁ based ▁ on ▁ the ▁ VIZ_* ▁ reference <strnewline> ▁ imagepath ▁ = ▁ the ▁ full ▁ path ▁ to ▁ the ▁ temp ▁ tile ▁ for ▁ the ▁ downloaded ▁ viz <strnewline> ▁ filename ▁ = ▁ the ▁ filename ▁ to ▁ use ▁ for ▁ appended ▁ attachments ▁ as ▁ well ▁ as ▁ exported ▁ files <strnewline> ▁ exportfilepath ▁ = ▁ the ▁ path ▁ to ▁ use ▁ for ▁ an ▁ exported ▁ file <strnewline> ▁ mergepdf ▁ = ▁ used ▁ for ▁ merging ▁ pdfs <strnewline> ▁ noattach ▁ = ▁ used ▁ with ▁ exportfilepath, ▁ makes ▁ the ▁ attachment ▁ not ▁ used <strnewline> <strnewline> ▁ """  <newline>  # ▁ MCOLES: ▁ These ▁ local ▁ variables ▁ are ▁ being ▁ set ▁ to ▁ avoid ▁ refactoring ▁ everything ▁ in ▁ this ▁ function <encdom>  # ▁ Yes, ▁ this ▁ is ▁ redundant ▁ and ▁ awful ▁ but ▁ we'll ▁ address ▁ it ▁ later <encdom> viewurlsuffix = self . view_url_suffix <newline> email_action_fieldname = self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . field_name <newline> email_body_fieldname = self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . field_name <newline> email_header_fieldname = self . action_field_dict [ EMAIL_HEADER_FIELDKEY ] . field_name <newline> email_footer_fieldname = self . action_field_dict [ EMAIL_FOOTER_FIELDKEY ] . field_name <newline> email_attachment_fieldname = self . action_field_dict [ EMAIL_ATTACHMENT_FIELDKEY ] . field_name <newline> sms_action_fieldname = self . action_field_dict [ SMS_ACTION_FIELDKEY ] . field_name <newline> sms_message_fieldname = self . action_field_dict [ SMS_MESSAGE_FIELDKEY ] . field_name <newline> vizcompleterefs = dict ( ) <newline> results = [ ] <newline> vizdistinctrefs = dict ( ) <newline> results = [ ] <newline> log . logger . debug ( u'Identifying ▁ content ▁ references' ) <newline>  # ▁ data ▁ is ▁ the ▁ CSV ▁ that ▁ has ▁ been ▁ downloaded ▁ for ▁ a ▁ given ▁ view <encdom>  # ▁ loop ▁ through ▁ it ▁ to ▁ make ▁ a ▁ result ▁ set ▁ of ▁ all ▁ viz ▁ references <encdom> for item in data : <newline> <indent> if email_action_fieldname : <newline> <indent> if self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . get_value_from_dict ( item ) == '1' : <newline>  # ▁ this ▁ might ▁ be ▁ able ▁ to ▁ be ▁ more ▁ efficient ▁ code <encdom> <indent> if 'VIZ_IMAGE' in self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . get_value_from_dict ( item ) or 'VIZ_LINK' in self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . get_value_from_dict ( item ) : <newline> <indent> results . extend ( re . findall ( u"VIZ_IMAGE\(.*?\)|VIZ_LINK\(.*?\)" , self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . get_value_from_dict ( item ) ) ) <newline> <dedent> if email_header_fieldname : <newline> <indent> results . extend ( re . findall ( u"VIZ_IMAGE\(.*?\)|VIZ_LINK\(.*?\)" , item [ email_header_fieldname ] ) ) <newline> <dedent> if email_footer_fieldname : <newline> <indent> results . extend ( re . findall ( u"VIZ_IMAGE\(.*?\)|VIZ_LINK\(.*?\)" , item [ email_footer_fieldname ] ) ) <newline> <dedent> if email_attachment_fieldname : <newline> <indent> results . extend ( re . findall ( u"VIZ_IMAGE\(.*?\)|VIZ_CSV\(.*?\)|VIZ_PDF\(.*?\)|VIZ_TWB\(.*?\)" , item [ email_attachment_fieldname ] ) ) <newline> <dedent> <dedent> <dedent> if sms_action_fieldname : <newline> <indent> if self . action_field_dict [ SMS_ACTION_FIELDKEY ] . get_value_from_dict ( item ) == '1' : <newline> <indent> if sms_message_fieldname : <newline> <indent> results . extend ( re . findall ( u"VIZ_LINK\(.*?\)" , item [ sms_message_fieldname ] ) ) <newline>  # ▁ loop ▁ through ▁ each ▁ found ▁ viz ▁ reference, ▁ i.e. ▁ everything ▁ in ▁ the ▁ VIZ_*(*). <encdom> <dedent> <dedent> <dedent> <dedent> for vizref in results : <newline>  # ▁ REVISIT!!! ▁ Can ▁ we ▁ lighten ▁ the ▁ log ▁ load ▁ (ha) ▁ here? <encdom>  # ▁ log.logger.debug(u'found ▁ content ▁ ref ▁ {}'.format(vizref)) <encdom> <indent> if vizref not in vizcompleterefs : <newline>  # ▁ create ▁ a ▁ dictionary ▁ to ▁ hold ▁ the ▁ necessary ▁ values ▁ for ▁ this ▁ viz ▁ reference <encdom> <indent> vizcompleterefs [ vizref ] = dict ( ) <newline>  # ▁ store ▁ the ▁ vizref ▁ itself ▁ as ▁ a ▁ value ▁ in ▁ the ▁ dict, ▁ will ▁ need ▁ later <encdom> vizcompleterefs [ vizref ] [ 'vizref' ] = vizref <newline>  # ▁ identifying ▁ the ▁ format ▁ for ▁ the ▁ output ▁ file <encdom> vizrefformat = re . match ( u'VIZ_(.*?)\(' , vizref ) <newline> if vizrefformat . group ( 1 ) == 'IMAGE' : <newline> <indent> vizcompleterefs [ vizref ] [ 'formatstring' ] = 'PNG' <newline> <dedent> else : <newline> <indent> vizcompleterefs [ vizref ] [ 'formatstring' ] = vizrefformat . group ( 1 ) <newline>  # ▁ this ▁ section ▁ parses ▁ out ▁ the ▁ vizref ▁ into ▁ several ▁ parts: <encdom>  # ▁ view_url_suffix ▁ - ▁ always ▁ present, ▁ this ▁ is ▁ the ▁ workbook/view ▁ plus ▁ any ▁ URL ▁ parameters <encdom>  # ▁ filename ▁ - ▁ optional ▁ custom ▁ filename ▁ for ▁ appended ▁ attachments <encdom>  # ▁ exportfilepath ▁ - ▁ optional ▁ custom ▁ path ▁ not ▁ yet ▁ supported) <encdom>  # ▁ mergepdf ▁ - ▁ option ▁ to ▁ merge ▁ multiple ▁ PDFs, ▁ only ▁ for ▁ VIZ_PDF() <encdom>  # ▁ vizlink ▁ - ▁ option ▁ to ▁ have ▁ an ▁ inline ▁ VIZ_IMAGE() ▁ be ▁ a ▁ URL ▁ link <encdom>  # ▁ rawlink ▁ - ▁ option ▁ to ▁ have ▁ a ▁ VIZ_LINK() ▁ not ▁ have ▁ any ▁ text, ▁ just ▁ the ▁ http: ▁ link <encdom>  # ▁ if ▁ the ▁ vizref ▁ is ▁ one ▁ of ▁ the ▁ placeholders ▁ i.e. ▁ just ▁ a ▁ VIZ_CSV() <encdom>  # ▁ then ▁ we ▁ will ▁ be ▁ pulling ▁ down ▁ the ▁ calling ▁ viz <encdom> <dedent> <dedent> if vizref in [ IMAGE_PLACEHOLDER , PDF_PLACEHOLDER , CSV_PLACEHOLDER , TWB_PLACEHOLDER , VIZLINK_PLACEHOLDER ] : <newline> <indent> vizcompleterefs [ vizref ] [ 'view_url_suffix' ] = viewurlsuffix <newline> <dedent> else : <newline>  # ▁ vizstring ▁ contains ▁ everything ▁ inside ▁ the ▁ VIZ_*() ▁ parentheses <encdom> <indent> vizstring = re . match ( u'VIZ_.*?\((.*?)\)' , vizref ) <newline>  # ▁ vizstring ▁ may ▁ contain ▁ reference ▁ to ▁ the ▁ viz ▁ plus ▁ advanced ▁ alert ▁ parameters ▁ like <encdom>  # ▁ a ▁ filename <encdom>  # ▁ if ▁ there ▁ is ▁ no ▁ delimiter ▁ then ▁ at ▁ this ▁ point ▁ we ▁ know ▁ the ▁ vizstring <encdom>  # ▁ is ▁ just ▁ a ▁ viz ▁ to ▁ use <encdom> if ARGUMENT_DELIMITER not in vizstring . group ( 1 ) : <newline>  # ▁ if ▁ the ▁ first ▁ character ▁ is ▁ ? ▁ then ▁ the ▁ content ▁ reference ▁ is ▁ something ▁ like <encdom>  # ▁ VIZ_IMAGE(?Region=East) ▁ so ▁ we ▁ need ▁ to ▁ use ▁ the ▁ trigger ▁ viz <encdom> <indent> if vizstring . group ( 1 ) [ 0 ] == '?' : <newline> <indent> vizcompleterefs [ vizref ] [ 'view_url_suffix' ] = viewurlsuffix + vizstring . group ( 1 ) <newline> <dedent> else : <newline> <indent> vizcompleterefs [ vizref ] [ 'view_url_suffix' ] = vizstring . group ( 1 ) <newline>  # ▁ there ▁ are ▁ one ▁ or ▁ more ▁ arguments <encdom> <dedent> <dedent> else : <newline>  # ▁ split ▁ vizstring ▁ into ▁ a ▁ list ▁ of ▁ arguments <encdom> <indent> vizstringlist = vizstring . group ( 1 ) . split ( ARGUMENT_DELIMITER ) <newline>  # ▁ first ▁ argument ▁ could ▁ be ▁ empty, ▁ such ▁ as ▁ VIZ_IMAGE(|filename=someFileName) <encdom>  # ▁ in ▁ that ▁ case ▁ we'll ▁ use ▁ the ▁ calling ▁ viz <encdom> if vizstringlist [ 0 ] == '' : <newline> <indent> vizcompleterefs [ vizref ] [ 'view_url_suffix' ] = viewurlsuffix <newline>  # ▁ first ▁ argument ▁ could ▁ also ▁ be ▁ a ▁ URL ▁ parameter ▁ such ▁ as <encdom>  # ▁ VIZ_IMAGE(?Region=East|filename=someFileName) <encdom> <dedent> elif vizstringlist [ 0 ] [ 0 ] == '?' : <newline> <indent> vizcompleterefs [ vizref ] [ 'view_url_suffix' ] = viewurlsuffix + vizstringlist [ 0 ] <newline>  # ▁ there ▁ are ▁ no ▁ arguments, ▁ so ▁ return ▁ only ▁ the ▁ entire ▁ view ▁ URL ▁ suffix <encdom> <dedent> else : <newline> <indent> vizcompleterefs [ vizref ] [ 'view_url_suffix' ] = vizstringlist [ 0 ] <newline>  # ▁ if ▁ there ▁ is ▁ more ▁ than ▁ one ▁ element ▁ in ▁ the ▁ vizstring ▁ list ▁ then ▁ we <encdom>  # ▁ know ▁ there ▁ are ▁ arguments ▁ to ▁ parse ▁ out <encdom>  # ▁ this ▁ code ▁ could ▁ probably ▁ be ▁ simpler <encdom> <dedent> if len ( vizstringlist ) > 1 : <newline> <indent> try : <newline>  # ▁ 0th ▁ element ▁ is ▁ the ▁ whole ▁ reference, ▁ so ▁ skip ▁ it <encdom> <indent> for element in vizstringlist [ 1 : ] : <newline>  # ▁ looking ▁ for ▁ filenames <encdom> <indent> if element . startswith ( EXPORTFILENAME_ARGUMENT ) : <newline> <indent> filename = re . match ( EXPORTFILENAME_ARGUMENT + u'=(.*)' , element ) . group ( 1 ) <newline>  # ▁ code ▁ from ▁ https://github.com/mitsuhiko/flask/blob/50dc2403526c5c5c67577767b05eb81e8fab0877/flask/helpers.py # L633 <encdom>  # ▁ for ▁ validating ▁ filenames <encdom> filename = posixpath . normpath ( filename ) <newline> for sep in _os_alt_seps : <newline> <indent> if sep in filename : <newline> <indent> errormessage = u'Found ▁ an ▁ invalid ▁ or ▁ non-allowed ▁ separator ▁ in ▁ filename: ▁ ' u'{} ▁ for ▁ content ▁ reference ▁ {}' . format ( filename , vizref ) <newline> self . error_list . append ( errormessage ) <newline> raise ValueError ( errormessage ) <newline> <dedent> <dedent> if os . path . isabs ( filename ) or '../' in filename or '..\\' in filename : <newline> <indent> errormessage = u'Found ▁ non-allowed ▁ path ▁ when ▁ expecting ▁ filename: ▁ ' u'{} ▁ for ▁ content ▁ reference ▁ {}' . format ( filename , vizref ) <newline> self . error_list . append ( errormessage ) <newline> raise ValueError ( errormessage ) <newline>  # ▁ check ▁ for ▁ non-allowed ▁ characters <encdom>  # ▁ check ▁ for ▁ non-allowed ▁ characters <encdom>  # ▁ code ▁ based ▁ on ▁ https://mail.python.org/pipermail/tutor/2010-December/080883.html <encdom>  # ▁ using ▁ ($L) ▁ option ▁ to ▁ set ▁ locale ▁ to ▁ handle ▁ accented ▁ characters <encdom> <dedent> nonallowedchars = re . findall ( u'(?L)[^\w ▁ \-._+]' , filename ) <newline> if len ( nonallowedchars ) > 0 : <newline> <indent> errormessage = u'Found ▁ non-allowed ▁ character(s): ▁ ' u'{} ▁ in ▁ filename ▁ {} ▁ for ▁ content ▁ reference ▁ ' u'{}, ▁ only ▁ allowed ▁ characters ▁ are ▁ alphanumeric, ▁ space, ▁ hyphen, ▁ underscore, ▁ ' u'period, ▁ and ▁ plus ▁ sign' . format ( u'' . join ( nonallowedchars ) , filename , vizref ) <newline> self . error_list . append ( errormessage ) <newline> raise ValueError ( errormessage ) <newline>  # ▁ if ▁ the ▁ output ▁ is ▁ anything ▁ but ▁ LINK ▁ then ▁ append ▁ the ▁ formatstring <encdom>  # ▁ to ▁ the ▁ output ▁ filename <encdom> <dedent> if vizcompleterefs [ vizref ] [ 'formatstring' ] != 'LINK' : <newline> <indent> vizcompleterefs [ vizref ] [ 'filename' ] = filename + '.' + vizcompleterefs [ vizref ] [ 'formatstring' ] . lower ( ) <newline> <dedent> else : <newline> <indent> vizcompleterefs [ vizref ] [ 'filename' ] = filename <newline>  # ▁ looking ▁ for ▁ mergepdf <encdom> <dedent> <dedent> if element . startswith ( MERGEPDF_ARGUMENT ) and vizcompleterefs [ vizref ] [ 'formatstring' ] . lower ( ) == 'pdf' : <newline> <indent> vizcompleterefs [ vizref ] [ MERGEPDF_ARGUMENT ] = 'y' <newline> <dedent> if element . startswith ( VIZLINK_ARGUMENT ) : <newline> <indent> vizcompleterefs [ vizref ] [ VIZLINK_ARGUMENT ] = 'y' <newline> <dedent> if element . startswith ( RAWLINK_ARGUMENT ) : <newline> <indent> vizcompleterefs [ vizref ] [ RAWLINK_ARGUMENT ] = 'y' <newline> <dedent> <dedent> <dedent> except Exception as e : <newline> <indent> errormessage = u'Alert ▁ was ▁ triggered, ▁ but ▁ unable ▁ to ▁ process ▁ arguments ▁ to ▁ a ▁ ' u'content ▁ reference ▁ with ▁ error:<br><br> ▁ {}' . format ( e . message ) <newline> self . error_list . append ( errormessage ) <newline> log . logger . error ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline>  # ▁ end ▁ of ▁ processing ▁ vizstringlist <encdom>  # ▁ end ▁ of ▁ checking ▁ for ▁ argument ▁ delimiters <encdom>  # ▁ end ▁ of ▁ parsing ▁ this ▁ vizref <encdom>  # ▁ creating ▁ distinct ▁ list ▁ of ▁ images ▁ to ▁ download <encdom>  # ▁ this ▁ is ▁ a ▁ dict ▁ so ▁ we ▁ have ▁ both ▁ the ▁ workbook/viewname ▁ aka ▁ view_url_suffix ▁ as ▁ well ▁ as ▁ the ▁ formatstring <encdom> <dedent> <dedent> <dedent> <dedent> if vizref not in vizdistinctrefs and vizcompleterefs [ vizref ] [ 'formatstring' ] != 'LINK' : <newline> <indent> vizdistinctrefs [ vizref ] = vizcompleterefs [ vizref ] <newline>  # ▁ end ▁ if ▁ vizref ▁ not ▁ in ▁ vizcompleterefs <encdom>  # ▁ end ▁ for ▁ vizref ▁ in ▁ results <encdom>  # ▁ loop ▁ over ▁ vizdistinctrefs ▁ to ▁ download ▁ images, ▁ PDFs, ▁ etc. ▁ from ▁ Tableau <encdom> <dedent> <dedent> for vizref in vizdistinctrefs : <newline> <indent> try : <newline>  # ▁ we ▁ need ▁ a ▁ full ▁ VizAlert ▁ instance ▁ to ▁ export ▁ the ▁ info, ▁ but ▁ with ▁ a ▁ different ▁ view_url_suffix <encdom>  # ▁ to ▁ avoid ▁ overwriting ▁ the ▁ view_url_suffix ▁ in ▁ ourself, ▁ create ▁ a ▁ deep ▁ copy ▁ and ▁ pass ▁ that ▁ instead <encdom>  # ▁ this ▁ should ▁ probably ▁ be ▁ implemented ▁ differently, ▁ but ▁ for ▁ now ▁ it'll ▁ have ▁ to ▁ do <encdom> <indent> view_url_suffix = vizdistinctrefs [ vizref ] [ 'view_url_suffix' ] <newline>  # ▁ export/render ▁ the ▁ viz ▁ to ▁ a ▁ file, ▁ store ▁ path ▁ to ▁ the ▁ download ▁ as ▁ value ▁ with ▁ vizref ▁ as ▁ key <encdom> vizdistinctrefs [ vizref ] [ 'imagepath' ] = tabhttp . export_view ( view_url_suffix , self . site_name ,  # ▁ content ▁ references ▁ must ▁ live ▁ on ▁ the ▁ same ▁ site ▁ as ▁ the ▁ alert ▁ itself <encdom> self . timeout_s , self . data_retrieval_tries , self . force_refresh , eval ( 'tabhttp.Format.' + vizdistinctrefs [ vizref ] [ 'formatstring' ] ) , self . viz_png_width , self . viz_png_height , self . subscriber_sysname , self . subscriber_domain ) <newline> <dedent> except Exception as e : <newline> <indent> errormessage = u'Unable ▁ to ▁ render ▁ content ▁ reference ▁ {} ▁ with ▁ error:<br> ▁ {}' . format ( vizref , e . message ) <newline> log . logger . error ( errormessage ) <newline> self . error_list . append ( errormessage ) <newline> raise UserWarning ( errormessage ) <newline>  # ▁ now ▁ match ▁ vizdistinctrefs ▁ to ▁ original ▁ references ▁ to ▁ store ▁ the ▁ correct ▁ imagepaths <encdom> <dedent> <dedent> for vizref in vizcompleterefs : <newline> <indent> if vizcompleterefs [ vizref ] [ 'formatstring' ] != 'LINK' : <newline> <indent> vizcompleterefs [ vizref ] [ 'imagepath' ] = vizdistinctrefs [ vizref ] [ 'imagepath' ] <newline> <dedent> <dedent> if len ( vizcompleterefs ) > 0 : <newline> <indent> log . logger . debug ( u'Returning ▁ all ▁ content ▁ references' ) <newline> <dedent> return vizcompleterefs <newline> <dedent> def get_unique_vizdata ( self , action_type ) : <newline> <indent>  """ Returns ▁ a ▁ unique ▁ list ▁ of ▁ all ▁ relevant ▁ action ▁ records ▁ in ▁ data. ▁ Also ▁ sorts ▁ data ▁ in ▁ proper ▁ order. """  <newline> preplist = [ ]  # ▁ list ▁ of ▁ dicts ▁ containing ▁ only ▁ keys ▁ of ▁ concern ▁ for ▁ de-duplication ▁ from ▁ data <encdom> <newline> uniquelist = [ ]  # ▁ unique-ified ▁ list ▁ of ▁ dicts <encdom> <newline> log . logger . debug ( u'Start ▁ of ▁ get_unique_vizdata' ) <newline>  # ▁ copy ▁ in ▁ only ▁ relevant ▁ fields ▁ from ▁ each ▁ record, ▁ specific ▁ to ▁ the ▁ action_type ▁ passed ▁ in. <encdom>  # ▁ Non-VizAlerts ▁ fields ▁ will ▁ be ▁ ignored <encdom> for item in self . trigger_data : <newline> <indent> newitem = dict ( ) <newline> for action_field in self . action_field_dict : <newline>  # ▁ Each ▁ action ▁ field ▁ we're ▁ looking ▁ for ▁ must: <encdom>  # ▁ Be ▁ of ▁ the ▁ correct ▁ type ▁ (email, ▁ sms, ▁ whatever ▁ else--or ▁ a ▁ generic ▁ type) <encdom>  # ▁ Have ▁ a ▁ field ▁ match ▁ in ▁ the ▁ actual ▁ trigger ▁ data <encdom>  # ▁ Have ▁ passed ▁ validation <encdom> <indent> if ( self . action_field_dict [ action_field ] . action_type == action_type or self . action_field_dict [ action_field ] . action_type == GENERAL_ACTION_TYPE ) and self . action_field_dict [ action_field ] . has_match ( ) and not self . action_field_dict [ action_field ] . has_errors ( ) : <newline> <indent> newitem [ self . action_field_dict [ action_field ] . field_name ] = item [ self . action_field_dict [ action_field ] . field_name ] <newline>  # ▁ add ▁ the ▁ new ▁ trimmed ▁ row ▁ to ▁ our ▁ list <encdom> <dedent> <dedent> preplist . append ( newitem ) <newline> <dedent> log . logger . debug ( u'Removing ▁ duplicates' ) <newline>  # ▁ remove ▁ duplicates, ▁ preserving ▁ original ▁ ordering <encdom>  # ▁ proposed ▁ solution ▁ from ▁ http://stackoverflow.com/questions/9427163/remove-duplicate-dict-in-list-in-python <encdom> seen = set ( ) <newline> for dictitem in preplist : <newline> <indent> t = tuple ( sorted ( dictitem . items ( ) ) ) <newline> if t not in seen : <newline> <indent> seen . add ( t ) <newline> uniquelist . append ( dictitem ) <newline> <dedent> <dedent> log . logger . debug ( u'Sorting ▁ unique ▁ rows' ) <newline>  # ▁ the ▁ data ▁ must ▁ now ▁ be ▁ sorted ▁ for ▁ use ▁ in ▁ Advanced ▁ Alerts ▁ with ▁ email ▁ consolidation <encdom>  # ▁ sort ▁ order ▁ is ▁ used ▁ first ▁ because ▁ the ▁ downloaded ▁ trigger ▁ csv ▁ can ▁ be ▁ re-ordered ▁ during <encdom>  # ▁ the ▁ download ▁ process ▁ from ▁ the ▁ original ▁ csv <encdom> if self . action_field_dict [ GENERAL_SORTORDER_FIELDKEY ] . field_name : <newline> <indent> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ GENERAL_SORTORDER_FIELDKEY ] . field_name ) ) <newline> log . logger . debug ( u'Sorting ▁ by ▁ {}' . format ( self . action_field_dict [ GENERAL_SORTORDER_FIELDKEY ] . field_name ) ) <newline>  # ▁ special ▁ case ▁ for ▁ Email ▁ Actions, ▁ where ▁ the ▁ Consolidate ▁ Lines ▁ flag ▁ is ▁ used <encdom> <dedent> if action_type == EMAIL_ACTION_TYPE : <newline> <indent> if self . action_field_dict [ EMAIL_ACTION_FIELDKEY ] . field_name and self . action_field_dict [ CONSOLIDATE_LINES_FIELDKEY ] . field_name : <newline> <indent> if self . action_field_dict [ EMAIL_BCC_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Sorting ▁ by ▁ BCC ▁ field ▁ {}' . format ( self . action_field_dict [ EMAIL_BCC_FIELDKEY ] . field_name ) ) <newline> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ EMAIL_BCC_FIELDKEY ] . field_name ) ) <newline> <dedent> if self . action_field_dict [ EMAIL_CC_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Sorting ▁ by ▁ CC ▁ field ▁ {}' . format ( self . action_field_dict [ EMAIL_CC_FIELDKEY ] . field_name ) ) <newline> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ EMAIL_CC_FIELDKEY ] . field_name ) ) <newline> <dedent> if self . action_field_dict [ EMAIL_FROM_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Sorting ▁ by ▁ From ▁ field ▁ {}' . format ( self . action_field_dict [ EMAIL_FROM_FIELDKEY ] . field_name ) ) <newline> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ EMAIL_FROM_FIELDKEY ] . field_name ) ) <newline> <dedent> if self . action_field_dict [ EMAIL_TO_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Sorting ▁ by ▁ To ▁ field ▁ {}' . format ( self . action_field_dict [ EMAIL_TO_FIELDKEY ] . field_name ) ) <newline> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ EMAIL_TO_FIELDKEY ] . field_name ) ) <newline> <dedent> if self . action_field_dict [ EMAIL_SUBJECT_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Sorting ▁ by ▁ Subject ▁ field ▁ {}' . format ( self . action_field_dict [ EMAIL_SUBJECT_FIELDKEY ] . field_name ) ) <newline> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ EMAIL_SUBJECT_FIELDKEY ] . field_name ) ) <newline>  # ▁ special ▁ case ▁ for ▁ SMS ▁ Actions, ▁ where ▁ the ▁ Consolidate ▁ Lines ▁ flag ▁ is ▁ used <encdom> <dedent> <dedent> <dedent> if action_type == SMS_ACTION_TYPE : <newline> <indent> if self . action_field_dict [ SMS_ACTION_FIELDKEY ] . field_name and self . action_field_dict [ CONSOLIDATE_LINES_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Sorting ▁ by ▁ To' ) <newline> if self . action_field_dict [ SMS_TO_FIELDKEY ] . field_name : <newline> <indent> uniquelist = sorted ( uniquelist , key = itemgetter ( self . action_field_dict [ SMS_TO_FIELDKEY ] . field_name ) ) <newline>  # ▁ Alert ▁ authors ▁ currently ▁ can't ▁ specify ▁ the ▁ SMS ▁ From ▁ Number <encdom> <dedent> <dedent> <dedent> log . logger . debug ( u'Done ▁ sorting, ▁ returning ▁ the ▁ list' ) <newline>  # ▁ return ▁ the ▁ list <encdom> return uniquelist <newline> <dedent> def append_attachments ( self , appendattachments , row , vizcompleterefs ) : <newline> <indent>  """ generic ▁ function ▁ for ▁ adding ▁ appended ▁ (non-inline) ▁ attachments """  <newline>  # ▁ there ▁ can ▁ be ▁ multiple ▁ content ▁ references ▁ in ▁ a ▁ single ▁ email ▁ attachment ▁ field <encdom>  # ▁ and ▁ order ▁ is ▁ important ▁ if ▁ these ▁ attachments ▁ are ▁ to ▁ be ▁ merged ▁ later <encdom>  # ▁ so ▁ we ▁ generate ▁ the ▁ list ▁ with ▁ a ▁ regex <encdom> if self . action_field_dict [ EMAIL_ATTACHMENT_FIELDKEY ] . field_name : <newline> <indent> attachmentrefs = [ ] <newline> attachmentrefs = re . findall ( u"VIZ_IMAGE\(.*?\)|VIZ_CSV\(.*?\)|VIZ_PDF\(.*?\)|VIZ_TWB\(.*?\)" , row [ self . action_field_dict [ EMAIL_ATTACHMENT_FIELDKEY ] . field_name ] ) <newline> if len ( attachmentrefs ) > 0 : <newline> <indent> log . logger . debug ( u'Adding ▁ appended ▁ attachments ▁ to ▁ list' ) <newline> <dedent> for attachmentref in attachmentrefs : <newline>  # ▁ only ▁ make ▁ appended ▁ attachments ▁ when ▁ they ▁ are ▁ needed <encdom> <indent> if attachmentref not in appendattachments : <newline> <indent> appendattachments . append ( vizcompleterefs [ attachmentref ] ) <newline> <dedent> <dedent> <dedent> return appendattachments <newline> <dedent> def append_body_and_inlineattachments ( self , body , inlineattachments , row , vizcompleterefs ) : <newline> <indent>  """ Generic ▁ function ▁ for ▁ filling ▁ email ▁ body ▁ text ▁ with ▁ the ▁ body ▁ & ▁ footers ▁ from ▁ the ▁ csv <strnewline> ▁ plus ▁ inserting ▁ viz ▁ references """  <newline>  """ for ▁ inline ▁ attachments ▁ and ▁ hyperlink ▁ text """  <newline> log . logger . debug ( u'Replacing ▁ body ▁ text ▁ with ▁ exact ▁ content ▁ references ▁ for ▁ inline ▁ attachments ▁ and ▁ hyperlinks' ) <newline> body . append ( self . action_field_dict [ EMAIL_BODY_FIELDKEY ] . get_value_from_dict ( row ) ) <newline>  # ▁ add ▁ the ▁ footer ▁ if ▁ needed <encdom> if self . action_field_dict [ EMAIL_FOOTER_FIELDKEY ] . field_name : <newline> <indent> log . logger . debug ( u'Adding ▁ the ▁ custom ▁ footer' ) <newline> body . append ( row [ self . action_field_dict [ EMAIL_FOOTER_FIELDKEY ] . field_name ] . replace ( DEFAULT_FOOTER , bodyfooter . format ( self . subscriber_email , self . subscriber_sysname , self . get_view_url ( ) , self . view_name ) ) ) <newline> <dedent> else : <newline>  # ▁ no ▁ footer ▁ specified, ▁ add ▁ the ▁ default ▁ footer <encdom> <indent> log . logger . debug ( u'Adding ▁ the ▁ default ▁ footer' ) <newline> body . append ( bodyfooter . format ( self . subscriber_email , self . subscriber_sysname , self . get_view_url ( ) , self . view_name ) ) <newline>  # ▁ find ▁ all ▁ distinct ▁ content ▁ references ▁ in ▁ the ▁ email ▁ body ▁ list <encdom>  # ▁ so ▁ we ▁ can ▁ replace ▁ each ▁ with ▁ an ▁ inline ▁ image ▁ or ▁ hyperlink ▁ text <encdom> <dedent> log . logger . debug ( u'Finding ▁ all ▁ content ▁ refs' ) <newline> foundcontent = re . findall ( u"VIZ_IMAGE\(.*?\)|VIZ_LINK\(.*?\)" , ' ▁ ' . join ( body ) ) <newline> foundcontentset = set ( foundcontent ) <newline> vizrefs = list ( foundcontentset ) <newline> if len ( vizrefs ) > 0 : <newline> <indent> for vizref in vizrefs : <newline> <indent> log . logger . debug ( u'Iterating... ▁ Ref: ▁ {}' . format ( vizref ) ) <newline>  # ▁ replacing ▁ VIZ_IMAGE() ▁ with ▁ inline ▁ images <encdom> if vizcompleterefs [ vizref ] [ 'formatstring' ] == 'PNG' : <newline>  # ▁ add ▁ hyperlinks ▁ to ▁ images ▁ if ▁ necessary <encdom> <indent> if VIZLINK_ARGUMENT in vizcompleterefs [ vizref ] and vizcompleterefs [ vizref ] [ VIZLINK_ARGUMENT ] == 'y' : <newline> <indent> replacestring = u'<a ▁ href="' + self . get_view_url ( vizcompleterefs [ vizref ] [ 'view_url_suffix' ] ) + u'"><img ▁ src="cid:{}">' . format ( basename ( vizcompleterefs [ vizref ] [ 'imagepath' ] ) ) + u'</a>' <newline> <dedent> else : <newline> <indent> replacestring = u'<img ▁ src="cid:{}">' . format ( basename ( vizcompleterefs [ vizref ] [ 'imagepath' ] ) ) <newline> <dedent> replaceresult = replace_in_list ( body , vizref , replacestring ) <newline> if replaceresult [ 'foundstring' ] : <newline> <indent> body = replaceresult [ 'outlist' ] <newline>  # ▁ create ▁ a ▁ list ▁ of ▁ inline ▁ attachments <encdom> if vizcompleterefs [ vizref ] not in inlineattachments : <newline> <indent> inlineattachments . append ( vizcompleterefs [ vizref ] ) <newline> <dedent> <dedent> else : <newline> <indent> raise UserWarning ( u'Unable ▁ to ▁ locate ▁ downloaded ▁ image ▁ for ▁ {}, ▁ check ▁ whether ▁ the ▁ content ▁ ' u'reference ▁ is ▁ properly ▁ URL ▁ encoded.' . format ( vizref ) ) <newline>  # ▁ we're ▁ replacing ▁ # VIZ_LINK ▁ text <encdom> <dedent> <dedent> elif vizcompleterefs [ vizref ] [ 'formatstring' ] == 'LINK' : <newline>  # ▁ use ▁ raw ▁ link ▁ if ▁ that ▁ option ▁ is ▁ present <encdom> <indent> if RAWLINK_ARGUMENT in vizcompleterefs [ vizref ] and vizcompleterefs [ vizref ] [ RAWLINK_ARGUMENT ] == 'y' : <newline> <indent> replacestring = self . get_view_url ( vizcompleterefs [ vizref ] [ 'view_url_suffix' ] ) <newline> <dedent> else : <newline>  # ▁ test ▁ for ▁ whether ▁ the ▁ filename ▁ field ▁ is ▁ used, ▁ if ▁ so ▁ that ▁ is ▁ the ▁ link ▁ text <encdom> <indent> if 'filename' in vizcompleterefs [ vizref ] and len ( vizcompleterefs [ vizref ] [ 'filename' ] ) > 0 : <newline> <indent> replacestring = u'<a ▁ href="' + self . get_view_url ( vizcompleterefs [ vizref ] [ 'view_url_suffix' ] ) + u'">' + vizcompleterefs [ vizref ] [ 'filename' ] + u'</a>' <newline>  # ▁ use ▁ the ▁ view_url_suffix ▁ as ▁ the ▁ link ▁ text <encdom> <dedent> else : <newline> <indent> replacestring = u'<a ▁ href="' + self . get_view_url ( vizcompleterefs [ vizref ] [ 'view_url_suffix' ] ) + u'">' + vizcompleterefs [ vizref ] [ 'view_url_suffix' ] + u'</a>' <newline> <dedent> <dedent> replaceresult = replace_in_list ( body , vizref , replacestring ) <newline> if replaceresult [ 'foundstring' ] : <newline> <indent> body = replaceresult [ 'outlist' ] <newline> <dedent> <dedent> <dedent> <dedent> return body , inlineattachments <newline> <dedent> def alert_failure ( self ) : <newline> <indent>  """ Alert ▁ the ▁ Admin, ▁ and ▁ optionally ▁ the ▁ Subscriber, ▁ to ▁ a ▁ failure ▁ to ▁ process ▁ their ▁ alert """  <newline> subject = u'VizAlerts ▁ was ▁ unable ▁ to ▁ process ▁ alert ▁ {}' . format ( self . view_name ) <newline> data_errors = [ ]  # ▁ errors ▁ found ▁ in ▁ the ▁ trigger ▁ data ▁ fields, ▁ or ▁ in ▁ the ▁ trigger ▁ data ▁ itself <encdom> <newline> other_errors = [ ]  # ▁ miscellaneous ▁ other ▁ errors ▁ we ▁ may ▁ have ▁ caught <encdom> <newline> error_text = u'The ▁ following ▁ errors ▁ were ▁ encountered ▁ trying ▁ to ▁ ' u'process ▁ your ▁ alert:<br ▁ /><br ▁ />'  # ▁ final ▁ error ▁ text ▁ to ▁ email <encdom> <newline> attachment = None <newline>  # ▁ dump ▁ all ▁ errors ▁ to ▁ the ▁ log ▁ for ▁ troubleshooting <encdom> log . logger . debug ( u'All ▁ errors ▁ found:' ) <newline> for error in self . error_list : <newline> <indent> log . logger . debug ( u'{}' . format ( error ) ) <newline>  # ▁ Separate ▁ the ▁ errors ▁ stored ▁ in ▁ a ▁ dictionary ▁ from ▁ the ▁ generic ▁ errors <encdom>  # ▁ structure ▁ a ▁ nice ▁ HTML ▁ table ▁ to ▁ help ▁ our ▁ beloved ▁ users ▁ sort ▁ out ▁ their ▁ problems <encdom>  # ▁ if ▁ the ▁ error ▁ doesn't ▁ fit ▁ into ▁ the ▁ table, ▁ add ▁ it ▁ to ▁ the ▁ other_errors ▁ list <encdom> <dedent> for error in self . error_list : <newline> <indent> if type ( error ) is dict : <newline> <indent> if 'Row' in error : <newline> <indent> data_errors . append ( u'<tr><td ▁ width="75">{}</td><td ▁ width="75">{}</td><td>{}</td><td>{}</td></tr>' . format ( error [ 'Row' ] , error [ 'Field' ] , error [ 'Value' ] , error [ 'Error' ] ) ) <newline> <dedent> <dedent> else : <newline> <indent> other_errors . append ( error ) <newline>  # ▁ Format ▁ the ▁ error ▁ text ▁ for ▁ the ▁ email <encdom> <dedent> <dedent> if len ( data_errors ) > 0 : <newline> <indent> data_errors . insert ( 0 , u'Errors ▁ found ▁ in ▁ alert ▁ data. ▁ See ▁ row ▁ numbers ▁ in ▁ attached ▁ CSV ▁ file:<br ▁ /><br ▁ />' u'<table ▁ border=1><tr><b><td>Row</td>' u'<td ▁ width="75">Field</td><td>Value</td><td>Error</td></b></tr>' ) <newline> data_errors . append ( u'</table>' ) <newline>  # ▁ append ▁ trigger ▁ data ▁ if ▁ we ▁ found ▁ problems ▁ with ▁ it <encdom> attachment = [ { 'imagepath' : self . trigger_data_file } ] <newline>  # ▁ add ▁ this ▁ to ▁ our ▁ final ▁ error ▁ text <encdom> error_text += u'' . join ( data_errors ) <newline> <dedent> if len ( other_errors ) > 0 : <newline> <indent> error_text += u'<br ▁ /><br ▁ />General ▁ errors:<br ▁ /><br ▁ />' + u'<br ▁ /><br ▁ />' . join ( other_errors ) <newline>  # ▁ tack ▁ on ▁ some ▁ failure ▁ deets ▁ (in ▁ the ▁ ugliest ▁ way ▁ possible, ▁ apparently) <encdom> <dedent> body = error_text + u'<br><br>' + u'<b>Alert ▁ Information:</b><br><br>' + u'<b>View ▁ URL:</b> ▁ <a ▁ href="{}">{}<a>' . format ( self . get_view_url ( ) , self . get_view_url ( ) ) + u'<br><b>Subscriber:</b> ▁ <a ▁ href="mailto:{}">{}</a>' . format ( self . subscriber_email , self . subscriber_sysname ) + u'<br><b>View ▁ Owner:</b> ▁ <a ▁ href="mailto:{}">{}</a>' . format ( self . owner_email , self . owner_sysname ) + u'<br><b>Site ▁ Id:</b> ▁ {}' . format ( self . site_name ) + u'<br><b>Project:</b> ▁ {}' . format ( self . project_name ) <newline> if self . notify_subscriber_on_failure : <newline> <indent> toaddrs = self . subscriber_email  # ▁ email ▁ the ▁ Subscriber, ▁ cc ▁ the ▁ Admin <encdom> <newline> ccaddrs = config . configs [ 'smtp.address.to' ] <newline> <dedent> else : <newline> <indent> toaddrs = config . configs [ 'smtp.address.to' ]  # ▁ just ▁ email ▁ the ▁ Admin <encdom> <newline> ccaddrs = None <newline> <dedent> if attachment : <newline> <indent> log . logger . debug ( u'Failure ▁ email ▁ should ▁ include ▁ attachment: ▁ {}' . format ( attachment ) ) <newline> <dedent> try : <newline> <indent> email_instance = emailaction . Email ( config . configs [ 'smtp.address.from' ] , toaddrs , subject , body , ccaddrs , None , None , attachment ) <newline> emailaction . send_email ( email_instance ) <newline> <dedent> except Exception as e : <newline> <indent> log . logger . error ( u'Unknown ▁ error ▁ sending ▁ exception ▁ alert ▁ email: ▁ {}' . format ( e . message ) ) <newline> <dedent> <dedent> <dedent> def merge_pdf_attachments ( appendattachments ) : <newline> <indent>  """ ▁ Checks ▁ the ▁ list ▁ of ▁ appended ▁ attachments ▁ for ▁ any ▁ merged ▁ pdfs. ▁ Any ▁ pdf ▁ attachments ▁ that ▁ need ▁ to ▁ be ▁ merged ▁ are ▁ merged, ▁ then ▁ the ▁ revised ▁ attachments ▁ is ▁ returned """  <newline> tempdir = config . configs [ 'temp.dir' ] <newline> revisedappendattachments = [ ] <newline> mergedfilenames = dict ( ) <newline>  # ▁ loop ▁ through ▁ append ▁ attachments ▁ list ▁ to ▁ find ▁ the ▁ potential ▁ merges <encdom> for attachment in appendattachments : <newline> <indent> if 'mergepdf' in attachment : <newline>  # ▁ there ▁ could ▁ be ▁ multiple ▁ merges ▁ in ▁ a ▁ single ▁ output, ▁ so ▁ start ▁ a ▁ list ▁ with ▁ the ▁ attachments <encdom> <indent> if attachment [ 'filename' ] not in mergedfilenames : <newline> <indent> mergedfilenames [ attachment [ 'filename' ] ] = OrderedDict ( ) <newline> <dedent> mergedfilenames [ attachment [ 'filename' ] ] [ attachment [ 'vizref' ] ] = attachment <newline>  # ▁ this ▁ isn't ▁ a ▁ merged ▁ pdf, ▁ so ▁ just ▁ append ▁ the ▁ attachment <encdom> <dedent> else : <newline> <indent> revisedappendattachments . append ( attachment ) <newline> <dedent> <dedent> if mergedfilenames : <newline>  # ▁ loop ▁ through ▁ list ▁ of ▁ filenames ▁ to ▁ merge ▁ the ▁ PDFs <encdom> <indent> for listtomerge in mergedfilenames : <newline>  # ▁ if ▁ there's ▁ only ▁ one ▁ PDF ▁ to ▁ merge ▁ then ▁ let's ▁ not ▁ go ▁ any ▁ further, ▁ just ▁ use ▁ the ▁ attachment <encdom> <indent> if len ( mergedfilenames [ listtomerge ] ) == 1 : <newline> <indent> log . logger . debug ( u'Request ▁ to ▁ merge ▁ multiple ▁ PDFs ▁ into ▁ ' + listtomerge + ', ▁ only ▁ one ▁ PDF ▁ found' ) <newline> for attachment in mergedfilenames [ listtomerge ] : <newline> <indent> revisedappendattachments . append ( mergedfilenames [ listtomerge ] [ attachment ] ) <newline>  # ▁ now ▁ to ▁ merge ▁ some ▁ PDFs: <encdom> <dedent> <dedent> else : <newline> <indent> log . logger . debug ( u'Merging ▁ PDFs ▁ for ▁ ' + listtomerge ) <newline> try : <newline>  # ▁ we ▁ know ▁ all ▁ attachments ▁ in ▁ a ▁ given ▁ list ▁ have ▁ the ▁ same ▁ filename ▁ due ▁ to ▁ the ▁ loop ▁ above <encdom>  # ▁ so ▁ we ▁ can ▁ just ▁ pull ▁ the ▁ first ▁ one <encdom> <indent> merger = PdfFileMerger ( ) <newline> i = 0 <newline> for attachment in mergedfilenames [ listtomerge ] : <newline> <indent> if i == 0 : <newline> <indent> mergedfilename = mergedfilenames [ listtomerge ] [ attachment ] [ 'filename' ] <newline> <dedent> merger . append ( PdfFileReader ( mergedfilenames [ listtomerge ] [ attachment ] [ 'imagepath' ] , "rb" ) ) <newline> i = i + 1 <newline>  # ▁ make ▁ the ▁ temp ▁ filename ▁ for ▁ the ▁ merged ▁ pdf <encdom> <dedent> datestring = datetime . datetime . now ( ) . strftime ( '%Y%m%d%H%M%S%f' ) <newline> mergedfilepath = tempdir + datestring + '_' + threading . current_thread ( ) . name + '_' + mergedfilename <newline> merger . write ( mergedfilepath ) <newline> mergedattachment = { 'filename' : mergedfilename , 'imagepath' : mergedfilepath , 'formatstring' : 'PDF' , 'vizref' : 'mergepdf ▁ file ▁ ' + 'filename' } <newline> revisedappendattachments . append ( mergedattachment ) <newline> <dedent> except Exception as e : <newline> <indent> log . logger . error ( u'Could ▁ not ▁ generate ▁ merged ▁ PDF ▁ for ▁ filename ▁ {}: ▁ {}' . format ( mergedfilename , e ) ) <newline> raise e <newline> <dedent> <dedent> <dedent> <dedent> return ( revisedappendattachments ) <newline> <dedent> def replace_in_list ( inlist , findstr , replacestr ) : <newline> <indent>  """ Replaces ▁ all ▁ occurrences ▁ of ▁ a ▁ string ▁ in ▁ a ▁ list ▁ of ▁ strings """  <newline> outlist = [ ] <newline> foundstring = False <newline> for item in inlist : <newline> <indent> if item . find ( findstr ) != - 1 : <newline> <indent> foundstring = True <newline> <dedent> outlist . append ( item . replace ( findstr , replacestr ) ) <newline>  # ▁ return ▁ a ▁ dictionary ▁ with ▁ a ▁ boolean ▁ indicating ▁ whether ▁ we ▁ did ▁ replace ▁ anything, ▁ and ▁ the ▁ new ▁ list <encdom> <dedent> return { 'foundstring' : foundstring , 'outlist' : outlist } <newline> <dedent>
 """ Functions ▁ to ▁ parse ▁ datetime ▁ objects. """  <newline>  # ▁ We're ▁ using ▁ regular ▁ expressions ▁ rather ▁ than ▁ time.strptime ▁ because: <encdom>  # ▁ - ▁ They ▁ provide ▁ both ▁ validation ▁ and ▁ parsing. <encdom>  # ▁ - ▁ They're ▁ more ▁ flexible ▁ for ▁ datetimes. <encdom>  # ▁ - ▁ The ▁ date/datetime/time ▁ constructors ▁ produce ▁ friendlier ▁ error ▁ messages. <encdom> import datetime <newline> import re <newline> from django . utils import six <newline> from django . utils . timezone import get_fixed_timezone , utc <newline> date_re = re . compile ( r'(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})$' ) <newline> time_re = re . compile ( r'(?P<hour>\d{1,2}):(?P<minute>\d{1,2})' r'(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?' ) <newline> datetime_re = re . compile ( r'(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})' r'[T ▁ ](?P<hour>\d{1,2}):(?P<minute>\d{1,2})' r'(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?' r'(?P<tzinfo>Z|[+-]\d{2}(?::?\d{2})?)?$' ) <newline> standard_duration_re = re . compile ( r'(?:(?P<days>-?\d+) ▁ (days?, ▁ )?)?' r'((?:(?P<hours>\d+):)(?=\d+:\d+))?' r'(?:(?P<minutes>\d+):)?' r'(?P<seconds>\d+)' r'(?:\.(?P<microseconds>\d{1,6})\d{0,6})?' )  # ▁ Support ▁ the ▁ sections ▁ of ▁ ISO ▁ 8601 ▁ date ▁ representation ▁ that ▁ are ▁ accepted ▁ by <encdom>  # ▁ timedelta <encdom> iso8601_duration_re = re . compile ( r'^P' r'(?:(?P<days>\d+(.\d+)?)D)?' r'(?:T' r'(?:(?P<hours>\d+(.\d+)?)H)?' r'(?:(?P<minutes>\d+(.\d+)?)M)?' r'(?:(?P<seconds>\d+(.\d+)?)S)?' ) def parse_date ( value ) : <newline> <indent>  """ Parses ▁ a ▁ string ▁ and ▁ return ▁ a ▁ datetime.date. <strnewline> <strnewline> ▁ Raises ▁ ValueError ▁ if ▁ the ▁ input ▁ is ▁ well ▁ formatted ▁ but ▁ not ▁ a ▁ valid ▁ date. <strnewline> ▁ Returns ▁ None ▁ if ▁ the ▁ input ▁ isn't ▁ well ▁ formatted. <strnewline> ▁ """  <newline> match = date_re . match ( value ) <newline> if match : <newline> <indent> kw = { k : int ( v ) for k , v in six . iteritems ( match . groupdict ( ) ) } <newline> return datetime . date ( ** kw ) <newline> <dedent> <dedent> def parse_time ( value ) : <newline> <indent>  """ Parses ▁ a ▁ string ▁ and ▁ return ▁ a ▁ datetime.time. <strnewline> <strnewline> ▁ This ▁ function ▁ doesn't ▁ support ▁ time ▁ zone ▁ offsets. <strnewline> <strnewline> ▁ Raises ▁ ValueError ▁ if ▁ the ▁ input ▁ is ▁ well ▁ formatted ▁ but ▁ not ▁ a ▁ valid ▁ time. <strnewline> ▁ Returns ▁ None ▁ if ▁ the ▁ input ▁ isn't ▁ well ▁ formatted, ▁ in ▁ particular ▁ if ▁ it <strnewline> ▁ contains ▁ an ▁ offset. <strnewline> ▁ """  <newline> match = time_re . match ( value ) <newline> if match : <newline> <indent> kw = match . groupdict ( ) <newline> if kw [ 'microsecond' ] : <newline> <indent> kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' ) <newline> <dedent> kw = { k : int ( v ) for k , v in six . iteritems ( kw ) if v is not None } <newline> return datetime . time ( ** kw ) <newline> <dedent> <dedent> def parse_datetime ( value ) : <newline> <indent>  """ Parses ▁ a ▁ string ▁ and ▁ return ▁ a ▁ datetime.datetime. <strnewline> <strnewline> ▁ This ▁ function ▁ supports ▁ time ▁ zone ▁ offsets. ▁ When ▁ the ▁ input ▁ contains ▁ one, <strnewline> ▁ the ▁ output ▁ uses ▁ a ▁ timezone ▁ with ▁ a ▁ fixed ▁ offset ▁ from ▁ UTC. <strnewline> <strnewline> ▁ Raises ▁ ValueError ▁ if ▁ the ▁ input ▁ is ▁ well ▁ formatted ▁ but ▁ not ▁ a ▁ valid ▁ datetime. <strnewline> ▁ Returns ▁ None ▁ if ▁ the ▁ input ▁ isn't ▁ well ▁ formatted. <strnewline> ▁ """  <newline> match = datetime_re . match ( value ) <newline> if match : <newline> <indent> kw = match . groupdict ( ) <newline> if kw [ 'microsecond' ] : <newline> <indent> kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' ) <newline> <dedent> tzinfo = kw . pop ( 'tzinfo' ) <newline> if tzinfo == 'Z' : <newline> <indent> tzinfo = utc <newline> <dedent> elif tzinfo is not None : <newline> <indent> offset_mins = int ( tzinfo [ - 2 : ] ) if len ( tzinfo ) > 3 else 0 <newline> offset = 60 * int ( tzinfo [ 1 : 3 ] ) + offset_mins <newline> if tzinfo [ 0 ] == '-' : <newline> <indent> offset = - offset <newline> <dedent> tzinfo = get_fixed_timezone ( offset ) <newline> <dedent> kw = { k : int ( v ) for k , v in six . iteritems ( kw ) if v is not None } <newline> kw [ 'tzinfo' ] = tzinfo <newline> return datetime . datetime ( ** kw ) <newline> <dedent> <dedent> def parse_duration ( value ) : <newline> <indent>  """ Parses ▁ a ▁ duration ▁ string ▁ and ▁ returns ▁ a ▁ datetime.timedelta. <strnewline> <strnewline> ▁ The ▁ preferred ▁ format ▁ for ▁ durations ▁ in ▁ Django ▁ is ▁'%d ▁ %H:%M:%S.%f'. <strnewline> <strnewline> ▁ Also ▁ supports ▁ ISO ▁ 8601 ▁ representation. <strnewline> ▁ """  <newline> match = standard_duration_re . match ( value ) <newline> if not match : <newline> <indent> match = iso8601_duration_re . match ( value ) <newline> <dedent> if match : <newline> <indent> kw = match . groupdict ( ) <newline> if kw . get ( 'microseconds' ) : <newline> <indent> kw [ 'microseconds' ] = kw [ 'microseconds' ] . ljust ( 6 , '0' ) <newline> <dedent> kw = { k : float ( v ) for k , v in six . iteritems ( kw ) if v is not None } <newline> return datetime . timedelta ( ** kw ) <newline> <dedent> <dedent>
 # ▁ file: ▁ rfcomm-server.py <encdom>  # ▁ auth: ▁ Albert ▁ Huang ▁ <albert@csail.mit.edu> <encdom>  # ▁ desc: ▁ simple ▁ demonstration ▁ of ▁ a ▁ server ▁ application ▁ that ▁ uses ▁ RFCOMM ▁ sockets <encdom>  # ▁ $Id: ▁ rfcomm-server.py ▁ 518 ▁ 2007-08-10 ▁ 07:20:07Z ▁ albert ▁ $ <encdom> from bluetooth import * <newline> server_sock = BluetoothSocket ( RFCOMM ) <newline> server_sock . bind ( ( "" , PORT_ANY ) ) <newline> server_sock . listen ( 1 ) <newline> port = server_sock . getsockname ( ) [ 1 ] <newline> uuid = "94f39d29-7d6d-437d-973b-fba39e49d4ee" <newline> advertise_service ( server_sock , "SampleServer" , service_id = uuid , service_classes = [ uuid , SERIAL_PORT_CLASS ] , profiles = [ SERIAL_PORT_PROFILE ] ,  # ▁ protocols ▁ = ▁ [ ▁ OBEX_UUID ▁ ] ▁ <encdom> ) <newline> print "Waiting ▁ for ▁ connection ▁ on ▁ RFCOMM ▁ channel ▁ %d" % port <newline> client_sock , client_info = server_sock . accept ( ) <newline> print "Accepted ▁ connection ▁ from ▁ " , client_info <newline> try : <newline> <indent> while True : <newline> <indent> data = client_sock . recv ( 1024 ) <newline> if len ( data ) == 0 : break <newline> print "received ▁ [%s]" % data <newline> <dedent> <dedent> except IOError : <newline> <indent> pass <newline> <dedent> print "disconnected" <newline> client_sock . close ( ) <newline> server_sock . close ( ) <newline> print "all ▁ done" <newline>
from django . core . management . base import BaseCommand , CommandError <newline> from urlshortenerapp . models import Line <newline> class Command ( BaseCommand ) : <newline> <indent> help = 'Add ▁ words.txt ▁ in ▁ database' <newline> def handle ( self , * args , ** options ) : <newline> <indent> with open ( 'words.txt' ) as file : <newline> <indent> self . stdout . write ( 'Creating........' ) <newline> for words in file : <newline> <indent> Line . objects . create ( text = words ) <newline> <dedent> <dedent> self . stdout . write ( self . style . SUCCESS ( 'Task ▁ Successful ▁ !' ) ) <newline> <dedent> <dedent>
 """ This ▁ file ▁ contains ▁ code ▁ for ▁ use ▁ with ▁"Think ▁ Stats", <strnewline> by ▁ Allen ▁ B. ▁ Downey, ▁ available ▁ from ▁ greenteapress.com <strnewline> <strnewline> Copyright ▁ 2014 ▁ Allen ▁ B. ▁ Downey <strnewline> License: ▁ GNU ▁ GPLv3 ▁ http://www.gnu.org/licenses/gpl.html <strnewline> """  <newline> from __future__ import print_function , division <newline> import unittest <newline> import survival <newline> import thinkstats2 <newline> import thinkplot <newline> class Test ( unittest . TestCase ) : <newline> <indent> def testSurvival ( self ) : <newline> <indent> complete = [ 1 , 2 , 3 , 4 , 5 ] <newline> ongoing = [ 3 , 4 , 5 ] <newline> hf = survival . EstimateHazardFunction ( complete , ongoing ) <newline> self . assertAlmostEqual ( hf [ 3 ] , 1 / 6.0 ) <newline> self . assertAlmostEqual ( hf [ 5 ] , 0.5 ) <newline> sf = hf . MakeSurvival ( ) <newline> self . assertAlmostEqual ( sf [ 3 ] , 0.625 ) <newline> self . assertAlmostEqual ( sf [ 5 ] , 0.234375 ) <newline> <dedent> <dedent> if __name__ == "__main__" : <newline> <indent> unittest . main ( ) <newline> <dedent>
from __future__ import unicode_literals <newline> from datetime import datetime , timedelta <newline> from django . template . defaultfilters import timeuntil_filter <newline> from django . test import SimpleTestCase <newline> from django . test . utils import requires_tz_support <newline> from . . utils import setup <newline> from . timezone_utils import TimezoneTestCase <newline> class TimeuntilTests ( TimezoneTestCase ) : <newline>  # ▁ Default ▁ compare ▁ with ▁ datetime.now() <encdom> <indent> @ setup ( { 'timeuntil01' : '{{ ▁ a|timeuntil ▁ }}' } ) <newline> def test_timeuntil01 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil01' , { 'a' : datetime . now ( ) + timedelta ( minutes = 2 , seconds = 10 ) } ) <newline> self . assertEqual ( output , '2\xa0minutes' ) <newline> <dedent> @ setup ( { 'timeuntil02' : '{{ ▁ a|timeuntil ▁ }}' } ) <newline> def test_timeuntil02 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil02' , { 'a' : ( datetime . now ( ) + timedelta ( days = 1 , seconds = 10 ) ) } ) <newline> self . assertEqual ( output , '1\xa0day' ) <newline> <dedent> @ setup ( { 'timeuntil03' : '{{ ▁ a|timeuntil ▁ }}' } ) <newline> def test_timeuntil03 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil03' , { 'a' : ( datetime . now ( ) + timedelta ( hours = 8 , minutes = 10 , seconds = 10 ) ) } ) <newline> self . assertEqual ( output , '8\xa0hours, ▁ 10\xa0minutes' ) <newline>  # ▁ Compare ▁ to ▁ a ▁ given ▁ parameter <encdom> <dedent> @ setup ( { 'timeuntil04' : '{{ ▁ a|timeuntil:b ▁ }}' } ) <newline> def test_timeuntil04 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil04' , { 'a' : self . now - timedelta ( days = 1 ) , 'b' : self . now - timedelta ( days = 2 ) } , ) <newline> self . assertEqual ( output , '1\xa0day' ) <newline> <dedent> @ setup ( { 'timeuntil05' : '{{ ▁ a|timeuntil:b ▁ }}' } ) <newline> def test_timeuntil05 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil05' , { 'a' : self . now - timedelta ( days = 2 ) , 'b' : self . now - timedelta ( days = 2 , minutes = 1 ) } , ) <newline> self . assertEqual ( output , '1\xa0minute' ) <newline>  # ▁ Regression ▁ for ▁ # 7443 <encdom> <dedent> @ setup ( { 'timeuntil06' : '{{ ▁ earlier|timeuntil ▁ }}' } ) <newline> def test_timeuntil06 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil06' , { 'earlier' : self . now - timedelta ( days = 7 ) } ) <newline> self . assertEqual ( output , '0\xa0minutes' ) <newline> <dedent> @ setup ( { 'timeuntil07' : '{{ ▁ earlier|timeuntil:now ▁ }}' } ) <newline> def test_timeuntil07 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil07' , { 'now' : self . now , 'earlier' : self . now - timedelta ( days = 7 ) } ) <newline> self . assertEqual ( output , '0\xa0minutes' ) <newline> <dedent> @ setup ( { 'timeuntil08' : '{{ ▁ later|timeuntil ▁ }}' } ) <newline> def test_timeuntil08 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil08' , { 'later' : self . now + timedelta ( days = 7 , hours = 1 ) } ) <newline> self . assertEqual ( output , '1\xa0week' ) <newline> <dedent> @ setup ( { 'timeuntil09' : '{{ ▁ later|timeuntil:now ▁ }}' } ) <newline> def test_timeuntil09 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil09' , { 'now' : self . now , 'later' : self . now + timedelta ( days = 7 ) } ) <newline> self . assertEqual ( output , '1\xa0week' ) <newline>  # ▁ Ensures ▁ that ▁ differing ▁ timezones ▁ are ▁ calculated ▁ correctly. <encdom> <dedent> @ requires_tz_support <newline> @ setup ( { 'timeuntil10' : '{{ ▁ a|timeuntil ▁ }}' } ) <newline> def test_timeuntil10 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil10' , { 'a' : self . now_tz } ) <newline> self . assertEqual ( output , '0\xa0minutes' ) <newline> <dedent> @ requires_tz_support <newline> @ setup ( { 'timeuntil11' : '{{ ▁ a|timeuntil ▁ }}' } ) <newline> def test_timeuntil11 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil11' , { 'a' : self . now_tz_i } ) <newline> self . assertEqual ( output , '0\xa0minutes' ) <newline> <dedent> @ setup ( { 'timeuntil12' : '{{ ▁ a|timeuntil:b ▁ }}' } ) <newline> def test_timeuntil12 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil12' , { 'a' : self . now_tz_i , 'b' : self . now_tz } ) <newline> self . assertEqual ( output , '0\xa0minutes' ) <newline>  # ▁ Regression ▁ for ▁ # 9065 ▁ (two ▁ date ▁ objects). <encdom> <dedent> @ setup ( { 'timeuntil13' : '{{ ▁ a|timeuntil:b ▁ }}' } ) <newline> def test_timeuntil13 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil13' , { 'a' : self . today , 'b' : self . today } ) <newline> self . assertEqual ( output , '0\xa0minutes' ) <newline> <dedent> @ setup ( { 'timeuntil14' : '{{ ▁ a|timeuntil:b ▁ }}' } ) <newline> def test_timeuntil14 ( self ) : <newline> <indent> output = self . engine . render_to_string ( 'timeuntil14' , { 'a' : self . today , 'b' : self . today - timedelta ( hours = 24 ) } ) <newline> self . assertEqual ( output , '1\xa0day' ) <newline> <dedent> <dedent> class FunctionTests ( SimpleTestCase ) : <newline> <indent> def test_until_now ( self ) : <newline> <indent> self . assertEqual ( timeuntil_filter ( datetime . now ( ) + timedelta ( 1 , 1 ) ) , '1\xa0day' ) <newline> <dedent> def test_explicit_date ( self ) : <newline> <indent> self . assertEqual ( timeuntil_filter ( datetime ( 2005 , 12 , 30 ) , datetime ( 2005 , 12 , 29 ) ) , '1\xa0day' ) <newline> <dedent> <dedent>
 # !/usr/bin/env ▁ python3 <encdom> import sys <newline> if __name__ == '__main__' : <newline> <indent> a_str = sys . argv [ 1 ] <newline> b_str = sys . argv [ 2 ] <newline> a = int ( sys . argv [ 1 ] ) <newline> b = int ( sys . argv [ 2 ] ) <newline> incrementer = 1 <newline> the_range = range ( a , b + incrementer , incrementer ) <newline> for i in the_range : <newline> <indent> print ( "a ▁ = ▁ " + str ( i ) + "(b=" + str ( b ) + ")" ) <newline> <dedent> <dedent>
 # ▁ Copyright ▁ (c) ▁ 2013 ▁ OpenStack ▁ Foundation. <encdom>  # ▁ All ▁ Rights ▁ Reserved. <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); ▁ you ▁ may <encdom>  # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. ▁ You ▁ may ▁ obtain <encdom>  # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, ▁ WITHOUT <encdom>  # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. ▁ See ▁ the <encdom>  # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations <encdom>  # ▁ under ▁ the ▁ License. <encdom> from eventlet import greenthread <newline> from oslo . config import cfg <newline> from oslo . db import exception as db_exc <newline> from oslo import messaging <newline> from oslo . serialization import jsonutils <newline> from oslo . utils import excutils <newline> from oslo . utils import timeutils <newline> import sqlalchemy as sa <newline> from sqlalchemy . orm import exc <newline> from sqlalchemy import sql <newline> from neutron . db import model_base <newline> from neutron . db import models_v2 <newline> from neutron . extensions import agent as ext_agent <newline> from neutron . i18n import _LW <newline> from neutron import manager <newline> from neutron . openstack . common import log as logging <newline> LOG = logging . getLogger ( __name__ ) <newline> cfg . CONF . register_opt ( cfg . IntOpt ( 'agent_down_time' , default = 75 , help = _ ( "Seconds ▁ to ▁ regard ▁ the ▁ agent ▁ is ▁ down; ▁ should ▁ be ▁ at ▁ " "least ▁ twice ▁ report_interval, ▁ to ▁ be ▁ sure ▁ the ▁ " "agent ▁ is ▁ down ▁ for ▁ good." ) ) ) <newline> class Agent ( model_base . BASEV2 , models_v2 . HasId ) : <newline> <indent>  """ Represents ▁ agents ▁ running ▁ in ▁ neutron ▁ deployments. """  <newline> __table_args__ = ( sa . UniqueConstraint ( 'agent_type' , 'host' , name = 'uniq_agents0agent_type0host' ) , ) <newline>  # ▁ L3 ▁ agent, ▁ DHCP ▁ agent, ▁ OVS ▁ agent, ▁ LinuxBridge <encdom> agent_type = sa . Column ( sa . String ( 255 ) , nullable = False ) <newline> binary = sa . Column ( sa . String ( 255 ) , nullable = False ) <newline>  # ▁ TOPIC ▁ is ▁ a ▁ fanout ▁ exchange ▁ topic <encdom> topic = sa . Column ( sa . String ( 255 ) , nullable = False ) <newline>  # ▁ TOPIC.host ▁ is ▁ a ▁ target ▁ topic <encdom> host = sa . Column ( sa . String ( 255 ) , nullable = False ) <newline> admin_state_up = sa . Column ( sa . Boolean , default = True , server_default = sql . true ( ) , nullable = False ) <newline>  # ▁ the ▁ time ▁ when ▁ first ▁ report ▁ came ▁ from ▁ agents <encdom> created_at = sa . Column ( sa . DateTime , nullable = False ) <newline>  # ▁ the ▁ time ▁ when ▁ first ▁ report ▁ came ▁ after ▁ agents ▁ start <encdom> started_at = sa . Column ( sa . DateTime , nullable = False ) <newline>  # ▁ updated ▁ when ▁ agents ▁ report <encdom> heartbeat_timestamp = sa . Column ( sa . DateTime , nullable = False ) <newline>  # ▁ description ▁ is ▁ note ▁ for ▁ admin ▁ user <encdom> description = sa . Column ( sa . String ( 255 ) ) <newline>  # ▁ configurations: ▁ a ▁ json ▁ dict ▁ string, ▁ I ▁ think ▁ 4095 ▁ is ▁ enough <encdom> configurations = sa . Column ( sa . String ( 4095 ) , nullable = False ) <newline> @ property <newline> def is_active ( self ) : <newline> <indent> return not AgentDbMixin . is_agent_down ( self . heartbeat_timestamp ) <newline> <dedent> <dedent> class AgentDbMixin ( ext_agent . AgentPluginBase ) : <newline> <indent>  """ Mixin ▁ class ▁ to ▁ add ▁ agent ▁ extension ▁ to ▁ db_base_plugin_v2. """  <newline> def _get_agent ( self , context , id ) : <newline> <indent> try : <newline> <indent> agent = self . _get_by_id ( context , Agent , id ) <newline> <dedent> except exc . NoResultFound : <newline> <indent> raise ext_agent . AgentNotFound ( id = id ) <newline> <dedent> return agent <newline> <dedent> def get_enabled_agent_on_host ( self , context , agent_type , host ) : <newline> <indent>  """ Return ▁ agent ▁ of ▁ agent_type ▁ for ▁ the ▁ specified ▁ host. """  <newline> query = context . session . query ( Agent ) <newline> query = query . filter ( Agent . agent_type == agent_type , Agent . host == host , Agent . admin_state_up == sql . true ( ) ) <newline> try : <newline> <indent> agent = query . one ( ) <newline> <dedent> except exc . NoResultFound : <newline> <indent> LOG . debug ( 'No ▁ enabled ▁ %(agent_type)s ▁ agent ▁ on ▁ host ▁ ' '%(host)s' % { 'agent_type' : agent_type , 'host' : host } ) <newline> return <newline> <dedent> if self . is_agent_down ( agent . heartbeat_timestamp ) : <newline> <indent> LOG . warn ( _LW ( '%(agent_type)s ▁ agent ▁ %(agent_id)s ▁ is ▁ not ▁ active' ) , { 'agent_type' : agent_type , 'agent_id' : agent . id } ) <newline> <dedent> return agent <newline> <dedent> @ classmethod <newline> def is_agent_down ( cls , heart_beat_time ) : <newline> <indent> return timeutils . is_older_than ( heart_beat_time , cfg . CONF . agent_down_time ) <newline> <dedent> def get_configuration_dict ( self , agent_db ) : <newline> <indent> try : <newline> <indent> conf = jsonutils . loads ( agent_db . configurations ) <newline> <dedent> except Exception : <newline> <indent> msg = _LW ( 'Configuration ▁ for ▁ agent ▁ %(agent_type)s ▁ on ▁ host ▁ %(host)s' ' ▁ is ▁ invalid.' ) <newline> LOG . warn ( msg , { 'agent_type' : agent_db . agent_type , 'host' : agent_db . host } ) <newline> conf = { } <newline> <dedent> return conf <newline> <dedent> def _make_agent_dict ( self , agent , fields = None ) : <newline> <indent> attr = ext_agent . RESOURCE_ATTRIBUTE_MAP . get ( ext_agent . RESOURCE_NAME + 's' ) <newline> res = dict ( ( k , agent [ k ] ) for k in attr if k not in [ 'alive' , 'configurations' ] ) <newline> res [ 'alive' ] = not AgentDbMixin . is_agent_down ( res [ 'heartbeat_timestamp' ] ) <newline> res [ 'configurations' ] = self . get_configuration_dict ( agent ) <newline> return self . _fields ( res , fields ) <newline> <dedent> def delete_agent ( self , context , id ) : <newline> <indent> with context . session . begin ( subtransactions = True ) : <newline> <indent> agent = self . _get_agent ( context , id ) <newline> context . session . delete ( agent ) <newline> <dedent> <dedent> def update_agent ( self , context , id , agent ) : <newline> <indent> agent_data = agent [ 'agent' ] <newline> with context . session . begin ( subtransactions = True ) : <newline> <indent> agent = self . _get_agent ( context , id ) <newline> agent . update ( agent_data ) <newline> <dedent> return self . _make_agent_dict ( agent ) <newline> <dedent> def get_agents_db ( self , context , filters = None ) : <newline> <indent> query = self . _get_collection_query ( context , Agent , filters = filters ) <newline> return query . all ( ) <newline> <dedent> def get_agents ( self , context , filters = None , fields = None ) : <newline> <indent> return self . _get_collection ( context , Agent , self . _make_agent_dict , filters = filters , fields = fields ) <newline> <dedent> def _get_agent_by_type_and_host ( self , context , agent_type , host ) : <newline> <indent> query = self . _model_query ( context , Agent ) <newline> try : <newline> <indent> agent_db = query . filter ( Agent . agent_type == agent_type , Agent . host == host ) . one ( ) <newline> return agent_db <newline> <dedent> except exc . NoResultFound : <newline> <indent> raise ext_agent . AgentNotFoundByTypeHost ( agent_type = agent_type , host = host ) <newline> <dedent> except exc . MultipleResultsFound : <newline> <indent> raise ext_agent . MultipleAgentFoundByTypeHost ( agent_type = agent_type , host = host ) <newline> <dedent> <dedent> def get_agent ( self , context , id , fields = None ) : <newline> <indent> agent = self . _get_agent ( context , id ) <newline> return self . _make_agent_dict ( agent , fields ) <newline> <dedent> def _create_or_update_agent ( self , context , agent ) : <newline> <indent> with context . session . begin ( subtransactions = True ) : <newline> <indent> res_keys = [ 'agent_type' , 'binary' , 'host' , 'topic' ] <newline> res = dict ( ( k , agent [ k ] ) for k in res_keys ) <newline> configurations_dict = agent . get ( 'configurations' , { } ) <newline> res [ 'configurations' ] = jsonutils . dumps ( configurations_dict ) <newline> current_time = timeutils . utcnow ( ) <newline> try : <newline> <indent> agent_db = self . _get_agent_by_type_and_host ( context , agent [ 'agent_type' ] , agent [ 'host' ] ) <newline> res [ 'heartbeat_timestamp' ] = current_time <newline> if agent . get ( 'start_flag' ) : <newline> <indent> res [ 'started_at' ] = current_time <newline> <dedent> greenthread . sleep ( 0 ) <newline> agent_db . update ( res ) <newline> <dedent> except ext_agent . AgentNotFoundByTypeHost : <newline> <indent> greenthread . sleep ( 0 ) <newline> res [ 'created_at' ] = current_time <newline> res [ 'started_at' ] = current_time <newline> res [ 'heartbeat_timestamp' ] = current_time <newline> res [ 'admin_state_up' ] = True <newline> agent_db = Agent ( ** res ) <newline> greenthread . sleep ( 0 ) <newline> context . session . add ( agent_db ) <newline> <dedent> greenthread . sleep ( 0 ) <newline> <dedent> <dedent> def create_or_update_agent ( self , context , agent ) : <newline> <indent>  """ Create ▁ or ▁ update ▁ agent ▁ according ▁ to ▁ report. """  <newline> try : <newline> <indent> return self . _create_or_update_agent ( context , agent ) <newline> <dedent> except db_exc . DBDuplicateEntry as e : <newline> <indent> with excutils . save_and_reraise_exception ( ) as ctxt : <newline> <indent> if e . columns == [ 'agent_type' , 'host' ] : <newline>  # ▁ It ▁ might ▁ happen ▁ that ▁ two ▁ or ▁ more ▁ concurrent ▁ transactions <encdom>  # ▁ are ▁ trying ▁ to ▁ insert ▁ new ▁ rows ▁ having ▁ the ▁ same ▁ value ▁ of <encdom>  # ▁ (agent_type, ▁ host) ▁ pair ▁ at ▁ the ▁ same ▁ time ▁ (if ▁ there ▁ has <encdom>  # ▁ been ▁ no ▁ such ▁ entry ▁ in ▁ the ▁ table ▁ and ▁ multiple ▁ agent ▁ status <encdom>  # ▁ updates ▁ are ▁ being ▁ processed ▁ at ▁ the ▁ moment). ▁ In ▁ this ▁ case <encdom>  # ▁ having ▁ a ▁ unique ▁ constraint ▁ on ▁ (agent_type, ▁ host) ▁ columns <encdom>  # ▁ guarantees ▁ that ▁ only ▁ one ▁ transaction ▁ will ▁ succeed ▁ and <encdom>  # ▁ insert ▁ a ▁ new ▁ agent ▁ entry, ▁ others ▁ will ▁ fail ▁ and ▁ be ▁ rolled <encdom>  # ▁ back. ▁ That ▁ means ▁ we ▁ must ▁ retry ▁ them ▁ one ▁ more ▁ time: ▁ no <encdom>  # ▁ INSERTs ▁ will ▁ be ▁ issued, ▁ because <encdom>  # ▁ _get_agent_by_type_and_host() ▁ will ▁ return ▁ the ▁ existing <encdom>  # ▁ agent ▁ entry, ▁ which ▁ will ▁ be ▁ updated ▁ multiple ▁ times <encdom> <indent> ctxt . reraise = False <newline> return self . _create_or_update_agent ( context , agent ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> class AgentExtRpcCallback ( object ) : <newline> <indent>  """ Processes ▁ the ▁ rpc ▁ report ▁ in ▁ plugin ▁ implementations. """  <newline> target = messaging . Target ( version = '1.0' ) <newline> START_TIME = timeutils . utcnow ( ) <newline> def __init__ ( self , plugin = None ) : <newline> <indent> super ( AgentExtRpcCallback , self ) . __init__ ( ) <newline> self . plugin = plugin <newline> <dedent> def report_state ( self , context , ** kwargs ) : <newline> <indent>  """ Report ▁ state ▁ from ▁ agent ▁ to ▁ server. """  <newline> time = kwargs [ 'time' ] <newline> time = timeutils . parse_strtime ( time ) <newline> if self . START_TIME > time : <newline> <indent> LOG . debug ( "Message ▁ with ▁ invalid ▁ timestamp ▁ received" ) <newline> return <newline> <dedent> agent_state = kwargs [ 'agent_state' ] [ 'agent_state' ] <newline> if not self . plugin : <newline> <indent> self . plugin = manager . NeutronManager . get_plugin ( ) <newline> <dedent> self . plugin . create_or_update_agent ( context , agent_state ) <newline> <dedent> <dedent>
from __future__ import absolute_import , division , unicode_literals <newline> from six import text_type <newline> import gettext <newline> _ = gettext . gettext <newline> try : <newline> <indent> from functools import reduce <newline> <dedent> except ImportError : <newline> <indent> pass <newline> <dedent> from . . constants import voidElements , booleanAttributes , spaceCharacters <newline> from . . constants import rcdataElements , entities , xmlEntities <newline> from . . import utils <newline> from xml . sax . saxutils import escape <newline> spaceCharacters = "" . join ( spaceCharacters ) <newline> try : <newline> <indent> from codecs import register_error , xmlcharrefreplace_errors <newline> <dedent> except ImportError : <newline> <indent> unicode_encode_errors = "strict" <newline> <dedent> else : <newline> <indent> unicode_encode_errors = "htmlentityreplace" <newline> encode_entity_map = { } <newline> is_ucs4 = len ( "\U0010FFFF" ) == 1 <newline> for k , v in list ( entities . items ( ) ) : <newline>  # ▁ skip ▁ multi-character ▁ entities <encdom> <indent> if ( ( is_ucs4 and len ( v ) > 1 ) or ( not is_ucs4 and len ( v ) > 2 ) ) : <newline> <indent> continue <newline> <dedent> if v != "&" : <newline> <indent> if len ( v ) == 2 : <newline> <indent> v = utils . surrogatePairToCodepoint ( v ) <newline> <dedent> else : <newline> <indent> v = ord ( v ) <newline> <dedent> if not v in encode_entity_map or k . islower ( ) : <newline>  # ▁ prefer ▁ &lt; ▁ over ▁ &LT; ▁ and ▁ similarly ▁ for ▁ &amp;, ▁ &gt;, ▁ etc. <encdom> <indent> encode_entity_map [ v ] = k <newline> <dedent> <dedent> <dedent> def htmlentityreplace_errors ( exc ) : <newline> <indent> if isinstance ( exc , ( UnicodeEncodeError , UnicodeTranslateError ) ) : <newline> <indent> res = [ ] <newline> codepoints = [ ] <newline> skip = False <newline> for i , c in enumerate ( exc . object [ exc . start : exc . end ] ) : <newline> <indent> if skip : <newline> <indent> skip = False <newline> continue <newline> <dedent> index = i + exc . start <newline> if utils . isSurrogatePair ( exc . object [ index : min ( [ exc . end , index + 2 ] ) ] ) : <newline> <indent> codepoint = utils . surrogatePairToCodepoint ( exc . object [ index : index + 2 ] ) <newline> skip = True <newline> <dedent> else : <newline> <indent> codepoint = ord ( c ) <newline> <dedent> codepoints . append ( codepoint ) <newline> <dedent> for cp in codepoints : <newline> <indent> e = encode_entity_map . get ( cp ) <newline> if e : <newline> <indent> res . append ( "&" ) <newline> res . append ( e ) <newline> if not e . endswith ( ";" ) : <newline> <indent> res . append ( ";" ) <newline> <dedent> <dedent> else : <newline> <indent> res . append ( "& # x%s;" % ( hex ( cp ) [ 2 : ] ) ) <newline> <dedent> <dedent> return ( "" . join ( res ) , exc . end ) <newline> <dedent> else : <newline> <indent> return xmlcharrefreplace_errors ( exc ) <newline> <dedent> <dedent> register_error ( unicode_encode_errors , htmlentityreplace_errors ) <newline> del register_error <newline> <dedent> class HTMLSerializer ( object ) : <newline>  # ▁ attribute ▁ quoting ▁ options <encdom> <indent> quote_attr_values = False <newline> quote_char = '"' <newline> use_best_quote_char = True <newline>  # ▁ tag ▁ syntax ▁ options <encdom> omit_optional_tags = True <newline> minimize_boolean_attributes = True <newline> use_trailing_solidus = False <newline> space_before_trailing_solidus = True <newline>  # ▁ escaping ▁ options <encdom> escape_lt_in_attrs = False <newline> escape_rcdata = False <newline> resolve_entities = True <newline>  # ▁ miscellaneous ▁ options <encdom> alphabetical_attributes = False <newline> inject_meta_charset = True <newline> strip_whitespace = False <newline> sanitize = False <newline> options = ( "quote_attr_values" , "quote_char" , "use_best_quote_char" , "omit_optional_tags" , "minimize_boolean_attributes" , "use_trailing_solidus" , "space_before_trailing_solidus" , "escape_lt_in_attrs" , "escape_rcdata" , "resolve_entities" , "alphabetical_attributes" , "inject_meta_charset" , "strip_whitespace" , "sanitize" ) <newline> def __init__ ( self , ** kwargs ) : <newline> <indent>  """ Initialize ▁ HTMLSerializer. <strnewline> <strnewline> ▁ Keyword ▁ options ▁ (default ▁ given ▁ first ▁ unless ▁ specified) ▁ include: <strnewline> <strnewline> ▁ inject_meta_charset=True|False <strnewline> ▁ Whether ▁ it ▁ insert ▁ a ▁ meta ▁ element ▁ to ▁ define ▁ the ▁ character ▁ set ▁ of ▁ the <strnewline> ▁ document. <strnewline> ▁ quote_attr_values=True|False <strnewline> ▁ Whether ▁ to ▁ quote ▁ attribute ▁ values ▁ that ▁ don't ▁ require ▁ quoting <strnewline> ▁ per ▁ HTML5 ▁ parsing ▁ rules. <strnewline> ▁ quote_char=u'"'|u"'" <strnewline> ▁ Use ▁ given ▁ quote ▁ character ▁ for ▁ attribute ▁ quoting. ▁ Default ▁ is ▁ to <strnewline> ▁ use ▁ double ▁ quote ▁ unless ▁ attribute ▁ value ▁ contains ▁ a ▁ double ▁ quote, <strnewline> ▁ in ▁ which ▁ case ▁ single ▁ quotes ▁ are ▁ used ▁ instead. <strnewline> ▁ escape_lt_in_attrs=False|True <strnewline> ▁ Whether ▁ to ▁ escape ▁ < ▁ in ▁ attribute ▁ values. <strnewline> ▁ escape_rcdata=False|True <strnewline> ▁ Whether ▁ to ▁ escape ▁ characters ▁ that ▁ need ▁ to ▁ be ▁ escaped ▁ within ▁ normal <strnewline> ▁ elements ▁ within ▁ rcdata ▁ elements ▁ such ▁ as ▁ style. <strnewline> ▁ resolve_entities=True|False <strnewline> ▁ Whether ▁ to ▁ resolve ▁ named ▁ character ▁ entities ▁ that ▁ appear ▁ in ▁ the <strnewline> ▁ source ▁ tree. ▁ The ▁ XML ▁ predefined ▁ entities ▁ &lt; ▁ &gt; ▁ &amp; ▁ &quot; ▁ &apos; <strnewline> ▁ are ▁ unaffected ▁ by ▁ this ▁ setting. <strnewline> ▁ strip_whitespace=False|True <strnewline> ▁ Whether ▁ to ▁ remove ▁ semantically ▁ meaningless ▁ whitespace. ▁ (This <strnewline> ▁ compresses ▁ all ▁ whitespace ▁ to ▁ a ▁ single ▁ space ▁ except ▁ within ▁ pre.) <strnewline> ▁ minimize_boolean_attributes=True|False <strnewline> ▁ Shortens ▁ boolean ▁ attributes ▁ to ▁ give ▁ just ▁ the ▁ attribute ▁ value, <strnewline> ▁ for ▁ example ▁ <input ▁ disabled="disabled"> ▁ becomes ▁ <input ▁ disabled>. <strnewline> ▁ use_trailing_solidus=False|True <strnewline> ▁ Includes ▁ a ▁ close-tag ▁ slash ▁ at ▁ the ▁ end ▁ of ▁ the ▁ start ▁ tag ▁ of ▁ void <strnewline> ▁ elements ▁ (empty ▁ elements ▁ whose ▁ end ▁ tag ▁ is ▁ forbidden). ▁ E.g. ▁ <hr/>. <strnewline> ▁ space_before_trailing_solidus=True|False <strnewline> ▁ Places ▁ a ▁ space ▁ immediately ▁ before ▁ the ▁ closing ▁ slash ▁ in ▁ a ▁ tag <strnewline> ▁ using ▁ a ▁ trailing ▁ solidus. ▁ E.g. ▁ <hr ▁ />. ▁ Requires ▁ use_trailing_solidus. <strnewline> ▁ sanitize=False|True <strnewline> ▁ Strip ▁ all ▁ unsafe ▁ or ▁ unknown ▁ constructs ▁ from ▁ output. <strnewline> ▁ See ▁ `html5lib ▁ user ▁ documentation`_ <strnewline> ▁ omit_optional_tags=True|False <strnewline> ▁ Omit ▁ start/end ▁ tags ▁ that ▁ are ▁ optional. <strnewline> ▁ alphabetical_attributes=False|True <strnewline> ▁ Reorder ▁ attributes ▁ to ▁ be ▁ in ▁ alphabetical ▁ order. <strnewline> <strnewline> ▁ .. ▁ _html5lib ▁ user ▁ documentation: ▁ http://code.google.com/p/html5lib/wiki/UserDocumentation <strnewline> ▁ """  <newline> if 'quote_char' in kwargs : <newline> <indent> self . use_best_quote_char = False <newline> <dedent> for attr in self . options : <newline> <indent> setattr ( self , attr , kwargs . get ( attr , getattr ( self , attr ) ) ) <newline> <dedent> self . errors = [ ] <newline> self . strict = False <newline> <dedent> def encode ( self , string ) : <newline> <indent> assert ( isinstance ( string , text_type ) ) <newline> if self . encoding : <newline> <indent> return string . encode ( self . encoding , unicode_encode_errors ) <newline> <dedent> else : <newline> <indent> return string <newline> <dedent> <dedent> def encodeStrict ( self , string ) : <newline> <indent> assert ( isinstance ( string , text_type ) ) <newline> if self . encoding : <newline> <indent> return string . encode ( self . encoding , "strict" ) <newline> <dedent> else : <newline> <indent> return string <newline> <dedent> <dedent> def serialize ( self , treewalker , encoding = None ) : <newline> <indent> self . encoding = encoding <newline> in_cdata = False <newline> self . errors = [ ] <newline> if encoding and self . inject_meta_charset : <newline> <indent> from . . filters . inject_meta_charset import Filter <newline> treewalker = Filter ( treewalker , encoding ) <newline>  # ▁ WhitespaceFilter ▁ should ▁ be ▁ used ▁ before ▁ OptionalTagFilter <encdom>  # ▁ for ▁ maximum ▁ efficiently ▁ of ▁ this ▁ latter ▁ filter <encdom> <dedent> if self . strip_whitespace : <newline> <indent> from . . filters . whitespace import Filter <newline> treewalker = Filter ( treewalker ) <newline> <dedent> if self . sanitize : <newline> <indent> from . . filters . sanitizer import Filter <newline> treewalker = Filter ( treewalker ) <newline> <dedent> if self . omit_optional_tags : <newline> <indent> from . . filters . optionaltags import Filter <newline> treewalker = Filter ( treewalker ) <newline>  # ▁ Alphabetical ▁ attributes ▁ must ▁ be ▁ last, ▁ as ▁ other ▁ filters <encdom>  # ▁ could ▁ add ▁ attributes ▁ and ▁ alter ▁ the ▁ order <encdom> <dedent> if self . alphabetical_attributes : <newline> <indent> from . . filters . alphabeticalattributes import Filter <newline> treewalker = Filter ( treewalker ) <newline> <dedent> for token in treewalker : <newline> <indent> type = token [ "type" ] <newline> if type == "Doctype" : <newline> <indent> doctype = "<!DOCTYPE ▁ %s" % token [ "name" ] <newline> if token [ "publicId" ] : <newline> <indent> doctype += ' ▁ PUBLIC ▁"%s"' % token [ "publicId" ] <newline> <dedent> elif token [ "systemId" ] : <newline> <indent> doctype += " ▁ SYSTEM" <newline> <dedent> if token [ "systemId" ] : <newline> <indent> if token [ "systemId" ] . find ( '"' ) >= 0 : <newline> <indent> if token [ "systemId" ] . find ( "'" ) >= 0 : <newline> <indent> self . serializeError ( _ ( "System ▁ identifer ▁ contains ▁ both ▁ single ▁ and ▁ double ▁ quote ▁ characters" ) ) <newline> <dedent> quote_char = "'" <newline> <dedent> else : <newline> <indent> quote_char = '"' <newline> <dedent> doctype += " ▁ %s%s%s" % ( quote_char , token [ "systemId" ] , quote_char ) <newline> <dedent> doctype += ">" <newline> yield self . encodeStrict ( doctype ) <newline> <dedent> elif type in ( "Characters" , "SpaceCharacters" ) : <newline> <indent> if type == "SpaceCharacters" or in_cdata : <newline> <indent> if in_cdata and token [ "data" ] . find ( "</" ) >= 0 : <newline> <indent> self . serializeError ( _ ( "Unexpected ▁ </ ▁ in ▁ CDATA" ) ) <newline> <dedent> yield self . encode ( token [ "data" ] ) <newline> <dedent> else : <newline> <indent> yield self . encode ( escape ( token [ "data" ] ) ) <newline> <dedent> <dedent> elif type in ( "StartTag" , "EmptyTag" ) : <newline> <indent> name = token [ "name" ] <newline> yield self . encodeStrict ( "<%s" % name ) <newline> if name in rcdataElements and not self . escape_rcdata : <newline> <indent> in_cdata = True <newline> <dedent> elif in_cdata : <newline> <indent> self . serializeError ( _ ( "Unexpected ▁ child ▁ element ▁ of ▁ a ▁ CDATA ▁ element" ) ) <newline> <dedent> for ( attr_namespace , attr_name ) , attr_value in token [ "data" ] . items ( ) : <newline>  # ▁ TODO: ▁ Add ▁ namespace ▁ support ▁ here <encdom> <indent> k = attr_name <newline> v = attr_value <newline> yield self . encodeStrict ( ' ▁ ' ) <newline> yield self . encodeStrict ( k ) <newline> if not self . minimize_boolean_attributes or ( k not in booleanAttributes . get ( name , tuple ( ) ) and k not in booleanAttributes . get ( "" , tuple ( ) ) ) : <newline> <indent> yield self . encodeStrict ( "=" ) <newline> if self . quote_attr_values or not v : <newline> <indent> quote_attr = True <newline> <dedent> else : <newline> <indent> quote_attr = reduce ( lambda x , y : x or ( y in v ) , spaceCharacters + ">\"'=" , False ) <newline> <dedent> v = v . replace ( "&" , "&amp;" ) <newline> if self . escape_lt_in_attrs : <newline> <indent> v = v . replace ( "<" , "&lt;" ) <newline> <dedent> if quote_attr : <newline> <indent> quote_char = self . quote_char <newline> if self . use_best_quote_char : <newline> <indent> if "'" in v and '"' not in v : <newline> <indent> quote_char = '"' <newline> <dedent> elif '"' in v and "'" not in v : <newline> <indent> quote_char = "'" <newline> <dedent> <dedent> if quote_char == "'" : <newline> <indent> v = v . replace ( "'" , "& # 39;" ) <newline> <dedent> else : <newline> <indent> v = v . replace ( '"' , "&quot;" ) <newline> <dedent> yield self . encodeStrict ( quote_char ) <newline> yield self . encode ( v ) <newline> yield self . encodeStrict ( quote_char ) <newline> <dedent> else : <newline> <indent> yield self . encode ( v ) <newline> <dedent> <dedent> <dedent> if name in voidElements and self . use_trailing_solidus : <newline> <indent> if self . space_before_trailing_solidus : <newline> <indent> yield self . encodeStrict ( " ▁ /" ) <newline> <dedent> else : <newline> <indent> yield self . encodeStrict ( "/" ) <newline> <dedent> <dedent> yield self . encode ( ">" ) <newline> <dedent> elif type == "EndTag" : <newline> <indent> name = token [ "name" ] <newline> if name in rcdataElements : <newline> <indent> in_cdata = False <newline> <dedent> elif in_cdata : <newline> <indent> self . serializeError ( _ ( "Unexpected ▁ child ▁ element ▁ of ▁ a ▁ CDATA ▁ element" ) ) <newline> <dedent> yield self . encodeStrict ( "</%s>" % name ) <newline> <dedent> elif type == "Comment" : <newline> <indent> data = token [ "data" ] <newline> if data . find ( "--" ) >= 0 : <newline> <indent> self . serializeError ( _ ( "Comment ▁ contains ▁ --" ) ) <newline> <dedent> yield self . encodeStrict ( "<!--%s-->" % token [ "data" ] ) <newline> <dedent> elif type == "Entity" : <newline> <indent> name = token [ "name" ] <newline> key = name + ";" <newline> if not key in entities : <newline> <indent> self . serializeError ( _ ( "Entity ▁ %s ▁ not ▁ recognized" % name ) ) <newline> <dedent> if self . resolve_entities and key not in xmlEntities : <newline> <indent> data = entities [ key ] <newline> <dedent> else : <newline> <indent> data = "&%s;" % name <newline> <dedent> yield self . encodeStrict ( data ) <newline> <dedent> else : <newline> <indent> self . serializeError ( token [ "data" ] ) <newline> <dedent> <dedent> <dedent> def render ( self , treewalker , encoding = None ) : <newline> <indent> if encoding : <newline> <indent> return b"" . join ( list ( self . serialize ( treewalker , encoding ) ) ) <newline> <dedent> else : <newline> <indent> return "" . join ( list ( self . serialize ( treewalker ) ) ) <newline> <dedent> <dedent> def serializeError ( self , data = "XXX ▁ ERROR ▁ MESSAGE ▁ NEEDED" ) : <newline>  # ▁ XXX ▁ The ▁ idea ▁ is ▁ to ▁ make ▁ data ▁ mandatory. <encdom> <indent> self . errors . append ( data ) <newline> if self . strict : <newline> <indent> raise SerializeError <newline> <dedent> <dedent> <dedent> def SerializeError ( Exception ) : <newline> <indent>  """ Error ▁ in ▁ serialized ▁ tree """  <newline> pass <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ Form ▁ implementation ▁ generated ▁ from ▁ reading ▁ ui ▁ file ▁'settings.ui' <encdom>  # ▁ Created: ▁ Thu ▁ Dec ▁ 25 ▁ 23:21:20 ▁ 2014 <encdom>  # ▁ by: ▁ PyQt4 ▁ UI ▁ code ▁ generator ▁ 4.10.3 <encdom>  # ▁ WARNING! ▁ All ▁ changes ▁ made ▁ in ▁ this ▁ file ▁ will ▁ be ▁ lost! <encdom> from PyQt4 import QtCore , QtGui <newline> try : <newline> <indent> _fromUtf8 = QtCore . QString . fromUtf8 <newline> <dedent> except AttributeError : <newline> <indent> def _fromUtf8 ( s ) : <newline> <indent> return s <newline> <dedent> <dedent> try : <newline> <indent> _encoding = QtGui . QApplication . UnicodeUTF8 <newline> def _translate ( context , text , disambig ) : <newline> <indent> return QtGui . QApplication . translate ( context , text , disambig , _encoding ) <newline> <dedent> <dedent> except AttributeError : <newline> <indent> def _translate ( context , text , disambig ) : <newline> <indent> return QtGui . QApplication . translate ( context , text , disambig ) <newline> <dedent> <dedent> class Ui_settingsDialog ( object ) : <newline> <indent> def setupUi ( self , settingsDialog ) : <newline> <indent> settingsDialog . setObjectName ( _fromUtf8 ( "settingsDialog" ) ) <newline> settingsDialog . resize ( 521 , 413 ) <newline> self . gridLayout = QtGui . QGridLayout ( settingsDialog ) <newline> self . gridLayout . setObjectName ( _fromUtf8 ( "gridLayout" ) ) <newline> self . buttonBox = QtGui . QDialogButtonBox ( settingsDialog ) <newline> self . buttonBox . setOrientation ( QtCore . Qt . Horizontal ) <newline> self . buttonBox . setStandardButtons ( QtGui . QDialogButtonBox . Cancel | QtGui . QDialogButtonBox . Ok ) <newline> self . buttonBox . setObjectName ( _fromUtf8 ( "buttonBox" ) ) <newline> self . gridLayout . addWidget ( self . buttonBox , 1 , 0 , 1 , 1 ) <newline> self . tabWidgetSettings = QtGui . QTabWidget ( settingsDialog ) <newline> self . tabWidgetSettings . setObjectName ( _fromUtf8 ( "tabWidgetSettings" ) ) <newline> self . tabUserInterface = QtGui . QWidget ( ) <newline> self . tabUserInterface . setEnabled ( True ) <newline> self . tabUserInterface . setObjectName ( _fromUtf8 ( "tabUserInterface" ) ) <newline> self . formLayout = QtGui . QFormLayout ( self . tabUserInterface ) <newline> self . formLayout . setObjectName ( _fromUtf8 ( "formLayout" ) ) <newline> self . checkBoxStartOnLogon = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxStartOnLogon . setObjectName ( _fromUtf8 ( "checkBoxStartOnLogon" ) ) <newline> self . formLayout . setWidget ( 0 , QtGui . QFormLayout . LabelRole , self . checkBoxStartOnLogon ) <newline> self . checkBoxStartInTray = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxStartInTray . setObjectName ( _fromUtf8 ( "checkBoxStartInTray" ) ) <newline> self . formLayout . setWidget ( 1 , QtGui . QFormLayout . SpanningRole , self . checkBoxStartInTray ) <newline> self . checkBoxMinimizeToTray = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxMinimizeToTray . setChecked ( True ) <newline> self . checkBoxMinimizeToTray . setObjectName ( _fromUtf8 ( "checkBoxMinimizeToTray" ) ) <newline> self . formLayout . setWidget ( 2 , QtGui . QFormLayout . LabelRole , self . checkBoxMinimizeToTray ) <newline> self . checkBoxShowTrayNotifications = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxShowTrayNotifications . setObjectName ( _fromUtf8 ( "checkBoxShowTrayNotifications" ) ) <newline> self . formLayout . setWidget ( 3 , QtGui . QFormLayout . LabelRole , self . checkBoxShowTrayNotifications ) <newline> self . checkBoxPortableMode = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxPortableMode . setObjectName ( _fromUtf8 ( "checkBoxPortableMode" ) ) <newline> self . formLayout . setWidget ( 4 , QtGui . QFormLayout . LabelRole , self . checkBoxPortableMode ) <newline> self . PortableModeDescription = QtGui . QLabel ( self . tabUserInterface ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . PortableModeDescription . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . PortableModeDescription . setSizePolicy ( sizePolicy ) <newline> self . PortableModeDescription . setWordWrap ( True ) <newline> self . PortableModeDescription . setObjectName ( _fromUtf8 ( "PortableModeDescription" ) ) <newline> self . formLayout . setWidget ( 5 , QtGui . QFormLayout . SpanningRole , self . PortableModeDescription ) <newline> self . checkBoxWillinglySendToMobile = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxWillinglySendToMobile . setObjectName ( _fromUtf8 ( "checkBoxWillinglySendToMobile" ) ) <newline> self . formLayout . setWidget ( 6 , QtGui . QFormLayout . SpanningRole , self . checkBoxWillinglySendToMobile ) <newline> self . checkBoxUseIdenticons = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxUseIdenticons . setObjectName ( _fromUtf8 ( "checkBoxUseIdenticons" ) ) <newline> self . formLayout . setWidget ( 7 , QtGui . QFormLayout . LabelRole , self . checkBoxUseIdenticons ) <newline> self . checkBoxReplyBelow = QtGui . QCheckBox ( self . tabUserInterface ) <newline> self . checkBoxReplyBelow . setObjectName ( _fromUtf8 ( "checkBoxReplyBelow" ) ) <newline> self . formLayout . setWidget ( 8 , QtGui . QFormLayout . LabelRole , self . checkBoxReplyBelow ) <newline> self . groupBox = QtGui . QGroupBox ( self . tabUserInterface ) <newline> self . groupBox . setObjectName ( _fromUtf8 ( "groupBox" ) ) <newline> self . formLayout_2 = QtGui . QFormLayout ( self . groupBox ) <newline> self . formLayout_2 . setObjectName ( _fromUtf8 ( "formLayout_2" ) ) <newline> self . languageComboBox = QtGui . QComboBox ( self . groupBox ) <newline> self . languageComboBox . setMinimumSize ( QtCore . QSize ( 100 , 0 ) ) <newline> self . languageComboBox . setObjectName ( _fromUtf8 ( "languageComboBox" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 1 , _fromUtf8 ( "English" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 2 , _fromUtf8 ( "Esperanto" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 3 , _fromUtf8 ( "Français" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 4 , _fromUtf8 ( "Deutsch" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 5 , _fromUtf8 ( "Español" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 6 , _fromUtf8 ( "русский" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 7 , _fromUtf8 ( "Norsk" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 8 , _fromUtf8 ( "العربية" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 9 , _fromUtf8 ( "简体中文" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 10 , _fromUtf8 ( "日本語" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 11 , _fromUtf8 ( "Nederlands" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . setItemText ( 12 , _fromUtf8 ( "Česky" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . languageComboBox . addItem ( _fromUtf8 ( "" ) ) <newline> self . formLayout_2 . setWidget ( 0 , QtGui . QFormLayout . LabelRole , self . languageComboBox ) <newline> self . formLayout . setWidget ( 9 , QtGui . QFormLayout . FieldRole , self . groupBox ) <newline> self . tabWidgetSettings . addTab ( self . tabUserInterface , _fromUtf8 ( "" ) ) <newline> self . tabNetworkSettings = QtGui . QWidget ( ) <newline> self . tabNetworkSettings . setObjectName ( _fromUtf8 ( "tabNetworkSettings" ) ) <newline> self . gridLayout_4 = QtGui . QGridLayout ( self . tabNetworkSettings ) <newline> self . gridLayout_4 . setObjectName ( _fromUtf8 ( "gridLayout_4" ) ) <newline> self . groupBox1 = QtGui . QGroupBox ( self . tabNetworkSettings ) <newline> self . groupBox1 . setObjectName ( _fromUtf8 ( "groupBox1" ) ) <newline> self . gridLayout_3 = QtGui . QGridLayout ( self . groupBox1 ) <newline> self . gridLayout_3 . setObjectName ( _fromUtf8 ( "gridLayout_3" ) ) <newline> spacerItem = QtGui . QSpacerItem ( 125 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_3 . addItem ( spacerItem , 0 , 0 , 1 , 1 ) <newline> self . label = QtGui . QLabel ( self . groupBox1 ) <newline> self . label . setObjectName ( _fromUtf8 ( "label" ) ) <newline> self . gridLayout_3 . addWidget ( self . label , 0 , 1 , 1 , 1 ) <newline> self . lineEditTCPPort = QtGui . QLineEdit ( self . groupBox1 ) <newline> self . lineEditTCPPort . setMaximumSize ( QtCore . QSize ( 70 , 16777215 ) ) <newline> self . lineEditTCPPort . setObjectName ( _fromUtf8 ( "lineEditTCPPort" ) ) <newline> self . gridLayout_3 . addWidget ( self . lineEditTCPPort , 0 , 2 , 1 , 1 ) <newline> self . gridLayout_4 . addWidget ( self . groupBox1 , 0 , 0 , 1 , 1 ) <newline> self . groupBox_3 = QtGui . QGroupBox ( self . tabNetworkSettings ) <newline> self . groupBox_3 . setObjectName ( _fromUtf8 ( "groupBox_3" ) ) <newline> self . gridLayout_9 = QtGui . QGridLayout ( self . groupBox_3 ) <newline> self . gridLayout_9 . setObjectName ( _fromUtf8 ( "gridLayout_9" ) ) <newline> spacerItem1 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_9 . addItem ( spacerItem1 , 0 , 0 , 2 , 1 ) <newline> self . label_24 = QtGui . QLabel ( self . groupBox_3 ) <newline> self . label_24 . setObjectName ( _fromUtf8 ( "label_24" ) ) <newline> self . gridLayout_9 . addWidget ( self . label_24 , 0 , 1 , 1 , 1 ) <newline> self . lineEditMaxDownloadRate = QtGui . QLineEdit ( self . groupBox_3 ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . lineEditMaxDownloadRate . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . lineEditMaxDownloadRate . setSizePolicy ( sizePolicy ) <newline> self . lineEditMaxDownloadRate . setMaximumSize ( QtCore . QSize ( 60 , 16777215 ) ) <newline> self . lineEditMaxDownloadRate . setObjectName ( _fromUtf8 ( "lineEditMaxDownloadRate" ) ) <newline> self . gridLayout_9 . addWidget ( self . lineEditMaxDownloadRate , 0 , 2 , 1 , 1 ) <newline> self . label_25 = QtGui . QLabel ( self . groupBox_3 ) <newline> self . label_25 . setObjectName ( _fromUtf8 ( "label_25" ) ) <newline> self . gridLayout_9 . addWidget ( self . label_25 , 1 , 1 , 1 , 1 ) <newline> self . lineEditMaxUploadRate = QtGui . QLineEdit ( self . groupBox_3 ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . lineEditMaxUploadRate . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . lineEditMaxUploadRate . setSizePolicy ( sizePolicy ) <newline> self . lineEditMaxUploadRate . setMaximumSize ( QtCore . QSize ( 60 , 16777215 ) ) <newline> self . lineEditMaxUploadRate . setObjectName ( _fromUtf8 ( "lineEditMaxUploadRate" ) ) <newline> self . gridLayout_9 . addWidget ( self . lineEditMaxUploadRate , 1 , 2 , 1 , 1 ) <newline> self . gridLayout_4 . addWidget ( self . groupBox_3 , 2 , 0 , 1 , 1 ) <newline> self . groupBox_2 = QtGui . QGroupBox ( self . tabNetworkSettings ) <newline> self . groupBox_2 . setObjectName ( _fromUtf8 ( "groupBox_2" ) ) <newline> self . gridLayout_2 = QtGui . QGridLayout ( self . groupBox_2 ) <newline> self . gridLayout_2 . setObjectName ( _fromUtf8 ( "gridLayout_2" ) ) <newline> self . label_2 = QtGui . QLabel ( self . groupBox_2 ) <newline> self . label_2 . setObjectName ( _fromUtf8 ( "label_2" ) ) <newline> self . gridLayout_2 . addWidget ( self . label_2 , 0 , 0 , 1 , 1 ) <newline> self . label_3 = QtGui . QLabel ( self . groupBox_2 ) <newline> self . label_3 . setObjectName ( _fromUtf8 ( "label_3" ) ) <newline> self . gridLayout_2 . addWidget ( self . label_3 , 1 , 1 , 1 , 1 ) <newline> self . lineEditSocksHostname = QtGui . QLineEdit ( self . groupBox_2 ) <newline> self . lineEditSocksHostname . setObjectName ( _fromUtf8 ( "lineEditSocksHostname" ) ) <newline> self . gridLayout_2 . addWidget ( self . lineEditSocksHostname , 1 , 2 , 1 , 2 ) <newline> self . label_4 = QtGui . QLabel ( self . groupBox_2 ) <newline> self . label_4 . setObjectName ( _fromUtf8 ( "label_4" ) ) <newline> self . gridLayout_2 . addWidget ( self . label_4 , 1 , 4 , 1 , 1 ) <newline> self . lineEditSocksPort = QtGui . QLineEdit ( self . groupBox_2 ) <newline> self . lineEditSocksPort . setObjectName ( _fromUtf8 ( "lineEditSocksPort" ) ) <newline> self . gridLayout_2 . addWidget ( self . lineEditSocksPort , 1 , 5 , 1 , 1 ) <newline> self . checkBoxAuthentication = QtGui . QCheckBox ( self . groupBox_2 ) <newline> self . checkBoxAuthentication . setObjectName ( _fromUtf8 ( "checkBoxAuthentication" ) ) <newline> self . gridLayout_2 . addWidget ( self . checkBoxAuthentication , 2 , 1 , 1 , 1 ) <newline> self . label_5 = QtGui . QLabel ( self . groupBox_2 ) <newline> self . label_5 . setObjectName ( _fromUtf8 ( "label_5" ) ) <newline> self . gridLayout_2 . addWidget ( self . label_5 , 2 , 2 , 1 , 1 ) <newline> self . lineEditSocksUsername = QtGui . QLineEdit ( self . groupBox_2 ) <newline> self . lineEditSocksUsername . setEnabled ( False ) <newline> self . lineEditSocksUsername . setObjectName ( _fromUtf8 ( "lineEditSocksUsername" ) ) <newline> self . gridLayout_2 . addWidget ( self . lineEditSocksUsername , 2 , 3 , 1 , 1 ) <newline> self . label_6 = QtGui . QLabel ( self . groupBox_2 ) <newline> self . label_6 . setObjectName ( _fromUtf8 ( "label_6" ) ) <newline> self . gridLayout_2 . addWidget ( self . label_6 , 2 , 4 , 1 , 1 ) <newline> self . lineEditSocksPassword = QtGui . QLineEdit ( self . groupBox_2 ) <newline> self . lineEditSocksPassword . setEnabled ( False ) <newline> self . lineEditSocksPassword . setInputMethodHints ( QtCore . Qt . ImhHiddenText | QtCore . Qt . ImhNoAutoUppercase | QtCore . Qt . ImhNoPredictiveText ) <newline> self . lineEditSocksPassword . setEchoMode ( QtGui . QLineEdit . Password ) <newline> self . lineEditSocksPassword . setObjectName ( _fromUtf8 ( "lineEditSocksPassword" ) ) <newline> self . gridLayout_2 . addWidget ( self . lineEditSocksPassword , 2 , 5 , 1 , 1 ) <newline> self . checkBoxSocksListen = QtGui . QCheckBox ( self . groupBox_2 ) <newline> self . checkBoxSocksListen . setObjectName ( _fromUtf8 ( "checkBoxSocksListen" ) ) <newline> self . gridLayout_2 . addWidget ( self . checkBoxSocksListen , 3 , 1 , 1 , 4 ) <newline> self . comboBoxProxyType = QtGui . QComboBox ( self . groupBox_2 ) <newline> self . comboBoxProxyType . setObjectName ( _fromUtf8 ( "comboBoxProxyType" ) ) <newline> self . comboBoxProxyType . addItem ( _fromUtf8 ( "" ) ) <newline> self . comboBoxProxyType . addItem ( _fromUtf8 ( "" ) ) <newline> self . comboBoxProxyType . addItem ( _fromUtf8 ( "" ) ) <newline> self . gridLayout_2 . addWidget ( self . comboBoxProxyType , 0 , 1 , 1 , 1 ) <newline> self . gridLayout_4 . addWidget ( self . groupBox_2 , 1 , 0 , 1 , 1 ) <newline> spacerItem2 = QtGui . QSpacerItem ( 20 , 40 , QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Expanding ) <newline> self . gridLayout_4 . addItem ( spacerItem2 , 3 , 0 , 1 , 1 ) <newline> self . tabWidgetSettings . addTab ( self . tabNetworkSettings , _fromUtf8 ( "" ) ) <newline> self . tabDemandedDifficulty = QtGui . QWidget ( ) <newline> self . tabDemandedDifficulty . setObjectName ( _fromUtf8 ( "tabDemandedDifficulty" ) ) <newline> self . gridLayout_6 = QtGui . QGridLayout ( self . tabDemandedDifficulty ) <newline> self . gridLayout_6 . setObjectName ( _fromUtf8 ( "gridLayout_6" ) ) <newline> self . label_9 = QtGui . QLabel ( self . tabDemandedDifficulty ) <newline> self . label_9 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_9 . setObjectName ( _fromUtf8 ( "label_9" ) ) <newline> self . gridLayout_6 . addWidget ( self . label_9 , 1 , 1 , 1 , 1 ) <newline> self . label_10 = QtGui . QLabel ( self . tabDemandedDifficulty ) <newline> self . label_10 . setWordWrap ( True ) <newline> self . label_10 . setObjectName ( _fromUtf8 ( "label_10" ) ) <newline> self . gridLayout_6 . addWidget ( self . label_10 , 2 , 0 , 1 , 3 ) <newline> self . label_11 = QtGui . QLabel ( self . tabDemandedDifficulty ) <newline> self . label_11 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_11 . setObjectName ( _fromUtf8 ( "label_11" ) ) <newline> self . gridLayout_6 . addWidget ( self . label_11 , 3 , 1 , 1 , 1 ) <newline> self . label_8 = QtGui . QLabel ( self . tabDemandedDifficulty ) <newline> self . label_8 . setWordWrap ( True ) <newline> self . label_8 . setObjectName ( _fromUtf8 ( "label_8" ) ) <newline> self . gridLayout_6 . addWidget ( self . label_8 , 0 , 0 , 1 , 3 ) <newline> spacerItem3 = QtGui . QSpacerItem ( 203 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_6 . addItem ( spacerItem3 , 1 , 0 , 1 , 1 ) <newline> self . label_12 = QtGui . QLabel ( self . tabDemandedDifficulty ) <newline> self . label_12 . setWordWrap ( True ) <newline> self . label_12 . setObjectName ( _fromUtf8 ( "label_12" ) ) <newline> self . gridLayout_6 . addWidget ( self . label_12 , 4 , 0 , 1 , 3 ) <newline> self . lineEditSmallMessageDifficulty = QtGui . QLineEdit ( self . tabDemandedDifficulty ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . lineEditSmallMessageDifficulty . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . lineEditSmallMessageDifficulty . setSizePolicy ( sizePolicy ) <newline> self . lineEditSmallMessageDifficulty . setMaximumSize ( QtCore . QSize ( 70 , 16777215 ) ) <newline> self . lineEditSmallMessageDifficulty . setObjectName ( _fromUtf8 ( "lineEditSmallMessageDifficulty" ) ) <newline> self . gridLayout_6 . addWidget ( self . lineEditSmallMessageDifficulty , 3 , 2 , 1 , 1 ) <newline> self . lineEditTotalDifficulty = QtGui . QLineEdit ( self . tabDemandedDifficulty ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . lineEditTotalDifficulty . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . lineEditTotalDifficulty . setSizePolicy ( sizePolicy ) <newline> self . lineEditTotalDifficulty . setMaximumSize ( QtCore . QSize ( 70 , 16777215 ) ) <newline> self . lineEditTotalDifficulty . setObjectName ( _fromUtf8 ( "lineEditTotalDifficulty" ) ) <newline> self . gridLayout_6 . addWidget ( self . lineEditTotalDifficulty , 1 , 2 , 1 , 1 ) <newline> spacerItem4 = QtGui . QSpacerItem ( 203 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_6 . addItem ( spacerItem4 , 3 , 0 , 1 , 1 ) <newline> spacerItem5 = QtGui . QSpacerItem ( 20 , 40 , QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Expanding ) <newline> self . gridLayout_6 . addItem ( spacerItem5 , 5 , 0 , 1 , 1 ) <newline> self . tabWidgetSettings . addTab ( self . tabDemandedDifficulty , _fromUtf8 ( "" ) ) <newline> self . tabMaxAcceptableDifficulty = QtGui . QWidget ( ) <newline> self . tabMaxAcceptableDifficulty . setObjectName ( _fromUtf8 ( "tabMaxAcceptableDifficulty" ) ) <newline> self . gridLayout_7 = QtGui . QGridLayout ( self . tabMaxAcceptableDifficulty ) <newline> self . gridLayout_7 . setObjectName ( _fromUtf8 ( "gridLayout_7" ) ) <newline> self . label_15 = QtGui . QLabel ( self . tabMaxAcceptableDifficulty ) <newline> self . label_15 . setWordWrap ( True ) <newline> self . label_15 . setObjectName ( _fromUtf8 ( "label_15" ) ) <newline> self . gridLayout_7 . addWidget ( self . label_15 , 0 , 0 , 1 , 3 ) <newline> spacerItem6 = QtGui . QSpacerItem ( 102 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_7 . addItem ( spacerItem6 , 1 , 0 , 1 , 1 ) <newline> self . label_13 = QtGui . QLabel ( self . tabMaxAcceptableDifficulty ) <newline> self . label_13 . setLayoutDirection ( QtCore . Qt . LeftToRight ) <newline> self . label_13 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_13 . setObjectName ( _fromUtf8 ( "label_13" ) ) <newline> self . gridLayout_7 . addWidget ( self . label_13 , 1 , 1 , 1 , 1 ) <newline> self . lineEditMaxAcceptableTotalDifficulty = QtGui . QLineEdit ( self . tabMaxAcceptableDifficulty ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . lineEditMaxAcceptableTotalDifficulty . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . lineEditMaxAcceptableTotalDifficulty . setSizePolicy ( sizePolicy ) <newline> self . lineEditMaxAcceptableTotalDifficulty . setMaximumSize ( QtCore . QSize ( 70 , 16777215 ) ) <newline> self . lineEditMaxAcceptableTotalDifficulty . setObjectName ( _fromUtf8 ( "lineEditMaxAcceptableTotalDifficulty" ) ) <newline> self . gridLayout_7 . addWidget ( self . lineEditMaxAcceptableTotalDifficulty , 1 , 2 , 1 , 1 ) <newline> spacerItem7 = QtGui . QSpacerItem ( 102 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_7 . addItem ( spacerItem7 , 2 , 0 , 1 , 1 ) <newline> self . label_14 = QtGui . QLabel ( self . tabMaxAcceptableDifficulty ) <newline> self . label_14 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_14 . setObjectName ( _fromUtf8 ( "label_14" ) ) <newline> self . gridLayout_7 . addWidget ( self . label_14 , 2 , 1 , 1 , 1 ) <newline> self . lineEditMaxAcceptableSmallMessageDifficulty = QtGui . QLineEdit ( self . tabMaxAcceptableDifficulty ) <newline> sizePolicy = QtGui . QSizePolicy ( QtGui . QSizePolicy . Fixed , QtGui . QSizePolicy . Fixed ) <newline> sizePolicy . setHorizontalStretch ( 0 ) <newline> sizePolicy . setVerticalStretch ( 0 ) <newline> sizePolicy . setHeightForWidth ( self . lineEditMaxAcceptableSmallMessageDifficulty . sizePolicy ( ) . hasHeightForWidth ( ) ) <newline> self . lineEditMaxAcceptableSmallMessageDifficulty . setSizePolicy ( sizePolicy ) <newline> self . lineEditMaxAcceptableSmallMessageDifficulty . setMaximumSize ( QtCore . QSize ( 70 , 16777215 ) ) <newline> self . lineEditMaxAcceptableSmallMessageDifficulty . setObjectName ( _fromUtf8 ( "lineEditMaxAcceptableSmallMessageDifficulty" ) ) <newline> self . gridLayout_7 . addWidget ( self . lineEditMaxAcceptableSmallMessageDifficulty , 2 , 2 , 1 , 1 ) <newline> spacerItem8 = QtGui . QSpacerItem ( 20 , 147 , QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Expanding ) <newline> self . gridLayout_7 . addItem ( spacerItem8 , 3 , 1 , 1 , 1 ) <newline> self . tabWidgetSettings . addTab ( self . tabMaxAcceptableDifficulty , _fromUtf8 ( "" ) ) <newline> self . tabNamecoin = QtGui . QWidget ( ) <newline> self . tabNamecoin . setObjectName ( _fromUtf8 ( "tabNamecoin" ) ) <newline> self . gridLayout_8 = QtGui . QGridLayout ( self . tabNamecoin ) <newline> self . gridLayout_8 . setObjectName ( _fromUtf8 ( "gridLayout_8" ) ) <newline> spacerItem9 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_8 . addItem ( spacerItem9 , 2 , 0 , 1 , 1 ) <newline> self . label_16 = QtGui . QLabel ( self . tabNamecoin ) <newline> self . label_16 . setWordWrap ( True ) <newline> self . label_16 . setObjectName ( _fromUtf8 ( "label_16" ) ) <newline> self . gridLayout_8 . addWidget ( self . label_16 , 0 , 0 , 1 , 3 ) <newline> self . label_17 = QtGui . QLabel ( self . tabNamecoin ) <newline> self . label_17 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_17 . setObjectName ( _fromUtf8 ( "label_17" ) ) <newline> self . gridLayout_8 . addWidget ( self . label_17 , 2 , 1 , 1 , 1 ) <newline> self . lineEditNamecoinHost = QtGui . QLineEdit ( self . tabNamecoin ) <newline> self . lineEditNamecoinHost . setObjectName ( _fromUtf8 ( "lineEditNamecoinHost" ) ) <newline> self . gridLayout_8 . addWidget ( self . lineEditNamecoinHost , 2 , 2 , 1 , 1 ) <newline> spacerItem10 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_8 . addItem ( spacerItem10 , 3 , 0 , 1 , 1 ) <newline> spacerItem11 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_8 . addItem ( spacerItem11 , 4 , 0 , 1 , 1 ) <newline> self . label_18 = QtGui . QLabel ( self . tabNamecoin ) <newline> self . label_18 . setEnabled ( True ) <newline> self . label_18 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_18 . setObjectName ( _fromUtf8 ( "label_18" ) ) <newline> self . gridLayout_8 . addWidget ( self . label_18 , 3 , 1 , 1 , 1 ) <newline> self . lineEditNamecoinPort = QtGui . QLineEdit ( self . tabNamecoin ) <newline> self . lineEditNamecoinPort . setObjectName ( _fromUtf8 ( "lineEditNamecoinPort" ) ) <newline> self . gridLayout_8 . addWidget ( self . lineEditNamecoinPort , 3 , 2 , 1 , 1 ) <newline> spacerItem12 = QtGui . QSpacerItem ( 20 , 40 , QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Expanding ) <newline> self . gridLayout_8 . addItem ( spacerItem12 , 8 , 1 , 1 , 1 ) <newline> self . labelNamecoinUser = QtGui . QLabel ( self . tabNamecoin ) <newline> self . labelNamecoinUser . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . labelNamecoinUser . setObjectName ( _fromUtf8 ( "labelNamecoinUser" ) ) <newline> self . gridLayout_8 . addWidget ( self . labelNamecoinUser , 4 , 1 , 1 , 1 ) <newline> self . lineEditNamecoinUser = QtGui . QLineEdit ( self . tabNamecoin ) <newline> self . lineEditNamecoinUser . setObjectName ( _fromUtf8 ( "lineEditNamecoinUser" ) ) <newline> self . gridLayout_8 . addWidget ( self . lineEditNamecoinUser , 4 , 2 , 1 , 1 ) <newline> spacerItem13 = QtGui . QSpacerItem ( 40 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_8 . addItem ( spacerItem13 , 5 , 0 , 1 , 1 ) <newline> self . labelNamecoinPassword = QtGui . QLabel ( self . tabNamecoin ) <newline> self . labelNamecoinPassword . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . labelNamecoinPassword . setObjectName ( _fromUtf8 ( "labelNamecoinPassword" ) ) <newline> self . gridLayout_8 . addWidget ( self . labelNamecoinPassword , 5 , 1 , 1 , 1 ) <newline> self . lineEditNamecoinPassword = QtGui . QLineEdit ( self . tabNamecoin ) <newline> self . lineEditNamecoinPassword . setInputMethodHints ( QtCore . Qt . ImhHiddenText | QtCore . Qt . ImhNoAutoUppercase | QtCore . Qt . ImhNoPredictiveText ) <newline> self . lineEditNamecoinPassword . setEchoMode ( QtGui . QLineEdit . Password ) <newline> self . lineEditNamecoinPassword . setObjectName ( _fromUtf8 ( "lineEditNamecoinPassword" ) ) <newline> self . gridLayout_8 . addWidget ( self . lineEditNamecoinPassword , 5 , 2 , 1 , 1 ) <newline> self . labelNamecoinTestResult = QtGui . QLabel ( self . tabNamecoin ) <newline> self . labelNamecoinTestResult . setText ( _fromUtf8 ( "" ) ) <newline> self . labelNamecoinTestResult . setObjectName ( _fromUtf8 ( "labelNamecoinTestResult" ) ) <newline> self . gridLayout_8 . addWidget ( self . labelNamecoinTestResult , 7 , 0 , 1 , 2 ) <newline> self . pushButtonNamecoinTest = QtGui . QPushButton ( self . tabNamecoin ) <newline> self . pushButtonNamecoinTest . setObjectName ( _fromUtf8 ( "pushButtonNamecoinTest" ) ) <newline> self . gridLayout_8 . addWidget ( self . pushButtonNamecoinTest , 7 , 2 , 1 , 1 ) <newline> self . horizontalLayout = QtGui . QHBoxLayout ( ) <newline> self . horizontalLayout . setObjectName ( _fromUtf8 ( "horizontalLayout" ) ) <newline> self . label_21 = QtGui . QLabel ( self . tabNamecoin ) <newline> self . label_21 . setObjectName ( _fromUtf8 ( "label_21" ) ) <newline> self . horizontalLayout . addWidget ( self . label_21 ) <newline> self . radioButtonNamecoinNamecoind = QtGui . QRadioButton ( self . tabNamecoin ) <newline> self . radioButtonNamecoinNamecoind . setObjectName ( _fromUtf8 ( "radioButtonNamecoinNamecoind" ) ) <newline> self . horizontalLayout . addWidget ( self . radioButtonNamecoinNamecoind ) <newline> self . radioButtonNamecoinNmcontrol = QtGui . QRadioButton ( self . tabNamecoin ) <newline> self . radioButtonNamecoinNmcontrol . setObjectName ( _fromUtf8 ( "radioButtonNamecoinNmcontrol" ) ) <newline> self . horizontalLayout . addWidget ( self . radioButtonNamecoinNmcontrol ) <newline> self . gridLayout_8 . addLayout ( self . horizontalLayout , 1 , 0 , 1 , 3 ) <newline> self . tabWidgetSettings . addTab ( self . tabNamecoin , _fromUtf8 ( "" ) ) <newline> self . tabResendsExpire = QtGui . QWidget ( ) <newline> self . tabResendsExpire . setObjectName ( _fromUtf8 ( "tabResendsExpire" ) ) <newline> self . gridLayout_5 = QtGui . QGridLayout ( self . tabResendsExpire ) <newline> self . gridLayout_5 . setObjectName ( _fromUtf8 ( "gridLayout_5" ) ) <newline> self . label_7 = QtGui . QLabel ( self . tabResendsExpire ) <newline> self . label_7 . setWordWrap ( True ) <newline> self . label_7 . setObjectName ( _fromUtf8 ( "label_7" ) ) <newline> self . gridLayout_5 . addWidget ( self . label_7 , 0 , 0 , 1 , 3 ) <newline> spacerItem14 = QtGui . QSpacerItem ( 212 , 20 , QtGui . QSizePolicy . Expanding , QtGui . QSizePolicy . Minimum ) <newline> self . gridLayout_5 . addItem ( spacerItem14 , 1 , 0 , 1 , 1 ) <newline> self . widget = QtGui . QWidget ( self . tabResendsExpire ) <newline> self . widget . setMinimumSize ( QtCore . QSize ( 231 , 75 ) ) <newline> self . widget . setObjectName ( _fromUtf8 ( "widget" ) ) <newline> self . label_19 = QtGui . QLabel ( self . widget ) <newline> self . label_19 . setGeometry ( QtCore . QRect ( 10 , 20 , 101 , 20 ) ) <newline> self . label_19 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_19 . setObjectName ( _fromUtf8 ( "label_19" ) ) <newline> self . label_20 = QtGui . QLabel ( self . widget ) <newline> self . label_20 . setGeometry ( QtCore . QRect ( 30 , 40 , 80 , 16 ) ) <newline> self . label_20 . setAlignment ( QtCore . Qt . AlignRight | QtCore . Qt . AlignTrailing | QtCore . Qt . AlignVCenter ) <newline> self . label_20 . setObjectName ( _fromUtf8 ( "label_20" ) ) <newline> self . lineEditDays = QtGui . QLineEdit ( self . widget ) <newline> self . lineEditDays . setGeometry ( QtCore . QRect ( 113 , 20 , 51 , 20 ) ) <newline> self . lineEditDays . setObjectName ( _fromUtf8 ( "lineEditDays" ) ) <newline> self . lineEditMonths = QtGui . QLineEdit ( self . widget ) <newline> self . lineEditMonths . setGeometry ( QtCore . QRect ( 113 , 40 , 51 , 20 ) ) <newline> self . lineEditMonths . setObjectName ( _fromUtf8 ( "lineEditMonths" ) ) <newline> self . label_22 = QtGui . QLabel ( self . widget ) <newline> self . label_22 . setGeometry ( QtCore . QRect ( 169 , 23 , 61 , 16 ) ) <newline> self . label_22 . setObjectName ( _fromUtf8 ( "label_22" ) ) <newline> self . label_23 = QtGui . QLabel ( self . widget ) <newline> self . label_23 . setGeometry ( QtCore . QRect ( 170 , 41 , 71 , 16 ) ) <newline> self . label_23 . setObjectName ( _fromUtf8 ( "label_23" ) ) <newline> self . gridLayout_5 . addWidget ( self . widget , 1 , 2 , 1 , 1 ) <newline> spacerItem15 = QtGui . QSpacerItem ( 20 , 129 , QtGui . QSizePolicy . Minimum , QtGui . QSizePolicy . Expanding ) <newline> self . gridLayout_5 . addItem ( spacerItem15 , 2 , 1 , 1 , 1 ) <newline> self . tabWidgetSettings . addTab ( self . tabResendsExpire , _fromUtf8 ( "" ) ) <newline> self . gridLayout . addWidget ( self . tabWidgetSettings , 0 , 0 , 1 , 1 ) <newline> self . retranslateUi ( settingsDialog ) <newline> self . tabWidgetSettings . setCurrentIndex ( 0 ) <newline> QtCore . QObject . connect ( self . buttonBox , QtCore . SIGNAL ( _fromUtf8 ( "accepted()" ) ) , settingsDialog . accept ) <newline> QtCore . QObject . connect ( self . buttonBox , QtCore . SIGNAL ( _fromUtf8 ( "rejected()" ) ) , settingsDialog . reject ) <newline> QtCore . QObject . connect ( self . checkBoxAuthentication , QtCore . SIGNAL ( _fromUtf8 ( "toggled(bool)" ) ) , self . lineEditSocksUsername . setEnabled ) <newline> QtCore . QObject . connect ( self . checkBoxAuthentication , QtCore . SIGNAL ( _fromUtf8 ( "toggled(bool)" ) ) , self . lineEditSocksPassword . setEnabled ) <newline> QtCore . QMetaObject . connectSlotsByName ( settingsDialog ) <newline> settingsDialog . setTabOrder ( self . tabWidgetSettings , self . checkBoxStartOnLogon ) <newline> settingsDialog . setTabOrder ( self . checkBoxStartOnLogon , self . checkBoxStartInTray ) <newline> settingsDialog . setTabOrder ( self . checkBoxStartInTray , self . checkBoxMinimizeToTray ) <newline> settingsDialog . setTabOrder ( self . checkBoxMinimizeToTray , self . lineEditTCPPort ) <newline> settingsDialog . setTabOrder ( self . lineEditTCPPort , self . comboBoxProxyType ) <newline> settingsDialog . setTabOrder ( self . comboBoxProxyType , self . lineEditSocksHostname ) <newline> settingsDialog . setTabOrder ( self . lineEditSocksHostname , self . lineEditSocksPort ) <newline> settingsDialog . setTabOrder ( self . lineEditSocksPort , self . checkBoxAuthentication ) <newline> settingsDialog . setTabOrder ( self . checkBoxAuthentication , self . lineEditSocksUsername ) <newline> settingsDialog . setTabOrder ( self . lineEditSocksUsername , self . lineEditSocksPassword ) <newline> settingsDialog . setTabOrder ( self . lineEditSocksPassword , self . checkBoxSocksListen ) <newline> settingsDialog . setTabOrder ( self . checkBoxSocksListen , self . buttonBox ) <newline> <dedent> def retranslateUi ( self , settingsDialog ) : <newline> <indent> settingsDialog . setWindowTitle ( _translate ( "settingsDialog" , "Settings" , None ) ) <newline> self . checkBoxStartOnLogon . setText ( _translate ( "settingsDialog" , "Start ▁ Bitmessage ▁ on ▁ user ▁ login" , None ) ) <newline> self . checkBoxStartInTray . setText ( _translate ( "settingsDialog" , "Start ▁ Bitmessage ▁ in ▁ the ▁ tray ▁ (don\'t ▁ show ▁ main ▁ window)" , None ) ) <newline> self . checkBoxMinimizeToTray . setText ( _translate ( "settingsDialog" , "Minimize ▁ to ▁ tray" , None ) ) <newline> self . checkBoxShowTrayNotifications . setText ( _translate ( "settingsDialog" , "Show ▁ notification ▁ when ▁ message ▁ received" , None ) ) <newline> self . checkBoxPortableMode . setText ( _translate ( "settingsDialog" , "Run ▁ in ▁ Portable ▁ Mode" , None ) ) <newline> self . PortableModeDescription . setText ( _translate ( "settingsDialog" , "In ▁ Portable ▁ Mode, ▁ messages ▁ and ▁ config ▁ files ▁ are ▁ stored ▁ in ▁ the ▁ same ▁ directory ▁ as ▁ the ▁ program ▁ rather ▁ than ▁ the ▁ normal ▁ application-data ▁ folder. ▁ This ▁ makes ▁ it ▁ convenient ▁ to ▁ run ▁ Bitmessage ▁ from ▁ a ▁ USB ▁ thumb ▁ drive." , None ) ) <newline> self . checkBoxWillinglySendToMobile . setText ( _translate ( "settingsDialog" , "Willingly ▁ include ▁ unencrypted ▁ destination ▁ address ▁ when ▁ sending ▁ to ▁ a ▁ mobile ▁ device" , None ) ) <newline> self . checkBoxUseIdenticons . setText ( _translate ( "settingsDialog" , "Use ▁ Identicons" , None ) ) <newline> self . checkBoxReplyBelow . setText ( _translate ( "settingsDialog" , "Reply ▁ below ▁ Quote" , None ) ) <newline> self . groupBox . setTitle ( _translate ( "settingsDialog" , "Interface ▁ Language" , None ) ) <newline> self . languageComboBox . setItemText ( 0 , _translate ( "settingsDialog" , "System ▁ Settings" , "system" ) ) <newline> self . languageComboBox . setItemText ( 13 , _translate ( "settingsDialog" , "Pirate ▁ English" , "en_pirate" ) ) <newline> self . languageComboBox . setItemText ( 14 , _translate ( "settingsDialog" , "Other ▁ (set ▁ in ▁ keys.dat)" , "other" ) ) <newline> self . tabWidgetSettings . setTabText ( self . tabWidgetSettings . indexOf ( self . tabUserInterface ) , _translate ( "settingsDialog" , "User ▁ Interface" , None ) ) <newline> self . groupBox1 . setTitle ( _translate ( "settingsDialog" , "Listening ▁ port" , None ) ) <newline> self . label . setText ( _translate ( "settingsDialog" , "Listen ▁ for ▁ connections ▁ on ▁ port:" , None ) ) <newline> self . groupBox_3 . setTitle ( _translate ( "settingsDialog" , "Bandwidth ▁ limit" , None ) ) <newline> self . label_24 . setText ( _translate ( "settingsDialog" , "Maximum ▁ download ▁ rate ▁ (kB/s): ▁ [0: ▁ unlimited]" , None ) ) <newline> self . label_25 . setText ( _translate ( "settingsDialog" , "Maximum ▁ upload ▁ rate ▁ (kB/s): ▁ [0: ▁ unlimited]" , None ) ) <newline> self . groupBox_2 . setTitle ( _translate ( "settingsDialog" , "Proxy ▁ server ▁ / ▁ Tor" , None ) ) <newline> self . label_2 . setText ( _translate ( "settingsDialog" , "Type:" , None ) ) <newline> self . label_3 . setText ( _translate ( "settingsDialog" , "Server ▁ hostname:" , None ) ) <newline> self . label_4 . setText ( _translate ( "settingsDialog" , "Port:" , None ) ) <newline> self . checkBoxAuthentication . setText ( _translate ( "settingsDialog" , "Authentication" , None ) ) <newline> self . label_5 . setText ( _translate ( "settingsDialog" , "Username:" , None ) ) <newline> self . label_6 . setText ( _translate ( "settingsDialog" , "Pass:" , None ) ) <newline> self . checkBoxSocksListen . setText ( _translate ( "settingsDialog" , "Listen ▁ for ▁ incoming ▁ connections ▁ when ▁ using ▁ proxy" , None ) ) <newline> self . comboBoxProxyType . setItemText ( 0 , _translate ( "settingsDialog" , "none" , None ) ) <newline> self . comboBoxProxyType . setItemText ( 1 , _translate ( "settingsDialog" , "SOCKS4a" , None ) ) <newline> self . comboBoxProxyType . setItemText ( 2 , _translate ( "settingsDialog" , "SOCKS5" , None ) ) <newline> self . tabWidgetSettings . setTabText ( self . tabWidgetSettings . indexOf ( self . tabNetworkSettings ) , _translate ( "settingsDialog" , "Network ▁ Settings" , None ) ) <newline> self . label_9 . setText ( _translate ( "settingsDialog" , "Total ▁ difficulty:" , None ) ) <newline> self . label_10 . setText ( _translate ( "settingsDialog" , "The ▁ \'Total ▁ difficulty\' ▁ affects ▁ the ▁ absolute ▁ amount ▁ of ▁ work ▁ the ▁ sender ▁ must ▁ complete. ▁ Doubling ▁ this ▁ value ▁ doubles ▁ the ▁ amount ▁ of ▁ work." , None ) ) <newline> self . label_11 . setText ( _translate ( "settingsDialog" , "Small ▁ message ▁ difficulty:" , None ) ) <newline> self . label_8 . setText ( _translate ( "settingsDialog" , "When ▁ someone ▁ sends ▁ you ▁ a ▁ message, ▁ their ▁ computer ▁ must ▁ first ▁ complete ▁ some ▁ work. ▁ The ▁ difficulty ▁ of ▁ this ▁ work, ▁ by ▁ default, ▁ is ▁ 1. ▁ You ▁ may ▁ raise ▁ this ▁ default ▁ for ▁ new ▁ addresses ▁ you ▁ create ▁ by ▁ changing ▁ the ▁ values ▁ here. ▁ Any ▁ new ▁ addresses ▁ you ▁ create ▁ will ▁ require ▁ senders ▁ to ▁ meet ▁ the ▁ higher ▁ difficulty. ▁ There ▁ is ▁ one ▁ exception: ▁ if ▁ you ▁ add ▁ a ▁ friend ▁ or ▁ acquaintance ▁ to ▁ your ▁ address ▁ book, ▁ Bitmessage ▁ will ▁ automatically ▁ notify ▁ them ▁ when ▁ you ▁ next ▁ send ▁ a ▁ message ▁ that ▁ they ▁ need ▁ only ▁ complete ▁ the ▁ minimum ▁ amount ▁ of ▁ work: ▁ difficulty ▁ 1. ▁ " , None ) ) <newline> self . label_12 . setText ( _translate ( "settingsDialog" , "The ▁ \'Small ▁ message ▁ difficulty\' ▁ mostly ▁ only ▁ affects ▁ the ▁ difficulty ▁ of ▁ sending ▁ small ▁ messages. ▁ Doubling ▁ this ▁ value ▁ makes ▁ it ▁ almost ▁ twice ▁ as ▁ difficult ▁ to ▁ send ▁ a ▁ small ▁ message ▁ but ▁ doesn\'t ▁ really ▁ affect ▁ large ▁ messages." , None ) ) <newline> self . tabWidgetSettings . setTabText ( self . tabWidgetSettings . indexOf ( self . tabDemandedDifficulty ) , _translate ( "settingsDialog" , "Demanded ▁ difficulty" , None ) ) <newline> self . label_15 . setText ( _translate ( "settingsDialog" , "Here ▁ you ▁ may ▁ set ▁ the ▁ maximum ▁ amount ▁ of ▁ work ▁ you ▁ are ▁ willing ▁ to ▁ do ▁ to ▁ send ▁ a ▁ message ▁ to ▁ another ▁ person. ▁ Setting ▁ these ▁ values ▁ to ▁ 0 ▁ means ▁ that ▁ any ▁ value ▁ is ▁ acceptable." , None ) ) <newline> self . label_13 . setText ( _translate ( "settingsDialog" , "Maximum ▁ acceptable ▁ total ▁ difficulty:" , None ) ) <newline> self . label_14 . setText ( _translate ( "settingsDialog" , "Maximum ▁ acceptable ▁ small ▁ message ▁ difficulty:" , None ) ) <newline> self . tabWidgetSettings . setTabText ( self . tabWidgetSettings . indexOf ( self . tabMaxAcceptableDifficulty ) , _translate ( "settingsDialog" , "Max ▁ acceptable ▁ difficulty" , None ) ) <newline> self . label_16 . setText ( _translate ( "settingsDialog" , "<html><head/><body><p>Bitmessage ▁ can ▁ utilize ▁ a ▁ different ▁ Bitcoin-based ▁ program ▁ called ▁ Namecoin ▁ to ▁ make ▁ addresses ▁ human-friendly. ▁ For ▁ example, ▁ instead ▁ of ▁ having ▁ to ▁ tell ▁ your ▁ friend ▁ your ▁ long ▁ Bitmessage ▁ address, ▁ you ▁ can ▁ simply ▁ tell ▁ him ▁ to ▁ send ▁ a ▁ message ▁ to ▁ <span ▁ style=\" ▁ font-style:italic;\">test. ▁ </span></p><p>(Getting ▁ your ▁ own ▁ Bitmessage ▁ address ▁ into ▁ Namecoin ▁ is ▁ still ▁ rather ▁ difficult).</p><p>Bitmessage ▁ can ▁ use ▁ either ▁ namecoind ▁ directly ▁ or ▁ a ▁ running ▁ nmcontrol ▁ instance.</p></body></html>" , None ) ) <newline> self . label_17 . setText ( _translate ( "settingsDialog" , "Host:" , None ) ) <newline> self . label_18 . setText ( _translate ( "settingsDialog" , "Port:" , None ) ) <newline> self . labelNamecoinUser . setText ( _translate ( "settingsDialog" , "Username:" , None ) ) <newline> self . labelNamecoinPassword . setText ( _translate ( "settingsDialog" , "Password:" , None ) ) <newline> self . pushButtonNamecoinTest . setText ( _translate ( "settingsDialog" , "Test" , None ) ) <newline> self . label_21 . setText ( _translate ( "settingsDialog" , "Connect ▁ to:" , None ) ) <newline> self . radioButtonNamecoinNamecoind . setText ( _translate ( "settingsDialog" , "Namecoind" , None ) ) <newline> self . radioButtonNamecoinNmcontrol . setText ( _translate ( "settingsDialog" , "NMControl" , None ) ) <newline> self . tabWidgetSettings . setTabText ( self . tabWidgetSettings . indexOf ( self . tabNamecoin ) , _translate ( "settingsDialog" , "Namecoin ▁ integration" , None ) ) <newline> self . label_7 . setText ( _translate ( "settingsDialog" , "<html><head/><body><p>By ▁ default, ▁ if ▁ you ▁ send ▁ a ▁ message ▁ to ▁ someone ▁ and ▁ he ▁ is ▁ offline ▁ for ▁ more ▁ than ▁ two ▁ days, ▁ Bitmessage ▁ will ▁ send ▁ the ▁ message ▁ again ▁ after ▁ an ▁ additional ▁ two ▁ days. ▁ This ▁ will ▁ be ▁ continued ▁ with ▁ exponential ▁ backoff ▁ forever; ▁ messages ▁ will ▁ be ▁ resent ▁ after ▁ 5, ▁ 10, ▁ 20 ▁ days ▁ ect. ▁ until ▁ the ▁ receiver ▁ acknowledges ▁ them. ▁ Here ▁ you ▁ may ▁ change ▁ that ▁ behavior ▁ by ▁ having ▁ Bitmessage ▁ give ▁ up ▁ after ▁ a ▁ certain ▁ number ▁ of ▁ days ▁ or ▁ months.</p><p>Leave ▁ these ▁ input ▁ fields ▁ blank ▁ for ▁ the ▁ default ▁ behavior. ▁ </p></body></html>" , None ) ) <newline> self . label_19 . setText ( _translate ( "settingsDialog" , "Give ▁ up ▁ after" , None ) ) <newline> self . label_20 . setText ( _translate ( "settingsDialog" , "and" , None ) ) <newline> self . label_22 . setText ( _translate ( "settingsDialog" , "days" , None ) ) <newline> self . label_23 . setText ( _translate ( "settingsDialog" , "months." , None ) ) <newline> self . tabWidgetSettings . setTabText ( self . tabWidgetSettings . indexOf ( self . tabResendsExpire ) , _translate ( "settingsDialog" , "Resends ▁ Expire" , None ) ) <newline> <dedent> <dedent> import bitmessage_icons_rc <newline>
 """ Helpers ▁ to ▁ create ▁ and ▁ manage ▁ local ▁ juju ▁ charms. """  <newline> from contextlib import contextmanager <newline> import logging <newline> import os <newline> import pexpect <newline> import re <newline> import subprocess <newline> import yaml <newline> from utility import ( ensure_deleted , JujuAssertionError , ) <newline> __metaclass__ = type <newline> log = logging . getLogger ( "jujucharm" ) <newline> class Charm : <newline> <indent>  """ Representation ▁ of ▁ a ▁ juju ▁ charm. """  <newline> DEFAULT_MAINTAINER = "juju-qa@lists.canonical.com" <newline> DEFAULT_SERIES = ( "bionic" , "xenial" , "trusty" ) <newline> DEFAULT_DESCRIPTION = "description" <newline> NAME_REGEX = re . compile ( '^[a-z][a-z0-9]*(-[a-z0-9]*[a-z][a-z0-9]*)*$' ) <newline> def __init__ ( self , name , summary , maintainer = None , series = None , description = None , storage = None , ensure_valid_name = True ) : <newline> <indent> if ensure_valid_name and Charm . NAME_REGEX . match ( name ) is None : <newline> <indent> raise JujuAssertionError ( 'Invalid ▁ Juju ▁ Charm ▁ Name, ▁"{}" ▁ does ▁ not ▁ match ▁"{}".' . format ( name , Charm . NAME_REGEX . pattern ) ) <newline> <dedent> self . metadata = { "name" : name , "summary" : summary , "maintainer" : maintainer or self . DEFAULT_MAINTAINER , "series" : series or self . DEFAULT_SERIES , "description" : description or self . DEFAULT_DESCRIPTION } <newline> if storage is not None : <newline> <indent> self . metadata [ "storage" ] = storage <newline> <dedent> self . _hook_scripts = { } <newline> <dedent> def to_dir ( self , directory ) : <newline> <indent>  """ Serialize ▁ charm ▁ into ▁ a ▁ new ▁ directory. """  <newline> with open ( os . path . join ( directory , "metadata.yaml" ) , "w" ) as f : <newline> <indent> yaml . safe_dump ( self . metadata , f , default_flow_style = False ) <newline> <dedent> if self . _hook_scripts : <newline> <indent> hookdir = os . path . join ( directory , "hooks" ) <newline> os . mkdir ( hookdir ) <newline> for hookname in self . _hook_scripts : <newline> <indent> with open ( os . path . join ( hookdir , hookname ) , "w" ) as f : <newline> <indent> os . fchmod ( f . fileno ( ) , 0o755 ) <newline> f . write ( self . _hook_scripts [ hookname ] ) <newline> <dedent> <dedent> <dedent> <dedent> def to_repo_dir ( self , repo_dir ) : <newline> <indent>  """ Serialize ▁ charm ▁ into ▁ a ▁ directory ▁ for ▁ a ▁ repository ▁ of ▁ charms. """  <newline> charm_dir = os . path . join ( repo_dir , self . default_series , self . metadata [ "name" ] ) <newline> os . makedirs ( charm_dir ) <newline> self . to_dir ( charm_dir ) <newline> return charm_dir <newline> <dedent> @ property <newline> def default_series ( self ) : <newline> <indent> series = self . metadata . get ( "series" , self . DEFAULT_SERIES ) <newline> if series and isinstance ( series , ( tuple , list ) ) : <newline> <indent> return series [ 0 ] <newline> <dedent> return series <newline> <dedent> def add_hook_script ( self , name , script ) : <newline> <indent> self . _hook_scripts [ name ] = script <newline> <dedent> <dedent> def local_charm_path ( charm , juju_ver , series = None , repository = None , platform = 'ubuntu' ) : <newline> <indent>  """ Create ▁ either ▁ Juju ▁ 1.x ▁ or ▁ 2.x ▁ local ▁ charm ▁ path. """  <newline> if juju_ver . startswith ( '1.' ) : <newline> <indent> if series : <newline> <indent> series = '{}/' . format ( series ) <newline> <dedent> else : <newline> <indent> series = '' <newline> <dedent> local_path = 'local:{}{}' . format ( series , charm ) <newline> return local_path <newline> <dedent> else : <newline> <indent> charm_dir = { 'ubuntu' : 'charms' , 'win' : 'charms-win' , 'centos' : 'charms-centos' } <newline> abs_path = charm <newline> if repository : <newline> <indent> abs_path = os . path . join ( repository , charm ) <newline> <dedent> elif os . environ . get ( 'JUJU_REPOSITORY' ) : <newline> <indent> repository = os . path . join ( os . environ [ 'JUJU_REPOSITORY' ] , charm_dir [ platform ] ) <newline> abs_path = os . path . join ( repository , charm ) <newline> <dedent> return abs_path <newline> <dedent> <dedent> class CharmCommand : <newline> <indent> default_api_url = 'https://api.jujucharms.com/charmstore' <newline> def __init__ ( self , charm_bin , api_url = None ) : <newline> <indent>  """ Simple ▁ charm ▁ command ▁ wrapper. """  <newline> self . charm_bin = charm_bin <newline> self . api_url = sane_charm_store_api_url ( api_url ) <newline> <dedent> def _get_env ( self ) : <newline> <indent> return { 'JUJU_CHARMSTORE' : self . api_url } <newline> <dedent> @ contextmanager <newline> def logged_in_user ( self , user_email , password ) : <newline> <indent>  """ Contextmanager ▁ that ▁ logs ▁ in ▁ and ▁ ensures ▁ user ▁ logs ▁ out. """  <newline> try : <newline> <indent> self . login ( user_email , password ) <newline> yield <newline> <dedent> finally : <newline> <indent> try : <newline> <indent> self . logout ( ) <newline> <dedent> except Exception as e : <newline> <indent> log . error ( 'Failed ▁ to ▁ logout: ▁ {}' . format ( str ( e ) ) ) <newline> default_juju_data = os . path . join ( os . environ [ 'HOME' ] , '.local' , 'share' , 'juju' ) <newline> juju_data = os . environ . get ( 'JUJU_DATA' , default_juju_data ) <newline> token_file = os . path . join ( juju_data , 'store-usso-token' ) <newline> cookie_file = os . path . join ( os . environ [ 'HOME' ] , '.go-cookies' ) <newline> log . debug ( 'Removing ▁ {} ▁ and ▁ {}' . format ( token_file , cookie_file ) ) <newline> ensure_deleted ( token_file ) <newline> ensure_deleted ( cookie_file ) <newline> <dedent> <dedent> <dedent> def login ( self , user_email , password ) : <newline> <indent> log . debug ( 'Logging ▁ {} ▁ in.' . format ( user_email ) ) <newline> try : <newline> <indent> command = pexpect . spawn ( self . charm_bin , [ 'login' ] , env = self . _get_env ( ) ) <newline> command . expect ( '(?i)Login ▁ to ▁ Ubuntu ▁ SSO' ) <newline> command . expect ( '(?i)Press ▁ return ▁ to ▁ select.*\.' ) <newline> command . expect ( '(?i)E-Mail:' ) <newline> command . sendline ( user_email ) <newline> command . expect ( '(?i)Password' ) <newline> command . sendline ( password ) <newline> command . expect ( '(?i)Two-factor ▁ auth' ) <newline> command . sendline ( ) <newline> command . expect ( pexpect . EOF ) <newline> if command . isalive ( ) : <newline> <indent> raise AssertionError ( 'Failed ▁ to ▁ log ▁ user ▁ in ▁ to ▁ {}' . format ( self . api_url ) ) <newline> <dedent> <dedent> except ( pexpect . TIMEOUT , pexpect . EOF ) as e : <newline> <indent> raise AssertionError ( 'Failed ▁ to ▁ log ▁ user ▁ in: ▁ {}' . format ( e ) ) <newline> <dedent> <dedent> def logout ( self ) : <newline> <indent> log . debug ( 'Logging ▁ out.' ) <newline> self . run ( 'logout' ) <newline> <dedent> def run ( self , sub_command , * arguments ) : <newline> <indent> try : <newline> <indent> output = subprocess . check_output ( [ self . charm_bin , sub_command ] + list ( arguments ) , env = self . _get_env ( ) , stderr = subprocess . STDOUT ) <newline> return output <newline> <dedent> except subprocess . CalledProcessError as e : <newline> <indent> log . error ( e . output ) <newline> raise <newline> <dedent> <dedent> <dedent> def sane_charm_store_api_url ( url ) : <newline> <indent>  """ Ensure ▁ the ▁ store ▁ url ▁ includes ▁ the ▁ right ▁ parts. """  <newline> if url is None : <newline> <indent> return CharmCommand . default_api_url <newline> <dedent> return '{}/charmstore' . format ( url ) <newline> <dedent>
 # ▁ Copyright ▁ 2012 ▁ the ▁ V8 ▁ project ▁ authors. ▁ All ▁ rights ▁ reserved. <encdom>  # ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms, ▁ with ▁ or ▁ without <encdom>  # ▁ modification, ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are <encdom>  # ▁ met: <encdom>  # ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright <encdom>  # ▁ notice, ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer. <encdom>  # ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above <encdom>  # ▁ copyright ▁ notice, ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following <encdom>  # ▁ disclaimer ▁ in ▁ the ▁ documentation ▁ and/or ▁ other ▁ materials ▁ provided <encdom>  # ▁ with ▁ the ▁ distribution. <encdom>  # ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ Google ▁ Inc. ▁ nor ▁ the ▁ names ▁ of ▁ its <encdom>  # ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived <encdom>  # ▁ from ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission. <encdom>  # ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS <encdom>  # ▁"AS ▁ IS" ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES, ▁ INCLUDING, ▁ BUT ▁ NOT <encdom>  # ▁ LIMITED ▁ TO, ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR <encdom>  # ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED. ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT <encdom>  # ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT, ▁ INDIRECT, ▁ INCIDENTAL, <encdom>  # ▁ SPECIAL, ▁ EXEMPLARY, ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ (INCLUDING, ▁ BUT ▁ NOT <encdom>  # ▁ LIMITED ▁ TO, ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES; ▁ LOSS ▁ OF ▁ USE, <encdom>  # ▁ DATA, ▁ OR ▁ PROFITS; ▁ OR ▁ BUSINESS ▁ INTERRUPTION) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY <encdom>  # ▁ THEORY ▁ OF ▁ LIABILITY, ▁ WHETHER ▁ IN ▁ CONTRACT, ▁ STRICT ▁ LIABILITY, ▁ OR ▁ TORT <encdom>  # ▁ (INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE <encdom>  # ▁ OF ▁ THIS ▁ SOFTWARE, ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE. <encdom> import multiprocessing <newline> import os <newline> import shutil <newline> import subprocess <newline> import threading <newline> import time <newline> from . import daemon <newline> from . import local_handler <newline> from . import presence_handler <newline> from . import signatures <newline> from . import status_handler <newline> from . import work_handler <newline> from . . network import perfdata <newline> class Server ( daemon . Daemon ) : <newline> <indent> def __init__ ( self , pidfile , root , stdin = "/dev/null" , stdout = "/dev/null" , stderr = "/dev/null" ) : <newline> <indent> super ( Server , self ) . __init__ ( pidfile , stdin , stdout , stderr ) <newline> self . root = root <newline> self . local_handler = None <newline> self . local_handler_thread = None <newline> self . work_handler = None <newline> self . work_handler_thread = None <newline> self . status_handler = None <newline> self . status_handler_thread = None <newline> self . presence_daemon = None <newline> self . presence_daemon_thread = None <newline> self . peers = [ ] <newline> self . jobs = multiprocessing . cpu_count ( ) <newline> self . peer_list_lock = threading . Lock ( ) <newline> self . perf_data_lock = None <newline> self . presence_daemon_lock = None <newline> self . datadir = os . path . join ( self . root , "data" ) <newline> pubkey_fingerprint_filename = os . path . join ( self . datadir , "mypubkey" ) <newline> with open ( pubkey_fingerprint_filename ) as f : <newline> <indent> self . pubkey_fingerprint = f . read ( ) . strip ( ) <newline> <dedent> self . relative_perf_filename = os . path . join ( self . datadir , "myperf" ) <newline> if os . path . exists ( self . relative_perf_filename ) : <newline> <indent> with open ( self . relative_perf_filename ) as f : <newline> <indent> try : <newline> <indent> self . relative_perf = float ( f . read ( ) ) <newline> <dedent> except : <newline> <indent> self . relative_perf = 1.0 <newline> <dedent> <dedent> <dedent> else : <newline> <indent> self . relative_perf = 1.0 <newline> <dedent> <dedent> def run ( self ) : <newline> <indent> os . nice ( 20 ) <newline> self . ip = presence_handler . GetOwnIP ( ) <newline> self . perf_data_manager = perfdata . PerfDataManager ( self . datadir ) <newline> self . perf_data_lock = threading . Lock ( ) <newline> self . local_handler = local_handler . LocalSocketServer ( self ) <newline> self . local_handler_thread = threading . Thread ( target = self . local_handler . serve_forever ) <newline> self . local_handler_thread . start ( ) <newline> self . work_handler = work_handler . WorkSocketServer ( self ) <newline> self . work_handler_thread = threading . Thread ( target = self . work_handler . serve_forever ) <newline> self . work_handler_thread . start ( ) <newline> self . status_handler = status_handler . StatusSocketServer ( self ) <newline> self . status_handler_thread = threading . Thread ( target = self . status_handler . serve_forever ) <newline> self . status_handler_thread . start ( ) <newline> self . presence_daemon = presence_handler . PresenceDaemon ( self ) <newline> self . presence_daemon_thread = threading . Thread ( target = self . presence_daemon . serve_forever ) <newline> self . presence_daemon_thread . start ( ) <newline> self . presence_daemon . FindPeers ( ) <newline> time . sleep ( 0.5 )  # ▁ Give ▁ those ▁ peers ▁ some ▁ time ▁ to ▁ reply. <encdom> <newline> with self . peer_list_lock : <newline> <indent> for p in self . peers : <newline> <indent> if p . address == self . ip : continue <newline> status_handler . RequestTrustedPubkeys ( p , self ) <newline> <dedent> <dedent> while True : <newline> <indent> try : <newline> <indent> self . PeriodicTasks ( ) <newline> time . sleep ( 60 ) <newline> <dedent> except Exception , e : <newline> <indent> print ( "MAIN ▁ LOOP ▁ EXCEPTION: ▁ %s" % e ) <newline> self . Shutdown ( ) <newline> break <newline> <dedent> except KeyboardInterrupt : <newline> <indent> self . Shutdown ( ) <newline> break <newline> <dedent> <dedent> <dedent> def Shutdown ( self ) : <newline> <indent> with open ( self . relative_perf_filename , "w" ) as f : <newline> <indent> f . write ( "%s" % self . relative_perf ) <newline> <dedent> self . presence_daemon . shutdown ( ) <newline> self . presence_daemon . server_close ( ) <newline> self . local_handler . shutdown ( ) <newline> self . local_handler . server_close ( ) <newline> self . work_handler . shutdown ( ) <newline> self . work_handler . server_close ( ) <newline> self . status_handler . shutdown ( ) <newline> self . status_handler . server_close ( ) <newline> <dedent> def PeriodicTasks ( self ) : <newline>  # ▁ If ▁ we ▁ know ▁ peers ▁ we ▁ don't ▁ trust, ▁ see ▁ if ▁ someone ▁ else ▁ trusts ▁ them. <encdom> <indent> with self . peer_list_lock : <newline> <indent> for p in self . peers : <newline> <indent> if p . trusted : continue <newline> if self . IsTrusted ( p . pubkey ) : <newline> <indent> p . trusted = True <newline> status_handler . ITrustYouNow ( p ) <newline> continue <newline> <dedent> for p2 in self . peers : <newline> <indent> if not p2 . trusted : continue <newline> status_handler . TryTransitiveTrust ( p2 , p . pubkey , self ) <newline>  # ▁ TODO: ▁ Ping ▁ for ▁ more ▁ peers ▁ waiting ▁ to ▁ be ▁ discovered. <encdom>  # ▁ TODO: ▁ Update ▁ the ▁ checkout ▁ (if ▁ currently ▁ idle). <encdom> <dedent> <dedent> <dedent> <dedent> def AddPeer ( self , peer ) : <newline> <indent> with self . peer_list_lock : <newline> <indent> for p in self . peers : <newline> <indent> if p . address == peer . address : <newline> <indent> return <newline> <dedent> <dedent> self . peers . append ( peer ) <newline> <dedent> if peer . trusted : <newline> <indent> status_handler . ITrustYouNow ( peer ) <newline> <dedent> <dedent> def DeletePeer ( self , peer_address ) : <newline> <indent> with self . peer_list_lock : <newline> <indent> for i in xrange ( len ( self . peers ) ) : <newline> <indent> if self . peers [ i ] . address == peer_address : <newline> <indent> del self . peers [ i ] <newline> return <newline> <dedent> <dedent> <dedent> <dedent> def MarkPeerAsTrusting ( self , peer_address ) : <newline> <indent> with self . peer_list_lock : <newline> <indent> for p in self . peers : <newline> <indent> if p . address == peer_address : <newline> <indent> p . trusting_me = True <newline> break <newline> <dedent> <dedent> <dedent> <dedent> def UpdatePeerPerformance ( self , peer_address , performance ) : <newline> <indent> with self . peer_list_lock : <newline> <indent> for p in self . peers : <newline> <indent> if p . address == peer_address : <newline> <indent> p . relative_performance = performance <newline> <dedent> <dedent> <dedent> <dedent> def CopyToTrusted ( self , pubkey_filename ) : <newline> <indent> with open ( pubkey_filename , "r" ) as f : <newline> <indent> lines = f . readlines ( ) <newline> fingerprint = lines [ - 1 ] . strip ( ) <newline> <dedent> target_filename = self . _PubkeyFilename ( fingerprint ) <newline> shutil . copy ( pubkey_filename , target_filename ) <newline> with self . peer_list_lock : <newline> <indent> for peer in self . peers : <newline> <indent> if peer . address == self . ip : continue <newline> if peer . pubkey == fingerprint : <newline> <indent> status_handler . ITrustYouNow ( peer ) <newline> <dedent> else : <newline> <indent> result = self . SignTrusted ( fingerprint ) <newline> status_handler . NotifyNewTrusted ( peer , result ) <newline> <dedent> <dedent> <dedent> return fingerprint <newline> <dedent> def _PubkeyFilename ( self , pubkey_fingerprint ) : <newline> <indent> return os . path . join ( self . root , "trusted" , "%s.pem" % pubkey_fingerprint ) <newline> <dedent> def IsTrusted ( self , pubkey_fingerprint ) : <newline> <indent> return os . path . exists ( self . _PubkeyFilename ( pubkey_fingerprint ) ) <newline> <dedent> def ListTrusted ( self ) : <newline> <indent> path = os . path . join ( self . root , "trusted" ) <newline> if not os . path . exists ( path ) : return [ ] <newline> return [ f [ : - 4 ] for f in os . listdir ( path ) if f . endswith ( ".pem" ) ] <newline> <dedent> def SignTrusted ( self , pubkey_fingerprint ) : <newline> <indent> if not self . IsTrusted ( pubkey_fingerprint ) : <newline> <indent> return [ ] <newline> <dedent> filename = self . _PubkeyFilename ( pubkey_fingerprint ) <newline> result = signatures . ReadFileAndSignature ( filename )  # ▁ Format: ▁ [key, ▁ sig]. <encdom> <newline> return [ pubkey_fingerprint , result [ 0 ] , result [ 1 ] , self . pubkey_fingerprint ] <newline> <dedent> def AcceptNewTrusted ( self , data ) : <newline>  # ▁ The ▁ format ▁ of ▁ |data| ▁ matches ▁ the ▁ return ▁ value ▁ of ▁ |SignTrusted()|. <encdom> <indent> if not data : return <newline> fingerprint = data [ 0 ] <newline> pubkey = data [ 1 ] <newline> signature = data [ 2 ] <newline> signer = data [ 3 ] <newline> if not self . IsTrusted ( signer ) : <newline> <indent> return <newline> <dedent> if self . IsTrusted ( fingerprint ) : <newline> <indent> return  # ▁ Already ▁ trust ▁ this ▁ guy. <encdom> <newline> <dedent> filename = self . _PubkeyFilename ( fingerprint ) <newline> signer_pubkeyfile = self . _PubkeyFilename ( signer ) <newline> if not signatures . VerifySignature ( filename , pubkey , signature , signer_pubkeyfile ) : <newline> <indent> return <newline> <dedent> return  # ▁ Nothing ▁ more ▁ to ▁ do. <encdom> <newline> <dedent> def AddPerfData ( self , test_key , duration , arch , mode ) : <newline> <indent> data_store = self . perf_data_manager . GetStore ( arch , mode ) <newline> data_store . RawUpdatePerfData ( str ( test_key ) , duration ) <newline> <dedent> def CompareOwnPerf ( self , test , arch , mode ) : <newline> <indent> data_store = self . perf_data_manager . GetStore ( arch , mode ) <newline> observed = data_store . FetchPerfData ( test ) <newline> if not observed : return <newline> own_perf_estimate = observed / test . duration <newline> with self . perf_data_lock : <newline> <indent> kLearnRateLimiter = 9999 <newline> self . relative_perf *= kLearnRateLimiter <newline> self . relative_perf += own_perf_estimate <newline> self . relative_perf /= ( kLearnRateLimiter + 1 ) <newline> <dedent> <dedent> <dedent>
 # ▁ Copyright ▁ 2015 ▁ The ▁ TensorFlow ▁ Authors. ▁ All ▁ Rights ▁ Reserved. <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); <encdom>  # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. <encdom>  # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, <encdom>  # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. <encdom>  # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and <encdom>  # ▁ limitations ▁ under ▁ the ▁ License. <encdom>  """ Tests ▁ for ▁ the ▁ DynamicPartition ▁ op. """  <newline> from __future__ import absolute_import <newline> from __future__ import division <newline> from __future__ import print_function <newline> import unittest <newline> import numpy as np <newline> from six . moves import xrange  # ▁ pylint: ▁ disable=redefined-builtin <encdom> <newline> from tensorflow . python . framework import constant_op <newline> from tensorflow . python . framework import dtypes <newline> from tensorflow . python . ops import array_ops <newline> from tensorflow . python . ops import data_flow_ops <newline> from tensorflow . python . ops import gradients_impl <newline> import tensorflow . python . ops . data_flow_grad  # ▁ pylint: ▁ disable=unused-import <encdom> <newline> from tensorflow . python . platform import test <newline> class DynamicPartitionTest ( test . TestCase ) : <newline> <indent> def testSimpleOneDimensional ( self ) : <newline> <indent> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( [ 0 , 13 , 2 , 39 , 4 , 17 ] , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( [ 0 , 0 , 2 , 3 , 2 , 1 ] ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 4 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 4 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ 0 , 13 ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ 17 ] , partition_vals [ 1 ] ) <newline> self . assertAllEqual ( [ 2 , 4 ] , partition_vals [ 2 ] ) <newline> self . assertAllEqual ( [ 39 ] , partition_vals [ 3 ] ) <newline>  # ▁ Vector ▁ data ▁ input ▁ to ▁ DynamicPartition ▁ results ▁ in <encdom>  # ▁ `num_partitions` ▁ vectors ▁ of ▁ unknown ▁ length. <encdom> self . assertEqual ( [ None ] , partitions [ 0 ] . get_shape ( ) . as_list ( ) ) <newline> self . assertEqual ( [ None ] , partitions [ 1 ] . get_shape ( ) . as_list ( ) ) <newline> self . assertEqual ( [ None ] , partitions [ 2 ] . get_shape ( ) . as_list ( ) ) <newline> self . assertEqual ( [ None ] , partitions [ 3 ] . get_shape ( ) . as_list ( ) ) <newline> <dedent> def testSimpleTwoDimensional ( self ) : <newline> <indent> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( [ [ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 9 , 10 , 11 ] , [ 12 , 13 , 14 ] , [ 15 , 16 , 17 ] ] , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( [ 0 , 0 , 2 , 3 , 2 , 1 ] ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 4 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 4 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ [ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ [ 15 , 16 , 17 ] ] , partition_vals [ 1 ] ) <newline> self . assertAllEqual ( [ [ 6 , 7 , 8 ] , [ 12 , 13 , 14 ] ] , partition_vals [ 2 ] ) <newline> self . assertAllEqual ( [ [ 9 , 10 , 11 ] ] , partition_vals [ 3 ] ) <newline>  # ▁ Vector ▁ data ▁ input ▁ to ▁ DynamicPartition ▁ results ▁ in <encdom>  # ▁ `num_partitions` ▁ matrices ▁ with ▁ an ▁ unknown ▁ number ▁ of ▁ rows, ▁ and ▁ 3 ▁ columns. <encdom> self . assertEqual ( [ None , 3 ] , partitions [ 0 ] . get_shape ( ) . as_list ( ) ) <newline> self . assertEqual ( [ None , 3 ] , partitions [ 1 ] . get_shape ( ) . as_list ( ) ) <newline> self . assertEqual ( [ None , 3 ] , partitions [ 2 ] . get_shape ( ) . as_list ( ) ) <newline> self . assertEqual ( [ None , 3 ] , partitions [ 3 ] . get_shape ( ) . as_list ( ) ) <newline> <dedent> def testLargeOneDimensional ( self ) : <newline> <indent> num = 100000 <newline> data_list = [ x for x in range ( num ) ] <newline> indices_list = [ x % 2 for x in range ( num ) ] <newline> part1 = [ x for x in range ( num ) if x % 2 == 0 ] <newline> part2 = [ x for x in range ( num ) if x % 2 == 1 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 2 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 2 , len ( partition_vals ) ) <newline> self . assertAllEqual ( part1 , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( part2 , partition_vals [ 1 ] ) <newline> <dedent> def testLargeTwoDimensional ( self ) : <newline> <indent> rows = 100000 <newline> cols = 100 <newline> data_list = [ None ] * rows <newline> for i in range ( rows ) : <newline> <indent> data_list [ i ] = [ i for _ in range ( cols ) ] <newline> <dedent> num_partitions = 97 <newline> indices_list = [ ( i ** 2 ) % num_partitions for i in range ( rows ) ] <newline> parts = [ [ ] for _ in range ( num_partitions ) ] <newline> for i in range ( rows ) : <newline> <indent> parts [ ( i ** 2 ) % num_partitions ] . append ( data_list [ i ] ) <newline> <dedent> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = num_partitions ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( num_partitions , len ( partition_vals ) ) <newline> for i in range ( num_partitions ) : <newline>  # ▁ reshape ▁ because ▁ of ▁ empty ▁ parts <encdom> <indent> parts_np = np . array ( parts [ i ] , dtype = np . float ) . reshape ( - 1 , cols ) <newline> self . assertAllEqual ( parts_np , partition_vals [ i ] ) <newline> <dedent> <dedent> def testSimpleComplex ( self ) : <newline> <indent> data_list = [ 1 + 2j , 3 + 4j , 5 + 6j , 7 + 8j ] <newline> indices_list = [ 1 , 0 , 1 , 0 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . complex64 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 2 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 2 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ 3 + 4j , 7 + 8j ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ 1 + 2j , 5 + 6j ] , partition_vals [ 1 ] ) <newline> <dedent> def testScalarPartitions ( self ) : <newline> <indent> data_list = [ 10 , 13 , 12 , 11 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float64 ) <newline> indices = 3 <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 4 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 4 , len ( partition_vals ) ) <newline> self . assertAllEqual ( np . array ( [ ] , dtype = np . float64 ) . reshape ( - 1 , 4 ) , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( np . array ( [ ] , dtype = np . float64 ) . reshape ( - 1 , 4 ) , partition_vals [ 1 ] ) <newline> self . assertAllEqual ( np . array ( [ ] , dtype = np . float64 ) . reshape ( - 1 , 4 ) , partition_vals [ 2 ] ) <newline> self . assertAllEqual ( np . array ( [ 10 , 13 , 12 , 11 ] , dtype = np . float64 ) . reshape ( - 1 , 4 ) , partition_vals [ 3 ] ) <newline> <dedent> def testHigherRank ( self ) : <newline> <indent> np . random . seed ( 7 ) <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> for n in 2 , 3 : <newline> <indent> for shape in ( 4 , ) , ( 4 , 5 ) , ( 4 , 5 , 2 ) : <newline> <indent> partitions = np . random . randint ( n , size = np . prod ( shape ) ) . reshape ( shape ) <newline> for extra_shape in ( ) , ( 6 , ) , ( 6 , 7 ) : <newline> <indent> data = np . random . randn ( * ( shape + extra_shape ) ) <newline> partitions_t = constant_op . constant ( partitions , dtype = dtypes . int32 ) <newline> data_t = constant_op . constant ( data ) <newline> outputs = data_flow_ops . dynamic_partition ( data_t , partitions_t , num_partitions = n ) <newline> self . assertEqual ( n , len ( outputs ) ) <newline> outputs_val = sess . run ( outputs ) <newline> for i , output in enumerate ( outputs_val ) : <newline> <indent> self . assertAllEqual ( output , data [ partitions == i ] ) <newline>  # ▁ Test ▁ gradients <encdom> <dedent> outputs_grad = [ 7 * output for output in outputs_val ] <newline> grads = gradients_impl . gradients ( outputs , [ data_t , partitions_t ] , outputs_grad ) <newline> self . assertEqual ( grads [ 1 ] , None )  # ▁ Partitions ▁ has ▁ no ▁ gradients <encdom> <newline> self . assertAllEqual ( 7 * data , sess . run ( grads [ 0 ] ) ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> def testEmptyParts ( self ) : <newline> <indent> data_list = [ 1 , 2 , 3 , 4 ] <newline> indices_list = [ 1 , 3 , 1 , 3 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 4 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 4 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ 1 , 3 ] , partition_vals [ 1 ] ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 2 ] ) <newline> self . assertAllEqual ( [ 2 , 4 ] , partition_vals [ 3 ] ) <newline> <dedent> def testEmptyDataTwoDimensional ( self ) : <newline> <indent> data_list = [ [ ] , [ ] ] <newline> indices_list = [ 0 , 1 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 3 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 3 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ [ ] ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ [ ] ] , partition_vals [ 1 ] ) <newline> self . assertAllEqual ( np . array ( [ ] , dtype = np . float ) . reshape ( 0 , 0 ) , partition_vals [ 2 ] ) <newline> <dedent> def testEmptyPartitions ( self ) : <newline> <indent> data_list = [ ] <newline> indices_list = [ ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 2 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 2 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 1 ] ) <newline> <dedent> @ unittest . skip ( "Fails ▁ on ▁ windows." ) <newline> def testGPUTooManyParts ( self ) : <newline>  # ▁ This ▁ test ▁ only ▁ makes ▁ sense ▁ on ▁ the ▁ GPU. ▁ There ▁ we ▁ do ▁ not ▁ check <encdom>  # ▁ for ▁ errors. ▁ In ▁ this ▁ case, ▁ we ▁ should ▁ discard ▁ all ▁ but ▁ the ▁ first <encdom>  # ▁ num_partitions ▁ indices. <encdom> <indent> if not test . is_gpu_available ( ) : <newline> <indent> return <newline> <dedent> data_list = [ 1 , 2 , 3 , 4 , 5 , 6 ] <newline> indices_list = [ 6 , 5 , 4 , 3 , 1 , 0 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 2 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 2 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ 6 ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ 5 ] , partition_vals [ 1 ] ) <newline> <dedent> @ unittest . skip ( "Fails ▁ on ▁ windows." ) <newline> def testGPUPartsTooLarge ( self ) : <newline>  # ▁ This ▁ test ▁ only ▁ makes ▁ sense ▁ on ▁ the ▁ GPU. ▁ There ▁ we ▁ do ▁ not ▁ check <encdom>  # ▁ for ▁ errors. ▁ In ▁ this ▁ case, ▁ we ▁ should ▁ discard ▁ all ▁ the ▁ values <encdom>  # ▁ larger ▁ than ▁ num_partitions. <encdom> <indent> if not test . is_gpu_available ( ) : <newline> <indent> return <newline> <dedent> data_list = [ 1 , 2 , 3 , 4 , 5 , 6 ] <newline> indices_list = [ 10 , 11 , 2 , 12 , 0 , 1000 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 5 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 5 , len ( partition_vals ) ) <newline> self . assertAllEqual ( [ 5 ] , partition_vals [ 0 ] ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 1 ] ) <newline> self . assertAllEqual ( [ 3 ] , partition_vals [ 2 ] ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 3 ] ) <newline> self . assertAllEqual ( [ ] , partition_vals [ 4 ] ) <newline> <dedent> @ unittest . skip ( "Fails ▁ on ▁ windows." ) <newline> def testGPUAllIndicesBig ( self ) : <newline>  # ▁ This ▁ test ▁ only ▁ makes ▁ sense ▁ on ▁ the ▁ GPU. ▁ There ▁ we ▁ do ▁ not ▁ check <encdom>  # ▁ for ▁ errors. ▁ In ▁ this ▁ case, ▁ we ▁ should ▁ discard ▁ all ▁ the ▁ values <encdom>  # ▁ and ▁ have ▁ an ▁ empty ▁ output. <encdom> <indent> if not test . is_gpu_available ( ) : <newline> <indent> return <newline> <dedent> data_list = [ 1.1 , 2.1 , 3.1 , 4.1 , 5.1 , 6.1 ] <newline> indices_list = [ 90 , 70 , 60 , 100 , 110 , 40 ] <newline> with self . session ( use_gpu = True ) as sess : <newline> <indent> data = constant_op . constant ( data_list , dtype = dtypes . float32 ) <newline> indices = constant_op . constant ( indices_list , dtype = dtypes . int32 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 40 ) <newline> partition_vals = sess . run ( partitions ) <newline> <dedent> self . assertEqual ( 40 , len ( partition_vals ) ) <newline> for i in range ( 40 ) : <newline> <indent> self . assertAllEqual ( [ ] , partition_vals [ i ] ) <newline> <dedent> <dedent> def testErrorIndexOutOfRange ( self ) : <newline> <indent> with self . cached_session ( ) as sess : <newline> <indent> data = constant_op . constant ( [ [ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 9 , 10 , 11 ] , [ 12 , 13 , 14 ] ] ) <newline> indices = constant_op . constant ( [ 0 , 2 , 99 , 2 , 2 ] ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 4 ) <newline> with self . assertRaisesOpError ( r"partitions\[2\] ▁ = ▁ 99 ▁ is ▁ not ▁ in ▁ \[0, ▁ 4\)" ) : <newline> <indent> sess . run ( partitions ) <newline> <dedent> <dedent> <dedent> def testScalarIndexOutOfRange ( self ) : <newline> <indent> with self . cached_session ( ) as sess : <newline> <indent> bad = 17 <newline> data = np . zeros ( 5 ) <newline> partitions = data_flow_ops . dynamic_partition ( data , bad , num_partitions = 7 ) <newline> with self . assertRaisesOpError ( r"partitions ▁ = ▁ 17 ▁ is ▁ not ▁ in ▁ \[0, ▁ 7\)" ) : <newline> <indent> sess . run ( partitions ) <newline> <dedent> <dedent> <dedent> def testHigherRankIndexOutOfRange ( self ) : <newline> <indent> with self . cached_session ( ) as sess : <newline> <indent> shape = ( 2 , 3 ) <newline> indices = array_ops . placeholder ( shape = shape , dtype = np . int32 ) <newline> data = np . zeros ( shape + ( 5 , ) ) <newline> partitions = data_flow_ops . dynamic_partition ( data , indices , num_partitions = 7 ) <newline> for i in xrange ( 2 ) : <newline> <indent> for j in xrange ( 3 ) : <newline> <indent> bad = np . zeros ( shape , dtype = np . int32 ) <newline> bad [ i , j ] = 17 <newline> with self . assertRaisesOpError ( r"partitions\[%d,%d\] ▁ = ▁ 17 ▁ is ▁ not ▁ in ▁ \[0, ▁ 7\)" % ( i , j ) ) : <newline> <indent> sess . run ( partitions , feed_dict = { indices : bad } ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> def testErrorWrongDimsIndices ( self ) : <newline> <indent> data = constant_op . constant ( [ [ 0 ] , [ 1 ] , [ 2 ] ] ) <newline> indices = constant_op . constant ( [ [ 0 ] , [ 0 ] ] ) <newline> with self . assertRaises ( ValueError ) : <newline> <indent> data_flow_ops . dynamic_partition ( data , indices , num_partitions = 4 ) <newline>  # ▁ see ▁ https://github.com/tensorflow/tensorflow/issues/17106 <encdom> <dedent> <dedent> def testCUBBug ( self ) : <newline> <indent> x = constant_op . constant ( np . random . randn ( 3072 ) ) <newline> inds = [ 0 ] * 189 + [ 1 ] * 184 + [ 2 ] * 184 + [ 3 ] * 191 + [ 4 ] * 192 + [ 5 ] * 195 + [ 6 ] * 195 <newline> inds += [ 7 ] * 195 + [ 8 ] * 188 + [ 9 ] * 195 + [ 10 ] * 188 + [ 11 ] * 202 + [ 12 ] * 194 <newline> inds += [ 13 ] * 194 + [ 14 ] * 194 + [ 15 ] * 192 <newline> self . assertEqual ( len ( inds ) , x . shape [ 0 ] ) <newline> partitioned = data_flow_ops . dynamic_partition ( x , inds , 16 ) <newline> with self . cached_session ( ) as sess : <newline> <indent> res = sess . run ( partitioned ) <newline> <dedent> self . assertEqual ( res [ - 1 ] . shape [ 0 ] , 192 ) <newline> <dedent> <dedent> if __name__ == "__main__" : <newline> <indent> test . main ( ) <newline> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom> from __future__ import unicode_literals <newline> import sys <newline> import re <newline> from textwrap import dedent <newline> from curtsies . fmtfuncs import bold , green , magenta , cyan , red , plain <newline> from bpython . curtsiesfrontend import interpreter <newline> from bpython . _py3compat import py3 <newline> from bpython . test import mock , unittest <newline> pypy = 'PyPy' in sys . version <newline> def remove_ansi ( s ) : <newline> <indent> return re . sub ( r'(\x9B|\x1B\[)[0-?]*[ ▁ -\/]*[@-~]' . encode ( 'ascii' ) , b'' , s ) <newline> <dedent> class TestInterpreter ( unittest . TestCase ) : <newline> <indent> def interp_errlog ( self ) : <newline> <indent> i = interpreter . Interp ( ) <newline> a = [ ] <newline> i . write = a . append <newline> return i , a <newline> <dedent> def err_lineno ( self , a ) : <newline> <indent> strings = [ x . __unicode__ ( ) for x in a ] <newline> for line in reversed ( strings ) : <newline> <indent> clean_line = remove_ansi ( line ) <newline> m = re . search ( r'line ▁ (\d+)[,]' , clean_line ) <newline> if m : <newline> <indent> return int ( m . group ( 1 ) ) <newline> <dedent> <dedent> return None <newline> <dedent> def test_syntaxerror ( self ) : <newline> <indent> i , a = self . interp_errlog ( ) <newline> i . runsource ( '1.1.1.1' ) <newline> if pypy : <newline> <indent> expected = ( ' ▁ ▁ File ▁ ' + green ( '"<input>"' ) + ', ▁ line ▁ ' + bold ( magenta ( '1' ) ) + ' \n ▁ ▁ ▁ ▁ 1.1.1.1 \n ▁ ▁ ▁ ▁ ▁ ▁ ^ \n ' + bold ( red ( 'SyntaxError' ) ) + ': ▁ ' + cyan ( 'invalid ▁ syntax' ) + ' \n ' ) <newline> <dedent> else : <newline> <indent> expected = ( ' ▁ ▁ File ▁ ' + green ( '"<input>"' ) + ', ▁ line ▁ ' + bold ( magenta ( '1' ) ) + ' \n ▁ ▁ ▁ ▁ 1.1.1.1 \n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ^ \n ' + bold ( red ( 'SyntaxError' ) ) + ': ▁ ' + cyan ( 'invalid ▁ syntax' ) + ' \n ' ) <newline> <dedent> self . assertMultiLineEqual ( str ( plain ( '' ) . join ( a ) ) , str ( expected ) ) <newline> self . assertEquals ( plain ( '' ) . join ( a ) , expected ) <newline> <dedent> def test_traceback ( self ) : <newline> <indent> i , a = self . interp_errlog ( ) <newline> def f ( ) : <newline> <indent> return 1 / 0 <newline> <dedent> def gfunc ( ) : <newline> <indent> return f ( ) <newline> <dedent> i . runsource ( 'gfunc()' ) <newline> if pypy : <newline> <indent> global_not_found = "global ▁ name ▁'gfunc' ▁ is ▁ not ▁ defined" <newline> <dedent> else : <newline> <indent> global_not_found = "name ▁'gfunc' ▁ is ▁ not ▁ defined" <newline> <dedent> expected = ( 'Traceback ▁ (most ▁ recent ▁ call ▁ last): \n ▁ ▁ File ▁ ' + green ( '"<input>"' ) + ', ▁ line ▁ ' + bold ( magenta ( '1' ) ) + ', ▁ in ▁ ' + cyan ( '<module>' ) + ' \n ▁ ▁ ▁ ▁ gfunc() \n ' + bold ( red ( 'NameError' ) ) + ': ▁ ' + cyan ( global_not_found ) + ' \n ' ) <newline> self . assertMultiLineEqual ( str ( plain ( '' ) . join ( a ) ) , str ( expected ) ) <newline> self . assertEquals ( plain ( '' ) . join ( a ) , expected ) <newline> <dedent> @ unittest . skipIf ( py3 , "runsource() ▁ accepts ▁ only ▁ unicode ▁ in ▁ Python ▁ 3" ) <newline> def test_runsource_bytes ( self ) : <newline> <indent> i = interpreter . Interp ( encoding = b'latin-1' ) <newline> i . runsource ( "a ▁ = ▁ b'\xfe'" . encode ( 'latin-1' ) , encode = False ) <newline> self . assertIsInstance ( i . locals [ 'a' ] , str ) <newline> self . assertEqual ( i . locals [ 'a' ] , b"\xfe" ) <newline> i . runsource ( "b ▁ = ▁ u'\xfe'" . encode ( 'latin-1' ) , encode = False ) <newline> self . assertIsInstance ( i . locals [ 'b' ] , unicode ) <newline> self . assertEqual ( i . locals [ 'b' ] , "\xfe" ) <newline> <dedent> @ unittest . skipUnless ( py3 , "Only ▁ a ▁ syntax ▁ error ▁ in ▁ Python ▁ 3" ) <newline> def test_runsource_bytes_over_128_syntax_error_py3 ( self ) : <newline> <indent> i = interpreter . Interp ( encoding = b'latin-1' ) <newline> i . showsyntaxerror = mock . Mock ( return_value = None ) <newline> i . runsource ( "a ▁ = ▁ b'\xfe'" ) <newline> i . showsyntaxerror . assert_called_with ( mock . ANY ) <newline> <dedent> @ unittest . skipIf ( py3 , "encode ▁ is ▁ Python ▁ 2 ▁ only" ) <newline> def test_runsource_bytes_over_128_syntax_error_py2 ( self ) : <newline> <indent> i = interpreter . Interp ( encoding = b'latin-1' ) <newline> i . runsource ( b"a ▁ = ▁ b'\xfe'" ) <newline> self . assertIsInstance ( i . locals [ 'a' ] , type ( b'' ) ) <newline> self . assertEqual ( i . locals [ 'a' ] , b"\xfe" ) <newline> <dedent> @ unittest . skipIf ( py3 , "encode ▁ is ▁ Python ▁ 2 ▁ only" ) <newline> def test_runsource_unicode ( self ) : <newline> <indent> i = interpreter . Interp ( encoding = b'latin-1' ) <newline> i . runsource ( "a ▁ = ▁ u'\xfe'" ) <newline> self . assertIsInstance ( i . locals [ 'a' ] , type ( u'' ) ) <newline> self . assertEqual ( i . locals [ 'a' ] , u"\xfe" ) <newline> <dedent> def test_getsource_works_on_interactively_defined_functions ( self ) : <newline> <indent> source = 'def ▁ foo(x): \n ▁ ▁ ▁ ▁ return ▁ x ▁ + ▁ 1 \n ' <newline> i = interpreter . Interp ( ) <newline> i . runsource ( source ) <newline> import inspect <newline> inspected_source = inspect . getsource ( i . locals [ 'foo' ] ) <newline> self . assertEquals ( inspected_source , source ) <newline> <dedent> @ unittest . skipIf ( py3 , "encode ▁ only ▁ does ▁ anything ▁ in ▁ Python ▁ 2" ) <newline> def test_runsource_unicode_autoencode_and_noencode ( self ) : <newline> <indent>  """ error ▁ line ▁ numbers ▁ should ▁ be ▁ fixed """  <newline>  # ▁ Since ▁ correct ▁ behavior ▁ for ▁ unicode ▁ is ▁ the ▁ same <encdom>  # ▁ for ▁ auto ▁ and ▁ False, ▁ run ▁ the ▁ same ▁ tests <encdom> for encode in [ 'auto' , False ] : <newline> <indent> i , a = self . interp_errlog ( ) <newline> i . runsource ( u'[1 ▁ + ▁ 1, \n abcd]' , encode = encode ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( u'[1 ▁ + ▁ 1, \n abcd]' , encode = encode ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( u' # encoding: ▁ utf-8 \n abcd' , encode = encode ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( u' # encoding: ▁ utf-8 \n abcd' , filename = 'x.py' , encode = encode ) <newline> self . assertIn ( 'SyntaxError:' , '' . join ( '' . join ( remove_ansi ( x . __unicode__ ( ) ) for x in a ) ) ) <newline> <dedent> <dedent> @ unittest . skipIf ( py3 , "encode ▁ only ▁ does ▁ anything ▁ in ▁ Python ▁ 2" ) <newline> def test_runsource_unicode_encode ( self ) : <newline> <indent> i , _ = self . interp_errlog ( ) <newline> with self . assertRaises ( ValueError ) : <newline> <indent> i . runsource ( u'1 ▁ + ▁ 1' , encode = True ) <newline> <dedent> i , _ = self . interp_errlog ( ) <newline> with self . assertRaises ( ValueError ) : <newline> <indent> i . runsource ( u'1 ▁ + ▁ 1' , filename = 'x.py' , encode = True ) <newline> <dedent> <dedent> @ unittest . skipIf ( py3 , "encode ▁ only ▁ does ▁ anything ▁ in ▁ Python ▁ 2" ) <newline> def test_runsource_bytestring_noencode ( self ) : <newline> <indent> i , a = self . interp_errlog ( ) <newline> i . runsource ( b'[1 ▁ + ▁ 1, \n abcd]' , encode = False ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( b'[1 ▁ + ▁ 1, \n abcd]' , filename = 'x.py' , encode = False ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( dedent ( b ''' \ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # encoding: ▁ utf-8 <strnewline> <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ["%s", <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ abcd] '''  % ( u'åß∂ƒ' . encode ( 'utf8' ) , ) ) , encode = False ) <newline> self . assertEqual ( self . err_lineno ( a ) , 4 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( dedent ( b ''' \ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # encoding: ▁ utf-8 <strnewline> <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ["%s", <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ abcd] '''  % ( u'åß∂ƒ' . encode ( 'utf8' ) , ) ) , filename = 'x.py' , encode = False ) <newline> self . assertEqual ( self . err_lineno ( a ) , 4 ) <newline> <dedent> @ unittest . skipIf ( py3 , "encode ▁ only ▁ does ▁ anything ▁ in ▁ Python ▁ 2" ) <newline> def test_runsource_bytestring_encode ( self ) : <newline> <indent> i , a = self . interp_errlog ( ) <newline> i . runsource ( b'[1 ▁ + ▁ 1, \n abcd]' , encode = True ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> with self . assertRaises ( ValueError ) : <newline> <indent> i . runsource ( b'[1 ▁ + ▁ 1, \n abcd]' , filename = 'x.py' , encode = True ) <newline> <dedent> i , a = self . interp_errlog ( ) <newline> i . runsource ( dedent ( b ''' \ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # encoding: ▁ utf-8 <strnewline> <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ [u"%s", <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ abcd] '''  % ( u'åß∂ƒ' . encode ( 'utf8' ) , ) ) , encode = True ) <newline> self . assertEqual ( self . err_lineno ( a ) , 4 ) <newline> i , a = self . interp_errlog ( ) <newline> with self . assertRaises ( ValueError ) : <newline> <indent> i . runsource ( dedent ( b ''' \ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # encoding: ▁ utf-8 <strnewline> <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ [u"%s", <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ abcd] '''  % ( u'åß∂ƒ' . encode ( 'utf8' ) , ) ) , filename = 'x.py' , encode = True ) <newline> <dedent> <dedent> @ unittest . skipIf ( py3 , "encode ▁ only ▁ does ▁ anything ▁ in ▁ Python ▁ 2" ) <newline> def test_runsource_bytestring_autoencode ( self ) : <newline> <indent> i , a = self . interp_errlog ( ) <newline> i . runsource ( b'[1 ▁ + ▁ 1, \n ▁ abcd]' ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( b'[1 ▁ + ▁ 1, \n abcd]' , filename = 'x.py' ) <newline> self . assertEqual ( self . err_lineno ( a ) , 2 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( dedent ( b ''' \ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # encoding: ▁ utf-8 <strnewline> <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ [u"%s", <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ abcd] '''  % ( u'åß∂ƒ' . encode ( 'utf8' ) , ) ) ) <newline> self . assertEqual ( self . err_lineno ( a ) , 4 ) <newline> i , a = self . interp_errlog ( ) <newline> i . runsource ( dedent ( b ''' \ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # encoding: ▁ utf-8 <strnewline> <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ [u"%s", <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ abcd] '''  % ( u'åß∂ƒ' . encode ( 'utf8' ) , ) ) ) <newline> self . assertEqual ( self . err_lineno ( a ) , 4 ) <newline> <dedent> <dedent>
 # ▁ Copyright ▁ (C) ▁ 2012 ▁ Massimo ▁ Santini ▁ <massimo.santini@unimi.it> <encdom>  # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Learning-Week-2012-Software. <encdom>  # ▁ Learning-Week-2012-Software ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or <encdom>  # ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by <encdom>  # ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License, ▁ or ▁ (at ▁ your <encdom>  # ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ Learning-Week-2012-Software ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be <encdom>  # ▁ useful, ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. <tabsymbol> See ▁ the ▁ GNU ▁ General <encdom>  # ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along ▁ with <encdom>  # ▁ Learning-Week-2012-Software ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <encdom> from . usr import usr <newline> from . img import img <newline> from . gby import gby <newline> from . xml import xml <newline> APPLICATIONS = { 'usr' : usr , 'img' : img , 'gby' : gby , 'xml' : xml , } <newline>
 # !/usr/bin/env ▁ python <encdom>  # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  """ <strnewline> File: ▁ division.py <strnewline> Author: ▁ Inokentiy ▁ Babushkin <strnewline> Email: ▁ inokentiy.babushkin@googlemail.com <strnewline> Github: ▁ ibabushkin <strnewline> Description: <strnewline> ▁ Find ▁ optimized ▁ integer ▁ divisions ▁ and ▁ recover ▁ the ▁ divisor <strnewline> ▁ in ▁ a ▁ function. <strnewline> """  <newline> import argparse <newline> import sys <newline> import math <newline> from Iridium . defines . util . instructions import Instruction <newline> from Iridium . defines . util . parser import CodeCrawler <newline> def hex2signeddecimal ( hexstr ) : <newline> <indent>  """ <strnewline> ▁ Take ▁ the ▁ hexdump ▁ of ▁ a ▁ dword ▁ (or ▁ any ▁ other ▁ sequence ▁ of ▁ memory) ▁ and <strnewline> ▁ interpret ▁ it ▁ as ▁ a ▁ signed ▁ integer. <strnewline> ▁ """  <newline> return int ( bin ( int ( hexstr , 16 ) ) , 2 ) - ( 1 << 32 ) <newline> <dedent> def get_divisor ( magic , rshift , bitness = 32 ) : <newline> <indent>  """ <strnewline> ▁ see ▁ the ▁ explanation ▁ at <strnewline> ▁ http://reverseengineering.stackexchange.com/questions/1397/how-can-i-reverse-optimized-integer-division-modulo-by-constant-operations <strnewline> ▁ basically ▁ calculates ▁ the ▁ divisor ▁ from ▁ magic ▁ constant ▁ and ▁ shift <strnewline> ▁ amount, ▁ as ▁ well ▁ as ▁ used ▁ register ▁ size. <strnewline> ▁ """  <newline> magic = hex2signeddecimal ( magic ) <newline> return int ( math . ceil ( ( 2.0 ** ( bitness + rshift ) ) / ( magic + 2 ** bitness ) ) ) <newline> <dedent> class DivisionParser ( CodeCrawler ) : <newline> <indent>  """ <strnewline> ▁ The ▁ class ▁ retrieving ▁ and ▁ working ▁ on ▁ the ▁ information <strnewline> ▁ present ▁ in ▁ the ▁ analyzed ▁ source, ▁ equivalent ▁ to ▁ Graph ▁ and ▁ DataParser <strnewline> ▁ """  <newline> def __init__ ( self , text ) : <newline> <indent>  """ <strnewline> ▁ Set ▁ default ▁ threshold ▁ vales ▁ and ▁ prepare <strnewline> ▁ for ▁ analysis. <strnewline> ▁ """  <newline> CodeCrawler . __init__ ( self , text ) <newline> self . next_imul = 5  # ▁ a ▁ threshold ▁ value, ▁ see ▁ help <encdom> <newline> self . next_sar = 9  # ▁ see ▁ directly ▁ above <encdom> <newline> <dedent> def find_interesting_code_sequences ( self ) : <newline> <indent>  """ <strnewline> ▁ Find ▁ and ▁ analyze ▁ optimized ▁ divisions. <strnewline> ▁ """  <newline> for index , instruction in enumerate ( self . code ) : <newline> <indent> if isinstance ( instruction , Instruction ) : <newline> <indent> if instruction . mnemonic == 'mov' and ( instruction . operands [ 1 ] . endswith ( 'h' ) or instruction . operands [ 1 ] . startswith ( '0x' ) ) : <newline> <indent> destination , hexstr = instruction . operands <newline> next_imul = self . find_next_instruction ( index + 1 , 'imul' , destination + ', ▁ %X' ) <newline> if next_imul < self . next_imul and next_imul : <newline> <indent> next_sar = self . find_next_instruction ( index + 1 , 'sar' , '%X, ▁ %X' ) <newline> if next_sar < self . next_sar and next_sar : <newline> <indent> shift = self . code [ index + next_sar + 1 ] . operands [ 1 ] <newline> if '0x' not in hexstr : <newline> <indent> magic = '0x' + hexstr . lower ( ) [ : - 1 ] <newline> <dedent> else : <newline> <indent> magic = hexstr <newline> <dedent> print 'Found ▁ candidate ▁ for ▁ optimized ▁ integer ▁ division ▁ \ <strnewline> starting ▁ at ▁ line ▁ ' + str ( index ) + ':' <newline> print 'constant: ▁ ' + magic + ', ▁ rshift: ▁ ' + shift <newline> if '0x' in shift : <newline> <indent> shift = int ( shift , 16 ) <newline> <dedent> else : <newline> <indent> shift = int ( shift ) <newline> <dedent> result = get_divisor ( magic , shift ) <newline> print '--> ▁ division ▁ by ▁ ' + str ( result ) <newline> <dedent> <dedent> <dedent> <dedent> <dedent> <dedent> def find_next_instruction ( self , start_index , mnemonic , opers ) : <newline> <indent>  """ <strnewline> ▁ Get ▁ the ▁ distance ▁ to ▁ the ▁ next ▁ instruction ▁ matching ▁ the ▁ args. <strnewline> ▁ Warning: ▁ might ▁ return ▁ None. <strnewline> ▁ opers ▁ should ▁ look ▁ like ▁ these ▁ examples: ▁'%X, ▁ %X', ▁'%X, ▁ eax', ▁'eax, ▁ %X' <strnewline> ▁ where ▁ %X ▁ is ▁ a ▁ wildcard <strnewline> ▁ """  <newline> first , magic_constant = opers . split ( ', ▁ ' ) <newline> for index , instruction in enumerate ( self . code [ start_index : ] ) : <newline> <indent> if isinstance ( instruction , Instruction ) : <newline> <indent> if instruction . mnemonic == mnemonic : <newline> <indent> if ( first == '%X' or first == instruction . operands [ 0 ] ) and ( magic_constant == '%X' or ( magic_constant == instruction . operands [ 1 ] ) ) : <newline> <indent> return index <newline> <dedent> <dedent> <dedent> <dedent> <dedent> <dedent> if __name__ == '__main__' : <newline> <indent> ARG_PARSER = argparse . ArgumentParser ( description = 'The ▁ division ▁ analysis ▁ module, ▁ capable ▁ to ▁ work ▁ stand-alone' ) <newline> ARG_PARSER . add_argument ( '-s' , '--source' , help = 'Optional ▁ file ▁ to ▁ be ▁ analyzed, ▁ if ▁ not ▁ present,\ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ the ▁ hard-coded-default ▁ is ▁ used ▁ (for ▁ debugging ▁ purposes)' ) <newline> ARG_PARSER . add_argument ( '-o' , '--output' , help = 'Optional ▁ file ▁ to ▁ redirect ▁ input ▁ to' ) <newline> ARG_PARSER . add_argument ( '--next-imul-threshold' , help =  ''' Maximal ▁ index-difference ▁ between <strnewline> ▁ ▁ ▁ ▁ the ▁ imul ▁ and ▁ the ▁ loading ▁ of ▁ the ▁ constant ▁ to ▁ consider <strnewline> ▁ ▁ ▁ ▁ the ▁ corresponding ▁ code-block ▁ an ▁ optimized ▁ division, ▁ defaults ▁ to ▁ 5. <strnewline> ▁ ▁ ▁ ▁ Use ▁ with ▁ care, ▁ default ▁ value ▁ should ▁ work ▁ in ▁ most ▁ cases. <strnewline> ▁ ▁ ▁ ▁ If ▁ it ▁ does ▁ not, ▁ it ▁ is ▁ advised ▁ to ▁ extract ▁ the ▁ parameters ▁ by ▁ hand <strnewline> ▁ ▁ ▁ ▁ and ▁ call ▁ the ▁ module ▁ in ▁ interactive ▁ mode ▁ (see ▁ below). '''  ) <newline> ARG_PARSER . add_argument ( '--next-sar-threshold' , help =  ''' Maximal ▁ index-difference ▁ between ▁ the <strnewline> ▁ ▁ ▁ ▁ right-shift ▁ and ▁ the ▁ loading ▁ of ▁ the ▁ constant ▁ to ▁ consider ▁ the ▁ corresponding <strnewline> ▁ ▁ ▁ ▁ code-block ▁ an ▁ optimized ▁ division, ▁ defaults ▁ to ▁ 9. ▁ Use ▁ with ▁ care, ▁ default <strnewline> ▁ ▁ ▁ ▁ value ▁ should ▁ work ▁ in ▁ most ▁ cases. ▁ If ▁ it ▁ does ▁ not, ▁ it ▁ is ▁ advised ▁ to <strnewline> ▁ ▁ ▁ ▁ extract ▁ the ▁ parameters ▁ by ▁ hand ▁ and ▁ call ▁ the ▁ module ▁ in ▁ interactive <strnewline> ▁ ▁ ▁ ▁ mode ▁ (see ▁ below). '''  ) <newline> ARG_PARSER . add_argument ( '--interactive' , '-i' , action = 'store_true' , help =  ''' Ask ▁ the ▁ user ▁ for ▁ input ▁ and ▁ process ▁ it ▁ as ▁ if <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ it ▁ was ▁ extracted ▁ from ▁ an ▁ assembly-listing. <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Overrides ▁ all ▁ other ▁ options. '''  ) <newline> SOURCE = '../../tests/division_analysis/main.asm' <newline> ARGS = ARG_PARSER . parse_args ( ) <newline> if ARGS . source : <newline> <indent> SOURCE = ARGS . source <newline> <dedent> if ARGS . output : <newline> <indent> sys . stdout = open ( ARGS . output , 'wb' ) <newline> <dedent> LINES = [ line . strip ( ' \n ' ) for line in open ( SOURCE , 'rb' ) . readlines ( ) ] <newline> if not ARGS . interactive : <newline> <indent> DIV = DivisionParser ( LINES ) <newline> if ARGS . next_imul_threshold : <newline> <indent> DIV . next_imul = int ( ARGS . next_imul_threshold ) <newline> <dedent> if ARGS . next_sar_threshold : <newline> <indent> DIV . next_sar = int ( ARGS . next_sar_threshold ) <newline> <dedent> DIV . find_interesting_code_sequences ( ) <newline> <dedent> else : <newline> <indent> DIV = DivisionParser ( LINES ) <newline> MAGIC_NUMBER = raw_input ( 'Enter ▁ constant ▁ as ▁ hex ▁ number ▁ prefixed\ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ by ▁ 0x ▁ (input ▁ not ▁ verified!): ▁ ' ) <newline> RIGHT_SHIFT = int ( raw_input ( 'Enter ▁ RIGHT_SHIFT ▁ amount\ <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ (must ▁ be ▁ int, ▁ input ▁ not ▁ verified): ▁ ' ) ) <newline> print 'Divisor ▁ seems ▁ to ▁ be ▁ ' + str ( get_divisor ( MAGIC_NUMBER , RIGHT_SHIFT ) ) + '.' <newline> <dedent> <dedent>
 # ▁ (c) ▁ 2017, ▁ Toshio ▁ Kuratomi ▁ <tkuratomi@ansible.com> <encdom>  # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible <encdom>  # ▁ Ansible ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <encdom>  # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by <encdom>  # ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License, ▁ or <encdom>  # ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <encdom>  # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License <encdom>  # ▁ along ▁ with ▁ Ansible. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <encdom>  # ▁ Make ▁ coding ▁ more ▁ python3-ish <encdom> from __future__ import ( absolute_import , division , print_function ) <newline> __metaclass__ = type <newline> import imp <newline> import zipfile <newline> from collections import namedtuple <newline> from functools import partial <newline> from io import BytesIO , StringIO <newline> import pytest <newline> import ansible . errors <newline> from ansible . compat . six import PY2 <newline> from ansible . compat . six . moves import builtins <newline> from ansible . executor . module_common import recursive_finder <newline> original_find_module = imp . find_module <newline> @ pytest . fixture <newline> def finder_containers ( ) : <newline> <indent> FinderContainers = namedtuple ( 'FinderContainers' , [ 'py_module_names' , 'py_module_cache' , 'zf' ] ) <newline> py_module_names = set ( ) <newline>  # py_module_cache ▁ = ▁ {('__init__',): ▁ b''} <encdom> py_module_cache = { } <newline> zipoutput = BytesIO ( ) <newline> zf = zipfile . ZipFile ( zipoutput , mode = 'w' , compression = zipfile . ZIP_STORED ) <newline>  # zf.writestr('ansible/__init__.py', ▁ b'') <encdom> return FinderContainers ( py_module_names , py_module_cache , zf ) <newline> <dedent> def find_module_foo ( module_utils_data , * args , ** kwargs ) : <newline> <indent> if args [ 0 ] == 'foo' : <newline> <indent> return ( module_utils_data , '/usr/lib/python2.7/site-packages/ansible/module_utils/foo.py' , ( '.py' , 'r' , imp . PY_SOURCE ) ) <newline> <dedent> return original_find_module ( * args , ** kwargs ) <newline> <dedent> def find_package_foo ( module_utils_data , * args , ** kwargs ) : <newline> <indent> if args [ 0 ] == 'foo' : <newline> <indent> return ( module_utils_data , '/usr/lib/python2.7/site-packages/ansible/module_utils/foo' , ( '' , '' , imp . PKG_DIRECTORY ) ) <newline> <dedent> return original_find_module ( * args , ** kwargs ) <newline> <dedent> class TestRecursiveFinder ( object ) : <newline> <indent> def test_no_module_utils ( self , finder_containers ) : <newline> <indent> name = 'ping' <newline> data = b' # !/usr/bin/python \n return ▁ \'{\"changed\": ▁ false}\'' <newline> recursive_finder ( name , data , * finder_containers ) <newline> assert finder_containers . py_module_names == set ( ( ) ) <newline> assert finder_containers . py_module_cache == { } <newline> assert frozenset ( finder_containers . zf . namelist ( ) ) == frozenset ( ) <newline> <dedent> def test_from_import_toplevel_package ( self , finder_containers , mocker ) : <newline> <indent> if PY2 : <newline> <indent> module_utils_data = BytesIO ( b' # ▁ License \n def ▁ do_something(): \n ▁ ▁ ▁ ▁ pass \n ' ) <newline> <dedent> else : <newline> <indent> module_utils_data = StringIO ( u' # ▁ License \n def ▁ do_something(): \n ▁ ▁ ▁ ▁ pass \n ' ) <newline> <dedent> mocker . patch ( 'imp.find_module' , side_effect = partial ( find_package_foo , module_utils_data ) ) <newline> mocker . patch ( 'ansible.executor.module_common._slurp' , side_effect = lambda x : b' # ▁ License \n def ▁ do_something(): \n ▁ ▁ ▁ ▁ pass \n ' ) <newline> name = 'ping' <newline> data = b' # !/usr/bin/python \n from ▁ ansible.module_utils ▁ import ▁ foo' <newline> recursive_finder ( name , data , * finder_containers ) <newline> mocker . stopall ( ) <newline> assert finder_containers . py_module_names == set ( ( ( 'foo' , '__init__' ) , ) ) <newline> assert finder_containers . py_module_cache == { } <newline> assert frozenset ( finder_containers . zf . namelist ( ) ) == frozenset ( ( 'ansible/module_utils/foo/__init__.py' , ) ) <newline> <dedent> def test_from_import_toplevel_module ( self , finder_containers , mocker ) : <newline> <indent> if PY2 : <newline> <indent> module_utils_data = BytesIO ( b' # ▁ License \n def ▁ do_something(): \n ▁ ▁ ▁ ▁ pass \n ' ) <newline> <dedent> else : <newline> <indent> module_utils_data = StringIO ( u' # ▁ License \n def ▁ do_something(): \n ▁ ▁ ▁ ▁ pass \n ' ) <newline> <dedent> mocker . patch ( 'imp.find_module' , side_effect = partial ( find_module_foo , module_utils_data ) ) <newline> name = 'ping' <newline> data = b' # !/usr/bin/python \n from ▁ ansible.module_utils ▁ import ▁ foo' <newline> recursive_finder ( name , data , * finder_containers ) <newline> mocker . stopall ( ) <newline> assert finder_containers . py_module_names == set ( ( ( 'foo' , ) , ) ) <newline> assert finder_containers . py_module_cache == { } <newline> assert frozenset ( finder_containers . zf . namelist ( ) ) == frozenset ( ( 'ansible/module_utils/foo.py' , ) ) <newline>  # ▁ Test ▁ importing ▁ six ▁ with ▁ many ▁ permutations ▁ because ▁ it ▁ is ▁ not ▁ a ▁ normal ▁ module <encdom> <dedent> def test_from_import_six ( self , finder_containers ) : <newline> <indent> name = 'ping' <newline> data = b' # !/usr/bin/python \n from ▁ ansible.module_utils ▁ import ▁ six' <newline> recursive_finder ( name , data , * finder_containers ) <newline> assert finder_containers . py_module_names == set ( ( ( 'six' , ) , ) ) <newline> assert finder_containers . py_module_cache == { } <newline> assert frozenset ( finder_containers . zf . namelist ( ) ) == frozenset ( ( 'ansible/module_utils/six.py' , ) ) <newline> <dedent> def test_import_six ( self , finder_containers ) : <newline> <indent> name = 'ping' <newline> data = b' # !/usr/bin/python \n import ▁ ansible.module_utils.six' <newline> recursive_finder ( name , data , * finder_containers ) <newline> assert finder_containers . py_module_names == set ( ( ( 'six' , ) , ) ) <newline> assert finder_containers . py_module_cache == { } <newline> assert frozenset ( finder_containers . zf . namelist ( ) ) == frozenset ( ( 'ansible/module_utils/six.py' , ) ) <newline> <dedent> def test_import_six_from_many_submodules ( self , finder_containers ) : <newline> <indent> name = 'ping' <newline> data = b' # !/usr/bin/python \n from ▁ ansible.module_utils.six.moves.urllib.parse ▁ import ▁ urlparse' <newline> recursive_finder ( name , data , * finder_containers ) <newline> assert finder_containers . py_module_names == set ( ( ( 'six' , ) , ) ) <newline> assert finder_containers . py_module_cache == { } <newline> assert frozenset ( finder_containers . zf . namelist ( ) ) == frozenset ( ( 'ansible/module_utils/six.py' , ) ) <newline> <dedent> <dedent>
 # !/usr/bin/python <encdom>  # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  # ▁ Copyright ▁ 2015 ▁ clowwindy <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); ▁ you ▁ may <encdom>  # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. ▁ You ▁ may ▁ obtain <encdom>  # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, ▁ WITHOUT <encdom>  # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. ▁ See ▁ the <encdom>  # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations <encdom>  # ▁ under ▁ the ▁ License. <encdom> from __future__ import absolute_import , division , print_function , with_statement <newline> import sys <newline> import os <newline> import signal <newline> import select <newline> import time <newline> import argparse <newline> from subprocess import Popen , PIPE <newline> python = [ 'python' ] <newline> default_url = 'http://localhost/' <newline> parser = argparse . ArgumentParser ( description = 'test ▁ Shadowsocks' ) <newline> parser . add_argument ( '-c' , '--client-conf' , type = str , default = None ) <newline> parser . add_argument ( '-s' , '--server-conf' , type = str , default = None ) <newline> parser . add_argument ( '-a' , '--client-args' , type = str , default = None ) <newline> parser . add_argument ( '-b' , '--server-args' , type = str , default = None ) <newline> parser . add_argument ( '--with-coverage' , action = 'store_true' , default = None ) <newline> parser . add_argument ( '--should-fail' , action = 'store_true' , default = None ) <newline> parser . add_argument ( '--tcp-only' , action = 'store_true' , default = None ) <newline> parser . add_argument ( '--url' , type = str , default = default_url ) <newline> parser . add_argument ( '--dns' , type = str , default = '8.8.8.8' ) <newline> config = parser . parse_args ( ) <newline> if config . with_coverage : <newline> <indent> python = [ 'coverage' , 'run' , '-p' , '-a' ] <newline> <dedent> client_args = python + [ 'shadowsocks/local.py' , '-v' ] <newline> server_args = python + [ 'shadowsocks/server.py' , '-v' ] <newline> if config . client_conf : <newline> <indent> client_args . extend ( [ '-c' , config . client_conf ] ) <newline> if config . server_conf : <newline> <indent> server_args . extend ( [ '-c' , config . server_conf ] ) <newline> <dedent> else : <newline> <indent> server_args . extend ( [ '-c' , config . client_conf ] ) <newline> <dedent> <dedent> if config . client_args : <newline> <indent> client_args . extend ( config . client_args . split ( ) ) <newline> if config . server_args : <newline> <indent> server_args . extend ( config . server_args . split ( ) ) <newline> <dedent> else : <newline> <indent> server_args . extend ( config . client_args . split ( ) ) <newline> <dedent> <dedent> if config . url == default_url : <newline> <indent> server_args . extend ( [ '--forbidden-ip' , '' ] ) <newline> <dedent> p1 = Popen ( server_args , stdin = PIPE , stdout = PIPE , stderr = PIPE , close_fds = True ) <newline> p2 = Popen ( client_args , stdin = PIPE , stdout = PIPE , stderr = PIPE , close_fds = True ) <newline> p3 = None <newline> p4 = None <newline> p3_fin = False <newline> p4_fin = False <newline>  # ▁ 1 ▁ shadowsocks ▁ started <encdom>  # ▁ 2 ▁ curl ▁ started <encdom>  # ▁ 3 ▁ curl ▁ finished <encdom>  # ▁ 4 ▁ dig ▁ started <encdom>  # ▁ 5 ▁ dig ▁ finished <encdom> stage = 1 <newline> try : <newline> <indent> local_ready = False <newline> server_ready = False <newline> fdset = [ p1 . stdout , p2 . stdout , p1 . stderr , p2 . stderr ] <newline> while True : <newline> <indent> r , w , e = select . select ( fdset , [ ] , fdset ) <newline> if e : <newline> <indent> break <newline> <dedent> for fd in r : <newline> <indent> line = fd . readline ( ) <newline> if not line : <newline> <indent> if stage == 2 and fd == p3 . stdout : <newline> <indent> stage = 3 <newline> <dedent> if stage == 4 and fd == p4 . stdout : <newline> <indent> stage = 5 <newline> <dedent> <dedent> if bytes != str : <newline> <indent> line = str ( line , 'utf8' ) <newline> <dedent> sys . stderr . write ( line ) <newline> if line . find ( 'starting ▁ local' ) >= 0 : <newline> <indent> local_ready = True <newline> <dedent> if line . find ( 'starting ▁ server' ) >= 0 : <newline> <indent> server_ready = True <newline> <dedent> <dedent> if stage == 1 : <newline> <indent> time . sleep ( 2 ) <newline> p3 = Popen ( [ 'curl' , config . url , '-v' , '-L' , '--socks5-hostname' , '127.0.0.1:1081' , '-m' , '15' , '--connect-timeout' , '10' ] , stdin = PIPE , stdout = PIPE , stderr = PIPE , close_fds = True ) <newline> if p3 is not None : <newline> <indent> fdset . append ( p3 . stdout ) <newline> fdset . append ( p3 . stderr ) <newline> stage = 2 <newline> <dedent> else : <newline> <indent> sys . exit ( 1 ) <newline> <dedent> <dedent> if stage == 3 and p3 is not None : <newline> <indent> fdset . remove ( p3 . stdout ) <newline> fdset . remove ( p3 . stderr ) <newline> r = p3 . wait ( ) <newline> if config . should_fail : <newline> <indent> if r == 0 : <newline> <indent> sys . exit ( 1 ) <newline> <dedent> <dedent> else : <newline> <indent> if r != 0 : <newline> <indent> sys . exit ( 1 ) <newline> <dedent> <dedent> if config . tcp_only : <newline> <indent> break <newline> <dedent> p4 = Popen ( [ 'socksify' , 'dig' , '@%s' % config . dns , 'www.google.com' ] , stdin = PIPE , stdout = PIPE , stderr = PIPE , close_fds = True ) <newline> if p4 is not None : <newline> <indent> fdset . append ( p4 . stdout ) <newline> fdset . append ( p4 . stderr ) <newline> stage = 4 <newline> <dedent> else : <newline> <indent> sys . exit ( 1 ) <newline> <dedent> <dedent> if stage == 5 : <newline> <indent> r = p4 . wait ( ) <newline> if config . should_fail : <newline> <indent> if r == 0 : <newline> <indent> sys . exit ( 1 ) <newline> <dedent> print ( 'test ▁ passed ▁ (expecting ▁ failure)' ) <newline> <dedent> else : <newline> <indent> if r != 0 : <newline> <indent> sys . exit ( 1 ) <newline> <dedent> print ( 'test ▁ passed' ) <newline> <dedent> break <newline> <dedent> <dedent> <dedent> finally : <newline> <indent> for p in [ p1 , p2 ] : <newline> <indent> try : <newline> <indent> os . kill ( p . pid , signal . SIGINT ) <newline> os . waitpid ( p . pid , 0 ) <newline> <dedent> except OSError : <newline> <indent> pass <newline> <dedent> <dedent> <dedent>
 # ▁ ToHTML ▁ (c) ▁ 2002, ▁ 2003, ▁ 2005, ▁ 2006, ▁ 2007, ▁ 2008 <encdom>  # ▁ David ▁ Turner ▁ <david@freetype.org> <encdom> from sources import * <newline> from content import * <newline> from formatter import * <newline> import time <newline>  # ▁ The ▁ following ▁ defines ▁ the ▁ HTML ▁ header ▁ used ▁ by ▁ all ▁ generated ▁ pages. <encdom> html_header_1 =  """ \ <strnewline> <!DOCTYPE ▁ HTML ▁ PUBLIC ▁"-//W3C//DTD ▁ HTML ▁ 4.01 ▁ Transitional//EN" <strnewline>"http://www.w3.org/TR/html4/loose.dtd"> <strnewline> <html> <strnewline> <head> <strnewline> <meta ▁ http-equiv="Content-Type" ▁ content="text/html; ▁ charset=utf-8"> <strnewline> <title>\ <strnewline> """  <newline> html_header_2 =  """ \ <strnewline> ▁ API ▁ Reference</title> <strnewline> <style ▁ type="text/css"> <strnewline> ▁ ▁ body ▁ { ▁ font-family: ▁ Verdana, ▁ Geneva, ▁ Arial, ▁ Helvetica, ▁ serif; <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ color: ▁ # 000000; <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ background: ▁ # FFFFFF; ▁ } <strnewline> <strnewline> ▁ ▁ p ▁ { ▁ text-align: ▁ justify; ▁ } <strnewline> ▁ ▁ h1 ▁ { ▁ text-align: ▁ center; ▁ } <strnewline> ▁ ▁ li ▁ { ▁ text-align: ▁ justify; ▁ } <strnewline> ▁ ▁ td ▁ { ▁ padding: ▁ 0 ▁ 0.5em ▁ 0 ▁ 0.5em; ▁ } <strnewline> ▁ ▁ td.left ▁ { ▁ padding: ▁ 0 ▁ 0.5em ▁ 0 ▁ 0.5em; <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ text-align: ▁ left; ▁ } <strnewline> <strnewline> ▁ ▁ a:link ▁ { ▁ color: ▁ # 0000EF; ▁ } <strnewline> ▁ ▁ a:visited ▁ { ▁ color: ▁ # 51188E; ▁ } <strnewline> ▁ ▁ a:hover ▁ { ▁ color: ▁ # FF0000; ▁ } <strnewline> <strnewline> ▁ ▁ span.keyword ▁ { ▁ font-family: ▁ monospace; <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ text-align: ▁ left; <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ white-space: ▁ pre; <strnewline> ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ color: ▁ darkblue; ▁ } <strnewline> <strnewline> ▁ ▁ pre.colored ▁ { ▁ color: ▁ blue; ▁ } <strnewline> <strnewline> ▁ ▁ ul.empty ▁ { ▁ list-style-type: ▁ none; ▁ } <strnewline> </style> <strnewline> </head> <strnewline> <body> <strnewline> """  <newline> html_header_3 =  """ <strnewline> <table ▁ align=center><tr><td><font ▁ size=-1>[<a ▁ href="\ <strnewline> """  <newline> html_header_3i =  """ <strnewline> <table ▁ align=center><tr><td ▁ width="100%"></td> <strnewline> <td><font ▁ size=-1>[<a ▁ href="\ <strnewline> """  <newline> html_header_4 =  """ \ <strnewline>">Index</a>]</font></td> <strnewline> <td ▁ width="100%"></td> <strnewline> <td><font ▁ size=-1>[<a ▁ href="\ <strnewline> """  <newline> html_header_5 =  """ \ <strnewline> ">TOC</a>]</font></td></tr></table> <strnewline> <center><h1>\ <strnewline> """  <newline> html_header_5t =  """ \ <strnewline>">Index</a>]</font></td> <strnewline> <td ▁ width="100%"></td></tr></table> <strnewline> <center><h1>\ <strnewline> """  <newline> html_header_6 =  """ \ <strnewline> ▁ API ▁ Reference</h1></center> <strnewline> """  <newline>  # ▁ The ▁ HTML ▁ footer ▁ used ▁ by ▁ all ▁ generated ▁ pages. <encdom> html_footer =  """ \ <strnewline> </body> <strnewline> </html>\ <strnewline> """  <newline>  # ▁ The ▁ header ▁ and ▁ footer ▁ used ▁ for ▁ each ▁ section. <encdom> section_title_header = "<center><h1>" <newline> section_title_footer = "</h1></center>" <newline>  # ▁ The ▁ header ▁ and ▁ footer ▁ used ▁ for ▁ code ▁ segments. <encdom> code_header = '<pre ▁ class="colored">' <newline> code_footer = '</pre>' <newline>  # ▁ Paragraph ▁ header ▁ and ▁ footer. <encdom> para_header = "<p>" <newline> para_footer = "</p>" <newline>  # ▁ Block ▁ header ▁ and ▁ footer. <encdom> block_header = '<table ▁ align=center ▁ width="75%"><tr><td>' <newline> block_footer_start =  """ \ <strnewline> </td></tr></table> <strnewline> <hr ▁ width="75%"> <strnewline> <table ▁ align=center ▁ width="75%"><tr><td><font ▁ size=-2>[<a ▁ href="\ <strnewline> """  <newline> block_footer_middle =  """ \ <strnewline>">Index</a>]</font></td> <strnewline> <td ▁ width="100%"></td> <strnewline> <td><font ▁ size=-2>[<a ▁ href="\ <strnewline> """  <newline> block_footer_end =  """ \ <strnewline> ">TOC</a>]</font></td></tr></table> <strnewline> """  <newline>  # ▁ Description ▁ header/footer. <encdom> description_header = '<table ▁ align=center ▁ width="87%"><tr><td>' <newline> description_footer = "</td></tr></table><br>" <newline>  # ▁ Marker ▁ header/inter/footer ▁ combination. <encdom> marker_header = '<table ▁ align=center ▁ width="87%" ▁ cellpadding=5><tr ▁ bgcolor=" # EEEEFF"><td><em><b>' <newline> marker_inter = "</b></em></td></tr><tr><td>" <newline> marker_footer = "</td></tr></table>" <newline>  # ▁ Header ▁ location ▁ header/footer. <encdom> header_location_header = '<table ▁ align=center ▁ width="87%"><tr><td>' <newline> header_location_footer = "</td></tr></table><br>" <newline>  # ▁ Source ▁ code ▁ extracts ▁ header/footer. <encdom> source_header = '<table ▁ align=center ▁ width="87%"><tr ▁ bgcolor=" # D6E8FF"><td><pre> \n ' <newline> source_footer = " \n </pre></table><br>" <newline>  # ▁ Chapter ▁ header/inter/footer. <encdom> chapter_header = '<br><table ▁ align=center ▁ width="75%"><tr><td><h2>' <newline> chapter_inter = '</h2><ul ▁ class="empty"><li>' <newline> chapter_footer = '</li></ul></td></tr></table>' <newline>  # ▁ Index ▁ footer. <encdom> index_footer_start =  """ \ <strnewline> <hr> <strnewline> <table><tr><td ▁ width="100%"></td> <strnewline> <td><font ▁ size=-2>[<a ▁ href="\ <strnewline> """  <newline> index_footer_end =  """ \ <strnewline> ">TOC</a>]</font></td></tr></table> <strnewline> """  <newline>  # ▁ TOC ▁ footer. <encdom> toc_footer_start =  """ \ <strnewline> <hr> <strnewline> <table><tr><td><font ▁ size=-2>[<a ▁ href="\ <strnewline> """  <newline> toc_footer_end =  """ \ <strnewline>">Index</a>]</font></td> <strnewline> <td ▁ width="100%"></td> <strnewline> </tr></table> <strnewline> """  <newline>  # ▁ source ▁ language ▁ keyword ▁ coloration/styling <encdom> keyword_prefix = '<span ▁ class="keyword">' <newline> keyword_suffix = '</span>' <newline> section_synopsis_header = '<h2>Synopsis</h2>' <newline> section_synopsis_footer = '' <newline>  # ▁ Translate ▁ a ▁ single ▁ line ▁ of ▁ source ▁ to ▁ HTML. ▁ This ▁ will ▁ convert <encdom>  # ▁ a ▁"<" ▁ into ▁"&lt.", ▁">" ▁ into ▁"&gt.", ▁ etc. <encdom> def html_quote ( line ) : <newline> <indent> result = string . replace ( line , "&" , "&amp;" ) <newline> result = string . replace ( result , "<" , "&lt;" ) <newline> result = string . replace ( result , ">" , "&gt;" ) <newline> return result <newline>  # ▁ same ▁ as ▁'html_quote', ▁ but ▁ ignores ▁ left ▁ and ▁ right ▁ brackets <encdom> <dedent> def html_quote0 ( line ) : <newline> <indent> return string . replace ( line , "&" , "&amp;" ) <newline> <dedent> def dump_html_code ( lines , prefix = "" ) : <newline>  # ▁ clean ▁ the ▁ last ▁ empty ▁ lines <encdom> <indent> l = len ( self . lines ) <newline> while l > 0 and string . strip ( self . lines [ l - 1 ] ) == "" : <newline> <indent> l = l - 1 <newline>  # ▁ The ▁ code ▁ footer ▁ should ▁ be ▁ directly ▁ appended ▁ to ▁ the ▁ last ▁ code <encdom>  # ▁ line ▁ to ▁ avoid ▁ an ▁ additional ▁ blank ▁ line. <encdom> <dedent> print prefix + code_header , <newline> for line in self . lines [ 0 : l + 1 ] : <newline> <indent> print ' \n ' + prefix + html_quote ( line ) , <newline> <dedent> print prefix + code_footer , <newline> <dedent> class HtmlFormatter ( Formatter ) : <newline> <indent> def __init__ ( self , processor , project_title , file_prefix ) : <newline> <indent> Formatter . __init__ ( self , processor ) <newline> global html_header_1 , html_header_2 , html_header_3 <newline> global html_header_4 , html_header_5 , html_footer <newline> if file_prefix : <newline> <indent> file_prefix = file_prefix + "-" <newline> <dedent> else : <newline> <indent> file_prefix = "" <newline> <dedent> self . headers = processor . headers <newline> self . project_title = project_title <newline> self . file_prefix = file_prefix <newline> self . html_header = html_header_1 + project_title + html_header_2 + html_header_3 + file_prefix + "index.html" + html_header_4 + file_prefix + "toc.html" + html_header_5 + project_title + html_header_6 <newline> self . html_index_header = html_header_1 + project_title + html_header_2 + html_header_3i + file_prefix + "toc.html" + html_header_5 + project_title + html_header_6 <newline> self . html_toc_header = html_header_1 + project_title + html_header_2 + html_header_3 + file_prefix + "index.html" + html_header_5t + project_title + html_header_6 <newline> self . html_footer = "<center><font ▁ size=" "-2" ">generated ▁ on ▁ " + time . asctime ( time . localtime ( time . time ( ) ) ) + "</font></center>" + html_footer <newline> self . columns = 3 <newline> <dedent> def make_section_url ( self , section ) : <newline> <indent> return self . file_prefix + section . name + ".html" <newline> <dedent> def make_block_url ( self , block ) : <newline> <indent> return self . make_section_url ( block . section ) + " # " + block . name <newline> <dedent> def make_html_words ( self , words ) : <newline> <indent>  """ ▁ convert ▁ a ▁ series ▁ of ▁ simple ▁ words ▁ into ▁ some ▁ HTML ▁ text ▁ """  <newline> line = "" <newline> if words : <newline> <indent> line = html_quote ( words [ 0 ] ) <newline> for w in words [ 1 : ] : <newline> <indent> line = line + " ▁ " + html_quote ( w ) <newline> <dedent> <dedent> return line <newline> <dedent> def make_html_word ( self , word ) : <newline> <indent>  """ analyze ▁ a ▁ simple ▁ word ▁ to ▁ detect ▁ cross-references ▁ and ▁ styling """  <newline>  # ▁ look ▁ for ▁ cross-references <encdom> m = re_crossref . match ( word ) <newline> if m : <newline> <indent> try : <newline> <indent> name = m . group ( 1 ) <newline> rest = m . group ( 2 ) <newline> block = self . identifiers [ name ] <newline> url = self . make_block_url ( block ) <newline> return '<a ▁ href="' + url + '">' + name + '</a>' + rest <newline> <dedent> except : <newline>  # ▁ we ▁ detected ▁ a ▁ cross-reference ▁ to ▁ an ▁ unknown ▁ item <encdom> <indent> sys . stderr . write ( "WARNING: ▁ undefined ▁ cross ▁ reference ▁ '" + name + "'. \n " ) <newline> return '?' + name + '?' + rest <newline>  # ▁ look ▁ for ▁ italics ▁ and ▁ bolds <encdom> <dedent> <dedent> m = re_italic . match ( word ) <newline> if m : <newline> <indent> name = m . group ( 1 ) <newline> rest = m . group ( 3 ) <newline> return '<i>' + name + '</i>' + rest <newline> <dedent> m = re_bold . match ( word ) <newline> if m : <newline> <indent> name = m . group ( 1 ) <newline> rest = m . group ( 3 ) <newline> return '<b>' + name + '</b>' + rest <newline> <dedent> return html_quote ( word ) <newline> <dedent> def make_html_para ( self , words ) : <newline> <indent>  """ ▁ convert ▁ words ▁ of ▁ a ▁ paragraph ▁ into ▁ tagged ▁ HTML ▁ text, ▁ handle ▁ xrefs ▁ """  <newline> line = "" <newline> if words : <newline> <indent> line = self . make_html_word ( words [ 0 ] ) <newline> for word in words [ 1 : ] : <newline> <indent> line = line + " ▁ " + self . make_html_word ( word ) <newline>  # ▁ convert ▁ `...' ▁ quotations ▁ into ▁ real ▁ left ▁ and ▁ right ▁ single ▁ quotes <encdom> <dedent> line = re . sub ( r"(^|\W)`(.*?)'(\W|$)" , r'\1&lsquo;\2&rsquo;\3' , line ) <newline>  # ▁ convert ▁ tilde ▁ into ▁ non-breakable ▁ space <encdom> line = string . replace ( line , "~" , "&nbsp;" ) <newline> <dedent> return para_header + line + para_footer <newline> <dedent> def make_html_code ( self , lines ) : <newline> <indent>  """ ▁ convert ▁ a ▁ code ▁ sequence ▁ to ▁ HTML ▁ """  <newline> line = code_header + ' \n ' <newline> for l in lines : <newline> <indent> line = line + html_quote ( l ) + ' \n ' <newline> <dedent> return line + code_footer <newline> <dedent> def make_html_items ( self , items ) : <newline> <indent>  """ ▁ convert ▁ a ▁ field's ▁ content ▁ into ▁ some ▁ valid ▁ HTML ▁ """  <newline> lines = [ ] <newline> for item in items : <newline> <indent> if item . lines : <newline> <indent> lines . append ( self . make_html_code ( item . lines ) ) <newline> <dedent> else : <newline> <indent> lines . append ( self . make_html_para ( item . words ) ) <newline> <dedent> <dedent> return string . join ( lines , ' \n ' ) <newline> <dedent> def print_html_items ( self , items ) : <newline> <indent> print self . make_html_items ( items ) <newline> <dedent> def print_html_field ( self , field ) : <newline> <indent> if field . name : <newline> <indent> print "<table><tr ▁ valign=top><td><b>" + field . name + "</b></td><td>" <newline> <dedent> print self . make_html_items ( field . items ) <newline> if field . name : <newline> <indent> print "</td></tr></table>" <newline> <dedent> <dedent> def html_source_quote ( self , line , block_name = None ) : <newline> <indent> result = "" <newline> while line : <newline> <indent> m = re_source_crossref . match ( line ) <newline> if m : <newline> <indent> name = m . group ( 2 ) <newline> prefix = html_quote ( m . group ( 1 ) ) <newline> length = len ( m . group ( 0 ) ) <newline> if name == block_name : <newline>  # ▁ this ▁ is ▁ the ▁ current ▁ block ▁ name, ▁ if ▁ any <encdom> <indent> result = result + prefix + '<b>' + name + '</b>' <newline> <dedent> elif re_source_keywords . match ( name ) : <newline>  # ▁ this ▁ is ▁ a ▁ C ▁ keyword <encdom> <indent> result = result + prefix + keyword_prefix + name + keyword_suffix <newline> <dedent> elif self . identifiers . has_key ( name ) : <newline>  # ▁ this ▁ is ▁ a ▁ known ▁ identifier <encdom> <indent> block = self . identifiers [ name ] <newline> result = result + prefix + '<a ▁ href="' + self . make_block_url ( block ) + '">' + name + '</a>' <newline> <dedent> else : <newline> <indent> result = result + html_quote ( line [ : length ] ) <newline> <dedent> line = line [ length : ] <newline> <dedent> else : <newline> <indent> result = result + html_quote ( line ) <newline> line = [ ] <newline> <dedent> <dedent> return result <newline> <dedent> def print_html_field_list ( self , fields ) : <newline> <indent> print "<p></p>" <newline> print "<table ▁ cellpadding=3 ▁ border=0>" <newline> for field in fields : <newline> <indent> if len ( field . name ) > 22 : <newline> <indent> print "<tr ▁ valign=top><td ▁ colspan=0><b>" + field . name + "</b></td></tr>" <newline> print "<tr ▁ valign=top><td></td><td>" <newline> <dedent> else : <newline> <indent> print "<tr ▁ valign=top><td><b>" + field . name + "</b></td><td>" <newline> <dedent> self . print_html_items ( field . items ) <newline> print "</td></tr>" <newline> <dedent> print "</table>" <newline> <dedent> def print_html_markup ( self , markup ) : <newline> <indent> table_fields = [ ] <newline> for field in markup . fields : <newline> <indent> if field . name : <newline>  # ▁ we ▁ begin ▁ a ▁ new ▁ series ▁ of ▁ field ▁ or ▁ value ▁ definitions, ▁ we <encdom>  # ▁ will ▁ record ▁ them ▁ in ▁ the ▁'table_fields' ▁ list ▁ before ▁ outputting <encdom>  # ▁ all ▁ of ▁ them ▁ as ▁ a ▁ single ▁ table <encdom> <indent> table_fields . append ( field ) <newline> <dedent> else : <newline> <indent> if table_fields : <newline> <indent> self . print_html_field_list ( table_fields ) <newline> table_fields = [ ] <newline> <dedent> self . print_html_items ( field . items ) <newline> <dedent> <dedent> if table_fields : <newline> <indent> self . print_html_field_list ( table_fields ) <newline>  # ▁ Formatting ▁ the ▁ index <encdom> <dedent> <dedent> def index_enter ( self ) : <newline> <indent> print self . html_index_header <newline> self . index_items = { } <newline> <dedent> def index_name_enter ( self , name ) : <newline> <indent> block = self . identifiers [ name ] <newline> url = self . make_block_url ( block ) <newline> self . index_items [ name ] = url <newline> <dedent> def index_exit ( self ) : <newline>  # ▁ block_index ▁ already ▁ contains ▁ the ▁ sorted ▁ list ▁ of ▁ index ▁ names <encdom> <indent> count = len ( self . block_index ) <newline> rows = ( count + self . columns - 1 ) / self . columns <newline> print "<table ▁ align=center ▁ border=0 ▁ cellpadding=0 ▁ cellspacing=0>" <newline> for r in range ( rows ) : <newline> <indent> line = "<tr>" <newline> for c in range ( self . columns ) : <newline> <indent> i = r + c * rows <newline> if i < count : <newline> <indent> bname = self . block_index [ r + c * rows ] <newline> url = self . index_items [ bname ] <newline> line = line + '<td><a ▁ href="' + url + '">' + bname + '</a></td>' <newline> <dedent> else : <newline> <indent> line = line + '<td></td>' <newline> <dedent> <dedent> line = line + "</tr>" <newline> print line <newline> <dedent> print "</table>" <newline> print index_footer_start + self . file_prefix + "toc.html" + index_footer_end <newline> print self . html_footer <newline> self . index_items = { } <newline> <dedent> def index_dump ( self , index_filename = None ) : <newline> <indent> if index_filename == None : <newline> <indent> index_filename = self . file_prefix + "index.html" <newline> <dedent> Formatter . index_dump ( self , index_filename ) <newline>  # ▁ Formatting ▁ the ▁ table ▁ of ▁ content <encdom> <dedent> def toc_enter ( self ) : <newline> <indent> print self . html_toc_header <newline> print "<center><h1>Table ▁ of ▁ Contents</h1></center>" <newline> <dedent> def toc_chapter_enter ( self , chapter ) : <newline> <indent> print chapter_header + string . join ( chapter . title ) + chapter_inter <newline> print "<table ▁ cellpadding=5>" <newline> <dedent> def toc_section_enter ( self , section ) : <newline> <indent> print '<tr ▁ valign=top><td ▁ class="left">' <newline> print '<a ▁ href="' + self . make_section_url ( section ) + '">' + section . title + '</a></td><td>' <newline> print self . make_html_para ( section . abstract ) <newline> <dedent> def toc_section_exit ( self , section ) : <newline> <indent> print "</td></tr>" <newline> <dedent> def toc_chapter_exit ( self , chapter ) : <newline> <indent> print "</table>" <newline> print chapter_footer <newline> <dedent> def toc_index ( self , index_filename ) : <newline> <indent> print chapter_header + '<a ▁ href="' + index_filename + '">Global ▁ Index</a>' + chapter_inter + chapter_footer <newline> <dedent> def toc_exit ( self ) : <newline> <indent> print toc_footer_start + self . file_prefix + "index.html" + toc_footer_end <newline> print self . html_footer <newline> <dedent> def toc_dump ( self , toc_filename = None , index_filename = None ) : <newline> <indent> if toc_filename == None : <newline> <indent> toc_filename = self . file_prefix + "toc.html" <newline> <dedent> if index_filename == None : <newline> <indent> index_filename = self . file_prefix + "index.html" <newline> <dedent> Formatter . toc_dump ( self , toc_filename , index_filename ) <newline>  # ▁ Formatting ▁ sections <encdom> <dedent> def section_enter ( self , section ) : <newline> <indent> print self . html_header <newline> print section_title_header <newline> print section . title <newline> print section_title_footer <newline> maxwidth = 0 <newline> for b in section . blocks . values ( ) : <newline> <indent> if len ( b . name ) > maxwidth : <newline> <indent> maxwidth = len ( b . name ) <newline> <dedent> <dedent> width = 70  # ▁ XXX ▁ magic ▁ number <encdom> <newline> if maxwidth < > 0 : <newline>  # ▁ print ▁ section ▁ synopsis <encdom> <indent> print section_synopsis_header <newline> print "<table ▁ align=center ▁ cellspacing=5 ▁ cellpadding=0 ▁ border=0>" <newline> columns = width / maxwidth <newline> if columns < 1 : <newline> <indent> columns = 1 <newline> <dedent> count = len ( section . block_names ) <newline> rows = ( count + columns - 1 ) / columns <newline> for r in range ( rows ) : <newline> <indent> line = "<tr>" <newline> for c in range ( columns ) : <newline> <indent> i = r + c * rows <newline> line = line + '<td></td><td>' <newline> if i < count : <newline> <indent> name = section . block_names [ i ] <newline> line = line + '<a ▁ href=" # ' + name + '">' + name + '</a>' <newline> <dedent> line = line + '</td>' <newline> <dedent> line = line + "</tr>" <newline> print line <newline> <dedent> print "</table><br><br>" <newline> print section_synopsis_footer <newline> <dedent> print description_header <newline> print self . make_html_items ( section . description ) <newline> print description_footer <newline> <dedent> def block_enter ( self , block ) : <newline> <indent> print block_header <newline>  # ▁ place ▁ html ▁ anchor ▁ if ▁ needed <encdom> if block . name : <newline> <indent> print '<h4><a ▁ name="' + block . name + '">' + block . name + '</a></h4>' <newline>  # ▁ dump ▁ the ▁ block ▁ C ▁ source ▁ lines ▁ now <encdom> <dedent> if block . code : <newline> <indent> header = '' <newline> for f in self . headers . keys ( ) : <newline> <indent> if block . source . filename . find ( f ) >= 0 : <newline> <indent> header = self . headers [ f ] + ' ▁ (' + f + ')' <newline> break ; <newline>  # ▁ if ▁ not ▁ header: <encdom>  # ▁ sys.stderr.write( ▁ \ <encdom>  # ▁'WARNING: ▁ No ▁ header ▁ macro ▁ for ▁ ' ▁ + ▁ block.source.filename ▁ + ▁'. \n ' ▁ ) <encdom> <dedent> <dedent> if header : <newline> <indent> print header_location_header <newline> print 'Defined ▁ in ▁ ' + header + '.' <newline> print header_location_footer <newline> <dedent> print source_header <newline> for l in block . code : <newline> <indent> print self . html_source_quote ( l , block . name ) <newline> <dedent> print source_footer <newline> <dedent> <dedent> def markup_enter ( self , markup , block ) : <newline> <indent> if markup . tag == "description" : <newline> <indent> print description_header <newline> <dedent> else : <newline> <indent> print marker_header + markup . tag + marker_inter <newline> <dedent> self . print_html_markup ( markup ) <newline> <dedent> def markup_exit ( self , markup , block ) : <newline> <indent> if markup . tag == "description" : <newline> <indent> print description_footer <newline> <dedent> else : <newline> <indent> print marker_footer <newline> <dedent> <dedent> def block_exit ( self , block ) : <newline> <indent> print block_footer_start + self . file_prefix + "index.html" + block_footer_middle + self . file_prefix + "toc.html" + block_footer_end <newline> <dedent> def section_exit ( self , section ) : <newline> <indent> print html_footer <newline> <dedent> def section_dump_all ( self ) : <newline> <indent> for section in self . sections : <newline> <indent> self . section_dump ( section , self . file_prefix + section . name + '.html' ) <newline>  # ▁ eof <encdom> <dedent> <dedent> <dedent>
from django . views . generic . base import TemplateView <newline> from braces . views import LoginRequiredMixin <newline> from openings . models import Opening <newline> from applications . models import Application <newline> from companysettings . models import InterviewStage <newline> class DashboardView ( LoginRequiredMixin , TemplateView ) : <newline> <indent> template_name = 'dashboard/dashboard.html' <newline> table_pagination = False <newline> def get_context_data ( self , ** kwargs ) : <newline> <indent> context = super ( DashboardView , self ) . get_context_data ( ** kwargs ) <newline> company = self . request . user . company <newline> context [ 'opening_list' ] = Opening . objects . filter ( company = company , published_date__isnull = False ) <newline> context [ 'interview_stages' ] = InterviewStage . objects . filter ( company = company ) <newline> context [ 'last_applications' ] = Application . objects . filter ( opening__company = company ) . select_related ( "opening" , "applicant" ) . order_by ( '-created' ) [ : 5 ] <newline> return context <newline> <dedent> <dedent>
from datetime import timedelta <newline> from fnmatch import fnmatch <newline> from glob import glob <newline> from operator import attrgetter <newline> import os <newline> from pathlib import Path <newline> import shutil <newline> import tempfile <newline> import zipfile <newline> import yaml <newline> import json <newline> try : <newline> <indent> from yaml import CBaseLoader as BaseYAMLLoader <newline> <dedent> except ImportError : <newline> <indent> from yaml import BaseLoader as BaseYAMLLoader <newline> <dedent> from django . conf import settings <newline> from django . template . defaultfilters import filesizeformat <newline> from lxml import etree <newline> from progressist import ProgressBar <newline> from requests import ConnectionError <newline> from ideascube . configuration import get_config , set_config <newline> from ideascube . mediacenter . forms import PackagedDocumentForm <newline> from ideascube . mediacenter . models import Document <newline> from ideascube . mediacenter . utils import guess_kind_from_filename <newline> from ideascube . models import User <newline> from ideascube . templatetags . ideascube_tags import smart_truncate <newline> from ideascube . utils import ( MetaRegistry , classproperty , get_file_sha256 , printerr , rm , urlretrieve , ) <newline> from . systemd import Manager as SystemManager , NoSuchUnit <newline> def load_from_basepath ( basepath ) : <newline> <indent> json_path = basepath + '.json' <newline> json_parsing_error = None <newline> try : <newline> <indent> return load_from_json_file ( json_path ) <newline> <dedent> except FileNotFoundError : <newline>  # ▁ Json ▁ file ▁ doesn't ▁ exists, ▁ let's ▁ try ▁ with ▁ the ▁ yml ▁ file. <encdom> <indent> pass <newline> <dedent> except ValueError as e : <newline>  # ▁ Something ▁ went ▁ wrong ▁ will ▁ decoding. <encdom>  # ▁ This ▁ could ▁ happen ▁ if ▁ we've ▁ parsed ▁ the ▁ yml ▁ wrongly ▁ and ▁ cannot <encdom>  # ▁ create ▁ a ▁ correct ▁ json. <encdom>  # ▁ Remove ▁ the ▁ json ▁ file ▁ and ▁ try ▁ to ▁ parse ▁ the ▁ yml ▁ again, <encdom>  # ▁ hopping ▁ that ▁ yml ▁ parsing ▁ has ▁ been ▁ fixed. <encdom> <indent> json_parsing_error = e <newline> pass <newline> <dedent> yml_path = basepath + '.yml' <newline> try : <newline> <indent> data = load_from_yml_file ( yml_path ) <newline> <dedent> except FileNotFoundError : <newline> <indent> if json_parsing_error is not None : <newline> <indent> raise json_parsing_error <newline> <dedent> raise <newline> <dedent> persist_to_file ( basepath , data ) <newline> os . remove ( yml_path ) <newline> return data <newline> <dedent> def load_from_json_file ( path ) : <newline> <indent> with open ( path , 'r' , encoding = 'utf-8' ) as f : <newline> <indent> content = f . read ( ) <newline> if not content : <newline> <indent> return None <newline> <dedent> return json . loads ( content ) <newline> <dedent> <dedent> def load_from_yml_file ( path ) : <newline> <indent> with open ( path , 'r' , encoding = 'utf-8' ) as f : <newline> <indent> return yaml . load ( f . read ( ) , Loader = BaseYAMLLoader ) <newline> <dedent> <dedent> def persist_to_file ( path , data ) : <newline> <indent>  """ Save ▁ catalog ▁ data ▁ to ▁ a ▁ local ▁ file <strnewline> <strnewline> ▁ Note: ▁ The ▁ function ▁ assumes ▁ that ▁ the ▁ data ▁ is ▁ serializable. <strnewline> ▁ """  <newline> json_path = path + '.json' <newline> with open ( json_path , 'w' , encoding = 'utf-8' ) as f : <newline> <indent> json . dump ( data , f , indent = 2 ) <newline> <dedent> <dedent> class InvalidFile ( Exception ) : <newline> <indent> pass <newline> <dedent> class MissingPackageMetadata ( Exception ) : <newline> <indent> def __init__ ( self , pkgid , missing_attribute ) : <newline> <indent> self . pkgid = pkgid <newline> self . missing_attribute = missing_attribute <newline> <dedent> def __str__ ( self ) : <newline> <indent> return "{self.pkgid} ▁ is ▁ missing ▁ a ▁ {self.missing_attribute}" . format ( self = self ) <newline> <dedent> <dedent> class InvalidPackageType ( Exception ) : <newline> <indent> def __init__ ( self , pkgid , type ) : <newline> <indent> self . pkgid = pkgid <newline> self . type = type <newline> <dedent> def __str__ ( self ) : <newline> <indent> return "{self.pkgid} ▁ has ▁ an ▁ invalid ▁ type: ▁ {self.type}" . format ( self = self ) <newline> <dedent> <dedent> class NoSuchPackage ( Exception ) : <newline> <indent> pass <newline> <dedent> class InvalidHandlerType ( Exception ) : <newline> <indent> pass <newline> <dedent> class InvalidPackageContent ( Exception ) : <newline> <indent> pass <newline> <dedent> class ExistingRemoteError ( Exception ) : <newline> <indent> def __init__ ( self , remote , conflict_attr ) : <newline> <indent> self . remote = remote <newline> self . conflict_attr = conflict_attr <newline> <dedent> def __str__ ( self ) : <newline> <indent> return ( 'A ▁ remote ▁ with ▁ this ▁ {self.conflict_attr} ▁ already ▁ exists: \n ' '{self.remote}' . format ( self = self ) ) <newline> <dedent> <dedent> class Remote : <newline> <indent> def __init__ ( self , id , name , url ) : <newline> <indent> self . id = id <newline> self . name = name <newline> self . url = url <newline> <dedent> @ classmethod <newline> def from_basepath ( cls , path ) : <newline> <indent> d = load_from_basepath ( path ) <newline> try : <newline> <indent> return cls ( d [ 'id' ] , d [ 'name' ] , d [ 'url' ] ) <newline> <dedent> except KeyError as e : <newline> <indent> raise InvalidFile ( 'Remote ▁ file ▁ is ▁ missing ▁ a ▁ {} ▁ key: ▁ {}' . format ( e , path ) ) <newline> <dedent> <dedent> def to_file ( self , path ) : <newline> <indent> d = { 'id' : self . id , 'name' : self . name , 'url' : self . url } <newline> persist_to_file ( path , d ) <newline> <dedent> def __str__ ( self ) : <newline> <indent> left = '[{self.id}] ▁ {self.name}' . format ( self = self ) <newline> return '{left:>35} ▁ : ▁ {self.url}' . format ( left = left , self = self ) <newline> <dedent> <dedent> class Handler : <newline> <indent> @ classproperty <newline> @ classmethod <newline> def _install_dir ( cls ) : <newline> <indent> name = cls . __name__ . lower ( ) <newline> default = os . path . join ( settings . STORAGE_ROOT , name ) <newline> setting = 'CATALOG_{}_INSTALL_DIR' . format ( name . upper ( ) ) <newline> return getattr ( settings , setting , default ) <newline> <dedent> @ classmethod <newline> def install ( cls , package , download_path ) : <newline> <indent> os . makedirs ( cls . _install_dir , exist_ok = True ) <newline> package . install ( download_path , cls . _install_dir ) <newline> <dedent> @ classmethod <newline> def remove ( cls , package ) : <newline> <indent> package . remove ( cls . _install_dir ) <newline> <dedent> @ classmethod <newline> def commit ( cls ) : <newline> <indent> pass <newline> <dedent> @ classmethod <newline> def restart_service ( cls , name ) : <newline> <indent> print ( 'Restarting ▁ service' , name ) <newline> try : <newline> <indent> manager = SystemManager ( ) <newline> service = manager . get_service ( name ) <newline> <dedent> except NoSuchUnit : <newline>  # ▁ Service ▁ is ▁ not ▁ installed, ▁ give ▁ up. <encdom> <indent> printerr ( 'No ▁ service ▁ named' , name ) <newline> <dedent> else : <newline> <indent> manager . restart ( service . Id ) <newline> <dedent> <dedent> <dedent> class Kiwix ( Handler ) : <newline> <indent> @ classmethod <newline> def commit ( cls ) : <newline> <indent> print ( 'Rebuilding ▁ the ▁ Kiwix ▁ library' ) <newline> library = etree . Element ( 'library' ) <newline> libdir = os . path . join ( cls . _install_dir , 'data' , 'library' ) <newline> os . makedirs ( libdir , exist_ok = True ) <newline> for libpath in glob ( os . path . join ( libdir , '*.xml' ) ) : <newline> <indent> zimname = os . path . basename ( libpath ) [ : - 4 ] <newline> with open ( libpath , 'r' ) as f : <newline> <indent> et = etree . parse ( f ) <newline> books = et . findall ( 'book' ) <newline>  # ▁ We ▁ only ▁ want ▁ to ▁ handle ▁ a ▁ single ▁ zim ▁ per ▁ zip <encdom> assert len ( books ) == 1 <newline> book = books [ 0 ] <newline> book . set ( 'path' , 'data/content/%s' % zimname ) <newline> index_path = 'data/index/%s.idx' % zimname <newline> if os . path . isdir ( os . path . join ( cls . _install_dir , index_path ) ) : <newline> <indent> book . set ( 'indexPath' , index_path ) <newline> <dedent> library . append ( book ) <newline> <dedent> <dedent> for zim_path in glob ( os . path . join ( cls . _install_dir , '*.zim' ) ) : <newline> <indent> zim_basename = os . path . basename ( zim_path ) <newline> book = etree . Element ( 'book' ) <newline> book . set ( 'id' , zim_basename [ : - 4 ] ) <newline> book . set ( 'path' , zim_basename ) <newline> library . append ( book ) <newline> <dedent> with open ( os . path . join ( cls . _install_dir , 'library.xml' ) , 'wb' ) as f : <newline> <indent> f . write ( etree . tostring ( library , xml_declaration = True , encoding = 'utf-8' ) ) <newline> <dedent> cls . restart_service ( 'kiwix-server' ) <newline> super ( ) . commit ( ) <newline> <dedent> <dedent> class Nginx ( Handler ) : <newline> <indent> pass <newline> <dedent> class MediaCenter ( Handler ) : <newline> <indent> pass <newline> <dedent> class Package ( metaclass = MetaRegistry ) : <newline> <indent> def __init__ ( self , id , metadata ) : <newline> <indent> self . id = id <newline> self . _metadata = metadata <newline> <dedent> def __eq__ ( self , other ) : <newline> <indent> return self . id == other . id and self . _metadata == other . _metadata <newline> <dedent> def __getattr__ ( self , name ) : <newline> <indent> try : <newline> <indent> return self . _metadata [ name ] <newline> <dedent> except KeyError : <newline> <indent> raise AttributeError ( name ) <newline> <dedent> <dedent> def __str__ ( self ) : <newline> <indent> return '{self.id}-{self.version}' . format ( self = self ) <newline> <dedent> @ property <newline> def version ( self ) : <newline>  # ▁ 0 ▁ has ▁ the ▁ advantage ▁ of ▁ always ▁ being ▁"smaller" ▁ than ▁ any ▁ other ▁ version <encdom> <indent> return self . _metadata . get ( 'version' , '0' ) <newline> <dedent> @ property <newline> def filesize ( self ) : <newline> <indent> try : <newline> <indent> return filesizeformat ( int ( self . size ) ) <newline> <dedent> except ValueError : <newline> <indent> return self . size <newline> <dedent> <dedent> def install ( self , download_path , install_dir ) : <newline> <indent> raise NotImplementedError ( 'Subclasses ▁ must ▁ implement ▁ this ▁ method' ) <newline> <dedent> def remove ( self , install_dir ) : <newline> <indent> raise NotImplementedError ( 'Subclasses ▁ must ▁ implement ▁ this ▁ method' ) <newline> <dedent> def assert_is_zipfile ( self , path ) : <newline> <indent> if not zipfile . is_zipfile ( path ) : <newline> <indent> rm ( path ) <newline> raise InvalidFile ( '{} ▁ is ▁ not ▁ a ▁ zip ▁ file' . format ( path ) ) <newline> <dedent> <dedent> <dedent> class BaseZim ( Package , no_register = True ) : <newline> <indent> handler = Kiwix <newline> template_id = "kiwix" <newline>  # ▁ [FIXME] ▁ Thoses ▁ two ▁ properties ▁ look ▁ like ▁ hacks. <encdom>  # ▁ We ▁ may ▁ want ▁ to ▁ find ▁ a ▁ way ▁ to ▁ find ▁ those ▁ information ▁ in ▁ the ▁ package ▁ or <encdom>  # ▁ catalog ▁ metadata. <encdom>  # ▁ For ▁ now, ▁ use ▁ special ▁ cases. <encdom> @ property <newline> def theme ( self ) : <newline>  # ▁ Strings ▁"discover", ▁"read" ▁ and ▁"learn" ▁ must ▁ be ▁ marked ▁ as ▁ translatable. <encdom>  # ▁ For ▁ this ▁ we ▁ use ▁ a ▁ dummy ▁ function ▁ who ▁ do ▁ nothing. <encdom>  # ▁ As ▁ the ▁ function ▁ is ▁ named ▁ _, ▁ gettext ▁ will ▁ mark ▁ the ▁ strings. <encdom> <indent> _ = lambda t : t <newline> base_name , extension = self . id . rsplit ( '.' , 1 ) <newline> if base_name in ( "wikipedia" , "wikivoyage" , "vikidia" ) : <newline> <indent> return _ ( "discover" ) <newline> <dedent> if base_name in ( "gutemberg" , "icd10" , "wikisource" , "wikibooks" , "bouquineux" ) : <newline> <indent> return _ ( "read" ) <newline> <dedent> return _ ( "learn" ) <newline> <dedent> @ property <newline> def css_class ( self ) : <newline> <indent> base_name , _ = self . id . rsplit ( '.' , 1 ) <newline> if base_name . startswith ( 'ted' ) : <newline> <indent> return 'ted' <newline> <dedent> return base_name <newline> <dedent> <dedent> class ZippedZim ( BaseZim , typename = 'zipped-zim' ) : <newline> <indent> def install ( self , download_path , install_dir ) : <newline> <indent> self . assert_is_zipfile ( download_path ) <newline> with zipfile . ZipFile ( download_path , "r" ) as z : <newline> <indent> names = z . namelist ( ) <newline> names = filter ( lambda n : n . startswith ( 'data/' ) , names ) <newline>  # ▁ Make ▁ it ▁ a ▁ list ▁ so ▁ we ▁ can ▁ reuse ▁ it ▁ later <encdom> names = list ( names ) <newline> z . extractall ( install_dir , members = names ) <newline> <dedent> datadir = os . path . join ( install_dir , 'data' ) <newline> for path in glob ( os . path . join ( datadir , '*' , '*.zim*' ) ) : <newline> <indent> relpath = os . path . relpath ( path , install_dir ) <newline> if os . path . isdir ( path ) : <newline>  # ▁ Dirs ▁ end ▁ with ▁ a ▁ / ▁ in ▁ the ▁ zip ▁ file ▁ list <encdom> <indent> relpath += '/' <newline> <dedent> if relpath not in names : <newline>  # ▁ Ignore ▁ zim ▁ files ▁ installed ▁ by ▁ other ▁ packages <encdom> <indent> continue <newline> <dedent> zimname = os . path . basename ( path ) . split ( '.zim' ) [ 0 ] + '.zim' <newline> new = path . replace ( zimname , '{0.id}.zim' . format ( self ) ) <newline> try : <newline> <indent> os . rename ( path , new ) <newline> <dedent> except OSError : <newline> <indent> rm ( new ) <newline> os . rename ( path , new ) <newline> <dedent> <dedent> <dedent> def remove ( self , install_dir ) : <newline> <indent> zimname = '{0.id}.zim*' . format ( self ) <newline> datadir = os . path . join ( install_dir , 'data' ) <newline> for path in glob ( os . path . join ( datadir , '*' , zimname ) ) : <newline> <indent> rm ( path ) <newline> <dedent> <dedent> <dedent> class Zim ( BaseZim , typename = 'zim' ) : <newline> <indent> def install ( self , download_path , install_dir ) : <newline> <indent> zim_name = '{self.id}.zim' . format ( self = self ) <newline> dest_name = os . path . join ( install_dir , zim_name ) <newline> shutil . copyfile ( download_path , dest_name ) <newline> <dedent> def remove ( self , install_dir ) : <newline> <indent> zimname = '{self.id}.zim' . format ( self = self ) <newline> rm ( os . path . join ( install_dir , zimname ) ) <newline> <dedent> <dedent> class SimpleZipPackage ( Package , no_register = True ) : <newline> <indent> def get_root_dir ( self , install_dir ) : <newline> <indent> return os . path . join ( install_dir , self . id ) <newline> <dedent> def install ( self , download_path , install_dir ) : <newline> <indent> self . assert_is_zipfile ( download_path ) <newline> with zipfile . ZipFile ( download_path , "r" ) as z : <newline> <indent> z . extractall ( self . get_root_dir ( install_dir ) ) <newline> <dedent> <dedent> def remove ( self , install_dir ) : <newline> <indent> try : <newline> <indent> shutil . rmtree ( self . get_root_dir ( install_dir ) ) <newline> <dedent> except FileNotFoundError as e : <newline> <indent> printerr ( e ) <newline> <dedent> <dedent> <dedent> class StaticSite ( SimpleZipPackage , typename = 'static-site' ) : <newline> <indent> template_id = 'static-site' <newline> handler = Nginx <newline>  # ▁ [FIXME] ▁ This ▁ propertie ▁ looks ▁ like ▁ hacks. <encdom> @ property <newline> def theme ( self ) : <newline>  # ▁ theme ▁ string ▁ must ▁ be ▁ marked ▁ as ▁ translatable. <encdom>  # ▁ For ▁ this ▁ we ▁ use ▁ a ▁ dummy ▁ function ▁ who ▁ do ▁ nothing. <encdom>  # ▁ As ▁ the ▁ function ▁ is ▁ named ▁ _, ▁ gettext ▁ will ▁ mark ▁ the ▁ strings. <encdom> <indent> _ = lambda t : t <newline> if '.map' in self . id or self . id in [ 'maguare.es' , 'cinescuela.es' ] : <newline> <indent> return _ ( 'discover' ) <newline> <dedent> return _ ( 'info' ) <newline> <dedent> @ property <newline> def css_class ( self ) : <newline> <indent> if '.map' in self . id : <newline> <indent> return 'maps' <newline> <dedent> base_name , * _ = self . id . split ( '.' ) <newline> return base_name <newline> <dedent> <dedent> class ZippedMedias ( SimpleZipPackage , typename = 'zipped-medias' ) : <newline> <indent> handler = MediaCenter <newline> template_id = "media-package" <newline> def remove ( self , install_dir ) : <newline>  # ▁ Easy ▁ part ▁ here. ▁ Just ▁ delete ▁ documents ▁ from ▁ the ▁ package. <encdom> <indent> Document . objects . filter ( package_id = self . id ) . delete ( ) <newline> super ( ) . remove ( install_dir ) <newline> <dedent> def install ( self , download_path , install_dir ) : <newline> <indent> super ( ) . install ( download_path , install_dir ) <newline> print ( 'Adding ▁ medias ▁ to ▁ mediacenter ▁ database.' ) <newline> root = self . get_root_dir ( install_dir ) <newline> manifestfile = Path ( root , 'manifest.yml' ) <newline> try : <newline> <indent> with manifestfile . open ( 'r' ) as m : <newline> <indent> manifest = yaml . load ( m . read ( ) , Loader = BaseYAMLLoader ) <newline> <dedent> <dedent> except FileNotFoundError : <newline> <indent> raise InvalidPackageContent ( 'Missing ▁ manifest ▁ file ▁ in ▁ {}' . format ( self . id ) ) <newline> <dedent> os . makedirs ( settings . MEDIA_ROOT , exist_ok = True ) <newline> catalog_path = os . path . join ( settings . MEDIA_ROOT , "catalog" ) <newline> try : <newline> <indent> os . symlink ( install_dir , catalog_path ) <newline> <dedent> except FileExistsError : <newline> <indent> if not os . path . islink ( catalog_path ) : <newline> <indent> printerr ( "Cannot ▁ install ▁ package ▁ {}. ▁ {} ▁ must ▁ not ▁ exist ▁ " "or ▁ being ▁ a ▁ symlink." . format ( self . id , catalog_path ) ) <newline> return <newline> <dedent> <dedent> pseudo_install_dir = os . path . join ( catalog_path , self . id ) <newline> for media in manifest [ 'medias' ] : <newline> <indent> try : <newline> <indent> self . _install_media ( media , pseudo_install_dir ) <newline> <dedent> except Exception as e : <newline>  # ▁ This ▁ can ▁ lead ▁ to ▁ installed ▁ package ▁ with ▁ uninstall ▁ media. <encdom>  # ▁ We ▁ sould ▁ handle ▁ this ▁ somehow. <encdom> <indent> printerr ( "Cannot ▁ install ▁ media ▁ {} ▁ from ▁ package ▁ {} ▁ : ▁ {}" . format ( media [ 'title' ] , self . id , e ) ) <newline> continue <newline> <dedent> <dedent> <dedent> def _install_media ( self , media_info , pseudo_install_dir ) : <newline> <indent> try : <newline> <indent> media_info [ 'title' ] = smart_truncate ( media_info [ 'title' ] . strip ( ) ) <newline> <dedent> except KeyError : <newline> <indent> raise InvalidPackageContent ( 'Missing ▁ title ▁ in ▁ {}' . format ( media_info ) ) <newline> <dedent> media_info [ 'lang' ] = media_info . get ( 'lang' , '' ) . strip ( ) . lower ( ) <newline> if not media_info [ 'lang' ] : <newline> <indent> raise InvalidPackageContent ( 'Missing ▁ lang ▁ in ▁ {}' . format ( media_info ) ) <newline> <dedent> kind = media_info . get ( 'kind' , '' ) . strip ( ) . lower ( ) <newline> if not kind or not hasattr ( Document , kind . upper ( ) ) : <newline> <indent> kind = guess_kind_from_filename ( media_info [ 'path' ] ) <newline> media_info [ 'kind' ] = kind or Document . OTHER <newline> <dedent> media_info [ 'package_id' ] = self . id <newline> media_info [ 'original' ] = os . path . join ( pseudo_install_dir , media_info [ 'path' ] ) <newline> if media_info . get ( 'preview' ) : <newline> <indent> media_info [ 'preview' ] = os . path . join ( pseudo_install_dir , media_info [ 'preview' ] ) <newline> <dedent> self . _save_media ( media_info , pseudo_install_dir ) <newline> <dedent> def _save_media ( self , metadata , install_dir ) : <newline> <indent> form = PackagedDocumentForm ( path = install_dir , data = metadata , instance = None ) <newline> if form . is_valid ( ) : <newline> <indent> form . save ( ) <newline> <dedent> else : <newline> <indent> lerr = [ "Some ▁ values ▁ are ▁ not ▁ valid ▁ :" ] <newline> for field , error in form . errors . items ( ) : <newline> <indent> lerr . append ( " ▁ - ▁ {}: ▁ {}" . format ( field , error . as_text ( ) ) ) <newline> <dedent> raise InvalidPackageContent ( " \n " . join ( lerr ) ) <newline> <dedent> <dedent> <dedent> class Bar ( ProgressBar ) : <newline> <indent> template = ( 'Downloading ▁ {item}: ▁ {percent} ▁ |{animation}| ▁ {done:B}/{total:B} ▁ ' '({speed:B}/s) ▁ | ▁ ETA: ▁ {eta}' ) <newline> throttle = timedelta ( seconds = 1 ) <newline> <dedent> class Catalog : <newline> <indent> def __init__ ( self ) : <newline> <indent> self . _cache_root = settings . CATALOG_CACHE_ROOT <newline> os . makedirs ( self . _cache_root , exist_ok = True ) <newline> self . _catalog_cache_basepath = os . path . join ( self . _cache_root , 'catalog' ) <newline> self . _local_package_cache = os . path . join ( self . _cache_root , 'packages' ) <newline> os . makedirs ( self . _local_package_cache , exist_ok = True ) <newline> self . _storage_root = settings . CATALOG_STORAGE_ROOT <newline> os . makedirs ( self . _storage_root , exist_ok = True ) <newline> self . _installed_storage_basepath = os . path . join ( self . _storage_root , 'installed' ) <newline> self . _remote_storage = os . path . join ( self . _storage_root , 'remotes' ) <newline> os . makedirs ( self . _remote_storage , exist_ok = True ) <newline> self . _remotes_value = None <newline> self . _available_value = None <newline> self . _installed_value = None <newline> self . _package_caches = [ self . _local_package_cache ] <newline> self . _bar = Bar ( ) <newline> <dedent> def _progress ( self , item , i , chunk_size , remote_size ) : <newline> <indent> self . _bar . update ( item = item , done = ( i + 1 ) * chunk_size , total = remote_size ) <newline>  # ▁ -- ▁ Manage ▁ packages ▁ ----- <encdom> <dedent> def _get_package ( self , id , source ) : <newline> <indent> try : <newline> <indent> metadata = source [ id ] <newline> <dedent> except KeyError : <newline> <indent> raise NoSuchPackage ( id ) <newline> <dedent> try : <newline> <indent> type = metadata [ 'type' ] <newline> <dedent> except KeyError : <newline> <indent> raise MissingPackageMetadata ( id , 'type' ) <newline> <dedent> try : <newline> <indent> return Package . registered_types [ type ] ( id , metadata ) <newline> <dedent> except KeyError : <newline> <indent> raise InvalidPackageType ( id , type ) <newline> <dedent> <dedent> def _expand_package_ids ( self , id_patterns , source ) : <newline> <indent> for id_pattern in id_patterns : <newline> <indent> if '*' in id_pattern : <newline> <indent> pkg_ids = [ pkg_id for pkg_id in source if fnmatch ( pkg_id , id_pattern ) ] <newline> if pkg_ids : <newline> <indent> yield from pkg_ids <newline> <dedent> else : <newline>  # ▁ The ▁ pattern ▁ could ▁ not ▁ be ▁ expanded, ▁ yield ▁ it ▁ back <encdom> <indent> yield id_pattern <newline> <dedent> <dedent> else : <newline> <indent> yield id_pattern <newline> <dedent> <dedent> <dedent> def _verify_sha256 ( self , path , sha256sum ) : <newline> <indent> sha = get_file_sha256 ( path ) <newline> return sha == sha256sum <newline> <dedent> def _fetch_package ( self , package ) : <newline> <indent> def _progress ( * args ) : <newline> <indent> self . _progress ( package . id , * args ) <newline> <dedent> filename = '{0.id}-{0.version}' . format ( package ) <newline> for cache in self . _package_caches : <newline> <indent> path = os . path . join ( cache , filename ) <newline> if os . path . isfile ( path ) : <newline> <indent> if self . _verify_sha256 ( path , package . sha256sum ) : <newline> <indent> return path <newline>  # ▁ This ▁ might ▁ be ▁ an ▁ incomplete ▁ download, ▁ try ▁ finishing ▁ it <encdom> <dedent> try : <newline> <indent> urlretrieve ( package . url , path , sha256sum = package . sha256sum , reporthook = _progress ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( e ) <newline> <dedent> <dedent> <dedent> path = os . path . join ( self . _local_package_cache , filename ) <newline> urlretrieve ( package . url , path , sha256sum = package . sha256sum , reporthook = _progress ) <newline> return path <newline> <dedent> def list_installed ( self , ids ) : <newline> <indent> ids = self . _expand_package_ids ( ids , self . _installed ) <newline> pkgs = [ ] <newline> for pkg_id in ids : <newline> <indent> try : <newline> <indent> pkgs . append ( self . _get_package ( pkg_id , self . _installed ) ) <newline> <dedent> except ( InvalidPackageType , MissingPackageMetadata , NoSuchPackage ) : <newline> <indent> continue <newline> <dedent> <dedent> return sorted ( pkgs , key = attrgetter ( 'id' ) ) <newline> <dedent> def list_available ( self , ids ) : <newline> <indent> ids = self . _expand_package_ids ( ids , self . _available ) <newline> pkgs = [ ] <newline> for pkg_id in ids : <newline> <indent> try : <newline> <indent> pkgs . append ( self . _get_package ( pkg_id , self . _available ) ) <newline> <dedent> except ( InvalidPackageType , MissingPackageMetadata , NoSuchPackage ) : <newline> <indent> continue <newline> <dedent> <dedent> return sorted ( pkgs , key = attrgetter ( 'id' ) ) <newline> <dedent> def list_upgradable ( self , ids ) : <newline> <indent> ids = self . _expand_package_ids ( ids , self . _installed ) <newline> pkgs = [ ] <newline> for pkg_id in ids : <newline> <indent> try : <newline> <indent> ipkg = self . _get_package ( pkg_id , self . _installed ) <newline> <dedent> except ( InvalidPackageType , MissingPackageMetadata , NoSuchPackage ) : <newline> <indent> continue <newline> <dedent> try : <newline> <indent> upkg = self . _get_package ( ipkg . id , self . _available ) <newline> <dedent> except ( InvalidPackageType , MissingPackageMetadata , NoSuchPackage ) : <newline> <indent> continue <newline> <dedent> if ipkg != upkg : <newline> <indent> pkgs . append ( upkg ) <newline> <dedent> <dedent> return sorted ( pkgs , key = attrgetter ( 'id' ) ) <newline> <dedent> def list_problems ( self , ids ) : <newline> <indent> errors = [ ] <newline> source = dict ( self . _available ) <newline> source . update ( self . _installed ) <newline> for pkgid , metadata in source . items ( ) : <newline> <indent> try : <newline> <indent> self . _get_package ( pkgid , source ) <newline> <dedent> except ( InvalidPackageType , MissingPackageMetadata ) as e : <newline> <indent> errors . append ( e ) <newline> <dedent> <dedent> return sorted ( errors , key = attrgetter ( 'pkgid' ) ) <newline> <dedent> @ staticmethod <newline> def _update_displayed_packages_on_home ( * , to_remove_ids = None , to_add_ids = None ) : <newline> <indent> displayed_packages = get_config ( 'home-page' , 'displayed-package-ids' ) <newline> if to_remove_ids : <newline> <indent> displayed_packages = [ id for id in displayed_packages if id not in to_remove_ids ] <newline> <dedent> if to_add_ids : <newline> <indent> displayed_packages . extend ( id for id in to_add_ids if id not in displayed_packages ) <newline> <dedent> set_config ( 'home-page' , 'displayed-package-ids' , displayed_packages , User . objects . get_system_user ( ) ) <newline> <dedent> def install_packages ( self , ids , keep_downloads = False ) : <newline> <indent> ids = self . _expand_package_ids ( ids , self . _available ) <newline> used_handlers = set ( ) <newline> installs = [ ] <newline> installed_ids = [ ] <newline>  # ▁ First ▁ get ▁ the ▁ list ▁ of ▁ installs ▁ and ▁ download ▁ them <encdom> for pkg_id in sorted ( ids ) : <newline> <indent> if pkg_id in self . _installed : <newline> <indent> printerr ( '{pkg_id} ▁ is ▁ already ▁ installed' . format ( pkg_id = pkg_id ) ) <newline> continue <newline> <dedent> pkg = self . _get_package ( pkg_id , self . _available ) <newline> try : <newline> <indent> download_path = self . _fetch_package ( pkg ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( e ) <newline> continue <newline> <dedent> installs . append ( { 'new' : pkg , 'download_path' : download_path } ) <newline>  # ▁ Now ▁ actually ▁ install ▁ the ▁ packages <encdom> <dedent> for install in installs : <newline> <indent> pkg = install [ 'new' ] <newline> download_path = install [ 'download_path' ] <newline> handler = pkg . handler <newline> try : <newline> <indent> print ( 'Installing ▁ {pkg}' . format ( pkg = pkg ) ) <newline> handler . install ( pkg , download_path ) <newline> used_handlers . add ( handler ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( 'Failed ▁ installing ▁ {pkg}: ▁ {e}' . format ( pkg = pkg , e = e ) ) <newline> continue <newline> <dedent> installed_ids . append ( pkg . id ) <newline> self . _installed [ pkg . id ] = self . _available [ pkg . id ] . copy ( ) <newline> self . _persist_catalog ( ) <newline> if not keep_downloads : <newline> <indent> rm ( download_path ) <newline> <dedent> <dedent> if installed_ids : <newline> <indent> self . _update_displayed_packages_on_home ( to_add_ids = installed_ids ) <newline> <dedent> for handler in used_handlers : <newline> <indent> handler . commit ( ) <newline> <dedent> <dedent> def remove_packages ( self , ids , commit = True ) : <newline> <indent> ids = self . _expand_package_ids ( ids , self . _installed ) <newline> used_handlers = set ( ) <newline> removed_ids = [ ] <newline> for pkg_id in sorted ( ids ) : <newline> <indent> try : <newline> <indent> pkg = self . _get_package ( pkg_id , self . _installed ) <newline> <dedent> except NoSuchPackage : <newline>  # ▁ The ▁ package ▁ is ▁ not ▁ installed, ▁ that's ▁ fine <encdom> <indent> printerr ( '{pkg_id} ▁ is ▁ not ▁ installed' . format ( pkg_id = pkg_id ) ) <newline> continue <newline> <dedent> handler = pkg . handler <newline> try : <newline> <indent> print ( 'Removing ▁ {pkg}' . format ( pkg = pkg ) ) <newline> handler . remove ( pkg ) <newline> used_handlers . add ( handler ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( 'Failed ▁ removing ▁ {pkg}: ▁ {e}' . format ( pkg = pkg , e = e ) ) <newline> continue <newline> <dedent> removed_ids . append ( pkg . id ) <newline> del ( self . _installed [ pkg . id ] ) <newline> self . _persist_catalog ( ) <newline> <dedent> if removed_ids : <newline> <indent> self . _update_displayed_packages_on_home ( to_remove_ids = removed_ids ) <newline> <dedent> if not commit : <newline> <indent> return <newline> <dedent> for handler in used_handlers : <newline> <indent> handler . commit ( ) <newline> <dedent> <dedent> def reinstall_packages ( self , ids , keep_downloads = False ) : <newline> <indent> self . remove_packages ( ids , commit = False ) <newline> self . install_packages ( ids , keep_downloads = keep_downloads ) <newline> <dedent> def upgrade_packages ( self , ids , keep_downloads = False ) : <newline> <indent> ids = self . _expand_package_ids ( ids , self . _installed ) <newline> used_handlers = set ( ) <newline> updates = [ ] <newline> new_package_ids = [ ] <newline>  # ▁ First ▁ get ▁ the ▁ list ▁ of ▁ updates ▁ and ▁ download ▁ them <encdom> for pkg_id in sorted ( ids ) : <newline> <indent> try : <newline> <indent> ipkg = self . _get_package ( pkg_id , self . _installed ) <newline> <dedent> except NoSuchPackage : <newline>  # ▁ Not ▁ installed ▁ yet, ▁ we'll ▁ install ▁ the ▁ latest ▁ version <encdom> <indent> ipkg = None <newline> <dedent> try : <newline> <indent> upkg = self . _get_package ( pkg_id , self . _available ) <newline> <dedent> except NoSuchPackage : <newline> <indent> if ipkg is not None : <newline> <indent> printerr ( 'Ignoring ▁ package: ▁ {pkg_id} ▁ is ▁ installed ▁ but ▁ now ▁ can ▁ ' 'not ▁ be ▁ found ▁ in ▁ any ▁ remote' . format ( pkg_id = pkg_id ) ) <newline> continue <newline> <dedent> else : <newline>  # ▁ Not ▁ installed ▁ and ▁ not ▁ available? ▁ This ▁ is ▁ clearly ▁ an ▁ error <encdom> <indent> raise <newline> <dedent> <dedent> if ipkg is not None and ipkg == upkg : <newline> <indent> printerr ( '{ipkg} ▁ has ▁ no ▁ update ▁ available' . format ( ipkg = ipkg ) ) <newline> continue <newline> <dedent> try : <newline> <indent> download_path = self . _fetch_package ( upkg ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( e ) <newline> continue <newline> <dedent> updates . append ( { 'old' : ipkg , 'new' : upkg , 'download_path' : download_path , } ) <newline>  # ▁ Now ▁ actually ▁ update ▁ the ▁ packages <encdom> <dedent> for update in updates : <newline> <indent> ipkg = update [ 'old' ] <newline> upkg = update [ 'new' ] <newline> download_path = update [ 'download_path' ] <newline> uhandler = upkg . handler <newline> if ipkg is not None : <newline> <indent> ihandler = ipkg . handler <newline> try : <newline> <indent> print ( 'Removing ▁ {ipkg}' . format ( ipkg = ipkg ) ) <newline> ihandler . remove ( ipkg ) <newline> used_handlers . add ( ihandler ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( 'Failed ▁ removing ▁ {ipkg}: ▁ {e}' . format ( ipkg = ipkg , e = e ) ) <newline> continue <newline> <dedent> <dedent> try : <newline> <indent> print ( 'Installing ▁ {upkg}' . format ( upkg = upkg ) ) <newline> uhandler . install ( upkg , download_path ) <newline> used_handlers . add ( uhandler ) <newline> <dedent> except Exception as e : <newline> <indent> printerr ( 'Failed ▁ installing ▁ {upkg}: ▁ {e}' . format ( upkg = upkg , e = e ) ) <newline> continue <newline> <dedent> if ipkg is None : <newline> <indent> new_package_ids . append ( upkg . id ) <newline> <dedent> self . _installed [ upkg . id ] = self . _available [ upkg . id ] . copy ( ) <newline> self . _persist_catalog ( ) <newline> if not keep_downloads : <newline> <indent> rm ( download_path ) <newline> <dedent> <dedent> self . _update_displayed_packages_on_home ( to_add_ids = new_package_ids ) <newline> for handler in used_handlers : <newline> <indent> handler . commit ( ) <newline>  # ▁ -- ▁ Manage ▁ local ▁ cache ▁ ----- <encdom> <dedent> <dedent> @ property <newline> def _available ( self ) : <newline> <indent> if self . _available_value is None : <newline> <indent> self . _available_value = { } <newline> try : <newline> <indent> catalog = load_from_basepath ( self . _catalog_cache_basepath ) <newline> <dedent> except FileNotFoundError : <newline>  # ▁ That's ▁ ok. <encdom> <indent> pass <newline> <dedent> else : <newline>  # ▁ load_from_basepath ▁ returns ▁ None ▁ for ▁ empty ▁ files <encdom> <indent> if catalog is not None : <newline> <indent> if 'available' in catalog and 'installed' in catalog : <newline>  # ▁ The ▁ cache ▁ on ▁ file ▁ is ▁ in ▁ the ▁ old ▁ format <encdom>  # ▁ https://framagit.org/ideascube/ideascube/issues/376 <encdom> <indent> self . _available_value = catalog [ 'available' ] <newline> self . _installed_value = catalog [ 'installed' ] <newline> <dedent> else : <newline> <indent> self . _available_value = catalog <newline> <dedent> <dedent> <dedent> <dedent> return self . _available_value <newline> <dedent> @ property <newline> def _installed ( self ) : <newline> <indent> if self . _installed_value is None : <newline> <indent> self . _installed_value = { } <newline> try : <newline> <indent> installed = load_from_basepath ( self . _installed_storage_basepath ) <newline> <dedent> except FileNotFoundError : <newline>  # ▁ Try ▁ compatible ▁ old ▁ format <encdom> <indent> try : <newline> <indent> catalog = load_from_basepath ( self . _catalog_cache_basepath ) <newline> <dedent> except FileNotFoundError : <newline>  # ▁ That's ▁ ok <encdom> <indent> pass <newline> <dedent> else : <newline>  # ▁ load_from_basepath ▁ returns ▁ None ▁ for ▁ empty ▁ files <encdom> <indent> if catalog is not None : <newline> <indent> if 'available' in catalog and 'installed' in catalog : <newline>  # ▁ The ▁ cache ▁ on ▁ file ▁ is ▁ in ▁ the ▁ old ▁ format <encdom>  # ▁ https://framagit.org/ideascube/ideascube/issues/376 <encdom> <indent> self . _available_value = catalog [ 'available' ] <newline> self . _installed_value = catalog [ 'installed' ] <newline> <dedent> elif self . _available_value is None : <newline>  # ▁ Now ▁ we ▁ have ▁ load ▁ the ▁ catalog, ▁ let's ▁ save ▁ it. <encdom> <indent> self . _available_value = catalog <newline> <dedent> <dedent> <dedent> <dedent> else : <newline>  # ▁ load_from_basepath ▁ returns ▁ None ▁ for ▁ empty ▁ files <encdom> <indent> if installed is not None : <newline> <indent> self . _installed_value = installed <newline> <dedent> <dedent> <dedent> return self . _installed_value <newline> <dedent> def _persist_catalog ( self ) : <newline> <indent> persist_to_file ( self . _catalog_cache_basepath , self . _available ) <newline> persist_to_file ( self . _installed_storage_basepath , self . _installed ) <newline> <dedent> def _update_installed_metadata ( self ) : <newline>  # ▁ These ▁ are ▁ the ▁ keys ▁ we ▁ must ▁ only ▁ ever ▁ update ▁ with ▁ an ▁ actual ▁ package <encdom>  # ▁ upgrade, ▁ and ▁ thus ▁ not ▁ here. <encdom> <indent> blacklist = ( 'sha256sum' , 'type' , 'version' , ) <newline> for pkgid in self . _installed : <newline> <indent> installed = self . _installed [ pkgid ] <newline> available = self . _available . get ( pkgid ) <newline> if available is None : <newline>  # ▁ The ▁ package ▁ was ▁ installed ▁ but ▁ it ▁ isn't ▁ available ▁ any ▁ more <encdom> <indent> continue <newline> <dedent> if any ( installed [ k ] != available [ k ] for k in blacklist ) : <newline>  # ▁ We ▁ really ▁ should ▁ upgrade ▁ this ▁ package, ▁ not ▁ update ▁ its <encdom>  # ▁ installed ▁ metadata ▁ here <encdom> <indent> continue <newline>  # ▁ The ▁ remote ▁ catalog ▁ metadata ▁ for ▁ this ▁ package ▁ changed, ▁ but ▁ the <encdom>  # ▁ values ▁ associated ▁ to ▁ blacklisted ▁ keys ▁ didn't. ▁ It ▁ is ▁ thus ▁ the <encdom>  # ▁ exact ▁ same ▁ package, ▁ just ▁ with ▁ updated ▁ (and ▁ let's ▁ hope ▁ improved) <encdom>  # ▁ name, ▁ description, ▁ ... <encdom> <dedent> self . _installed [ pkgid ] = available . copy ( ) <newline> <dedent> <dedent> def add_package_cache ( self , path ) : <newline> <indent> self . _package_caches . insert ( - 1 , os . path . abspath ( path ) ) <newline> <dedent> def update_cache ( self ) : <newline> <indent> self . _available_value = { } <newline> for remote in self . _remotes . values ( ) : <newline>  # ▁ TODO: ▁ Get ▁ resumable.urlretrieve ▁ to ▁ accept ▁ a ▁ file-like ▁ object? <encdom> <indent> with tempfile . NamedTemporaryFile ( ) as fd : <newline> <indent> tmppath = fd . name <newline> def _progress ( * args ) : <newline> <indent> self . _progress ( remote . name , * args ) <newline>  # ▁ TODO: ▁ Verify ▁ the ▁ download ▁ with ▁ sha256sum? ▁ Crypto ▁ signature? <encdom> <dedent> try : <newline> <indent> urlretrieve ( remote . url , tmppath , reporthook = _progress ) <newline> <dedent> except ConnectionError : <newline> <indent> print ( "Warning: ▁ Impossible ▁ to ▁ connect ▁ to ▁ the ▁ remote ▁ " "{remote.name}({remote.url}). \n " "Continuing ▁ without ▁ it." . format ( remote = remote ) ) <newline> continue <newline> <dedent> catalog = load_from_yml_file ( tmppath ) <newline>  # ▁ TODO: ▁ Handle ▁ content ▁ which ▁ was ▁ removed ▁ from ▁ the ▁ remote ▁ source <encdom> self . _available . update ( catalog [ 'all' ] ) <newline> <dedent> <dedent> self . _update_installed_metadata ( ) <newline> self . _persist_catalog ( ) <newline> <dedent> def clear_cache ( self ) : <newline> <indent> self . clear_package_cache ( ) <newline> self . clear_metadata_cache ( ) <newline> <dedent> def clear_metadata_cache ( self ) : <newline> <indent> self . _available_value = { } <newline> persist_to_file ( self . _catalog_cache_basepath , self . _available ) <newline> <dedent> def clear_package_cache ( self ) : <newline> <indent> rm ( self . _local_package_cache ) <newline> os . mkdir ( self . _local_package_cache ) <newline>  # ▁ -- ▁ Manage ▁ remote ▁ sources ▁ ----- <encdom> <dedent> @ property <newline> def _remotes ( self ) : <newline> <indent> if self . _remotes_value is None : <newline> <indent> self . _load_remotes ( ) <newline> <dedent> return self . _remotes_value <newline> <dedent> def _load_remotes ( self ) : <newline> <indent> self . _remotes_value = { } <newline> paths = glob ( os . path . join ( self . _remote_storage , '*.json' ) ) <newline> paths += glob ( os . path . join ( self . _remote_storage , '*.yml' ) ) <newline> basepaths = { os . path . splitext ( path ) [ 0 ] for path in paths } <newline> for basepath in basepaths : <newline> <indent> r = Remote . from_basepath ( basepath ) <newline> self . _remotes_value [ r . id ] = r <newline> <dedent> if self . _remotes_value : <newline> <indent> return <newline>  # ▁ We ▁ might ▁ have ▁ remotes ▁ in ▁ the ▁ old ▁ location <encdom> <dedent> old_remote_cache = os . path . join ( self . _cache_root , 'remotes' ) <newline> paths = glob ( os . path . join ( old_remote_cache , '*.yml' ) ) <newline> basepaths = { os . path . splitext ( path ) [ 0 ] for path in paths } <newline> for basepath in basepaths : <newline> <indent> r = Remote . from_basepath ( basepath ) <newline> r . to_file ( os . path . join ( self . _remote_storage , r . id ) ) <newline> self . _remotes_value [ r . id ] = r <newline> <dedent> if self . _remotes_value : <newline>  # ▁ So ▁ we ▁ did ▁ have ▁ old ▁ remotes ▁ after ▁ all... <encdom> <indent> rm ( old_remote_cache ) <newline> <dedent> <dedent> def list_remotes ( self ) : <newline> <indent> return sorted ( self . _remotes . values ( ) , key = attrgetter ( 'id' ) ) <newline> <dedent> def add_remote ( self , id , name , url ) : <newline> <indent> for remote in self . _remotes . values ( ) : <newline> <indent> if remote . id == id and remote . url == url : <newline> <indent> printerr ( 'This ▁ remote ▁ already ▁ exists, ▁ ignoring' ) <newline> return <newline> <dedent> if remote . id == id : <newline> <indent> raise ExistingRemoteError ( remote , 'id' ) <newline> <dedent> if remote . url == url : <newline> <indent> raise ExistingRemoteError ( remote , 'url' ) <newline> <dedent> <dedent> remote = Remote ( id , name , url ) <newline> remote . to_file ( os . path . join ( self . _remote_storage , id ) ) <newline> self . _remotes [ id ] = remote <newline> <dedent> def remove_remote ( self , id ) : <newline> <indent> if id not in self . _remotes : <newline> <indent> raise ValueError ( 'There ▁ is ▁ no ▁"{}" ▁ remote' . format ( id ) ) <newline> <dedent> del ( self . _remotes [ id ] ) <newline> rm ( os . path . join ( self . _remote_storage , '{}.yml' . format ( id ) ) ) <newline> rm ( os . path . join ( self . _remote_storage , '{}.json' . format ( id ) ) ) <newline> <dedent> <dedent>
 # ▁ Autogenerated ▁ by ▁ the ▁ KBase ▁ type ▁ compiler ▁ - <encdom>  # ▁ any ▁ changes ▁ made ▁ here ▁ will ▁ be ▁ overwritten <encdom>  # ▁ Passes ▁ on ▁ URLError, ▁ timeout, ▁ and ▁ BadStatusLine ▁ exceptions. <encdom>  # ▁ See: ▁ <encdom>  # ▁ http://docs.python.org/2/library/urllib2.html <encdom>  # ▁ http://docs.python.org/2/library/httplib.html <encdom> try : <newline> <indent> import json <newline> <dedent> except ImportError : <newline> <indent> import sys <newline> sys . path . append ( 'simplejson-2.3.3' ) <newline> import simplejson as json <newline> <dedent> import urllib2 , httplib , urlparse <newline> from urllib2 import URLError , HTTPError <newline> _CT = 'content-type' <newline> _AJ = 'application/json' <newline> _URL_SCHEME = frozenset ( [ 'http' , 'https' ] ) <newline> class ServerError ( Exception ) : <newline> <indent> def __init__ ( self , name , code , message ) : <newline> <indent> self . name = name <newline> self . code = code <newline> self . message = message <newline> <dedent> def __str__ ( self ) : <newline> <indent> return self . name + ': ▁ ' + str ( self . code ) + '. ▁ ' + self . message <newline> <dedent> <dedent> class Genotype_PhenotypeAPI : <newline> <indent> def __init__ ( self , url , timeout = 30 * 60 ) : <newline> <indent> if url is None : <newline> <indent> raise ValueError ( 'A ▁ url ▁ is ▁ required' ) <newline> <dedent> scheme , _ , _ , _ , _ , _ = urlparse . urlparse ( url ) <newline> if scheme not in _URL_SCHEME : <newline> <indent> raise ValueError ( url + " ▁ isn't ▁ a ▁ valid ▁ http ▁ url" ) <newline> <dedent> self . url = url <newline> self . timeout = int ( timeout ) <newline> if self . timeout < 1 : <newline> <indent> raise ValueError ( 'Timeout ▁ value ▁ must ▁ be ▁ at ▁ least ▁ 1 ▁ second' ) <newline> <dedent> <dedent> def get_experiments ( self , kb_genome ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.get_experiments' , 'params' : [ kb_genome ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def get_traits ( self , kb_study_experiment ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.get_traits' , 'params' : [ kb_study_experiment ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def traits_to_variations ( self , trait , pvaluecutoff ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.traits_to_variations' , 'params' : [ trait , pvaluecutoff ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def chromosome_position_from_variation_details ( self , variation_details ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.chromosome_position_from_variation_details' , 'params' : [ variation_details ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def traits_to_genes ( self , trait , pvaluecutoff , distance ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.traits_to_genes' , 'params' : [ trait , pvaluecutoff , distance ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def variations_to_genes ( self , chromosomal_positions , distance ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.variations_to_genes' , 'params' : [ chromosomal_positions , distance ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def find_common_snps ( self , trait_list_pvalue ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.find_common_snps' , 'params' : [ trait_list_pvalue ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> def selected_locations_to_genes ( self , trait , pmin , pmax , chromosomal_locations , distance ) : <newline> <indent> arg_hash = { 'method' : 'Genotype_PhenotypeAPI.selected_locations_to_genes' , 'params' : [ trait , pmin , pmax , chromosomal_locations , distance ] , 'version' : '1.1' } <newline> body = json . dumps ( arg_hash ) <newline> try : <newline> <indent> ret = urllib2 . urlopen ( self . url , body , timeout = self . timeout ) <newline> <dedent> except HTTPError as h : <newline> <indent> if _CT in h . headers and h . headers [ _CT ] == _AJ : <newline> <indent> err = json . loads ( h . read ( ) ) <newline> if 'error' in err : <newline> <indent> raise ServerError ( ** err [ 'error' ] ) <newline> <dedent> else :  # this ▁ should ▁ never ▁ happen... ▁ if ▁ it ▁ does ▁ <encdom> <newline> <indent> raise h  # ▁ h.read() ▁ will ▁ return ▁'' ▁ in ▁ the ▁ calling ▁ code. <encdom> <newline> <dedent> <dedent> else : <newline> <indent> raise h <newline> <dedent> <dedent> if ret . code != httplib . OK : <newline> <indent> raise URLError ( 'Received ▁ bad ▁ response ▁ code ▁ from ▁ server:' + ret . code ) <newline> <dedent> resp = json . loads ( ret . read ( ) ) <newline> if 'result' in resp : <newline> <indent> return resp [ 'result' ] [ 0 ] <newline> <dedent> else : <newline> <indent> raise ServerError ( 'Unknown' , 0 , 'An ▁ unknown ▁ server ▁ error ▁ occurred' ) <newline> <dedent> <dedent> <dedent>
 """ Functions ▁ that ▁ read ▁ and ▁ write ▁ gzipped ▁ files. <strnewline> <strnewline> The ▁ user ▁ of ▁ the ▁ file ▁ doesn't ▁ have ▁ to ▁ worry ▁ about ▁ the ▁ compression, <strnewline> but ▁ random ▁ access ▁ is ▁ not ▁ allowed. """  <newline>  # ▁ This ▁ is ▁ revision ▁ 53772 ▁ plus ▁ the ▁'gzip.py.diff' ▁ patch ▁ from: <encdom>  # ▁ http://bugs.python.org/issue1675951 <encdom>  # ▁ based ▁ on ▁ Andrew ▁ Kuchling's ▁ minigzip.py ▁ distributed ▁ with ▁ the ▁ zlib ▁ module <encdom>  # ▁ Original ▁ copyright ▁ statement: <encdom>  # ▁ PYTHON ▁ SOFTWARE ▁ FOUNDATION ▁ LICENSE ▁ VERSION ▁ 2 <encdom>  # ▁ 1. ▁ This ▁ LICENSE ▁ AGREEMENT ▁ is ▁ between ▁ the ▁ Python ▁ Software ▁ Foundation <encdom>  # ▁ ("PSF"), ▁ and ▁ the ▁ Individual ▁ or ▁ Organization ▁ ("Licensee") ▁ accessing <encdom>  # ▁ and ▁ otherwise ▁ using ▁ this ▁ software ▁ ("Python") ▁ in ▁ source ▁ or ▁ binary <encdom>  # ▁ form ▁ and ▁ its ▁ associated ▁ documentation. <encdom>  # ▁ 2. ▁ Subject ▁ to ▁ the ▁ terms ▁ and ▁ conditions ▁ of ▁ this ▁ License ▁ Agreement, <encdom>  # ▁ PSF ▁ hereby ▁ grants ▁ Licensee ▁ a ▁ nonexclusive, ▁ royalty-free, ▁ world-wide <encdom>  # ▁ license ▁ to ▁ reproduce, ▁ analyze, ▁ test, ▁ perform ▁ and/or ▁ display <encdom>  # ▁ publicly, ▁ prepare ▁ derivative ▁ works, ▁ distribute, ▁ and ▁ otherwise <encdom>  # ▁ use ▁ Python ▁ alone ▁ or ▁ in ▁ any ▁ derivative ▁ version, ▁ provided, ▁ however, <encdom>  # ▁ that ▁ PSF's ▁ License ▁ Agreement ▁ and ▁ PSF's ▁ notice ▁ of ▁ copyright, ▁ i.e., <encdom>  # ▁ "Copyright ▁ (c) ▁ 2001, ▁ 2002, ▁ 2003, ▁ 2004, ▁ 2005, ▁ 2006, ▁ 2007, ▁ 2008, <encdom>  # ▁ 2009 ▁ Python ▁ Software ▁ Foundation; ▁ All ▁ Rights ▁ Reserved" ▁ are ▁ retained <encdom>  # ▁ in ▁ Python ▁ alone ▁ or ▁ in ▁ any ▁ derivative ▁ version ▁ prepared ▁ by ▁ Licensee. <encdom>  # ▁ 3. ▁ In ▁ the ▁ event ▁ Licensee ▁ prepares ▁ a ▁ derivative ▁ work ▁ that ▁ is ▁ based <encdom>  # ▁ on ▁ or ▁ incorporates ▁ Python ▁ or ▁ any ▁ part ▁ thereof, ▁ and ▁ wants ▁ to ▁ make <encdom>  # ▁ the ▁ derivative ▁ work ▁ available ▁ to ▁ others ▁ as ▁ provided ▁ herein, ▁ then <encdom>  # ▁ Licensee ▁ hereby ▁ agrees ▁ to ▁ include ▁ in ▁ any ▁ such ▁ work ▁ a ▁ brief ▁ summary <encdom>  # ▁ of ▁ the ▁ changes ▁ made ▁ to ▁ Python. <encdom>  # ▁ 4. ▁ PSF ▁ is ▁ making ▁ Python ▁ available ▁ to ▁ Licensee ▁ on ▁ an ▁"AS ▁ IS" ▁ basis. <encdom>  # ▁ PSF ▁ MAKES ▁ NO ▁ REPRESENTATIONS ▁ OR ▁ WARRANTIES, ▁ EXPRESS ▁ OR ▁ IMPLIED. <encdom>  # ▁ BY ▁ WAY ▁ OF ▁ EXAMPLE, ▁ BUT ▁ NOT ▁ LIMITATION, ▁ PSF ▁ MAKES ▁ NO ▁ AND ▁ DISCLAIMS <encdom>  # ▁ ANY ▁ REPRESENTATION ▁ OR ▁ WARRANTY ▁ OF ▁ MERCHANTABILITY ▁ OR ▁ FITNESS ▁ FOR <encdom>  # ▁ ANY ▁ PARTICULAR ▁ PURPOSE ▁ OR ▁ THAT ▁ THE ▁ USE ▁ OF ▁ PYTHON ▁ WILL ▁ NOT ▁ INFRINGE <encdom>  # ▁ ANY ▁ THIRD ▁ PARTY ▁ RIGHTS. <encdom>  # ▁ 5. ▁ PSF ▁ SHALL ▁ NOT ▁ BE ▁ LIABLE ▁ TO ▁ LICENSEE ▁ OR ▁ ANY ▁ OTHER ▁ USERS ▁ OF ▁ PYTHON <encdom>  # ▁ FOR ▁ ANY ▁ INCIDENTAL, ▁ SPECIAL, ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ OR ▁ LOSS ▁ AS <encdom>  # ▁ A ▁ RESULT ▁ OF ▁ MODIFYING, ▁ DISTRIBUTING, ▁ OR ▁ OTHERWISE ▁ USING ▁ PYTHON, ▁ OR <encdom>  # ▁ ANY ▁ DERIVATIVE ▁ THEREOF, ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ THEREOF. <encdom>  # ▁ 6. ▁ This ▁ License ▁ Agreement ▁ will ▁ automatically ▁ terminate ▁ upon ▁ a <encdom>  # ▁ material ▁ breach ▁ of ▁ its ▁ terms ▁ and ▁ conditions. <encdom>  # ▁ 7. ▁ Nothing ▁ in ▁ this ▁ License ▁ Agreement ▁ shall ▁ be ▁ deemed ▁ to ▁ create ▁ any <encdom>  # ▁ relationship ▁ of ▁ agency, ▁ partnership, ▁ or ▁ joint ▁ venture ▁ between ▁ PSF <encdom>  # ▁ and ▁ Licensee. ▁ This ▁ License ▁ Agreement ▁ does ▁ not ▁ grant ▁ permission ▁ to <encdom>  # ▁ use ▁ PSF ▁ trademarks ▁ or ▁ trade ▁ name ▁ in ▁ a ▁ trademark ▁ sense ▁ to ▁ endorse <encdom>  # ▁ or ▁ promote ▁ products ▁ or ▁ services ▁ of ▁ Licensee, ▁ or ▁ any ▁ third ▁ party. <encdom>  # ▁ 8. ▁ By ▁ copying, ▁ installing ▁ or ▁ otherwise ▁ using ▁ Python, ▁ Licensee ▁ agrees <encdom>  # ▁ to ▁ be ▁ bound ▁ by ▁ the ▁ terms ▁ and ▁ conditions ▁ of ▁ this ▁ License ▁ Agreement. <encdom> import struct , sys , time <newline> import zlib <newline> import __builtin__ <newline> __all__ = [ "GzipFile" , "open" ] <newline> FTEXT , FHCRC , FEXTRA , FNAME , FCOMMENT = 1 , 2 , 4 , 8 , 16 <newline> READ , WRITE = 1 , 2 <newline> def LOWU32 ( i ) : <newline> <indent>  """ Return ▁ the ▁ low-order ▁ 32 ▁ bits ▁ of ▁ an ▁ int, ▁ as ▁ a ▁ non-negative ▁ int. """  <newline> return i & 0xFFFFFFFF L <newline> <dedent> def write32 ( output , value ) : <newline> <indent> output . write ( struct . pack ( "<l" , value ) ) <newline> <dedent> def write32u ( output , value ) : <newline>  # ▁ The ▁ L ▁ format ▁ writes ▁ the ▁ bit ▁ pattern ▁ correctly ▁ whether ▁ signed <encdom>  # ▁ or ▁ unsigned. <encdom> <indent> output . write ( struct . pack ( "<L" , value ) ) <newline> <dedent> def open ( filename , mode = "rb" , compresslevel = 9 ) : <newline> <indent>  """ Shorthand ▁ for ▁ GzipFile(filename, ▁ mode, ▁ compresslevel). <strnewline> <strnewline> ▁ The ▁ filename ▁ argument ▁ is ▁ required; ▁ mode ▁ defaults ▁ to ▁'rb' <strnewline> ▁ and ▁ compresslevel ▁ defaults ▁ to ▁ 9. <strnewline> <strnewline> ▁ """  <newline> return GzipFile ( filename , mode , compresslevel ) <newline> <dedent> class PaddedFile : <newline> <indent>  """ readonly ▁ file ▁ object ▁ that ▁ prepends ▁ string ▁ the ▁ content ▁ of ▁ f """  <newline> def __init__ ( self , string , f ) : <newline> <indent> self . _string = string <newline> self . _length = len ( string ) <newline> self . _file = f <newline> self . _read = 0 <newline> <dedent> def read ( self , size ) : <newline> <indent> if self . _read is None : <newline> <indent> return self . _file . read ( size ) <newline> <dedent> if self . _read + size <= self . _length : <newline> <indent> read = self . _read <newline> self . _read += size <newline> return self . _string [ read : self . _read ] <newline> <dedent> else : <newline> <indent> read = self . _read <newline> self . _read = None <newline> return self . _string [ read : ] + self . _file . read ( size - self . _length + read ) <newline> <dedent> <dedent> def unused ( self ) : <newline> <indent> if self . _read is None : <newline> <indent> return '' <newline> <dedent> return self . _string [ self . _read : ] <newline> <dedent> <dedent> class GzipFile : <newline> <indent>  """ The ▁ GzipFile ▁ class ▁ simulates ▁ most ▁ of ▁ the ▁ methods ▁ of ▁ a ▁ file ▁ object ▁ with <strnewline> ▁ the ▁ exception ▁ of ▁ the ▁ readinto() ▁ and ▁ truncate() ▁ methods. <strnewline> <strnewline> ▁ """  <newline> myfileobj = None <newline> def __init__ ( self , filename = None , mode = None , compresslevel = 9 , fileobj = None ) : <newline> <indent>  """ Constructor ▁ for ▁ the ▁ GzipFile ▁ class. <strnewline> <strnewline> ▁ At ▁ least ▁ one ▁ of ▁ fileobj ▁ and ▁ filename ▁ must ▁ be ▁ given ▁ a <strnewline> ▁ non-trivial ▁ value. <strnewline> <strnewline> ▁ The ▁ new ▁ class ▁ instance ▁ is ▁ based ▁ on ▁ fileobj, ▁ which ▁ can ▁ be ▁ a ▁ regular <strnewline> ▁ file, ▁ a ▁ StringIO ▁ object, ▁ or ▁ any ▁ other ▁ object ▁ which ▁ simulates ▁ a ▁ file. <strnewline> ▁ It ▁ defaults ▁ to ▁ None, ▁ in ▁ which ▁ case ▁ filename ▁ is ▁ opened ▁ to ▁ provide <strnewline> ▁ a ▁ file ▁ object. <strnewline> <strnewline> ▁ When ▁ fileobj ▁ is ▁ not ▁ None, ▁ the ▁ filename ▁ argument ▁ is ▁ only ▁ used ▁ to ▁ be <strnewline> ▁ included ▁ in ▁ the ▁ gzip ▁ file ▁ header, ▁ which ▁ may ▁ includes ▁ the ▁ original <strnewline> ▁ filename ▁ of ▁ the ▁ uncompressed ▁ file. ▁ It ▁ defaults ▁ to ▁ the ▁ filename ▁ of <strnewline> ▁ fileobj, ▁ if ▁ discernible; ▁ otherwise, ▁ it ▁ defaults ▁ to ▁ the ▁ empty ▁ string, <strnewline> ▁ and ▁ in ▁ this ▁ case ▁ the ▁ original ▁ filename ▁ is ▁ not ▁ included ▁ in ▁ the ▁ header. <strnewline> <strnewline> ▁ The ▁ mode ▁ argument ▁ can ▁ be ▁ any ▁ of ▁'r', ▁'rb', ▁'a', ▁'ab', ▁'w', ▁ or ▁'wb', <strnewline> ▁ depending ▁ on ▁ whether ▁ the ▁ file ▁ will ▁ be ▁ read ▁ or ▁ written. ▁ The ▁ default <strnewline> ▁ is ▁ the ▁ mode ▁ of ▁ fileobj ▁ if ▁ discernible; ▁ otherwise, ▁ the ▁ default ▁ is ▁'rb'. <strnewline> ▁ Be ▁ aware ▁ that ▁ only ▁ the ▁'rb', ▁'ab', ▁ and ▁'wb' ▁ values ▁ should ▁ be ▁ used <strnewline> ▁ for ▁ cross-platform ▁ portability. <strnewline> <strnewline> ▁ The ▁ compresslevel ▁ argument ▁ is ▁ an ▁ integer ▁ from ▁ 1 ▁ to ▁ 9 ▁ controlling ▁ the <strnewline> ▁ level ▁ of ▁ compression; ▁ 1 ▁ is ▁ fastest ▁ and ▁ produces ▁ the ▁ least ▁ compression, <strnewline> ▁ and ▁ 9 ▁ is ▁ slowest ▁ and ▁ produces ▁ the ▁ most ▁ compression. ▁ The ▁ default ▁ is ▁ 9. <strnewline> <strnewline> ▁ """  <newline>  # ▁ guarantee ▁ the ▁ file ▁ is ▁ opened ▁ in ▁ binary ▁ mode ▁ on ▁ platforms <encdom>  # ▁ that ▁ care ▁ about ▁ that ▁ sort ▁ of ▁ thing <encdom> if mode and 'b' not in mode : <newline> <indent> mode += 'b' <newline> <dedent> if fileobj is None : <newline> <indent> fileobj = self . myfileobj = __builtin__ . open ( filename , mode or 'rb' ) <newline> <dedent> if filename is None : <newline> <indent> if hasattr ( fileobj , 'name' ) : filename = fileobj . name <newline> else : filename = '' <newline> <dedent> if mode is None : <newline> <indent> if hasattr ( fileobj , 'mode' ) : mode = fileobj . mode <newline> else : mode = 'rb' <newline> <dedent> if mode [ 0 : 1 ] == 'r' : <newline> <indent> self . mode = READ <newline>  # ▁ Set ▁ flag ▁ indicating ▁ start ▁ of ▁ a ▁ new ▁ member <encdom> self . _new_member = True <newline> self . decompobj = zlib . decompressobj ( - zlib . MAX_WBITS ) <newline> self . crcval = zlib . crc32 ( "" ) <newline> self . buffer = [ ]  # ▁ List ▁ of ▁ data ▁ blocks <encdom> <newline> self . bufferlen = 0 <newline> self . pos = 0  # ▁ Offset ▁ of ▁ next ▁ data ▁ to ▁ read ▁ from ▁ buffer[0] <encdom> <newline> self . name = filename <newline> <dedent> elif mode [ 0 : 1 ] == 'w' or mode [ 0 : 1 ] == 'a' : <newline> <indent> self . mode = WRITE <newline> self . _init_write ( filename ) <newline> self . compress = zlib . compressobj ( compresslevel , zlib . DEFLATED , - zlib . MAX_WBITS , zlib . DEF_MEM_LEVEL , 0 ) <newline> <dedent> else : <newline> <indent> raise IOError , "Mode ▁ " + mode + " ▁ not ▁ supported" <newline> <dedent> self . size = 0 <newline> self . fileobj = fileobj <newline> self . offset = 0 <newline> if self . mode == WRITE : <newline> <indent> self . _write_gzip_header ( ) <newline> <dedent> <dedent> @ property <newline> def filename ( self ) : <newline> <indent> import warnings <newline> warnings . warn ( "use ▁ the ▁ name ▁ attribute" , DeprecationWarning ) <newline> if self . mode == WRITE and self . name [ - 3 : ] != ".gz" : <newline> <indent> return self . name + ".gz" <newline> <dedent> return self . name <newline> <dedent> def __repr__ ( self ) : <newline> <indent> s = repr ( self . fileobj ) <newline> return '<gzip ▁ ' + s [ 1 : - 1 ] + ' ▁ ' + hex ( id ( self ) ) + '>' <newline> <dedent> def _init_write ( self , filename ) : <newline> <indent> self . name = filename <newline> self . crc = zlib . crc32 ( "" ) <newline> self . writebuf = [ ] <newline> self . bufsize = 0 <newline> <dedent> def _write_gzip_header ( self ) : <newline> <indent> self . fileobj . write ( '\037\213' )  # ▁ magic ▁ header <encdom> <newline> self . fileobj . write ( '\010' )  # ▁ compression ▁ method <encdom> <newline> fname = self . name <newline> if fname . endswith ( ".gz" ) : <newline> <indent> fname = fname [ : - 3 ] <newline> <dedent> flags = 0 <newline> if fname : <newline> <indent> flags = FNAME <newline> <dedent> self . fileobj . write ( chr ( flags ) ) <newline> write32u ( self . fileobj , long ( time . time ( ) ) ) <newline> self . fileobj . write ( '\002' ) <newline> self . fileobj . write ( '\377' ) <newline> if fname : <newline> <indent> self . fileobj . write ( fname + '\000' ) <newline> <dedent> <dedent> def _read_gzip_header ( self , f ) : <newline> <indent> magic = f . read ( 2 ) <newline> if magic != '\037\213' : <newline> <indent> raise IOError , 'Not ▁ a ▁ gzipped ▁ file' <newline> <dedent> method = ord ( f . read ( 1 ) ) <newline> if method != 8 : <newline> <indent> raise IOError , 'Unknown ▁ compression ▁ method' <newline> <dedent> flag = ord ( f . read ( 1 ) ) <newline>  # ▁ modtime ▁ = ▁ f.read(4) <encdom>  # ▁ extraflag ▁ = ▁ f.read(1) <encdom>  # ▁ os ▁ = ▁ f.read(1) <encdom> f . read ( 6 ) <newline> if flag & FEXTRA : <newline>  # ▁ Read ▁ & ▁ discard ▁ the ▁ extra ▁ field, ▁ if ▁ present <encdom> <indent> xlen = ord ( f . read ( 1 ) ) <newline> xlen = xlen + 256 * ord ( f . read ( 1 ) ) <newline> f . read ( xlen ) <newline> <dedent> if flag & FNAME : <newline>  # ▁ Read ▁ and ▁ discard ▁ a ▁ null-terminated ▁ string ▁ containing ▁ the ▁ filename <encdom> <indent> while True : <newline> <indent> s = f . read ( 1 ) <newline> if not s or s == '\000' : <newline> <indent> break <newline> <dedent> <dedent> <dedent> if flag & FCOMMENT : <newline>  # ▁ Read ▁ and ▁ discard ▁ a ▁ null-terminated ▁ string ▁ containing ▁ a ▁ comment <encdom> <indent> while True : <newline> <indent> s = f . read ( 1 ) <newline> if not s or s == '\000' : <newline> <indent> break <newline> <dedent> <dedent> <dedent> if flag & FHCRC : <newline> <indent> f . read ( 2 )  # ▁ Read ▁ & ▁ discard ▁ the ▁ 16-bit ▁ header ▁ CRC <encdom> <newline> <dedent> <dedent> def write ( self , data ) : <newline> <indent> if self . mode != WRITE : <newline> <indent> import errno <newline> raise IOError ( errno . EBADF , "write() ▁ on ▁ read-only ▁ GzipFile ▁ object" ) <newline> <dedent> if self . fileobj is None : <newline> <indent> raise ValueError , "write() ▁ on ▁ closed ▁ GzipFile ▁ object" <newline> <dedent> if len ( data ) > 0 : <newline> <indent> self . size = self . size + len ( data ) <newline> self . crc = zlib . crc32 ( data , self . crc ) <newline> self . fileobj . write ( self . compress . compress ( data ) ) <newline> self . offset += len ( data ) <newline> <dedent> <dedent> def _read_eof ( self ) : <newline> <indent> if len ( self . decompobj . unused_data ) < 8 : <newline> <indent> unused = self . decompobj . unused_data + self . fileobj . read ( 8 - len ( self . decompobj . unused_data ) ) <newline> if len ( unused ) < 8 : <newline> <indent> raise IOError , "Unexpected ▁ EOF" <newline> <dedent> <dedent> else : <newline> <indent> unused = self . decompobj . unused_data <newline> <dedent> crc32 = struct . unpack ( "<L" , unused [ 0 : 4 ] ) [ 0 ]  # le ▁ signed ▁ int <encdom> <newline> isize = struct . unpack ( "<L" , unused [ 4 : 8 ] ) [ 0 ]  # le ▁ unsigned ▁ int <encdom> <newline>  # ▁ Do ▁ the ▁ CRC ▁ check ▁ with ▁ a ▁ LOWU32 ▁ on ▁ the ▁ read ▁ self.crcval ▁ due ▁ to ▁ the <encdom>  # ▁ signed/unsigned ▁ problem ▁ of ▁ the ▁ zlib ▁ crc ▁ code. <encdom> if crc32 != LOWU32 ( self . crcval ) : <newline> <indent> raise IOError , "CRC ▁ check ▁ failed" <newline> <dedent> if isize != LOWU32 ( self . size ) : <newline> <indent> raise IOError , "Incorrect ▁ length ▁ of ▁ data ▁ produced" <newline> <dedent> if len ( unused ) > 8 : <newline> <indent> f = PaddedFile ( unused [ 8 : ] , self . fileobj ) <newline> <dedent> else : <newline> <indent> f = self . fileobj <newline> <dedent> try : <newline> <indent> self . _read_gzip_header ( f ) <newline> <dedent> except IOError : <newline> <indent> return '' <newline> <dedent> if len ( unused ) > 8 : <newline> <indent> return f . unused ( ) <newline> <dedent> else : <newline> <indent> return '' <newline> <dedent> <dedent> def _read ( self , readsize ) : <newline> <indent> data = self . fileobj . read ( readsize ) <newline> while True : <newline> <indent> if data == "" : <newline> <indent> decompdata = self . decompobj . flush ( ) <newline> <dedent> else : <newline> <indent> decompdata = self . decompobj . decompress ( data ) <newline> <dedent> decomplen = len ( decompdata ) <newline> self . buffer . append ( decompdata ) <newline> self . bufferlen += decomplen <newline> self . size += decomplen <newline> self . crcval = zlib . crc32 ( decompdata , self . crcval ) <newline> if self . decompobj . unused_data : <newline> <indent> data = self . _read_eof ( ) <newline> self . decompobj = zlib . decompressobj ( - zlib . MAX_WBITS ) <newline> self . crcval = zlib . crc32 ( "" ) <newline> self . size = 0 <newline> if data : <newline> <indent> continue <newline> <dedent> <dedent> break <newline> <dedent> return data == '' <newline> <dedent> def read ( self , size = - 1 ) : <newline> <indent>  """ Decompress ▁ up ▁ to ▁ bytes ▁ bytes ▁ from ▁ input. <strnewline> <strnewline> ▁ Raise ▁ IOError. """  <newline> if self . mode != READ : <newline> <indent> import errno <newline> raise IOError ( errno . EBADF , "read() ▁ on ▁ write-only ▁ GzipFile ▁ object" ) <newline> <dedent> if self . _new_member : <newline> <indent> self . _read_gzip_header ( self . fileobj ) <newline> self . _new_member = False <newline> <dedent> while size < 0 or self . bufferlen < size : <newline> <indent> if size < 0 : <newline> <indent> readsize = 65536 - self . bufferlen <newline> <dedent> else : <newline> <indent> readsize = size - self . bufferlen <newline> <dedent> if readsize > 65536 : <newline> <indent> readsize = 32768 <newline> <dedent> elif readsize > 32768 : <newline> <indent> readsize = 16384 <newline> <dedent> elif readsize > 16384 : <newline> <indent> readsize = 8192 <newline> <dedent> elif readsize > 8192 : <newline> <indent> readsize = 4096 <newline> <dedent> elif readsize > 4096 : <newline> <indent> readsize = 2048 <newline> <dedent> else : <newline> <indent> readsize = 1024 <newline> <dedent> eof = self . _read ( readsize ) <newline> if eof : <newline> <indent> break <newline> <dedent> <dedent> if size < 0 : <newline> <indent> size = self . bufferlen <newline> <dedent> retdata = "" <newline> while size > 0 and self . buffer : <newline> <indent> decompdata = self . buffer [ 0 ] <newline> decomplen = len ( decompdata ) <newline> if size + self . pos <= decomplen : <newline> <indent> tmpdata = decompdata [ self . pos : size + self . pos ] <newline> retdata += tmpdata <newline> self . bufferlen -= size <newline> self . pos += size <newline> break <newline> <dedent> decomplen -= self . pos <newline> size -= decomplen <newline> self . bufferlen -= decomplen <newline> if self . pos != 0 : <newline> <indent> retdata += decompdata [ self . pos : ] <newline> <dedent> else : <newline> <indent> retdata += decompdata <newline> <dedent> self . pos = 0 <newline> self . buffer . pop ( 0 ) <newline> <dedent> self . offset += len ( retdata ) <newline> return retdata <newline> <dedent> def close ( self ) : <newline> <indent> if self . mode == WRITE : <newline> <indent> self . fileobj . write ( self . compress . flush ( ) ) <newline>  # ▁ The ▁ native ▁ zlib ▁ crc ▁ is ▁ an ▁ unsigned ▁ 32-bit ▁ integer, ▁ but <encdom>  # ▁ the ▁ Python ▁ wrapper ▁ implicitly ▁ casts ▁ that ▁ to ▁ a ▁ signed ▁ C <encdom>  # ▁ long. ▁ So, ▁ on ▁ a ▁ 32-bit ▁ box ▁ self.crc ▁ may ▁"look ▁ negative", <encdom>  # ▁ while ▁ the ▁ same ▁ crc ▁ on ▁ a ▁ 64-bit ▁ box ▁ may ▁"look ▁ positive". <encdom>  # ▁ To ▁ avoid ▁ irksome ▁ warnings ▁ from ▁ the ▁ `struct` ▁ module, ▁ force <encdom>  # ▁ it ▁ to ▁ look ▁ positive ▁ on ▁ all ▁ boxes. <encdom> write32u ( self . fileobj , LOWU32 ( self . crc ) ) <newline>  # ▁ self.size ▁ may ▁ exceed ▁ 2GB, ▁ or ▁ even ▁ 4GB <encdom> write32u ( self . fileobj , LOWU32 ( self . size ) ) <newline> self . fileobj = None <newline> <dedent> elif self . mode == READ : <newline> <indent> self . fileobj = None <newline> <dedent> if self . myfileobj : <newline> <indent> self . myfileobj . close ( ) <newline> self . myfileobj = None <newline> <dedent> <dedent> def __del__ ( self ) : <newline> <indent> try : <newline> <indent> if ( self . myfileobj is None and self . fileobj is None ) : <newline> <indent> return <newline> <dedent> <dedent> except AttributeError : <newline> <indent> return <newline> <dedent> self . close ( ) <newline> <dedent> def flush ( self , zlib_mode = zlib . Z_SYNC_FLUSH ) : <newline> <indent> if self . mode == WRITE : <newline>  # ▁ Ensure ▁ the ▁ compressor's ▁ buffer ▁ is ▁ flushed <encdom> <indent> self . fileobj . write ( self . compress . flush ( zlib_mode ) ) <newline> <dedent> self . fileobj . flush ( ) <newline> <dedent> def fileno ( self ) : <newline> <indent>  """ Invoke ▁ the ▁ underlying ▁ file ▁ object's ▁ fileno() ▁ method. <strnewline> <strnewline> ▁ This ▁ will ▁ raise ▁ AttributeError ▁ if ▁ the ▁ underlying ▁ file ▁ object <strnewline> ▁ doesn't ▁ support ▁ fileno(). <strnewline> ▁ """  <newline> return self . fileobj . fileno ( ) <newline> <dedent> def isatty ( self ) : <newline> <indent> return False <newline> <dedent> def tell ( self ) : <newline> <indent> return self . offset <newline> <dedent> def rewind ( self ) : <newline> <indent>  ''' Return ▁ the ▁ uncompressed ▁ stream ▁ file ▁ position ▁ indicator ▁ to ▁ the <strnewline> ▁ beginning ▁ of ▁ the ▁ file '''  <newline> if self . mode != READ : <newline> <indent> raise IOError ( "Can't ▁ rewind ▁ in ▁ write ▁ mode" ) <newline> <dedent> self . fileobj . seek ( 0 ) <newline> self . _new_member = True <newline> self . decompobj = zlib . decompressobj ( - zlib . MAX_WBITS ) <newline> self . crcval = zlib . crc32 ( "" ) <newline> self . buffer = [ ]  # ▁ List ▁ of ▁ data ▁ blocks <encdom> <newline> self . bufferlen = 0 <newline> self . pos = 0  # ▁ Offset ▁ of ▁ next ▁ data ▁ to ▁ read ▁ from ▁ buffer[0] <encdom> <newline> self . offset = 0 <newline> self . size = 0 <newline> <dedent> def seek ( self , offset , whence = 0 ) : <newline> <indent> if whence : <newline> <indent> if whence == 1 : <newline> <indent> offset = self . offset + offset <newline> <dedent> else : <newline> <indent> raise ValueError ( 'Seek ▁ from ▁ end ▁ not ▁ supported' ) <newline> <dedent> <dedent> if self . mode == WRITE : <newline> <indent> if offset < self . offset : <newline> <indent> raise IOError ( 'Negative ▁ seek ▁ in ▁ write ▁ mode' ) <newline> <dedent> count = offset - self . offset <newline> for i in range ( count // 1024 ) : <newline> <indent> self . write ( 1024 * '\0' ) <newline> <dedent> self . write ( ( count % 1024 ) * '\0' ) <newline> <dedent> elif self . mode == READ : <newline> <indent> if offset < self . offset : <newline>  # ▁ for ▁ negative ▁ seek, ▁ rewind ▁ and ▁ do ▁ positive ▁ seek <encdom> <indent> self . rewind ( ) <newline> <dedent> count = offset - self . offset <newline> for i in range ( count // 1024 ) : <newline> <indent> self . read ( 1024 ) <newline> <dedent> self . read ( count % 1024 ) <newline> <dedent> <dedent> def readline ( self , size = - 1 ) : <newline> <indent> if self . _new_member : <newline> <indent> self . _read_gzip_header ( self . fileobj ) <newline> self . _new_member = False <newline> <dedent> scansize = 0 <newline> buffpos = 0 <newline> while True : <newline> <indent> for idx in range ( buffpos , len ( self . buffer ) ) : <newline> <indent> if idx == 0 : <newline> <indent> scansize -= self . pos <newline> pos = self . buffer [ idx ] . find ( ' \n ' , self . pos ) <newline> <dedent> else : <newline> <indent> pos = self . buffer [ idx ] . find ( ' \n ' ) <newline> <dedent> if pos != - 1 : <newline> <indent> if size >= 0 and scansize + pos + 1 > size : <newline> <indent> return self . read ( size ) <newline> <dedent> return self . read ( scansize + pos + 1 ) <newline> <dedent> scansize += len ( self . buffer [ idx ] ) <newline> if size >= 0 and scansize > size : <newline> <indent> return self . read ( size ) <newline> <dedent> <dedent> buffpos = len ( self . buffer ) <newline> eof = self . _read ( 1024 ) <newline> if eof : <newline> <indent> return self . read ( scansize ) <newline> <dedent> <dedent> <dedent> def readlines ( self , sizehint = 0 ) : <newline>  # ▁ Negative ▁ numbers ▁ result ▁ in ▁ reading ▁ all ▁ the ▁ lines <encdom> <indent> if sizehint <= 0 : <newline> <indent> sizehint = sys . maxint <newline> <dedent> L = [ ] <newline> while sizehint > 0 : <newline> <indent> line = self . readline ( ) <newline> if line == "" : <newline> <indent> break <newline> <dedent> L . append ( line ) <newline> sizehint = sizehint - len ( line ) <newline> <dedent> return L <newline> <dedent> def writelines ( self , L ) : <newline> <indent> for line in L : <newline> <indent> self . write ( line ) <newline> <dedent> <dedent> def __iter__ ( self ) : <newline> <indent> return self <newline> <dedent> def next ( self ) : <newline> <indent> line = self . readline ( ) <newline> if line : <newline> <indent> return line <newline> <dedent> else : <newline> <indent> raise StopIteration <newline> <dedent> <dedent> <dedent> def _test ( ) : <newline>  # ▁ Act ▁ like ▁ gzip; ▁ with ▁ -d, ▁ act ▁ like ▁ gunzip. <encdom>  # ▁ The ▁ input ▁ file ▁ is ▁ not ▁ deleted, ▁ however, ▁ nor ▁ are ▁ any ▁ other ▁ gzip <encdom>  # ▁ options ▁ or ▁ features ▁ supported. <encdom> <indent> args = sys . argv [ 1 : ] <newline> decompress = args and args [ 0 ] == "-d" <newline> if decompress : <newline> <indent> args = args [ 1 : ] <newline> <dedent> if not args : <newline> <indent> args = [ "-" ] <newline> <dedent> for arg in args : <newline> <indent> if decompress : <newline> <indent> if arg == "-" : <newline> <indent> f = GzipFile ( filename = "" , mode = "rb" , fileobj = sys . stdin ) <newline> g = sys . stdout <newline> <dedent> else : <newline> <indent> if arg [ - 3 : ] != ".gz" : <newline> <indent> print "filename ▁ doesn't ▁ end ▁ in ▁ .gz:" , repr ( arg ) <newline> continue <newline> <dedent> f = open ( arg , "rb" ) <newline> g = __builtin__ . open ( arg [ : - 3 ] , "wb" ) <newline> <dedent> <dedent> else : <newline> <indent> if arg == "-" : <newline> <indent> f = sys . stdin <newline> g = GzipFile ( filename = "" , mode = "wb" , fileobj = sys . stdout ) <newline> <dedent> else : <newline> <indent> f = __builtin__ . open ( arg , "rb" ) <newline> g = open ( arg + ".gz" , "wb" ) <newline> <dedent> <dedent> while True : <newline> <indent> chunk = f . read ( 1024 ) <newline> if not chunk : <newline> <indent> break <newline> <dedent> g . write ( chunk ) <newline> <dedent> if g is not sys . stdout : <newline> <indent> g . close ( ) <newline> <dedent> if f is not sys . stdin : <newline> <indent> f . close ( ) <newline> <dedent> <dedent> <dedent> if __name__ == '__main__' : <newline> <indent> _test ( ) <newline> <dedent>
 # ▁ (c) ▁ 2014, ▁ Brian ▁ Coca ▁ <bcoca@ansible.com> <encdom>  # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible <encdom>  # ▁ Ansible ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <encdom>  # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by <encdom>  # ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License, ▁ or <encdom>  # ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <encdom>  # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License <encdom>  # ▁ along ▁ with ▁ Ansible. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <encdom> from __future__ import absolute_import <newline> import math <newline> import collections <newline> from ansible import errors <newline> def unique ( a ) : <newline> <indent> if isinstance ( a , collections . Hashable ) : <newline> <indent> c = set ( a ) <newline> <dedent> else : <newline> <indent> c = [ ] <newline> for x in a : <newline> <indent> if x not in c : <newline> <indent> c . append ( x ) <newline> <dedent> <dedent> <dedent> return c <newline> <dedent> def intersect ( a , b ) : <newline> <indent> if isinstance ( a , collections . Hashable ) and isinstance ( b , collections . Hashable ) : <newline> <indent> c = set ( a ) & set ( b ) <newline> <dedent> else : <newline> <indent> c = unique ( filter ( lambda x : x in b , a ) ) <newline> <dedent> return c <newline> <dedent> def difference ( a , b ) : <newline> <indent> if isinstance ( a , collections . Hashable ) and isinstance ( b , collections . Hashable ) : <newline> <indent> c = set ( a ) - set ( b ) <newline> <dedent> else : <newline> <indent> c = unique ( filter ( lambda x : x not in b , a ) ) <newline> <dedent> return c <newline> <dedent> def symmetric_difference ( a , b ) : <newline> <indent> if isinstance ( a , collections . Hashable ) and isinstance ( b , collections . Hashable ) : <newline> <indent> c = set ( a ) ^ set ( b ) <newline> <dedent> else : <newline> <indent> c = unique ( filter ( lambda x : x not in intersect ( a , b ) , union ( a , b ) ) ) <newline> <dedent> return c <newline> <dedent> def union ( a , b ) : <newline> <indent> if isinstance ( a , collections . Hashable ) and isinstance ( b , collections . Hashable ) : <newline> <indent> c = set ( a ) | set ( b ) <newline> <dedent> else : <newline> <indent> c = unique ( a + b ) <newline> <dedent> return c <newline> <dedent> def min ( a ) : <newline> <indent> _min = __builtins__ . get ( 'min' ) <newline> return _min ( a ) ; <newline> <dedent> def max ( a ) : <newline> <indent> _max = __builtins__ . get ( 'max' ) <newline> return _max ( a ) ; <newline> <dedent> def isnotanumber ( x ) : <newline> <indent> try : <newline> <indent> return math . isnan ( x ) <newline> <dedent> except TypeError : <newline> <indent> return False <newline> <dedent> <dedent> def logarithm ( x , base = math . e ) : <newline> <indent> try : <newline> <indent> if base == 10 : <newline> <indent> return math . log10 ( x ) <newline> <dedent> else : <newline> <indent> return math . log ( x , base ) <newline> <dedent> <dedent> except TypeError as e : <newline> <indent> raise errors . AnsibleFilterError ( 'log() ▁ can ▁ only ▁ be ▁ used ▁ on ▁ numbers: ▁ %s' % str ( e ) ) <newline> <dedent> <dedent> def power ( x , y ) : <newline> <indent> try : <newline> <indent> return math . pow ( x , y ) <newline> <dedent> except TypeError as e : <newline> <indent> raise errors . AnsibleFilterError ( 'pow() ▁ can ▁ only ▁ be ▁ used ▁ on ▁ numbers: ▁ %s' % str ( e ) ) <newline> <dedent> <dedent> def inversepower ( x , base = 2 ) : <newline> <indent> try : <newline> <indent> if base == 2 : <newline> <indent> return math . sqrt ( x ) <newline> <dedent> else : <newline> <indent> return math . pow ( x , 1.0 / float ( base ) ) <newline> <dedent> <dedent> except TypeError as e : <newline> <indent> raise errors . AnsibleFilterError ( 'root() ▁ can ▁ only ▁ be ▁ used ▁ on ▁ numbers: ▁ %s' % str ( e ) ) <newline> <dedent> <dedent> def human_readable ( size , isbits = False , unit = None ) : <newline> <indent> base = 'bits' if isbits else 'Bytes' <newline> suffix = '' <newline> ranges = ( ( 1 << 70 , 'Z' ) , ( 1 << 60 , 'E' ) , ( 1 << 50 , 'P' ) , ( 1 << 40 , 'T' ) , ( 1 << 30 , 'G' ) , ( 1 << 20 , 'M' ) , ( 1 << 10 , 'K' ) , ( 1 , base ) ) <newline> for limit , suffix in ranges : <newline> <indent> if ( unit is None and size >= limit ) or unit is not None and unit . upper ( ) == suffix : <newline> <indent> break <newline> <dedent> <dedent> if limit != 1 : <newline> <indent> suffix += base [ 0 ] <newline> <dedent> return '%.2f ▁ %s' % ( float ( size ) / limit , suffix ) <newline> <dedent> class FilterModule ( object ) : <newline> <indent>  ''' ▁ Ansible ▁ math ▁ jinja2 ▁ filters ▁ '''  <newline> def filters ( self ) : <newline> <indent> return {  # ▁ general ▁ math <encdom> 'isnan' : isnotanumber , 'min' : min , 'max' : max ,  # ▁ exponents ▁ and ▁ logarithms <encdom> 'log' : logarithm , 'pow' : power , 'root' : inversepower ,  # ▁ set ▁ theory <encdom> 'unique' : unique , 'intersect' : intersect , 'difference' : difference , 'symmetric_difference' : symmetric_difference , 'union' : union ,  # ▁ computer ▁ theory <encdom> 'human_readable' : human_readable , } <newline> <dedent> <dedent>
from . import util <newline> from . util import ( mkhead , sm_name , sm_section , SubmoduleConfigParser , find_first_remote_branch ) <newline> from git . objects . util import Traversable <newline> from io import BytesIO  # ▁ need ▁ a ▁ dict ▁ to ▁ set ▁ bloody ▁ .name ▁ field <encdom> <newline> from git . util import ( Iterable , join_path_native , to_native_path_linux , RemoteProgress , rmtree , unbare_repo ) <newline> from git . config import ( SectionConstraint , GitConfigParser , cp ) <newline> from git . exc import ( InvalidGitRepositoryError , NoSuchPathError , RepositoryDirtyError ) <newline> from git . compat import ( string_types , defenc ) <newline> import stat <newline> import git <newline> import os <newline> import logging <newline> import uuid <newline> __all__ = [ "Submodule" , "UpdateProgress" ] <newline> log = logging . getLogger ( 'git.objects.submodule.base' ) <newline> log . addHandler ( logging . NullHandler ( ) ) <newline> class UpdateProgress ( RemoteProgress ) : <newline> <indent>  """ Class ▁ providing ▁ detailed ▁ progress ▁ information ▁ to ▁ the ▁ caller ▁ who ▁ should <strnewline> ▁ derive ▁ from ▁ it ▁ and ▁ implement ▁ the ▁ ``update(...)`` ▁ message """  <newline> CLONE , FETCH , UPDWKTREE = [ 1 << x for x in range ( RemoteProgress . _num_op_codes , RemoteProgress . _num_op_codes + 3 ) ] <newline> _num_op_codes = RemoteProgress . _num_op_codes + 3 <newline> __slots__ = tuple ( ) <newline> <dedent> BEGIN = UpdateProgress . BEGIN <newline> END = UpdateProgress . END <newline> CLONE = UpdateProgress . CLONE <newline> FETCH = UpdateProgress . FETCH <newline> UPDWKTREE = UpdateProgress . UPDWKTREE <newline>  # ▁ IndexObject ▁ comes ▁ via ▁ util ▁ module, ▁ its ▁ a ▁'hacky' ▁ fix ▁ thanks ▁ to ▁ pythons ▁ import <encdom>  # ▁ mechanism ▁ which ▁ cause ▁ plenty ▁ of ▁ trouble ▁ of ▁ the ▁ only ▁ reason ▁ for ▁ packages ▁ and <encdom>  # ▁ modules ▁ is ▁ refactoring ▁ - ▁ subpackages ▁ shoudn't ▁ depend ▁ on ▁ parent ▁ packages <encdom> class Submodule ( util . IndexObject , Iterable , Traversable ) : <newline> <indent>  """ Implements ▁ access ▁ to ▁ a ▁ git ▁ submodule. ▁ They ▁ are ▁ special ▁ in ▁ that ▁ their ▁ sha <strnewline> ▁ represents ▁ a ▁ commit ▁ in ▁ the ▁ submodule's ▁ repository ▁ which ▁ is ▁ to ▁ be ▁ checked ▁ out <strnewline> ▁ at ▁ the ▁ path ▁ of ▁ this ▁ instance. <strnewline> ▁ The ▁ submodule ▁ type ▁ does ▁ not ▁ have ▁ a ▁ string ▁ type ▁ associated ▁ with ▁ it, ▁ as ▁ it ▁ exists <strnewline> ▁ solely ▁ as ▁ a ▁ marker ▁ in ▁ the ▁ tree ▁ and ▁ index. <strnewline> <strnewline> ▁ All ▁ methods ▁ work ▁ in ▁ bare ▁ and ▁ non-bare ▁ repositories. """  <newline> _id_attribute_ = "name" <newline> k_modules_file = '.gitmodules' <newline> k_head_option = 'branch' <newline> k_head_default = 'master' <newline> k_default_mode = stat . S_IFDIR | stat . S_IFLNK  # ▁ submodules ▁ are ▁ directories ▁ with ▁ link-status <encdom> <newline>  # ▁ this ▁ is ▁ a ▁ bogus ▁ type ▁ for ▁ base ▁ class ▁ compatability <encdom> type = 'submodule' <newline> __slots__ = ( '_parent_commit' , '_url' , '_branch_path' , '_name' , '__weakref__' ) <newline> _cache_attrs = ( 'path' , '_url' , '_branch_path' ) <newline> def __init__ ( self , repo , binsha , mode = None , path = None , name = None , parent_commit = None , url = None , branch_path = None ) : <newline> <indent>  """ Initialize ▁ this ▁ instance ▁ with ▁ its ▁ attributes. ▁ We ▁ only ▁ document ▁ the ▁ ones <strnewline> ▁ that ▁ differ ▁ from ▁ ``IndexObject`` <strnewline> <strnewline> ▁ :param ▁ repo: ▁ Our ▁ parent ▁ repository <strnewline> ▁ :param ▁ binsha: ▁ binary ▁ sha ▁ referring ▁ to ▁ a ▁ commit ▁ in ▁ the ▁ remote ▁ repository, ▁ see ▁ url ▁ parameter <strnewline> ▁ :param ▁ parent_commit: ▁ see ▁ set_parent_commit() <strnewline> ▁ :param ▁ url: ▁ The ▁ url ▁ to ▁ the ▁ remote ▁ repository ▁ which ▁ is ▁ the ▁ submodule <strnewline> ▁ :param ▁ branch_path: ▁ full ▁ (relative) ▁ path ▁ to ▁ ref ▁ to ▁ checkout ▁ when ▁ cloning ▁ the ▁ remote ▁ repository """  <newline> super ( Submodule , self ) . __init__ ( repo , binsha , mode , path ) <newline> self . size = 0 <newline> self . _parent_commit = parent_commit <newline> if url is not None : <newline> <indent> self . _url = url <newline> <dedent> if branch_path is not None : <newline> <indent> assert isinstance ( branch_path , string_types ) <newline> self . _branch_path = branch_path <newline> <dedent> if name is not None : <newline> <indent> self . _name = name <newline> <dedent> <dedent> def _set_cache_ ( self , attr ) : <newline> <indent> if attr in ( 'path' , '_url' , '_branch_path' ) : <newline> <indent> reader = self . config_reader ( ) <newline>  # ▁ default ▁ submodule ▁ values <encdom> try : <newline> <indent> self . path = reader . get_value ( 'path' ) <newline> <dedent> except cp . NoSectionError : <newline> <indent> raise ValueError ( "This ▁ submodule ▁ instance ▁ does ▁ not ▁ exist ▁ anymore ▁ in ▁'%s' ▁ file" % os . path . join ( self . repo . working_tree_dir , '.gitmodules' ) ) <newline>  # ▁ end <encdom> <dedent> self . _url = reader . get_value ( 'url' ) <newline>  # ▁ git-python ▁ extension ▁ values ▁ - ▁ optional <encdom> self . _branch_path = reader . get_value ( self . k_head_option , git . Head . to_full_path ( self . k_head_default ) ) <newline> <dedent> elif attr == '_name' : <newline> <indent> raise AttributeError ( "Cannot ▁ retrieve ▁ the ▁ name ▁ of ▁ a ▁ submodule ▁ if ▁ it ▁ was ▁ not ▁ set ▁ initially" ) <newline> <dedent> else : <newline> <indent> super ( Submodule , self ) . _set_cache_ ( attr ) <newline>  # ▁ END ▁ handle ▁ attribute ▁ name <encdom> <dedent> <dedent> def _get_intermediate_items ( self , item ) : <newline> <indent>  """ :return: ▁ all ▁ the ▁ submodules ▁ of ▁ our ▁ module ▁ repository """  <newline> try : <newline> <indent> return type ( self ) . list_items ( item . module ( ) ) <newline> <dedent> except InvalidGitRepositoryError : <newline> <indent> return list ( ) <newline>  # ▁ END ▁ handle ▁ intermeditate ▁ items <encdom> <dedent> <dedent> @ classmethod <newline> def _need_gitfile_submodules ( cls , git ) : <newline> <indent> return git . version_info [ : 3 ] >= ( 1 , 7 , 0 ) <newline> <dedent> def __eq__ ( self , other ) : <newline> <indent>  """ Compare ▁ with ▁ another ▁ submodule """  <newline>  # ▁ we ▁ may ▁ only ▁ compare ▁ by ▁ name ▁ as ▁ this ▁ should ▁ be ▁ the ▁ ID ▁ they ▁ are ▁ hashed ▁ with <encdom>  # ▁ Otherwise ▁ this ▁ type ▁ wouldn't ▁ be ▁ hashable <encdom>  # ▁ return ▁ self.path ▁ == ▁ other.path ▁ and ▁ self.url ▁ == ▁ other.url ▁ and ▁ super(Submodule, ▁ self).__eq__(other) <encdom> return self . _name == other . _name <newline> <dedent> def __ne__ ( self , other ) : <newline> <indent>  """ Compare ▁ with ▁ another ▁ submodule ▁ for ▁ inequality """  <newline> return not ( self == other ) <newline> <dedent> def __hash__ ( self ) : <newline> <indent>  """ Hash ▁ this ▁ instance ▁ using ▁ its ▁ logical ▁ id, ▁ not ▁ the ▁ sha """  <newline> return hash ( self . _name ) <newline> <dedent> def __str__ ( self ) : <newline> <indent> return self . _name <newline> <dedent> def __repr__ ( self ) : <newline> <indent> return "git.%s(name=%s, ▁ path=%s, ▁ url=%s, ▁ branch_path=%s)" % ( type ( self ) . __name__ , self . _name , self . path , self . url , self . branch_path ) <newline> <dedent> @ classmethod <newline> def _config_parser ( cls , repo , parent_commit , read_only ) : <newline> <indent>  """ :return: ▁ Config ▁ Parser ▁ constrained ▁ to ▁ our ▁ submodule ▁ in ▁ read ▁ or ▁ write ▁ mode <strnewline> ▁ :raise ▁ IOError: ▁ If ▁ the ▁ .gitmodules ▁ file ▁ cannot ▁ be ▁ found, ▁ either ▁ locally ▁ or ▁ in ▁ the ▁ repository <strnewline> ▁ at ▁ the ▁ given ▁ parent ▁ commit. ▁ Otherwise ▁ the ▁ exception ▁ would ▁ be ▁ delayed ▁ until ▁ the ▁ first <strnewline> ▁ access ▁ of ▁ the ▁ config ▁ parser """  <newline> parent_matches_head = True <newline> if parent_commit is not None : <newline> <indent> try : <newline> <indent> parent_matches_head = repo . head . commit == parent_commit <newline> <dedent> except ValueError : <newline>  # ▁ We ▁ are ▁ most ▁ likely ▁ in ▁ an ▁ empty ▁ repository, ▁ so ▁ the ▁ HEAD ▁ doesn't ▁ point ▁ to ▁ a ▁ valid ▁ ref <encdom> <indent> pass <newline>  # ▁ end ▁ hanlde ▁ parent_commit <encdom> <dedent> <dedent> if not repo . bare and parent_matches_head : <newline> <indent> fp_module = os . path . join ( repo . working_tree_dir , cls . k_modules_file ) <newline> <dedent> else : <newline> <indent> assert parent_commit is not None , "need ▁ valid ▁ parent_commit ▁ in ▁ bare ▁ repositories" <newline> try : <newline> <indent> fp_module = cls . _sio_modules ( parent_commit ) <newline> <dedent> except KeyError : <newline> <indent> raise IOError ( "Could ▁ not ▁ find ▁ %s ▁ file ▁ in ▁ the ▁ tree ▁ of ▁ parent ▁ commit ▁ %s" % ( cls . k_modules_file , parent_commit ) ) <newline>  # ▁ END ▁ handle ▁ exceptions <encdom>  # ▁ END ▁ handle ▁ non-bare ▁ working ▁ tree <encdom> <dedent> <dedent> if not read_only and ( repo . bare or not parent_matches_head ) : <newline> <indent> raise ValueError ( "Cannot ▁ write ▁ blobs ▁ of ▁'historical' ▁ submodule ▁ configurations" ) <newline>  # ▁ END ▁ handle ▁ writes ▁ of ▁ historical ▁ submodules <encdom> <dedent> return SubmoduleConfigParser ( fp_module , read_only = read_only ) <newline> <dedent> def _clear_cache ( self ) : <newline>  # ▁ clear ▁ the ▁ possibly ▁ changed ▁ values <encdom> <indent> for name in self . _cache_attrs : <newline> <indent> try : <newline> <indent> delattr ( self , name ) <newline> <dedent> except AttributeError : <newline> <indent> pass <newline>  # ▁ END ▁ try ▁ attr ▁ deletion <encdom>  # ▁ END ▁ for ▁ each ▁ name ▁ to ▁ delete <encdom> <dedent> <dedent> <dedent> @ classmethod <newline> def _sio_modules ( cls , parent_commit ) : <newline> <indent>  """ :return: ▁ Configuration ▁ file ▁ as ▁ BytesIO ▁ - ▁ we ▁ only ▁ access ▁ it ▁ through ▁ the ▁ respective ▁ blob's ▁ data """  <newline> sio = BytesIO ( parent_commit . tree [ cls . k_modules_file ] . data_stream . read ( ) ) <newline> sio . name = cls . k_modules_file <newline> return sio <newline> <dedent> def _config_parser_constrained ( self , read_only ) : <newline> <indent>  """ :return: ▁ Config ▁ Parser ▁ constrained ▁ to ▁ our ▁ submodule ▁ in ▁ read ▁ or ▁ write ▁ mode """  <newline> try : <newline> <indent> pc = self . parent_commit <newline> <dedent> except ValueError : <newline> <indent> pc = None <newline>  # ▁ end ▁ hande ▁ empty ▁ parent ▁ repository <encdom> <dedent> parser = self . _config_parser ( self . repo , pc , read_only ) <newline> parser . set_submodule ( self ) <newline> return SectionConstraint ( parser , sm_section ( self . name ) ) <newline> <dedent> @ classmethod <newline> def _module_abspath ( cls , parent_repo , path , name ) : <newline> <indent> if cls . _need_gitfile_submodules ( parent_repo . git ) : <newline> <indent> return os . path . join ( parent_repo . git_dir , 'modules' , name ) <newline> <dedent> else : <newline> <indent> return os . path . join ( parent_repo . working_tree_dir , path ) <newline>  # ▁ end <encdom> <dedent> <dedent> @ classmethod <newline> def _clone_repo ( cls , repo , url , path , name , ** kwargs ) : <newline> <indent>  """ :return: ▁ Repo ▁ instance ▁ of ▁ newly ▁ cloned ▁ repository <strnewline> ▁ :param ▁ repo: ▁ our ▁ parent ▁ repository <strnewline> ▁ :param ▁ url: ▁ url ▁ to ▁ clone ▁ from <strnewline> ▁ :param ▁ path: ▁ repository-relative ▁ path ▁ to ▁ the ▁ submodule ▁ checkout ▁ location <strnewline> ▁ :param ▁ name: ▁ canonical ▁ of ▁ the ▁ submodule <strnewline> ▁ :param ▁ kwrags: ▁ additinoal ▁ arguments ▁ given ▁ to ▁ git.clone """  <newline> module_abspath = cls . _module_abspath ( repo , path , name ) <newline> module_checkout_path = module_abspath <newline> if cls . _need_gitfile_submodules ( repo . git ) : <newline> <indent> kwargs [ 'separate_git_dir' ] = module_abspath <newline> module_abspath_dir = os . path . dirname ( module_abspath ) <newline> if not os . path . isdir ( module_abspath_dir ) : <newline> <indent> os . makedirs ( module_abspath_dir ) <newline> <dedent> module_checkout_path = os . path . join ( repo . working_tree_dir , path ) <newline>  # ▁ end <encdom> <dedent> clone = git . Repo . clone_from ( url , module_checkout_path , ** kwargs ) <newline> if cls . _need_gitfile_submodules ( repo . git ) : <newline> <indent> cls . _write_git_file_and_module_config ( module_checkout_path , module_abspath ) <newline>  # ▁ end <encdom> <dedent> return clone <newline> <dedent> @ classmethod <newline> def _to_relative_path ( cls , parent_repo , path ) : <newline> <indent>  """ :return: ▁ a ▁ path ▁ guaranteed ▁ to ▁ be ▁ relative ▁ to ▁ the ▁ given ▁ parent-repository <strnewline> ▁ :raise ▁ ValueError: ▁ if ▁ path ▁ is ▁ not ▁ contained ▁ in ▁ the ▁ parent ▁ repository's ▁ working ▁ tree """  <newline> path = to_native_path_linux ( path ) <newline> if path . endswith ( '/' ) : <newline> <indent> path = path [ : - 1 ] <newline>  # ▁ END ▁ handle ▁ trailing ▁ slash <encdom> <dedent> if os . path . isabs ( path ) : <newline> <indent> working_tree_linux = to_native_path_linux ( parent_repo . working_tree_dir ) <newline> if not path . startswith ( working_tree_linux ) : <newline> <indent> raise ValueError ( "Submodule ▁ checkout ▁ path ▁'%s' ▁ needs ▁ to ▁ be ▁ within ▁ the ▁ parents ▁ repository ▁ at ▁'%s'" % ( working_tree_linux , path ) ) <newline> <dedent> path = path [ len ( working_tree_linux ) + 1 : ] <newline> if not path : <newline> <indent> raise ValueError ( "Absolute ▁ submodule ▁ path ▁'%s' ▁ didn't ▁ yield ▁ a ▁ valid ▁ relative ▁ path" % path ) <newline>  # ▁ end ▁ verify ▁ converted ▁ relative ▁ path ▁ makes ▁ sense <encdom>  # ▁ end ▁ convert ▁ to ▁ a ▁ relative ▁ path <encdom> <dedent> <dedent> return path <newline> <dedent> @ classmethod <newline> def _write_git_file_and_module_config ( cls , working_tree_dir , module_abspath ) : <newline> <indent>  """ Writes ▁ a ▁ .git ▁ file ▁ containing ▁ a ▁ (preferably) ▁ relative ▁ path ▁ to ▁ the ▁ actual ▁ git ▁ module ▁ repository. <strnewline> ▁ It ▁ is ▁ an ▁ error ▁ if ▁ the ▁ module_abspath ▁ cannot ▁ be ▁ made ▁ into ▁ a ▁ relative ▁ path, ▁ relative ▁ to ▁ the ▁ working_tree_dir <strnewline> ▁ :note: ▁ will ▁ overwrite ▁ existing ▁ files ▁ ! <strnewline> ▁ :note: ▁ as ▁ we ▁ rewrite ▁ both ▁ the ▁ git ▁ file ▁ as ▁ well ▁ as ▁ the ▁ module ▁ configuration, ▁ we ▁ might ▁ fail ▁ on ▁ the ▁ configuration <strnewline> ▁ and ▁ will ▁ not ▁ roll ▁ back ▁ changes ▁ done ▁ to ▁ the ▁ git ▁ file. ▁ This ▁ should ▁ be ▁ a ▁ non-issue, ▁ but ▁ may ▁ easily ▁ be ▁ fixed <strnewline> ▁ if ▁ it ▁ becomes ▁ one <strnewline> ▁ :param ▁ working_tree_dir: ▁ directory ▁ to ▁ write ▁ the ▁ .git ▁ file ▁ into <strnewline> ▁ :param ▁ module_abspath: ▁ absolute ▁ path ▁ to ▁ the ▁ bare ▁ repository <strnewline> ▁ """  <newline> git_file = os . path . join ( working_tree_dir , '.git' ) <newline> rela_path = os . path . relpath ( module_abspath , start = working_tree_dir ) <newline> fp = open ( git_file , 'wb' ) <newline> fp . write ( ( "gitdir: ▁ %s" % rela_path ) . encode ( defenc ) ) <newline> fp . close ( ) <newline> writer = GitConfigParser ( os . path . join ( module_abspath , 'config' ) , read_only = False , merge_includes = False ) <newline> writer . set_value ( 'core' , 'worktree' , to_native_path_linux ( os . path . relpath ( working_tree_dir , start = module_abspath ) ) ) <newline> writer . release ( ) <newline>  # { ▁ Edit ▁ Interface <encdom> <dedent> @ classmethod <newline> def add ( cls , repo , name , path , url = None , branch = None , no_checkout = False ) : <newline> <indent>  """ Add ▁ a ▁ new ▁ submodule ▁ to ▁ the ▁ given ▁ repository. ▁ This ▁ will ▁ alter ▁ the ▁ index <strnewline> ▁ as ▁ well ▁ as ▁ the ▁ .gitmodules ▁ file, ▁ but ▁ will ▁ not ▁ create ▁ a ▁ new ▁ commit. <strnewline> ▁ If ▁ the ▁ submodule ▁ already ▁ exists, ▁ no ▁ matter ▁ if ▁ the ▁ configuration ▁ differs <strnewline> ▁ from ▁ the ▁ one ▁ provided, ▁ the ▁ existing ▁ submodule ▁ will ▁ be ▁ returned. <strnewline> <strnewline> ▁ :param ▁ repo: ▁ Repository ▁ instance ▁ which ▁ should ▁ receive ▁ the ▁ submodule <strnewline> ▁ :param ▁ name: ▁ The ▁ name/identifier ▁ for ▁ the ▁ submodule <strnewline> ▁ :param ▁ path: ▁ repository-relative ▁ or ▁ absolute ▁ path ▁ at ▁ which ▁ the ▁ submodule <strnewline> ▁ should ▁ be ▁ located <strnewline> ▁ It ▁ will ▁ be ▁ created ▁ as ▁ required ▁ during ▁ the ▁ repository ▁ initialization. <strnewline> ▁ :param ▁ url: ▁ git-clone ▁ compatible ▁ URL, ▁ see ▁ git-clone ▁ reference ▁ for ▁ more ▁ information <strnewline> ▁ If ▁ None, ▁ the ▁ repository ▁ is ▁ assumed ▁ to ▁ exist, ▁ and ▁ the ▁ url ▁ of ▁ the ▁ first <strnewline> ▁ remote ▁ is ▁ taken ▁ instead. ▁ This ▁ is ▁ useful ▁ if ▁ you ▁ want ▁ to ▁ make ▁ an ▁ existing <strnewline> ▁ repository ▁ a ▁ submodule ▁ of ▁ anotherone. <strnewline> ▁ :param ▁ branch: ▁ name ▁ of ▁ branch ▁ at ▁ which ▁ the ▁ submodule ▁ should ▁ (later) ▁ be ▁ checked ▁ out. <strnewline> ▁ The ▁ given ▁ branch ▁ must ▁ exist ▁ in ▁ the ▁ remote ▁ repository, ▁ and ▁ will ▁ be ▁ checked <strnewline> ▁ out ▁ locally ▁ as ▁ a ▁ tracking ▁ branch. <strnewline> ▁ It ▁ will ▁ only ▁ be ▁ written ▁ into ▁ the ▁ configuration ▁ if ▁ it ▁ not ▁ None, ▁ which ▁ is <strnewline> ▁ when ▁ the ▁ checked ▁ out ▁ branch ▁ will ▁ be ▁ the ▁ one ▁ the ▁ remote ▁ HEAD ▁ pointed ▁ to. <strnewline> ▁ The ▁ result ▁ you ▁ get ▁ in ▁ these ▁ situation ▁ is ▁ somewhat ▁ fuzzy, ▁ and ▁ it ▁ is ▁ recommended <strnewline> ▁ to ▁ specify ▁ at ▁ least ▁'master' ▁ here. <strnewline> ▁ Examples ▁ are ▁'master' ▁ or ▁'feature/new' <strnewline> ▁ :param ▁ no_checkout: ▁ if ▁ True, ▁ and ▁ if ▁ the ▁ repository ▁ has ▁ to ▁ be ▁ cloned ▁ manually, <strnewline> ▁ no ▁ checkout ▁ will ▁ be ▁ performed <strnewline> ▁ :return: ▁ The ▁ newly ▁ created ▁ submodule ▁ instance <strnewline> ▁ :note: ▁ works ▁ atomically, ▁ such ▁ that ▁ no ▁ change ▁ will ▁ be ▁ done ▁ if ▁ the ▁ repository <strnewline> ▁ update ▁ fails ▁ for ▁ instance """  <newline> if repo . bare : <newline> <indent> raise InvalidGitRepositoryError ( "Cannot ▁ add ▁ submodules ▁ to ▁ bare ▁ repositories" ) <newline>  # ▁ END ▁ handle ▁ bare ▁ repos <encdom> <dedent> path = cls . _to_relative_path ( repo , path ) <newline>  # ▁ assure ▁ we ▁ never ▁ put ▁ backslashes ▁ into ▁ the ▁ url, ▁ as ▁ some ▁ operating ▁ systems <encdom>  # ▁ like ▁ it ▁ ... <encdom> if url is not None : <newline> <indent> url = to_native_path_linux ( url ) <newline>  # ▁ END ▁ assure ▁ url ▁ correctness <encdom>  # ▁ INSTANTIATE ▁ INTERMEDIATE ▁ SM <encdom> <dedent> sm = cls ( repo , cls . NULL_BIN_SHA , cls . k_default_mode , path , name , url = 'invalid-temporary' ) <newline> if sm . exists ( ) : <newline>  # ▁ reretrieve ▁ submodule ▁ from ▁ tree <encdom> <indent> try : <newline> <indent> return repo . head . commit . tree [ path ] <newline> <dedent> except KeyError : <newline>  # ▁ could ▁ only ▁ be ▁ in ▁ index <encdom> <indent> index = repo . index <newline> entry = index . entries [ index . entry_key ( path , 0 ) ] <newline> sm . binsha = entry . binsha <newline> return sm <newline>  # ▁ END ▁ handle ▁ exceptions <encdom>  # ▁ END ▁ handle ▁ existing <encdom>  # ▁ fake-repo ▁ - ▁ we ▁ only ▁ need ▁ the ▁ functionality ▁ on ▁ the ▁ branch ▁ instance <encdom> <dedent> <dedent> br = git . Head ( repo , git . Head . to_full_path ( str ( branch ) or cls . k_head_default ) ) <newline> has_module = sm . module_exists ( ) <newline> branch_is_default = branch is None <newline> if has_module and url is not None : <newline> <indent> if url not in [ r . url for r in sm . module ( ) . remotes ] : <newline> <indent> raise ValueError ( "Specified ▁ URL ▁'%s' ▁ does ▁ not ▁ match ▁ any ▁ remote ▁ url ▁ of ▁ the ▁ repository ▁ at ▁'%s'" % ( url , sm . abspath ) ) <newline>  # ▁ END ▁ check ▁ url <encdom>  # ▁ END ▁ verify ▁ urls ▁ match <encdom> <dedent> <dedent> mrepo = None <newline> if url is None : <newline> <indent> if not has_module : <newline> <indent> raise ValueError ( "A ▁ URL ▁ was ▁ not ▁ given ▁ and ▁ existing ▁ repository ▁ did ▁ not ▁ exsit ▁ at ▁ %s" % path ) <newline>  # ▁ END ▁ check ▁ url <encdom> <dedent> mrepo = sm . module ( ) <newline> urls = [ r . url for r in mrepo . remotes ] <newline> if not urls : <newline> <indent> raise ValueError ( "Didn't ▁ find ▁ any ▁ remote ▁ url ▁ in ▁ repository ▁ at ▁ %s" % sm . abspath ) <newline>  # ▁ END ▁ verify ▁ we ▁ have ▁ url <encdom> <dedent> url = urls [ 0 ] <newline> <dedent> else : <newline>  # ▁ clone ▁ new ▁ repo <encdom> <indent> kwargs = { 'n' : no_checkout } <newline> if not branch_is_default : <newline> <indent> kwargs [ 'b' ] = br . name <newline>  # ▁ END ▁ setup ▁ checkout-branch <encdom>  # ▁ _clone_repo(cls, ▁ repo, ▁ url, ▁ path, ▁ name, ▁ **kwargs): <encdom> <dedent> mrepo = cls . _clone_repo ( repo , url , path , name , ** kwargs ) <newline>  # ▁ END ▁ verify ▁ url <encdom>  # ▁ It's ▁ important ▁ to ▁ add ▁ the ▁ URL ▁ to ▁ the ▁ parent ▁ config, ▁ to ▁ let ▁ `git ▁ submodule` ▁ know. <encdom>  # ▁ otherwise ▁ there ▁ is ▁ a ▁'-' ▁ character ▁ in ▁ front ▁ of ▁ the ▁ submodule ▁ listing <encdom>  # ▁ a38efa84daef914e4de58d1905a500d8d14aaf45 ▁ mymodule ▁ (v0.9.0-1-ga38efa8) <encdom>  # ▁ -a38efa84daef914e4de58d1905a500d8d14aaf45 ▁ submodules/intermediate/one <encdom> <dedent> writer = sm . repo . config_writer ( ) <newline> writer . set_value ( sm_section ( name ) , 'url' , url ) <newline> writer . release ( ) <newline>  # ▁ update ▁ configuration ▁ and ▁ index <encdom> index = sm . repo . index <newline> writer = sm . config_writer ( index = index , write = False ) <newline> writer . set_value ( 'url' , url ) <newline> writer . set_value ( 'path' , path ) <newline> sm . _url = url <newline> if not branch_is_default : <newline>  # ▁ store ▁ full ▁ path <encdom> <indent> writer . set_value ( cls . k_head_option , br . path ) <newline> sm . _branch_path = br . path <newline>  # ▁ END ▁ handle ▁ path <encdom> <dedent> writer . release ( ) <newline> del ( writer ) <newline>  # ▁ we ▁ deliberatly ▁ assume ▁ that ▁ our ▁ head ▁ matches ▁ our ▁ index ▁ ! <encdom> sm . binsha = mrepo . head . commit . binsha <newline> index . add ( [ sm ] , write = True ) <newline> return sm <newline> <dedent> def update ( self , recursive = False , init = True , to_latest_revision = False , progress = None , dry_run = False , force = False , keep_going = False ) : <newline> <indent>  """ Update ▁ the ▁ repository ▁ of ▁ this ▁ submodule ▁ to ▁ point ▁ to ▁ the ▁ checkout <strnewline> ▁ we ▁ point ▁ at ▁ with ▁ the ▁ binsha ▁ of ▁ this ▁ instance. <strnewline> <strnewline> ▁ :param ▁ recursive: ▁ if ▁ True, ▁ we ▁ will ▁ operate ▁ recursively ▁ and ▁ update ▁ child- <strnewline> ▁ modules ▁ as ▁ well. <strnewline> ▁ :param ▁ init: ▁ if ▁ True, ▁ the ▁ module ▁ repository ▁ will ▁ be ▁ cloned ▁ into ▁ place ▁ if ▁ necessary <strnewline> ▁ :param ▁ to_latest_revision: ▁ if ▁ True, ▁ the ▁ submodule's ▁ sha ▁ will ▁ be ▁ ignored ▁ during ▁ checkout. <strnewline> ▁ Instead, ▁ the ▁ remote ▁ will ▁ be ▁ fetched, ▁ and ▁ the ▁ local ▁ tracking ▁ branch ▁ updated. <strnewline> ▁ This ▁ only ▁ works ▁ if ▁ we ▁ have ▁ a ▁ local ▁ tracking ▁ branch, ▁ which ▁ is ▁ the ▁ case <strnewline> ▁ if ▁ the ▁ remote ▁ repository ▁ had ▁ a ▁ master ▁ branch, ▁ or ▁ of ▁ the ▁'branch' ▁ option <strnewline> ▁ was ▁ specified ▁ for ▁ this ▁ submodule ▁ and ▁ the ▁ branch ▁ existed ▁ remotely <strnewline> ▁ :param ▁ progress: ▁ UpdateProgress ▁ instance ▁ or ▁ None ▁ if ▁ no ▁ progress ▁ should ▁ be ▁ shown <strnewline> ▁ :param ▁ dry_run: ▁ if ▁ True, ▁ the ▁ operation ▁ will ▁ only ▁ be ▁ simulated, ▁ but ▁ not ▁ performed. <strnewline> ▁ All ▁ performed ▁ operations ▁ are ▁ read-only <strnewline> ▁ :param ▁ force: <strnewline> ▁ If ▁ True, ▁ we ▁ may ▁ reset ▁ heads ▁ even ▁ if ▁ the ▁ repository ▁ in ▁ question ▁ is ▁ dirty. ▁ Additinoally ▁ we ▁ will ▁ be ▁ allowed <strnewline> ▁ to ▁ set ▁ a ▁ tracking ▁ branch ▁ which ▁ is ▁ ahead ▁ of ▁ its ▁ remote ▁ branch ▁ back ▁ into ▁ the ▁ past ▁ or ▁ the ▁ location ▁ of ▁ the <strnewline> ▁ remote ▁ branch. ▁ This ▁ will ▁ essentially ▁'forget' ▁ commits. <strnewline> ▁ If ▁ False, ▁ local ▁ tracking ▁ branches ▁ that ▁ are ▁ in ▁ the ▁ future ▁ of ▁ their ▁ respective ▁ remote ▁ branches ▁ will ▁ simply <strnewline> ▁ not ▁ be ▁ moved. <strnewline> ▁ :param ▁ keep_going: ▁ if ▁ True, ▁ we ▁ will ▁ ignore ▁ but ▁ log ▁ all ▁ errors, ▁ and ▁ keep ▁ going ▁ recursively. <strnewline> ▁ Unless ▁ dry_run ▁ is ▁ set ▁ as ▁ well, ▁ keep_going ▁ could ▁ cause ▁ subsequent/inherited ▁ errors ▁ you ▁ wouldn't ▁ see <strnewline> ▁ otherwise. <strnewline> ▁ In ▁ conjunction ▁ with ▁ dry_run, ▁ it ▁ can ▁ be ▁ useful ▁ to ▁ anticipate ▁ all ▁ errors ▁ when ▁ updating ▁ submodules <strnewline> ▁ :note: ▁ does ▁ nothing ▁ in ▁ bare ▁ repositories <strnewline> ▁ :note: ▁ method ▁ is ▁ definitely ▁ not ▁ atomic ▁ if ▁ recurisve ▁ is ▁ True <strnewline> ▁ :return: ▁ self """  <newline> if self . repo . bare : <newline> <indent> return self <newline>  # ▁ END ▁ pass ▁ in ▁ bare ▁ mode <encdom> <dedent> if progress is None : <newline> <indent> progress = UpdateProgress ( ) <newline>  # ▁ END ▁ handle ▁ progress <encdom> <dedent> prefix = '' <newline> if dry_run : <newline> <indent> prefix = "DRY-RUN: ▁ " <newline>  # ▁ END ▁ handle ▁ prefix <encdom>  # ▁ to ▁ keep ▁ things ▁ plausible ▁ in ▁ dry-run ▁ mode <encdom> <dedent> if dry_run : <newline> <indent> mrepo = None <newline>  # ▁ END ▁ init ▁ mrepo <encdom> <dedent> try : <newline>  # ▁ ASSURE ▁ REPO ▁ IS ▁ PRESENT ▁ AND ▁ UPTODATE <encdom> <indent> try : <newline> <indent> mrepo = self . module ( ) <newline> rmts = mrepo . remotes <newline> len_rmts = len ( rmts ) <newline> for i , remote in enumerate ( rmts ) : <newline> <indent> op = FETCH <newline> if i == 0 : <newline> <indent> op |= BEGIN <newline>  # ▁ END ▁ handle ▁ start <encdom> <dedent> progress . update ( op , i , len_rmts , prefix + "Fetching ▁ remote ▁ %s ▁ of ▁ submodule ▁ %r" % ( remote , self . name ) ) <newline> if not dry_run : <newline> <indent> remote . fetch ( progress = progress ) <newline>  # ▁ END ▁ handle ▁ dry-run <encdom> <dedent> if i == len_rmts - 1 : <newline> <indent> op |= END <newline>  # ▁ END ▁ handle ▁ end <encdom> <dedent> progress . update ( op , i , len_rmts , prefix + "Done ▁ fetching ▁ remote ▁ of ▁ submodule ▁ %r" % self . name ) <newline>  # ▁ END ▁ fetch ▁ new ▁ data <encdom> <dedent> <dedent> except InvalidGitRepositoryError : <newline> <indent> if not init : <newline> <indent> return self <newline>  # ▁ END ▁ early ▁ abort ▁ if ▁ init ▁ is ▁ not ▁ allowed <encdom>  # ▁ there ▁ is ▁ no ▁ git-repository ▁ yet ▁ - ▁ but ▁ delete ▁ empty ▁ paths <encdom> <dedent> checkout_module_abspath = self . abspath <newline> if not dry_run and os . path . isdir ( checkout_module_abspath ) : <newline> <indent> try : <newline> <indent> os . rmdir ( checkout_module_abspath ) <newline> <dedent> except OSError : <newline> <indent> raise OSError ( "Module ▁ directory ▁ at ▁ %r ▁ does ▁ already ▁ exist ▁ and ▁ is ▁ non-empty" % checkout_module_abspath ) <newline>  # ▁ END ▁ handle ▁ OSError <encdom>  # ▁ END ▁ handle ▁ directory ▁ removal <encdom>  # ▁ don't ▁ check ▁ it ▁ out ▁ at ▁ first ▁ - ▁ nonetheless ▁ it ▁ will ▁ create ▁ a ▁ local <encdom>  # ▁ branch ▁ according ▁ to ▁ the ▁ remote-HEAD ▁ if ▁ possible <encdom> <dedent> <dedent> progress . update ( BEGIN | CLONE , 0 , 1 , prefix + "Cloning ▁ url ▁'%s' ▁ to ▁'%s' ▁ in ▁ submodule ▁ %r" % ( self . url , checkout_module_abspath , self . name ) ) <newline> if not dry_run : <newline> <indent> mrepo = self . _clone_repo ( self . repo , self . url , self . path , self . name , n = True ) <newline>  # ▁ END ▁ handle ▁ dry-run <encdom> <dedent> progress . update ( END | CLONE , 0 , 1 , prefix + "Done ▁ cloning ▁ to ▁ %s" % checkout_module_abspath ) <newline> if not dry_run : <newline>  # ▁ see ▁ whether ▁ we ▁ have ▁ a ▁ valid ▁ branch ▁ to ▁ checkout <encdom> <indent> try : <newline>  # ▁ find ▁ a ▁ remote ▁ which ▁ has ▁ our ▁ branch ▁ - ▁ we ▁ try ▁ to ▁ be ▁ flexible <encdom> <indent> remote_branch = find_first_remote_branch ( mrepo . remotes , self . branch_name ) <newline> local_branch = mkhead ( mrepo , self . branch_path ) <newline>  # ▁ have ▁ a ▁ valid ▁ branch, ▁ but ▁ no ▁ checkout ▁ - ▁ make ▁ sure ▁ we ▁ can ▁ figure <encdom>  # ▁ that ▁ out ▁ by ▁ marking ▁ the ▁ commit ▁ with ▁ a ▁ null_sha <encdom> local_branch . set_object ( util . Object ( mrepo , self . NULL_BIN_SHA ) ) <newline>  # ▁ END ▁ initial ▁ checkout ▁ + ▁ branch ▁ creation <encdom>  # ▁ make ▁ sure ▁ HEAD ▁ is ▁ not ▁ detached <encdom> mrepo . head . set_reference ( local_branch , logmsg = "submodule: ▁ attaching ▁ head ▁ to ▁ %s" % local_branch ) <newline> mrepo . head . ref . set_tracking_branch ( remote_branch ) <newline> <dedent> except IndexError : <newline> <indent> log . warn ( "Failed ▁ to ▁ checkout ▁ tracking ▁ branch ▁ %s" , self . branch_path ) <newline>  # ▁ END ▁ handle ▁ tracking ▁ branch <encdom>  # ▁ NOTE: ▁ Have ▁ to ▁ write ▁ the ▁ repo ▁ config ▁ file ▁ as ▁ well, ▁ otherwise <encdom>  # ▁ the ▁ default ▁ implementation ▁ will ▁ be ▁ offended ▁ and ▁ not ▁ update ▁ the ▁ repository <encdom>  # ▁ Maybe ▁ this ▁ is ▁ a ▁ good ▁ way ▁ to ▁ assure ▁ it ▁ doesn't ▁ get ▁ into ▁ our ▁ way, ▁ but <encdom>  # ▁ we ▁ want ▁ to ▁ stay ▁ backwards ▁ compatible ▁ too ▁ ... ▁ . ▁ Its ▁ so ▁ redundant ▁ ! <encdom> <dedent> writer = self . repo . config_writer ( ) <newline> writer . set_value ( sm_section ( self . name ) , 'url' , self . url ) <newline> writer . release ( ) <newline>  # ▁ END ▁ handle ▁ dry_run <encdom>  # ▁ END ▁ handle ▁ initalization <encdom>  # ▁ DETERMINE ▁ SHAS ▁ TO ▁ CHECKOUT <encdom> <dedent> <dedent> binsha = self . binsha <newline> hexsha = self . hexsha <newline> if mrepo is not None : <newline>  # ▁ mrepo ▁ is ▁ only ▁ set ▁ if ▁ we ▁ are ▁ not ▁ in ▁ dry-run ▁ mode ▁ or ▁ if ▁ the ▁ module ▁ existed <encdom> <indent> is_detached = mrepo . head . is_detached <newline>  # ▁ END ▁ handle ▁ dry_run <encdom> <dedent> if mrepo is not None and to_latest_revision : <newline> <indent> msg_base = "Cannot ▁ update ▁ to ▁ latest ▁ revision ▁ in ▁ repository ▁ at ▁ %r ▁ as ▁ " % mrepo . working_dir <newline> if not is_detached : <newline> <indent> rref = mrepo . head . ref . tracking_branch ( ) <newline> if rref is not None : <newline> <indent> rcommit = rref . commit <newline> binsha = rcommit . binsha <newline> hexsha = rcommit . hexsha <newline> <dedent> else : <newline> <indent> log . error ( "%s ▁ a ▁ tracking ▁ branch ▁ was ▁ not ▁ set ▁ for ▁ local ▁ branch ▁'%s'" , msg_base , mrepo . head . ref ) <newline>  # ▁ END ▁ handle ▁ remote ▁ ref <encdom> <dedent> <dedent> else : <newline> <indent> log . error ( "%s ▁ there ▁ was ▁ no ▁ local ▁ tracking ▁ branch" , msg_base ) <newline>  # ▁ END ▁ handle ▁ detached ▁ head <encdom>  # ▁ END ▁ handle ▁ to_latest_revision ▁ option <encdom>  # ▁ update ▁ the ▁ working ▁ tree <encdom>  # ▁ handles ▁ dry_run <encdom> <dedent> <dedent> if mrepo is not None and mrepo . head . commit . binsha != binsha : <newline>  # ▁ We ▁ must ▁ assure ▁ that ▁ our ▁ destination ▁ sha ▁ (the ▁ one ▁ to ▁ point ▁ to) ▁ is ▁ in ▁ the ▁ future ▁ of ▁ our ▁ current ▁ head. <encdom>  # ▁ Otherwise, ▁ we ▁ will ▁ reset ▁ changes ▁ that ▁ might ▁ have ▁ been ▁ done ▁ on ▁ the ▁ submodule, ▁ but ▁ were ▁ not ▁ yet ▁ pushed <encdom>  # ▁ We ▁ also ▁ handle ▁ the ▁ case ▁ that ▁ history ▁ has ▁ been ▁ rewritten, ▁ leaving ▁ no ▁ merge-base. ▁ In ▁ that ▁ case <encdom>  # ▁ we ▁ behave ▁ conservatively, ▁ protecting ▁ possible ▁ changes ▁ the ▁ user ▁ had ▁ done <encdom> <indent> may_reset = True <newline> if mrepo . head . commit . binsha != self . NULL_BIN_SHA : <newline> <indent> base_commit = mrepo . merge_base ( mrepo . head . commit , hexsha ) <newline> if len ( base_commit ) == 0 or base_commit [ 0 ] . hexsha == hexsha : <newline> <indent> if force : <newline> <indent> msg = "Will ▁ force ▁ checkout ▁ or ▁ reset ▁ on ▁ local ▁ branch ▁ that ▁ is ▁ possibly ▁ in ▁ the ▁ future ▁ of" <newline> msg += "the ▁ commit ▁ it ▁ will ▁ be ▁ checked ▁ out ▁ to, ▁ effectively ▁'forgetting' ▁ new ▁ commits" <newline> log . debug ( msg ) <newline> <dedent> else : <newline> <indent> msg = "Skipping ▁ %s ▁ on ▁ branch ▁'%s' ▁ of ▁ submodule ▁ repo ▁'%s' ▁ as ▁ it ▁ contains ▁ un-pushed ▁ commits" <newline> msg %= ( is_detached and "checkout" or "reset" , mrepo . head , mrepo ) <newline> log . info ( msg ) <newline> may_reset = False <newline>  # ▁ end ▁ handle ▁ force <encdom>  # ▁ end ▁ handle ▁ if ▁ we ▁ are ▁ in ▁ the ▁ future <encdom> <dedent> <dedent> if may_reset and not force and mrepo . is_dirty ( index = True , working_tree = True , untracked_files = True ) : <newline> <indent> raise RepositoryDirtyError ( mrepo , "Cannot ▁ reset ▁ a ▁ dirty ▁ repository" ) <newline>  # ▁ end ▁ handle ▁ force ▁ and ▁ dirty ▁ state <encdom>  # ▁ end ▁ handle ▁ empty ▁ repo <encdom>  # ▁ end ▁ verify ▁ future/past <encdom> <dedent> <dedent> progress . update ( BEGIN | UPDWKTREE , 0 , 1 , prefix + "Updating ▁ working ▁ tree ▁ at ▁ %s ▁ for ▁ submodule ▁ %r ▁ to ▁ revision ▁ %s" % ( self . path , self . name , hexsha ) ) <newline> if not dry_run and may_reset : <newline> <indent> if is_detached : <newline>  # ▁ NOTE: ▁ for ▁ now ▁ we ▁ force, ▁ the ▁ user ▁ is ▁ no ▁ supposed ▁ to ▁ change ▁ detached <encdom>  # ▁ submodules ▁ anyway. ▁ Maybe ▁ at ▁ some ▁ point ▁ this ▁ becomes ▁ an ▁ option, ▁ to <encdom>  # ▁ properly ▁ handle ▁ user ▁ modifications ▁ - ▁ see ▁ below ▁ for ▁ future ▁ options <encdom>  # ▁ regarding ▁ rebase ▁ and ▁ merge. <encdom> <indent> mrepo . git . checkout ( hexsha , force = force ) <newline> <dedent> else : <newline> <indent> mrepo . head . reset ( hexsha , index = True , working_tree = True ) <newline>  # ▁ END ▁ handle ▁ checkout <encdom>  # ▁ if ▁ we ▁ may ▁ reset/checkout <encdom> <dedent> <dedent> progress . update ( END | UPDWKTREE , 0 , 1 , prefix + "Done ▁ updating ▁ working ▁ tree ▁ for ▁ submodule ▁ %r" % self . name ) <newline>  # ▁ END ▁ update ▁ to ▁ new ▁ commit ▁ only ▁ if ▁ needed <encdom> <dedent> <dedent> except Exception as err : <newline> <indent> if not keep_going : <newline> <indent> raise <newline> <dedent> log . error ( str ( err ) ) <newline>  # ▁ end ▁ handle ▁ keep_going <encdom>  # ▁ HANDLE ▁ RECURSION <encdom> <dedent> if recursive : <newline>  # ▁ in ▁ dry_run ▁ mode, ▁ the ▁ module ▁ might ▁ not ▁ exist <encdom> <indent> if mrepo is not None : <newline> <indent> for submodule in self . iter_items ( self . module ( ) ) : <newline> <indent> submodule . update ( recursive , init , to_latest_revision , progress = progress , dry_run = dry_run , force = force , keep_going = keep_going ) <newline>  # ▁ END ▁ handle ▁ recursive ▁ update <encdom>  # ▁ END ▁ handle ▁ dry ▁ run <encdom>  # ▁ END ▁ for ▁ each ▁ submodule <encdom> <dedent> <dedent> <dedent> return self <newline> <dedent> @ unbare_repo <newline> def move ( self , module_path , configuration = True , module = True ) : <newline> <indent>  """ Move ▁ the ▁ submodule ▁ to ▁ a ▁ another ▁ module ▁ path. ▁ This ▁ involves ▁ physically ▁ moving <strnewline> ▁ the ▁ repository ▁ at ▁ our ▁ current ▁ path, ▁ changing ▁ the ▁ configuration, ▁ as ▁ well ▁ as <strnewline> ▁ adjusting ▁ our ▁ index ▁ entry ▁ accordingly. <strnewline> <strnewline> ▁ :param ▁ module_path: ▁ the ▁ path ▁ to ▁ which ▁ to ▁ move ▁ our ▁ module ▁ in ▁ the ▁ parent ▁ repostory's ▁ working ▁ tree, <strnewline> ▁ given ▁ as ▁ repository-relative ▁ or ▁ absolute ▁ path. ▁ Intermediate ▁ directories ▁ will ▁ be ▁ created <strnewline> ▁ accordingly. ▁ If ▁ the ▁ path ▁ already ▁ exists, ▁ it ▁ must ▁ be ▁ empty. <strnewline> ▁ Trailing ▁ (back)slashes ▁ are ▁ removed ▁ automatically <strnewline> ▁ :param ▁ configuration: ▁ if ▁ True, ▁ the ▁ configuration ▁ will ▁ be ▁ adjusted ▁ to ▁ let <strnewline> ▁ the ▁ submodule ▁ point ▁ to ▁ the ▁ given ▁ path. <strnewline> ▁ :param ▁ module: ▁ if ▁ True, ▁ the ▁ repository ▁ managed ▁ by ▁ this ▁ submodule <strnewline> ▁ will ▁ be ▁ moved ▁ as ▁ well. ▁ If ▁ False, ▁ we ▁ don't ▁ move ▁ the ▁ submodule's ▁ checkout, ▁ which ▁ may ▁ leave <strnewline> ▁ the ▁ parent ▁ repository ▁ in ▁ an ▁ inconsistent ▁ state. <strnewline> ▁ :return: ▁ self <strnewline> ▁ :raise ▁ ValueError: ▁ if ▁ the ▁ module ▁ path ▁ existed ▁ and ▁ was ▁ not ▁ empty, ▁ or ▁ was ▁ a ▁ file <strnewline> ▁ :note: ▁ Currently ▁ the ▁ method ▁ is ▁ not ▁ atomic, ▁ and ▁ it ▁ could ▁ leave ▁ the ▁ repository <strnewline> ▁ in ▁ an ▁ inconsistent ▁ state ▁ if ▁ a ▁ sub-step ▁ fails ▁ for ▁ some ▁ reason <strnewline> ▁ """  <newline> if module + configuration < 1 : <newline> <indent> raise ValueError ( "You ▁ must ▁ specify ▁ to ▁ move ▁ at ▁ least ▁ the ▁ module ▁ or ▁ the ▁ configuration ▁ of ▁ the ▁ submodule" ) <newline>  # ▁ END ▁ handle ▁ input <encdom> <dedent> module_checkout_path = self . _to_relative_path ( self . repo , module_path ) <newline>  # ▁ VERIFY ▁ DESTINATION <encdom> if module_checkout_path == self . path : <newline> <indent> return self <newline>  # ▁ END ▁ handle ▁ no ▁ change <encdom> <dedent> module_checkout_abspath = join_path_native ( self . repo . working_tree_dir , module_checkout_path ) <newline> if os . path . isfile ( module_checkout_abspath ) : <newline> <indent> raise ValueError ( "Cannot ▁ move ▁ repository ▁ onto ▁ a ▁ file: ▁ %s" % module_checkout_abspath ) <newline>  # ▁ END ▁ handle ▁ target ▁ files <encdom> <dedent> index = self . repo . index <newline> tekey = index . entry_key ( module_checkout_path , 0 ) <newline>  # ▁ if ▁ the ▁ target ▁ item ▁ already ▁ exists, ▁ fail <encdom> if configuration and tekey in index . entries : <newline> <indent> raise ValueError ( "Index ▁ entry ▁ for ▁ target ▁ path ▁ did ▁ already ▁ exist" ) <newline>  # ▁ END ▁ handle ▁ index ▁ key ▁ already ▁ there <encdom>  # ▁ remove ▁ existing ▁ destination <encdom> <dedent> if module : <newline> <indent> if os . path . exists ( module_checkout_abspath ) : <newline> <indent> if len ( os . listdir ( module_checkout_abspath ) ) : <newline> <indent> raise ValueError ( "Destination ▁ module ▁ directory ▁ was ▁ not ▁ empty" ) <newline>  # ▁ END ▁ handle ▁ non-emptiness <encdom> <dedent> if os . path . islink ( module_checkout_abspath ) : <newline> <indent> os . remove ( module_checkout_abspath ) <newline> <dedent> else : <newline> <indent> os . rmdir ( module_checkout_abspath ) <newline>  # ▁ END ▁ handle ▁ link <encdom> <dedent> <dedent> else : <newline>  # ▁ recreate ▁ parent ▁ directories <encdom>  # ▁ NOTE: ▁ renames() ▁ does ▁ that ▁ now <encdom> <indent> pass <newline>  # ▁ END ▁ handle ▁ existence <encdom>  # ▁ END ▁ handle ▁ module <encdom>  # ▁ move ▁ the ▁ module ▁ into ▁ place ▁ if ▁ possible <encdom> <dedent> <dedent> cur_path = self . abspath <newline> renamed_module = False <newline> if module and os . path . exists ( cur_path ) : <newline> <indent> os . renames ( cur_path , module_checkout_abspath ) <newline> renamed_module = True <newline> if os . path . isfile ( os . path . join ( module_checkout_abspath , '.git' ) ) : <newline> <indent> module_abspath = self . _module_abspath ( self . repo , self . path , self . name ) <newline> self . _write_git_file_and_module_config ( module_checkout_abspath , module_abspath ) <newline>  # ▁ end ▁ handle ▁ git ▁ file ▁ rewrite <encdom>  # ▁ END ▁ move ▁ physical ▁ module <encdom>  # ▁ rename ▁ the ▁ index ▁ entry ▁ - ▁ have ▁ to ▁ manipulate ▁ the ▁ index ▁ directly ▁ as <encdom>  # ▁ git-mv ▁ cannot ▁ be ▁ used ▁ on ▁ submodules ▁ ... ▁ yeah <encdom> <dedent> <dedent> previous_sm_path = self . path <newline> try : <newline> <indent> if configuration : <newline> <indent> try : <newline> <indent> ekey = index . entry_key ( self . path , 0 ) <newline> entry = index . entries [ ekey ] <newline> del ( index . entries [ ekey ] ) <newline> nentry = git . IndexEntry ( entry [ : 3 ] + ( module_checkout_path , ) + entry [ 4 : ] ) <newline> index . entries [ tekey ] = nentry <newline> <dedent> except KeyError : <newline> <indent> raise InvalidGitRepositoryError ( "Submodule's ▁ entry ▁ at ▁ %r ▁ did ▁ not ▁ exist" % ( self . path ) ) <newline>  # ▁ END ▁ handle ▁ submodule ▁ doesn't ▁ exist <encdom>  # ▁ update ▁ configuration <encdom> <dedent> writer = self . config_writer ( index = index )  # ▁ auto-write <encdom> <newline> writer . set_value ( 'path' , module_checkout_path ) <newline> self . path = module_checkout_path <newline> writer . release ( ) <newline> del ( writer ) <newline>  # ▁ END ▁ handle ▁ configuration ▁ flag <encdom> <dedent> <dedent> except Exception : <newline> <indent> if renamed_module : <newline> <indent> os . renames ( module_checkout_abspath , cur_path ) <newline>  # ▁ END ▁ undo ▁ module ▁ renaming <encdom> <dedent> raise <newline>  # ▁ END ▁ handle ▁ undo ▁ rename <encdom>  # ▁ Auto-rename ▁ submodule ▁ if ▁ it's ▁ name ▁ was ▁'default', ▁ that ▁ is, ▁ the ▁ checkout ▁ directory <encdom> <dedent> if previous_sm_path == self . name : <newline> <indent> self . rename ( module_checkout_path ) <newline>  # ▁ end <encdom> <dedent> return self <newline> <dedent> @ unbare_repo <newline> def remove ( self , module = True , force = False , configuration = True , dry_run = False ) : <newline> <indent>  """ Remove ▁ this ▁ submodule ▁ from ▁ the ▁ repository. ▁ This ▁ will ▁ remove ▁ our ▁ entry <strnewline> ▁ from ▁ the ▁ .gitmodules ▁ file ▁ and ▁ the ▁ entry ▁ in ▁ the ▁ .git/config ▁ file. <strnewline> <strnewline> ▁ :param ▁ module: ▁ If ▁ True, ▁ the ▁ module ▁ checkout ▁ we ▁ point ▁ to ▁ will ▁ be ▁ deleted <strnewline> ▁ as ▁ well. ▁ If ▁ the ▁ module ▁ is ▁ currently ▁ on ▁ a ▁ commit ▁ which ▁ is ▁ not ▁ part <strnewline> ▁ of ▁ any ▁ branch ▁ in ▁ the ▁ remote, ▁ if ▁ the ▁ currently ▁ checked ▁ out ▁ branch <strnewline> ▁ working ▁ tree, ▁ or ▁ untracked ▁ files, <strnewline> ▁ is ▁ ahead ▁ of ▁ its ▁ tracking ▁ branch, ▁ if ▁ you ▁ have ▁ modifications ▁ in ▁ the <strnewline> ▁ In ▁ case ▁ the ▁ removal ▁ of ▁ the ▁ repository ▁ fails ▁ for ▁ these ▁ reasons, ▁ the <strnewline> ▁ submodule ▁ status ▁ will ▁ not ▁ have ▁ been ▁ altered. <strnewline> ▁ If ▁ this ▁ submodule ▁ has ▁ child-modules ▁ on ▁ its ▁ own, ▁ these ▁ will ▁ be ▁ deleted <strnewline> ▁ prior ▁ to ▁ touching ▁ the ▁ own ▁ module. <strnewline> ▁ :param ▁ force: ▁ Enforces ▁ the ▁ deletion ▁ of ▁ the ▁ module ▁ even ▁ though ▁ it ▁ contains <strnewline> ▁ modifications. ▁ This ▁ basically ▁ enforces ▁ a ▁ brute-force ▁ file ▁ system ▁ based <strnewline> ▁ deletion. <strnewline> ▁ :param ▁ configuration: ▁ if ▁ True, ▁ the ▁ submodule ▁ is ▁ deleted ▁ from ▁ the ▁ configuration, <strnewline> ▁ otherwise ▁ it ▁ isn't. ▁ Although ▁ this ▁ should ▁ be ▁ enabled ▁ most ▁ of ▁ the ▁ times, <strnewline> ▁ this ▁ flag ▁ enables ▁ you ▁ to ▁ safely ▁ delete ▁ the ▁ repository ▁ of ▁ your ▁ submodule. <strnewline> ▁ :param ▁ dry_run: ▁ if ▁ True, ▁ we ▁ will ▁ not ▁ actually ▁ do ▁ anything, ▁ but ▁ throw ▁ the ▁ errors <strnewline> ▁ we ▁ would ▁ usually ▁ throw <strnewline> ▁ :return: ▁ self <strnewline> ▁ :note: ▁ doesn't ▁ work ▁ in ▁ bare ▁ repositories <strnewline> ▁ :note: ▁ doesn't ▁ work ▁ atomically, ▁ as ▁ failure ▁ to ▁ remove ▁ any ▁ part ▁ of ▁ the ▁ submodule ▁ will ▁ leave <strnewline> ▁ an ▁ inconsistent ▁ state <strnewline> ▁ :raise ▁ InvalidGitRepositoryError: ▁ thrown ▁ if ▁ the ▁ repository ▁ cannot ▁ be ▁ deleted <strnewline> ▁ :raise ▁ OSError: ▁ if ▁ directories ▁ or ▁ files ▁ could ▁ not ▁ be ▁ removed """  <newline> if not ( module or configuration ) : <newline> <indent> raise ValueError ( "Need ▁ to ▁ specify ▁ to ▁ delete ▁ at ▁ least ▁ the ▁ module, ▁ or ▁ the ▁ configuration" ) <newline>  # ▁ END ▁ handle ▁ parameters <encdom>  # ▁ Recursively ▁ remove ▁ children ▁ of ▁ this ▁ submodule <encdom> <dedent> nc = 0 <newline> for csm in self . children ( ) : <newline> <indent> nc += 1 <newline> csm . remove ( module , force , configuration , dry_run ) <newline> del ( csm ) <newline>  # ▁ end <encdom> <dedent> if configuration and not dry_run and nc > 0 : <newline>  # ▁ Assure ▁ we ▁ don't ▁ leave ▁ the ▁ parent ▁ repository ▁ in ▁ a ▁ dirty ▁ state, ▁ and ▁ commit ▁ our ▁ changes <encdom>  # ▁ It's ▁ important ▁ for ▁ recursive, ▁ unforced, ▁ deletions ▁ to ▁ work ▁ as ▁ expected <encdom> <indent> self . module ( ) . index . commit ( "Removed ▁ at ▁ least ▁ one ▁ of ▁ child-modules ▁ of ▁'%s'" % self . name ) <newline>  # ▁ end ▁ handle ▁ recursion <encdom>  # ▁ DELETE ▁ REPOSITORY ▁ WORKING ▁ TREE <encdom> <dedent> if module and self . module_exists ( ) : <newline> <indent> mod = self . module ( ) <newline> git_dir = mod . git_dir <newline> if force : <newline>  # ▁ take ▁ the ▁ fast ▁ lane ▁ and ▁ just ▁ delete ▁ everything ▁ in ▁ our ▁ module ▁ path <encdom>  # ▁ TODO: ▁ If ▁ we ▁ run ▁ into ▁ permission ▁ problems, ▁ we ▁ have ▁ a ▁ highly ▁ inconsistent <encdom>  # ▁ state. ▁ Delete ▁ the ▁ .git ▁ folders ▁ last, ▁ start ▁ with ▁ the ▁ submodules ▁ first <encdom> <indent> mp = self . abspath <newline> method = None <newline> if os . path . islink ( mp ) : <newline> <indent> method = os . remove <newline> <dedent> elif os . path . isdir ( mp ) : <newline> <indent> method = rmtree <newline> <dedent> elif os . path . exists ( mp ) : <newline> <indent> raise AssertionError ( "Cannot ▁ forcibly ▁ delete ▁ repository ▁ as ▁ it ▁ was ▁ neither ▁ a ▁ link, ▁ nor ▁ a ▁ directory" ) <newline>  # ▁ END ▁ handle ▁ brutal ▁ deletion <encdom> <dedent> if not dry_run : <newline> <indent> assert method <newline> method ( mp ) <newline>  # ▁ END ▁ apply ▁ deletion ▁ method <encdom> <dedent> <dedent> else : <newline>  # ▁ verify ▁ we ▁ may ▁ delete ▁ our ▁ module <encdom> <indent> if mod . is_dirty ( index = True , working_tree = True , untracked_files = True ) : <newline> <indent> raise InvalidGitRepositoryError ( "Cannot ▁ delete ▁ module ▁ at ▁ %s ▁ with ▁ any ▁ modifications, ▁ unless ▁ force ▁ is ▁ specified" % mod . working_tree_dir ) <newline>  # ▁ END ▁ check ▁ for ▁ dirt <encdom>  # ▁ figure ▁ out ▁ whether ▁ we ▁ have ▁ new ▁ commits ▁ compared ▁ to ▁ the ▁ remotes <encdom>  # ▁ NOTE: ▁ If ▁ the ▁ user ▁ pulled ▁ all ▁ the ▁ time, ▁ the ▁ remote ▁ heads ▁ might <encdom>  # ▁ not ▁ have ▁ been ▁ updated, ▁ so ▁ commits ▁ coming ▁ from ▁ the ▁ remote ▁ look <encdom>  # ▁ as ▁ if ▁ they ▁ come ▁ from ▁ us. ▁ But ▁ we ▁ stay ▁ strictly ▁ read-only ▁ and <encdom>  # ▁ don't ▁ fetch ▁ beforehand. <encdom> <dedent> for remote in mod . remotes : <newline> <indent> num_branches_with_new_commits = 0 <newline> rrefs = remote . refs <newline> for rref in rrefs : <newline> <indent> num_branches_with_new_commits += len ( mod . git . cherry ( rref ) ) != 0 <newline>  # ▁ END ▁ for ▁ each ▁ remote ▁ ref <encdom>  # ▁ not ▁ a ▁ single ▁ remote ▁ branch ▁ contained ▁ all ▁ our ▁ commits <encdom> <dedent> if num_branches_with_new_commits == len ( rrefs ) : <newline> <indent> raise InvalidGitRepositoryError ( "Cannot ▁ delete ▁ module ▁ at ▁ %s ▁ as ▁ there ▁ are ▁ new ▁ commits" % mod . working_tree_dir ) <newline>  # ▁ END ▁ handle ▁ new ▁ commits <encdom>  # ▁ have ▁ to ▁ manually ▁ delete ▁ references ▁ as ▁ python's ▁ scoping ▁ is <encdom>  # ▁ not ▁ existing, ▁ they ▁ could ▁ keep ▁ handles ▁ open ▁ ( ▁ on ▁ windows ▁ this ▁ is ▁ a ▁ problem ▁ ) <encdom> <dedent> if len ( rrefs ) : <newline> <indent> del ( rref ) <newline>  # ▁ END ▁ handle ▁ remotes <encdom> <dedent> del ( rrefs ) <newline> del ( remote ) <newline>  # ▁ END ▁ for ▁ each ▁ remote <encdom>  # ▁ finally ▁ delete ▁ our ▁ own ▁ submodule <encdom> <dedent> if not dry_run : <newline> <indent> wtd = mod . working_tree_dir <newline> del ( mod )  # ▁ release ▁ file-handles ▁ (windows) <encdom> <newline> rmtree ( wtd ) <newline>  # ▁ END ▁ delete ▁ tree ▁ if ▁ possible <encdom>  # ▁ END ▁ handle ▁ force <encdom> <dedent> <dedent> if not dry_run and os . path . isdir ( git_dir ) : <newline> <indent> rmtree ( git_dir ) <newline>  # ▁ end ▁ handle ▁ separate ▁ bare ▁ repository <encdom>  # ▁ END ▁ handle ▁ module ▁ deletion <encdom>  # ▁ void ▁ our ▁ data ▁ not ▁ to ▁ delay ▁ invalid ▁ access <encdom> <dedent> <dedent> if not dry_run : <newline> <indent> self . _clear_cache ( ) <newline>  # ▁ DELETE ▁ CONFIGURATION <encdom> <dedent> if configuration and not dry_run : <newline>  # ▁ first ▁ the ▁ index-entry <encdom> <indent> parent_index = self . repo . index <newline> try : <newline> <indent> del ( parent_index . entries [ parent_index . entry_key ( self . path , 0 ) ] ) <newline> <dedent> except KeyError : <newline> <indent> pass <newline>  # ▁ END ▁ delete ▁ entry <encdom> <dedent> parent_index . write ( ) <newline>  # ▁ now ▁ git ▁ config ▁ - ▁ need ▁ the ▁ config ▁ intact, ▁ otherwise ▁ we ▁ can't ▁ query <encdom>  # ▁ information ▁ anymore <encdom> writer = self . repo . config_writer ( ) <newline> writer . remove_section ( sm_section ( self . name ) ) <newline> writer . release ( ) <newline> writer = self . config_writer ( ) <newline> writer . remove_section ( ) <newline> writer . release ( ) <newline>  # ▁ END ▁ delete ▁ configuration <encdom> <dedent> return self <newline> <dedent> def set_parent_commit ( self , commit , check = True ) : <newline> <indent>  """ Set ▁ this ▁ instance ▁ to ▁ use ▁ the ▁ given ▁ commit ▁ whose ▁ tree ▁ is ▁ supposed ▁ to <strnewline> ▁ contain ▁ the ▁ .gitmodules ▁ blob. <strnewline> <strnewline> ▁ :param ▁ commit: <strnewline> ▁ Commit'ish ▁ reference ▁ pointing ▁ at ▁ the ▁ root_tree, ▁ or ▁ None ▁ to ▁ always ▁ point ▁ to ▁ the <strnewline> ▁ most ▁ recent ▁ commit <strnewline> ▁ :param ▁ check: <strnewline> ▁ if ▁ True, ▁ relatively ▁ expensive ▁ checks ▁ will ▁ be ▁ performed ▁ to ▁ verify <strnewline> ▁ validity ▁ of ▁ the ▁ submodule. <strnewline> ▁ :raise ▁ ValueError: ▁ if ▁ the ▁ commit's ▁ tree ▁ didn't ▁ contain ▁ the ▁ .gitmodules ▁ blob. <strnewline> ▁ :raise ▁ ValueError: <strnewline> ▁ if ▁ the ▁ parent ▁ commit ▁ didn't ▁ store ▁ this ▁ submodule ▁ under ▁ the ▁ current ▁ path <strnewline> ▁ :return: ▁ self """  <newline> if commit is None : <newline> <indent> self . _parent_commit = None <newline> return self <newline>  # ▁ end ▁ handle ▁ None <encdom> <dedent> pcommit = self . repo . commit ( commit ) <newline> pctree = pcommit . tree <newline> if self . k_modules_file not in pctree : <newline> <indent> raise ValueError ( "Tree ▁ of ▁ commit ▁ %s ▁ did ▁ not ▁ contain ▁ the ▁ %s ▁ file" % ( commit , self . k_modules_file ) ) <newline>  # ▁ END ▁ handle ▁ exceptions <encdom> <dedent> prev_pc = self . _parent_commit <newline> self . _parent_commit = pcommit <newline> if check : <newline> <indent> parser = self . _config_parser ( self . repo , self . _parent_commit , read_only = True ) <newline> if not parser . has_section ( sm_section ( self . name ) ) : <newline> <indent> self . _parent_commit = prev_pc <newline> raise ValueError ( "Submodule ▁ at ▁ path ▁ %r ▁ did ▁ not ▁ exist ▁ in ▁ parent ▁ commit ▁ %s" % ( self . path , commit ) ) <newline>  # ▁ END ▁ handle ▁ submodule ▁ did ▁ not ▁ exist <encdom>  # ▁ END ▁ handle ▁ checking ▁ mode <encdom>  # ▁ update ▁ our ▁ sha, ▁ it ▁ could ▁ have ▁ changed <encdom>  # ▁ If ▁ check ▁ is ▁ False, ▁ we ▁ might ▁ see ▁ a ▁ parent-commit ▁ that ▁ doens't ▁ even ▁ contain ▁ the ▁ submodule ▁ anymore. <encdom>  # ▁ in ▁ that ▁ case, ▁ mark ▁ our ▁ sha ▁ as ▁ being ▁ NULL <encdom> <dedent> <dedent> try : <newline> <indent> self . binsha = pctree [ self . path ] . binsha <newline> <dedent> except KeyError : <newline> <indent> self . binsha = self . NULL_BIN_SHA <newline>  # ▁ end <encdom> <dedent> self . _clear_cache ( ) <newline> return self <newline> <dedent> @ unbare_repo <newline> def config_writer ( self , index = None , write = True ) : <newline> <indent>  """ :return: ▁ a ▁ config ▁ writer ▁ instance ▁ allowing ▁ you ▁ to ▁ read ▁ and ▁ write ▁ the ▁ data <strnewline> ▁ belonging ▁ to ▁ this ▁ submodule ▁ into ▁ the ▁ .gitmodules ▁ file. <strnewline> <strnewline> ▁ :param ▁ index: ▁ if ▁ not ▁ None, ▁ an ▁ IndexFile ▁ instance ▁ which ▁ should ▁ be ▁ written. <strnewline> ▁ defaults ▁ to ▁ the ▁ index ▁ of ▁ the ▁ Submodule's ▁ parent ▁ repository. <strnewline> ▁ :param ▁ write: ▁ if ▁ True, ▁ the ▁ index ▁ will ▁ be ▁ written ▁ each ▁ time ▁ a ▁ configuration <strnewline> ▁ value ▁ changes. <strnewline> ▁ :note: ▁ the ▁ parameters ▁ allow ▁ for ▁ a ▁ more ▁ efficient ▁ writing ▁ of ▁ the ▁ index, <strnewline> ▁ as ▁ you ▁ can ▁ pass ▁ in ▁ a ▁ modified ▁ index ▁ on ▁ your ▁ own, ▁ prevent ▁ automatic ▁ writing, <strnewline> ▁ and ▁ write ▁ yourself ▁ once ▁ the ▁ whole ▁ operation ▁ is ▁ complete <strnewline> ▁ :raise ▁ ValueError: ▁ if ▁ trying ▁ to ▁ get ▁ a ▁ writer ▁ on ▁ a ▁ parent_commit ▁ which ▁ does ▁ not <strnewline> ▁ match ▁ the ▁ current ▁ head ▁ commit <strnewline> ▁ :raise ▁ IOError: ▁ If ▁ the ▁ .gitmodules ▁ file/blob ▁ could ▁ not ▁ be ▁ read """  <newline> writer = self . _config_parser_constrained ( read_only = False ) <newline> if index is not None : <newline> <indent> writer . config . _index = index <newline> <dedent> writer . config . _auto_write = write <newline> return writer <newline> <dedent> @ unbare_repo <newline> def rename ( self , new_name ) : <newline> <indent>  """ Rename ▁ this ▁ submodule <strnewline> ▁ :note: ▁ This ▁ method ▁ takes ▁ care ▁ of ▁ renaming ▁ the ▁ submodule ▁ in ▁ various ▁ places, ▁ such ▁ as <strnewline> <strnewline> ▁ * ▁ $parent_git_dir/config <strnewline> ▁ * ▁ $working_tree_dir/.gitmodules <strnewline> ▁ * ▁ (git ▁ >=v1.8.0: ▁ move ▁ submodule ▁ repository ▁ to ▁ new ▁ name) <strnewline> <strnewline> ▁ As ▁ .gitmodules ▁ will ▁ be ▁ changed, ▁ you ▁ would ▁ need ▁ to ▁ make ▁ a ▁ commit ▁ afterwards. ▁ The ▁ changed ▁ .gitmodules ▁ file <strnewline> ▁ will ▁ already ▁ be ▁ added ▁ to ▁ the ▁ index <strnewline> <strnewline> ▁ :return: ▁ this ▁ submodule ▁ instance <strnewline> ▁ """  <newline> if self . name == new_name : <newline> <indent> return self <newline>  # ▁ .git/config <encdom> <dedent> pw = self . repo . config_writer ( ) <newline>  # ▁ As ▁ we ▁ ourselves ▁ didn't ▁ write ▁ anything ▁ about ▁ submodules ▁ into ▁ the ▁ parent ▁ .git/config, ▁ we ▁ will ▁ not ▁ require <encdom>  # ▁ it ▁ to ▁ exist, ▁ and ▁ just ▁ ignore ▁ missing ▁ entries <encdom> if pw . has_section ( sm_section ( self . name ) ) : <newline> <indent> pw . rename_section ( sm_section ( self . name ) , sm_section ( new_name ) ) <newline>  # ▁ end <encdom> <dedent> pw . release ( ) <newline>  # ▁ .gitmodules <encdom> cw = self . config_writer ( write = True ) . config <newline> cw . rename_section ( sm_section ( self . name ) , sm_section ( new_name ) ) <newline> cw . release ( ) <newline> self . _name = new_name <newline>  # ▁ .git/modules <encdom> mod = self . module ( ) <newline> if mod . has_separate_working_tree ( ) : <newline> <indent> destination_module_abspath = self . _module_abspath ( self . repo , self . path , new_name ) <newline> source_dir = mod . git_dir <newline>  # ▁ Let's ▁ be ▁ sure ▁ the ▁ submodule ▁ name ▁ is ▁ not ▁ so ▁ obviously ▁ tied ▁ to ▁ a ▁ directory <encdom> if destination_module_abspath . startswith ( mod . git_dir ) : <newline> <indent> tmp_dir = self . _module_abspath ( self . repo , self . path , str ( uuid . uuid4 ( ) ) ) <newline> os . renames ( source_dir , tmp_dir ) <newline> source_dir = tmp_dir <newline>  # ▁ end ▁ handle ▁ self-containment <encdom> <dedent> os . renames ( source_dir , destination_module_abspath ) <newline> self . _write_git_file_and_module_config ( mod . working_tree_dir , destination_module_abspath ) <newline>  # ▁ end ▁ move ▁ separate ▁ git ▁ repository <encdom> <dedent> return self <newline>  # } ▁ END ▁ edit ▁ interface <encdom>  # { ▁ Query ▁ Interface <encdom> <dedent> @ unbare_repo <newline> def module ( self ) : <newline> <indent>  """ :return: ▁ Repo ▁ instance ▁ initialized ▁ from ▁ the ▁ repository ▁ at ▁ our ▁ submodule ▁ path <strnewline> ▁ :raise ▁ InvalidGitRepositoryError: ▁ if ▁ a ▁ repository ▁ was ▁ not ▁ available. ▁ This ▁ could <strnewline> ▁ also ▁ mean ▁ that ▁ it ▁ was ▁ not ▁ yet ▁ initialized """  <newline>  # ▁ late ▁ import ▁ to ▁ workaround ▁ circular ▁ dependencies <encdom> module_checkout_abspath = self . abspath <newline> try : <newline> <indent> repo = git . Repo ( module_checkout_abspath ) <newline> if repo != self . repo : <newline> <indent> return repo <newline>  # ▁ END ▁ handle ▁ repo ▁ uninitialized <encdom> <dedent> <dedent> except ( InvalidGitRepositoryError , NoSuchPathError ) : <newline> <indent> raise InvalidGitRepositoryError ( "No ▁ valid ▁ repository ▁ at ▁ %s" % module_checkout_abspath ) <newline> <dedent> else : <newline> <indent> raise InvalidGitRepositoryError ( "Repository ▁ at ▁ %r ▁ was ▁ not ▁ yet ▁ checked ▁ out" % module_checkout_abspath ) <newline>  # ▁ END ▁ handle ▁ exceptions <encdom> <dedent> <dedent> def module_exists ( self ) : <newline> <indent>  """ :return: ▁ True ▁ if ▁ our ▁ module ▁ exists ▁ and ▁ is ▁ a ▁ valid ▁ git ▁ repository. ▁ See ▁ module() ▁ method """  <newline> try : <newline> <indent> self . module ( ) <newline> return True <newline> <dedent> except Exception : <newline> <indent> return False <newline>  # ▁ END ▁ handle ▁ exception <encdom> <dedent> <dedent> def exists ( self ) : <newline> <indent>  """ <strnewline> ▁ :return: ▁ True ▁ if ▁ the ▁ submodule ▁ exists, ▁ False ▁ otherwise. ▁ Please ▁ note ▁ that <strnewline> ▁ a ▁ submodule ▁ may ▁ exist ▁ (in ▁ the ▁ .gitmodules ▁ file) ▁ even ▁ though ▁ its ▁ module <strnewline> ▁ doesn't ▁ exist ▁ on ▁ disk """  <newline>  # ▁ keep ▁ attributes ▁ for ▁ later, ▁ and ▁ restore ▁ them ▁ if ▁ we ▁ have ▁ no ▁ valid ▁ data <encdom>  # ▁ this ▁ way ▁ we ▁ do ▁ not ▁ actually ▁ alter ▁ the ▁ state ▁ of ▁ the ▁ object <encdom> loc = locals ( ) <newline> for attr in self . _cache_attrs : <newline> <indent> try : <newline> <indent> if hasattr ( self , attr ) : <newline> <indent> loc [ attr ] = getattr ( self , attr ) <newline>  # ▁ END ▁ if ▁ we ▁ have ▁ the ▁ attribute ▁ cache <encdom> <dedent> <dedent> except ( cp . NoSectionError , ValueError ) : <newline>  # ▁ on ▁ PY3, ▁ this ▁ can ▁ happen ▁ apparently ▁ ... ▁ don't ▁ know ▁ why ▁ this ▁ doesn't ▁ happen ▁ on ▁ PY2 <encdom> <indent> pass <newline>  # ▁ END ▁ for ▁ each ▁ attr <encdom> <dedent> <dedent> self . _clear_cache ( ) <newline> try : <newline> <indent> try : <newline> <indent> self . path <newline> return True <newline> <dedent> except Exception : <newline> <indent> return False <newline>  # ▁ END ▁ handle ▁ exceptions <encdom> <dedent> <dedent> finally : <newline> <indent> for attr in self . _cache_attrs : <newline> <indent> if attr in loc : <newline> <indent> setattr ( self , attr , loc [ attr ] ) <newline>  # ▁ END ▁ if ▁ we ▁ have ▁ a ▁ cache <encdom>  # ▁ END ▁ reapply ▁ each ▁ attribute <encdom>  # ▁ END ▁ handle ▁ object ▁ state ▁ consistency <encdom> <dedent> <dedent> <dedent> <dedent> @ property <newline> def branch ( self ) : <newline> <indent>  """ :return: ▁ The ▁ branch ▁ instance ▁ that ▁ we ▁ are ▁ to ▁ checkout <strnewline> ▁ :raise ▁ InvalidGitRepositoryError: ▁ if ▁ our ▁ module ▁ is ▁ not ▁ yet ▁ checked ▁ out """  <newline> return mkhead ( self . module ( ) , self . _branch_path ) <newline> <dedent> @ property <newline> def branch_path ( self ) : <newline> <indent>  """ <strnewline> ▁ :return: ▁ full ▁ (relative) ▁ path ▁ as ▁ string ▁ to ▁ the ▁ branch ▁ we ▁ would ▁ checkout <strnewline> ▁ from ▁ the ▁ remote ▁ and ▁ track """  <newline> return self . _branch_path <newline> <dedent> @ property <newline> def branch_name ( self ) : <newline> <indent>  """ :return: ▁ the ▁ name ▁ of ▁ the ▁ branch, ▁ which ▁ is ▁ the ▁ shortest ▁ possible ▁ branch ▁ name """  <newline>  # ▁ use ▁ an ▁ instance ▁ method, ▁ for ▁ this ▁ we ▁ create ▁ a ▁ temporary ▁ Head ▁ instance <encdom>  # ▁ which ▁ uses ▁ a ▁ repository ▁ that ▁ is ▁ available ▁ at ▁ least ▁ ( ▁ it ▁ makes ▁ no ▁ difference ▁ ) <encdom> return git . Head ( self . repo , self . _branch_path ) . name <newline> <dedent> @ property <newline> def url ( self ) : <newline> <indent>  """ :return: ▁ The ▁ url ▁ to ▁ the ▁ repository ▁ which ▁ our ▁ module-repository ▁ refers ▁ to """  <newline> return self . _url <newline> <dedent> @ property <newline> def parent_commit ( self ) : <newline> <indent>  """ :return: ▁ Commit ▁ instance ▁ with ▁ the ▁ tree ▁ containing ▁ the ▁ .gitmodules ▁ file <strnewline> ▁ :note: ▁ will ▁ always ▁ point ▁ to ▁ the ▁ current ▁ head's ▁ commit ▁ if ▁ it ▁ was ▁ not ▁ set ▁ explicitly """  <newline> if self . _parent_commit is None : <newline> <indent> return self . repo . commit ( ) <newline> <dedent> return self . _parent_commit <newline> <dedent> @ property <newline> def name ( self ) : <newline> <indent>  """ :return: ▁ The ▁ name ▁ of ▁ this ▁ submodule. ▁ It ▁ is ▁ used ▁ to ▁ identify ▁ it ▁ within ▁ the <strnewline> ▁ .gitmodules ▁ file. <strnewline> ▁ :note: ▁ by ▁ default, ▁ the ▁ name ▁ is ▁ the ▁ path ▁ at ▁ which ▁ to ▁ find ▁ the ▁ submodule, ▁ but <strnewline> ▁ in ▁ git-python ▁ it ▁ should ▁ be ▁ a ▁ unique ▁ identifier ▁ similar ▁ to ▁ the ▁ identifiers <strnewline> ▁ used ▁ for ▁ remotes, ▁ which ▁ allows ▁ to ▁ change ▁ the ▁ path ▁ of ▁ the ▁ submodule <strnewline> ▁ easily <strnewline> ▁ """  <newline> return self . _name <newline> <dedent> def config_reader ( self ) : <newline> <indent>  """ <strnewline> ▁ :return: ▁ ConfigReader ▁ instance ▁ which ▁ allows ▁ you ▁ to ▁ qurey ▁ the ▁ configuration ▁ values <strnewline> ▁ of ▁ this ▁ submodule, ▁ as ▁ provided ▁ by ▁ the ▁ .gitmodules ▁ file <strnewline> ▁ :note: ▁ The ▁ config ▁ reader ▁ will ▁ actually ▁ read ▁ the ▁ data ▁ directly ▁ from ▁ the ▁ repository <strnewline> ▁ and ▁ thus ▁ does ▁ not ▁ need ▁ nor ▁ care ▁ about ▁ your ▁ working ▁ tree. <strnewline> ▁ :note: ▁ Should ▁ be ▁ cached ▁ by ▁ the ▁ caller ▁ and ▁ only ▁ kept ▁ as ▁ long ▁ as ▁ needed <strnewline> ▁ :raise ▁ IOError: ▁ If ▁ the ▁ .gitmodules ▁ file/blob ▁ could ▁ not ▁ be ▁ read """  <newline> return self . _config_parser_constrained ( read_only = True ) <newline> <dedent> def children ( self ) : <newline> <indent>  """ <strnewline> ▁ :return: ▁ IterableList(Submodule, ▁ ...) ▁ an ▁ iterable ▁ list ▁ of ▁ submodules ▁ instances <strnewline> ▁ which ▁ are ▁ children ▁ of ▁ this ▁ submodule ▁ or ▁ 0 ▁ if ▁ the ▁ submodule ▁ is ▁ not ▁ checked ▁ out """  <newline> return self . _get_intermediate_items ( self ) <newline>  # } ▁ END ▁ query ▁ interface <encdom>  # { ▁ Iterable ▁ Interface <encdom> <dedent> @ classmethod <newline> def iter_items ( cls , repo , parent_commit = 'HEAD' ) : <newline> <indent>  """ :return: ▁ iterator ▁ yielding ▁ Submodule ▁ instances ▁ available ▁ in ▁ the ▁ given ▁ repository """  <newline> pc = repo . commit ( parent_commit )  # ▁ parent ▁ commit ▁ instance <encdom> <newline> try : <newline> <indent> parser = cls . _config_parser ( repo , pc , read_only = True ) <newline> <dedent> except IOError : <newline> <indent> raise StopIteration <newline>  # ▁ END ▁ handle ▁ empty ▁ iterator <encdom> <dedent> rt = pc . tree  # ▁ root ▁ tree <encdom> <newline> for sms in parser . sections ( ) : <newline> <indent> n = sm_name ( sms ) <newline> p = parser . get_value ( sms , 'path' ) <newline> u = parser . get_value ( sms , 'url' ) <newline> b = cls . k_head_default <newline> if parser . has_option ( sms , cls . k_head_option ) : <newline> <indent> b = str ( parser . get_value ( sms , cls . k_head_option ) ) <newline>  # ▁ END ▁ handle ▁ optional ▁ information <encdom>  # ▁ get ▁ the ▁ binsha <encdom> <dedent> index = repo . index <newline> try : <newline> <indent> sm = rt [ p ] <newline> <dedent> except KeyError : <newline>  # ▁ try ▁ the ▁ index, ▁ maybe ▁ it ▁ was ▁ just ▁ added <encdom> <indent> try : <newline> <indent> entry = index . entries [ index . entry_key ( p , 0 ) ] <newline> sm = Submodule ( repo , entry . binsha , entry . mode , entry . path ) <newline> <dedent> except KeyError : <newline> <indent> raise InvalidGitRepositoryError ( "Gitmodule ▁ path ▁ %r ▁ did ▁ not ▁ exist ▁ in ▁ revision ▁ of ▁ parent ▁ commit ▁ %s" % ( p , parent_commit ) ) <newline>  # ▁ END ▁ handle ▁ keyerror <encdom>  # ▁ END ▁ handle ▁ critical ▁ error <encdom>  # ▁ fill ▁ in ▁ remaining ▁ info ▁ - ▁ saves ▁ time ▁ as ▁ it ▁ doesn't ▁ have ▁ to ▁ be ▁ parsed ▁ again <encdom> <dedent> <dedent> sm . _name = n <newline> if pc != repo . commit ( ) : <newline> <indent> sm . _parent_commit = pc <newline>  # ▁ end ▁ set ▁ only ▁ if ▁ not ▁ most ▁ recent ▁ ! <encdom> <dedent> sm . _branch_path = git . Head . to_full_path ( b ) <newline> sm . _url = u <newline> yield sm <newline>  # ▁ END ▁ for ▁ each ▁ section <encdom>  # } ▁ END ▁ iterable ▁ interface <encdom> <dedent> <dedent> <dedent>
 """ <strnewline> Copyright ▁ 2017 ▁ Oliver ▁ Smith <strnewline> <strnewline> This ▁ file ▁ is ▁ part ▁ of ▁ pmbootstrap. <strnewline> <strnewline> pmbootstrap ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <strnewline> it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by <strnewline> the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License, ▁ or <strnewline> (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <strnewline> <strnewline> pmbootstrap ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <strnewline> but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <strnewline> MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <strnewline> GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <strnewline> <strnewline> You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License <strnewline> along ▁ with ▁ pmbootstrap. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <strnewline> """  <newline> import pmb . chroot . root <newline> def user ( args , cmd , suffix = "native" , working_dir = "/" , log = True , auto_init = True , return_stdout = False , check = True ) : <newline> <indent>  """ <strnewline> ▁ Run ▁ a ▁ command ▁ inside ▁ a ▁ chroot ▁ as ▁"user" <strnewline> <strnewline> ▁ :param ▁ log: ▁ When ▁ set ▁ to ▁ true, ▁ redirect ▁ all ▁ output ▁ to ▁ the ▁ logfile <strnewline> ▁ :param ▁ auto_init: ▁ Automatically ▁ initialize ▁ the ▁ chroot <strnewline> ▁ """  <newline> cmd = [ "su" , "pmos" , "-c" , " ▁ " . join ( cmd ) ] <newline> return pmb . chroot . root ( args , cmd , suffix , working_dir , log , auto_init , return_stdout , check ) <newline> <dedent> def exists ( args , username , suffix = "native" ) : <newline> <indent>  """ <strnewline> ▁ Checks ▁ if ▁ username ▁ exists ▁ in ▁ the ▁ system <strnewline> <strnewline> ▁ :param ▁ username: ▁ User ▁ name <strnewline> ▁ :returns: ▁ bool <strnewline> ▁ """  <newline> output = pmb . chroot . root ( args , [ "getent" , "passwd" , username ] , suffix , return_stdout = True , check = False ) <newline> return ( output is not None ) <newline> <dedent>
 """ A ▁ timer ▁ for ▁ games ▁ with ▁ set-rate ▁ FPS. <strnewline> """  <newline> import pygame <newline> import time <newline> class Clock ( object ) : <newline>  # ▁ The ▁ game ▁ time ▁ when ▁ one ▁ of ▁ the ▁ clock ▁ parameters ▁ was ▁ last ▁ changed <encdom> <indent> lastGameTime = None <newline>  # ▁ The ▁ real ▁ time ▁ corresponding ▁ to ▁ the ▁ last ▁ game ▁ time <encdom> lastRealTime = None <newline>  # ▁ The ▁ game ▁ time ▁ when ▁'tick' ▁ was ▁ last ▁ called <encdom> lastTickTime = None <newline>  # ▁ Whether ▁ the ▁ timer ▁ is ▁ paused ▁ or ▁ not <encdom> paused = False <newline>  # ▁ When ▁ this ▁ clock ▁ was ▁ created <encdom> startTime = None <newline>  # ▁ The ▁ speed ▁ which ▁ this ▁ clock ▁ moves ▁ at ▁ relative ▁ to ▁ the ▁ real ▁ clock <encdom> speed = 1 <newline> def __init__ ( self ) : <newline>  # self.startTime ▁ = ▁ time.time() <encdom> <indent> self . lastGameTime = 0 <newline> self . lastTickTime = 0 <newline> self . lastRealTime = time . time ( ) <newline> self . startTime = time . time ( ) <newline>  # ▁ Set ▁ the ▁ rate ▁ at ▁ which ▁ this ▁ clock ▁ ticks ▁ relative ▁ to ▁ the ▁ real ▁ clock <encdom> <dedent> def set_speed ( self , n ) : <newline> <indent> assert ( n >= 0 ) <newline> self . lastGameTime = self . get_time ( ) <newline> self . lastRealTime = time . time ( ) <newline> self . speed = n <newline>  # ▁ Pause ▁ the ▁ clock <encdom> <dedent> def pause ( self ) : <newline> <indent> if ( not self . paused ) : <newline> <indent> self . lastGameTime = self . get_time ( ) <newline> self . lastRealTime = time . time ( ) <newline> self . paused = True <newline>  # ▁ Resume ▁ the ▁ clock <encdom> <dedent> <dedent> def resume ( self ) : <newline> <indent> if ( self . paused ) : <newline> <indent> self . paused = False <newline> self . lastRealTime = time . time ( ) <newline> <dedent> <dedent> def tick ( self , fps = 0 ) : <newline> <indent> tm = self . get_time ( ) <newline> dt = tm - self . lastTickTime <newline> if ( fps > 0 ) : <newline> <indent> minTime = 1.0 / fps <newline> if ( dt < minTime ) : <newline> <indent> pygame . time . wait ( int ( ( minTime - dt ) * 1000 ) ) <newline> dt = minTime <newline> <dedent> <dedent> self . lastTickTime = tm <newline> return dt <newline>  # ▁ Returns ▁ the ▁ amount ▁ of ▁'game ▁ time' ▁ that ▁ has ▁ passed ▁ since ▁ creating <encdom>  # ▁ the ▁ clock ▁ (paused ▁ time ▁ does ▁ not ▁ count). <encdom> <dedent> def get_time ( self ) : <newline> <indent> if ( self . paused ) : <newline> <indent> return self . lastGameTime <newline> <dedent> return self . speed * ( time . time ( ) - self . lastRealTime ) + self . lastGameTime <newline> <dedent> def get_real_time ( self ) : <newline> <indent> return ( time . time ( ) - self . startTime ) <newline> <dedent> <dedent> class Timer : <newline> <indent>  """ A ▁ timer ▁ for ▁ games ▁ with ▁ set-rate ▁ FPS. """  <newline> def __init__ ( self , fps ) : <newline> <indent> if fps == 0 : <newline> <indent> self . tick = self . _blank <newline> return <newline> <dedent> self . wait = 1000 / fps <newline> self . nt = pygame . time . get_ticks ( ) <newline> pygame . time . wait ( 0 ) <newline> <dedent> def _blank ( self ) : <newline> <indent> pass <newline> <dedent> def tick ( self ) : <newline> <indent>  """ Wait ▁ correct ▁ amount ▁ of ▁ time ▁ each ▁ frame. ▁ Call ▁ this ▁ once ▁ per ▁ frame. """  <newline> self . ct = pygame . time . get_ticks ( ) <newline> if self . ct < self . nt : <newline> <indent> pygame . time . wait ( self . nt - self . ct ) <newline> self . nt += self . wait <newline> <dedent> else : <newline> <indent> self . nt = pygame . time . get_ticks ( ) + self . wait <newline> <dedent> <dedent> <dedent> class Speedometer : <newline> <indent>  """ A ▁ timer ▁ replacement ▁ that ▁ returns ▁ out ▁ FPS ▁ once ▁ a ▁ second. <strnewline> ▁ <strnewline> ▁ Attributes: <strnewline> ▁ fps ▁ -- ▁ always ▁ set ▁ to ▁ the ▁ current ▁ FPS <strnewline> <strnewline> ▁ """  <newline> def __init__ ( self ) : <newline> <indent> self . frames = 0 <newline> self . st = pygame . time . get_ticks ( ) <newline> self . fps = 0 <newline> <dedent> def tick ( self ) : <newline> <indent>  """ ▁ Call ▁ this ▁ once ▁ per ▁ frame. """  <newline> r = None <newline> self . frames += 1 <newline> self . ct = pygame . time . get_ticks ( ) <newline> if ( self . ct - self . st ) >= 1000 : <newline> <indent> r = self . fps = self . frames <newline>  # print ▁"%s: ▁ %d ▁ fps"%(self.__class__.__name__,self.fps) <encdom> self . frames = 0 <newline> self . st += 1000 <newline> <dedent> pygame . time . wait ( 0 )  # NOTE: ▁ not ▁ sure ▁ why, ▁ but ▁ you ▁ gotta ▁ call ▁ this ▁ now ▁ and ▁ again <encdom> <newline> return r <newline> <dedent> <dedent>
 # ▁ -*- ▁ coding: ▁ utf-8 ▁ -*- <encdom>  """ <strnewline> Tests ▁ for ▁ authentication ▁ widget <strnewline> <strnewline> From ▁ build ▁ dir, ▁ run ▁ from ▁ test ▁ directory: <strnewline> LC_ALL=en_US.UTF-8 ▁ ctest ▁ -R ▁ PyQgsAuthSettingsWidget ▁ -V <strnewline> <strnewline> .. ▁ note:: ▁ This ▁ program ▁ is ▁ free ▁ software; ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <strnewline> it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by <strnewline> the ▁ Free ▁ Software ▁ Foundation; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License, ▁ or <strnewline> (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <strnewline> """  <newline> import os <newline> import re <newline> import string <newline> import sys <newline> from shutil import rmtree <newline> import tempfile <newline> import random <newline> from qgis . core import QgsAuthMethodConfig , QgsNetworkAccessManager , QgsSettings , QgsApplication <newline> from qgis . gui import QgsAuthSettingsWidget <newline> from qgis . testing import start_app , unittest <newline> from utilities import unitTestDataPath <newline> __author__ = 'Alessandro ▁ Pasotti' <newline> __date__ = '27/09/2017' <newline> __copyright__ = 'Copyright ▁ 2017, ▁ The ▁ QGIS ▁ Project' <newline> QGIS_AUTH_DB_DIR_PATH = tempfile . mkdtemp ( ) <newline> os . environ [ 'QGIS_AUTH_DB_DIR_PATH' ] = QGIS_AUTH_DB_DIR_PATH <newline> qgis_app = start_app ( ) <newline> class TestAuthenticationWidget ( unittest . TestCase ) : <newline> <indent> @ classmethod <newline> def setUpClass ( cls ) : <newline> <indent>  """ Run ▁ before ▁ all ▁ tests: <strnewline> ▁ Creates ▁ an ▁ auth ▁ configuration """  <newline>  # ▁ Enable ▁ auth <encdom>  # ▁ os.environ['QGIS_AUTH_PASSWORD_FILE'] ▁ = ▁ QGIS_AUTH_PASSWORD_FILE <encdom> authm = QgsApplication . authManager ( ) <newline> assert ( authm . setMasterPassword ( 'masterpassword' , True ) ) <newline> cls . auth_config = QgsAuthMethodConfig ( 'Basic' ) <newline> cls . auth_config . setName ( 'test_auth_config' ) <newline> cls . username = '' . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) <newline> cls . password = cls . username [ : : - 1 ]  # ▁ reversed <encdom> <newline> cls . auth_config . setConfig ( 'username' , cls . username ) <newline> cls . auth_config . setConfig ( 'password' , cls . password ) <newline> assert ( authm . storeAuthenticationConfig ( cls . auth_config ) [ 0 ] ) <newline> <dedent> @ classmethod <newline> def tearDownClass ( cls ) : <newline> <indent>  """ Run ▁ after ▁ all ▁ tests """  <newline> rmtree ( QGIS_AUTH_DB_DIR_PATH ) <newline> <dedent> def setUp ( self ) : <newline> <indent>  """ Run ▁ before ▁ each ▁ test. """  <newline> pass <newline> <dedent> def tearDown ( self ) : <newline> <indent>  """ Run ▁ after ▁ each ▁ test. """  <newline> pass <newline> <dedent> def testWidgetNoArgs ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ the ▁ widget ▁ with ▁ no ▁ args <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( ) <newline> self . assertEqual ( w . username ( ) , '' ) <newline> self . assertEqual ( w . password ( ) , '' ) <newline> self . assertEqual ( w . configId ( ) , '' ) <newline> self . assertTrue ( w . configurationTabIsSelected ( ) ) <newline> self . assertFalse ( w . btnConvertToEncryptedIsEnabled ( ) ) <newline> <dedent> def testWidgetConfigId ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ the ▁ widget ▁ with ▁ configId <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( None , self . auth_config . id ( ) ) <newline> self . assertEqual ( w . username ( ) , '' ) <newline> self . assertEqual ( w . password ( ) , '' ) <newline> self . assertEqual ( w . configId ( ) , self . auth_config . id ( ) ) <newline> self . assertTrue ( w . configurationTabIsSelected ( ) ) <newline> self . assertFalse ( w . btnConvertToEncryptedIsEnabled ( ) ) <newline> <dedent> def testWidgetUsername ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ the ▁ widget ▁ with ▁ username ▁ only <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( None , None , 'username' ) <newline> self . assertEqual ( w . username ( ) , 'username' ) <newline> self . assertEqual ( w . password ( ) , '' ) <newline> self . assertEqual ( w . configId ( ) , '' ) <newline> self . assertFalse ( w . configurationTabIsSelected ( ) ) <newline> <dedent> def testWidgetPassword ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ the ▁ widget ▁ with ▁ password ▁ only <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( None , None , None , 'password' ) <newline> self . assertEqual ( w . username ( ) , '' ) <newline> self . assertEqual ( w . password ( ) , 'password' ) <newline> self . assertEqual ( w . configId ( ) , '' ) <newline> self . assertFalse ( w . configurationTabIsSelected ( ) ) <newline> <dedent> def testWidgetUsernameAndPassword ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ the ▁ widget ▁ with ▁ username ▁ and ▁ password <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( None , None , 'username' , 'password' ) <newline> self . assertEqual ( w . username ( ) , 'username' ) <newline> self . assertEqual ( w . password ( ) , 'password' ) <newline> self . assertEqual ( w . configId ( ) , '' ) <newline> self . assertFalse ( w . configurationTabIsSelected ( ) ) <newline> self . assertTrue ( w . btnConvertToEncryptedIsEnabled ( ) ) <newline> <dedent> def testConvertToEncrypted ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ the ▁ widget ▁ to ▁ encrypted ▁ conversion <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( None , None , 'username' , 'password' ) <newline> self . assertEqual ( w . username ( ) , 'username' ) <newline> self . assertEqual ( w . password ( ) , 'password' ) <newline> self . assertEqual ( w . configId ( ) , '' ) <newline> self . assertFalse ( w . configurationTabIsSelected ( ) ) <newline> self . assertTrue ( w . btnConvertToEncryptedIsEnabled ( ) ) <newline> self . assertTrue ( w . convertToEncrypted ( ) ) <newline> self . assertNotEqual ( w . configId ( ) , '' ) <newline> self . assertEqual ( w . username ( ) , '' ) <newline> self . assertEqual ( w . password ( ) , '' ) <newline> self . assertTrue ( w . configurationTabIsSelected ( ) ) <newline> self . assertFalse ( w . btnConvertToEncryptedIsEnabled ( ) ) <newline> <dedent> def test_setters ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ setters <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setUsername ( 'username' ) <newline> self . assertFalse ( w . configurationTabIsSelected ( ) ) <newline> self . assertEqual ( w . username ( ) , 'username' ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setPassword ( 'password' ) <newline> self . assertEqual ( w . password ( ) , 'password' ) <newline> self . assertFalse ( w . configurationTabIsSelected ( ) ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setConfigId ( self . auth_config . id ( ) ) <newline> self . assertEqual ( w . configId ( ) , self . auth_config . id ( ) ) <newline> self . assertTrue ( w . configurationTabIsSelected ( ) ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setUsername ( 'username' ) <newline> w . setPassword ( 'password' ) <newline> w . setConfigId ( self . auth_config . id ( ) ) <newline> self . assertEqual ( w . configId ( ) , self . auth_config . id ( ) ) <newline> self . assertTrue ( w . configurationTabIsSelected ( ) ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setDataprovider ( 'db2' ) <newline> self . assertEqual ( w . dataprovider ( ) , 'db2' ) <newline> <dedent> def test_storeCheckBoxes ( self ) : <newline> <indent>  """ <strnewline> ▁ Test ▁ store ▁ cb ▁ setters ▁ and ▁ getters <strnewline> ▁ """  <newline> w = QgsAuthSettingsWidget ( ) <newline> self . assertFalse ( w . storePasswordIsChecked ( ) ) <newline> self . assertFalse ( w . storeUsernameIsChecked ( ) ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setStorePasswordChecked ( True ) <newline> self . assertTrue ( w . storePasswordIsChecked ( ) ) <newline> self . assertFalse ( w . storeUsernameIsChecked ( ) ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setStoreUsernameChecked ( True ) <newline> self . assertFalse ( w . storePasswordIsChecked ( ) ) <newline> self . assertTrue ( w . storeUsernameIsChecked ( ) ) <newline> w = QgsAuthSettingsWidget ( ) <newline> w . setStoreUsernameChecked ( True ) <newline> w . setStorePasswordChecked ( True ) <newline> self . assertTrue ( w . storePasswordIsChecked ( ) ) <newline> self . assertTrue ( w . storeUsernameIsChecked ( ) ) <newline> <dedent> <dedent> if __name__ == '__main__' : <newline> <indent> unittest . main ( ) <newline> <dedent>
 """  <strnewline> A ▁ helper ▁ class ▁ for ▁ using ▁ TLS ▁ Lite ▁ with ▁ stdlib ▁ clients <strnewline> (httplib, ▁ xmlrpclib, ▁ imaplib, ▁ poplib). <strnewline> """  <newline> from gdata . tlslite . Checker import Checker <newline> class ClientHelper : <newline> <indent>  """ This ▁ is ▁ a ▁ helper ▁ class ▁ used ▁ to ▁ integrate ▁ TLS ▁ Lite ▁ with ▁ various <strnewline> ▁ TLS ▁ clients ▁ (e.g. ▁ poplib, ▁ smtplib, ▁ httplib, ▁ etc.) """  <newline> def __init__ ( self , username = None , password = None , sharedKey = None , certChain = None , privateKey = None , cryptoID = None , protocol = None , x509Fingerprint = None , x509TrustList = None , x509CommonName = None , settings = None ) : <newline> <indent>  """  <strnewline> ▁ For ▁ client ▁ authentication, ▁ use ▁ one ▁ of ▁ these ▁ argument <strnewline> ▁ combinations: <strnewline> ▁ - ▁ username, ▁ password ▁ (SRP) <strnewline> ▁ - ▁ username, ▁ sharedKey ▁ (shared-key) <strnewline> ▁ - ▁ certChain, ▁ privateKey ▁ (certificate) <strnewline>  <strnewline> ▁ For ▁ server ▁ authentication, ▁ you ▁ can ▁ either ▁ rely ▁ on ▁ the <strnewline> ▁ implicit ▁ mutual ▁ authentication ▁ performed ▁ by ▁ SRP ▁ or <strnewline> ▁ shared-keys, ▁ or ▁ you ▁ can ▁ do ▁ certificate-based ▁ server <strnewline> ▁ authentication ▁ with ▁ one ▁ of ▁ these ▁ argument ▁ combinations: <strnewline> ▁ - ▁ cryptoID[, ▁ protocol] ▁ (requires ▁ cryptoIDlib) <strnewline> ▁ - ▁ x509Fingerprint <strnewline> ▁ - ▁ x509TrustList[, ▁ x509CommonName] ▁ (requires ▁ cryptlib_py) <strnewline>  <strnewline> ▁ Certificate-based ▁ server ▁ authentication ▁ is ▁ compatible ▁ with <strnewline> ▁ SRP ▁ or ▁ certificate-based ▁ client ▁ authentication. ▁ It ▁ is <strnewline> ▁ not ▁ compatible ▁ with ▁ shared-keys. <strnewline>  <strnewline> ▁ The ▁ constructor ▁ does ▁ not ▁ perform ▁ the ▁ TLS ▁ handshake ▁ itself, ▁ but <strnewline> ▁ simply ▁ stores ▁ these ▁ arguments ▁ for ▁ later. ▁ The ▁ handshake ▁ is <strnewline> ▁ performed ▁ only ▁ when ▁ this ▁ class ▁ needs ▁ to ▁ connect ▁ with ▁ the <strnewline> ▁ server. ▁ Then ▁ you ▁ should ▁ be ▁ prepared ▁ to ▁ handle ▁ TLS-specific <strnewline> ▁ exceptions. ▁ See ▁ the ▁ client ▁ handshake ▁ functions ▁ in <strnewline> ▁ L{tlslite.TLSConnection.TLSConnection} ▁ for ▁ details ▁ on ▁ which <strnewline> ▁ exceptions ▁ might ▁ be ▁ raised. <strnewline>  <strnewline> ▁ @type ▁ username: ▁ str <strnewline> ▁ @param ▁ username: ▁ SRP ▁ or ▁ shared-key ▁ username. ▁ Requires ▁ the <strnewline> ▁'password' ▁ or ▁'sharedKey' ▁ argument. <strnewline>  <strnewline> ▁ @type ▁ password: ▁ str <strnewline> ▁ @param ▁ password: ▁ SRP ▁ password ▁ for ▁ mutual ▁ authentication. <strnewline> ▁ Requires ▁ the ▁'username' ▁ argument. <strnewline>  <strnewline> ▁ @type ▁ sharedKey: ▁ str <strnewline> ▁ @param ▁ sharedKey: ▁ Shared ▁ key ▁ for ▁ mutual ▁ authentication. <strnewline> ▁ Requires ▁ the ▁'username' ▁ argument. <strnewline>  <strnewline> ▁ @type ▁ certChain: ▁ L{tlslite.X509CertChain.X509CertChain} ▁ or <strnewline> ▁ L{cryptoIDlib.CertChain.CertChain} <strnewline> ▁ @param ▁ certChain: ▁ Certificate ▁ chain ▁ for ▁ client ▁ authentication. <strnewline> ▁ Requires ▁ the ▁'privateKey' ▁ argument. ▁ Excludes ▁ the ▁ SRP ▁ or <strnewline> ▁ shared-key ▁ related ▁ arguments. <strnewline>  <strnewline> ▁ @type ▁ privateKey: ▁ L{tlslite.utils.RSAKey.RSAKey} <strnewline> ▁ @param ▁ privateKey: ▁ Private ▁ key ▁ for ▁ client ▁ authentication. <strnewline> ▁ Requires ▁ the ▁'certChain' ▁ argument. ▁ Excludes ▁ the ▁ SRP ▁ or <strnewline> ▁ shared-key ▁ related ▁ arguments. <strnewline>  <strnewline> ▁ @type ▁ cryptoID: ▁ str <strnewline> ▁ @param ▁ cryptoID: ▁ cryptoID ▁ for ▁ server ▁ authentication. ▁ Mutually <strnewline> ▁ exclusive ▁ with ▁ the ▁'x509...' ▁ arguments. <strnewline>  <strnewline> ▁ @type ▁ protocol: ▁ str <strnewline> ▁ @param ▁ protocol: ▁ cryptoID ▁ protocol ▁ URI ▁ for ▁ server <strnewline> ▁ authentication. ▁ Requires ▁ the ▁'cryptoID' ▁ argument. <strnewline>  <strnewline> ▁ @type ▁ x509Fingerprint: ▁ str <strnewline> ▁ @param ▁ x509Fingerprint: ▁ Hex-encoded ▁ X.509 ▁ fingerprint ▁ for <strnewline> ▁ server ▁ authentication. ▁ Mutually ▁ exclusive ▁ with ▁ the ▁'cryptoID' <strnewline> ▁ and ▁'x509TrustList' ▁ arguments. <strnewline>  <strnewline> ▁ @type ▁ x509TrustList: ▁ list ▁ of ▁ L{tlslite.X509.X509} <strnewline> ▁ @param ▁ x509TrustList: ▁ A ▁ list ▁ of ▁ trusted ▁ root ▁ certificates. ▁ The <strnewline> ▁ other ▁ party ▁ must ▁ present ▁ a ▁ certificate ▁ chain ▁ which ▁ extends ▁ to <strnewline> ▁ one ▁ of ▁ these ▁ root ▁ certificates. ▁ The ▁ cryptlib_py ▁ module ▁ must ▁ be <strnewline> ▁ installed ▁ to ▁ use ▁ this ▁ parameter. ▁ Mutually ▁ exclusive ▁ with ▁ the <strnewline> ▁'cryptoID' ▁ and ▁'x509Fingerprint' ▁ arguments. <strnewline>  <strnewline> ▁ @type ▁ x509CommonName: ▁ str <strnewline> ▁ @param ▁ x509CommonName: ▁ The ▁ end-entity ▁ certificate's ▁'CN' ▁ field <strnewline> ▁ must ▁ match ▁ this ▁ value. ▁ For ▁ a ▁ web ▁ server, ▁ this ▁ is ▁ typically ▁ a <strnewline> ▁ server ▁ name ▁ such ▁ as ▁'www.amazon.com'. ▁ Mutually ▁ exclusive ▁ with <strnewline> ▁ the ▁'cryptoID' ▁ and ▁'x509Fingerprint' ▁ arguments. ▁ Requires ▁ the <strnewline> ▁'x509TrustList' ▁ argument. <strnewline>  <strnewline> ▁ @type ▁ settings: ▁ L{tlslite.HandshakeSettings.HandshakeSettings} <strnewline> ▁ @param ▁ settings: ▁ Various ▁ settings ▁ which ▁ can ▁ be ▁ used ▁ to ▁ control <strnewline> ▁ the ▁ ciphersuites, ▁ certificate ▁ types, ▁ and ▁ SSL/TLS ▁ versions <strnewline> ▁ offered ▁ by ▁ the ▁ client. <strnewline> ▁ """  <newline> self . username = None <newline> self . password = None <newline> self . sharedKey = None <newline> self . certChain = None <newline> self . privateKey = None <newline> self . checker = None <newline>  # SRP ▁ Authentication <encdom> if username and password and not ( sharedKey or certChain or privateKey ) : <newline> <indent> self . username = username <newline> self . password = password <newline>  # Shared ▁ Key ▁ Authentication <encdom> <dedent> elif username and sharedKey and not ( password or certChain or privateKey ) : <newline> <indent> self . username = username <newline> self . sharedKey = sharedKey <newline>  # Certificate ▁ Chain ▁ Authentication <encdom> <dedent> elif certChain and privateKey and not ( username or password or sharedKey ) : <newline> <indent> self . certChain = certChain <newline> self . privateKey = privateKey <newline>  # No ▁ Authentication <encdom> <dedent> elif not password and not username and not sharedKey and not certChain and not privateKey : <newline> <indent> pass <newline> <dedent> else : <newline> <indent> raise ValueError ( "Bad ▁ parameters" ) <newline>  # Authenticate ▁ the ▁ server ▁ based ▁ on ▁ its ▁ cryptoID ▁ or ▁ fingerprint <encdom> <dedent> if sharedKey and ( cryptoID or protocol or x509Fingerprint ) : <newline> <indent> raise ValueError ( "Can't ▁ use ▁ shared ▁ keys ▁ with ▁ other ▁ forms ▁ of" "authentication" ) <newline> <dedent> self . checker = Checker ( cryptoID , protocol , x509Fingerprint , x509TrustList , x509CommonName ) <newline> self . settings = settings <newline> self . tlsSession = None <newline> <dedent> def _handshake ( self , tlsConnection ) : <newline> <indent> if self . username and self . password : <newline> <indent> tlsConnection . handshakeClientSRP ( username = self . username , password = self . password , checker = self . checker , settings = self . settings , session = self . tlsSession ) <newline> <dedent> elif self . username and self . sharedKey : <newline> <indent> tlsConnection . handshakeClientSharedKey ( username = self . username , sharedKey = self . sharedKey , settings = self . settings ) <newline> <dedent> else : <newline> <indent> tlsConnection . handshakeClientCert ( certChain = self . certChain , privateKey = self . privateKey , checker = self . checker , settings = self . settings , session = self . tlsSession ) <newline> <dedent> self . tlsSession = tlsConnection . session <newline> <dedent> <dedent>
 # !/usr/bin/env ▁ python <encdom> import dotenv <newline> import os <newline> import sys <newline>  # ▁ These ▁ lines ▁ are ▁ required ▁ for ▁ interoperability ▁ between ▁ local ▁ and ▁ container ▁ environments. <encdom> dot_env = os . path . join ( os . getcwd ( ) , '.env' ) <newline> if os . path . exists ( dot_env ) : <newline> <indent> dotenv . read_dotenv ( ) <newline> <dedent> if __name__ == "__main__" : <newline> <indent> os . environ . setdefault ( "DJANGO_SETTINGS_MODULE" , "prs2.settings" ) <newline> try : <newline> <indent> from django . core . management import execute_from_command_line <newline> <dedent> except ImportError : <newline>  # ▁ The ▁ above ▁ import ▁ may ▁ fail ▁ for ▁ some ▁ other ▁ reason. ▁ Ensure ▁ that ▁ the <encdom>  # ▁ issue ▁ is ▁ really ▁ that ▁ Django ▁ is ▁ missing ▁ to ▁ avoid ▁ masking ▁ other <encdom>  # ▁ exceptions ▁ on ▁ Python ▁ 2. <encdom> <indent> try : <newline> <indent> import django <newline> <dedent> except ImportError : <newline> <indent> raise ImportError ( "Couldn't ▁ import ▁ Django. ▁ Are ▁ you ▁ sure ▁ it's ▁ installed ▁ and ▁ " "available ▁ on ▁ your ▁ PYTHONPATH ▁ environment ▁ variable? ▁ Did ▁ you ▁ " "forget ▁ to ▁ activate ▁ a ▁ virtual ▁ environment?" ) <newline> <dedent> raise <newline> <dedent> execute_from_command_line ( sys . argv ) <newline> <dedent>
from __future__ import division , print_function , absolute_import <newline> import numpy as np <newline> from numpy import pi , log , sqrt <newline> from numpy . testing import assert_ , assert_equal <newline> from scipy . special . _testutils import FuncData <newline> import scipy . special as sc <newline>  # ▁ Euler-Mascheroni ▁ constant <encdom> euler = 0.57721566490153286 <newline> def test_consistency ( ) : <newline>  # ▁ Make ▁ sure ▁ the ▁ implementation ▁ of ▁ digamma ▁ for ▁ real ▁ arguments <encdom>  # ▁ agrees ▁ with ▁ the ▁ implementation ▁ of ▁ digamma ▁ for ▁ complex ▁ arguments. <encdom>  # ▁ It's ▁ all ▁ poles ▁ after ▁ -1e16 <encdom> <indent> x = np . r_ [ - np . logspace ( 15 , - 30 , 200 ) , np . logspace ( - 30 , 300 , 200 ) ] <newline> dataset = np . vstack ( ( x + 0j , sc . digamma ( x ) ) ) . T <newline> FuncData ( sc . digamma , dataset , 0 , 1 , rtol = 5e-14 , nan_ok = True ) . check ( ) <newline> <dedent> def test_special_values ( ) : <newline>  # ▁ Test ▁ special ▁ values ▁ from ▁ Gauss's ▁ digamma ▁ theorem. ▁ See <encdom>  # ▁ https://en.wikipedia.org/wiki/Digamma_function <encdom> <indent> dataset = [ ( 1 , - euler ) , ( 0.5 , - 2 * log ( 2 ) - euler ) , ( 1 / 3 , - pi / ( 2 * sqrt ( 3 ) ) - 3 * log ( 3 ) / 2 - euler ) , ( 1 / 4 , - pi / 2 - 3 * log ( 2 ) - euler ) , ( 1 / 6 , - pi * sqrt ( 3 ) / 2 - 2 * log ( 2 ) - 3 * log ( 3 ) / 2 - euler ) , ( 1 / 8 , - pi / 2 - 4 * log ( 2 ) - ( pi + log ( 2 + sqrt ( 2 ) ) - log ( 2 - sqrt ( 2 ) ) ) / sqrt ( 2 ) - euler ) ] <newline> dataset = np . asarray ( dataset ) <newline> FuncData ( sc . digamma , dataset , 0 , 1 , rtol = 1e-14 ) . check ( ) <newline> <dedent> def test_nonfinite ( ) : <newline> <indent> pts = [ 0.0 , - 0.0 , np . inf ] <newline> std = [ - np . inf , np . inf , np . inf ] <newline> assert_equal ( sc . digamma ( pts ) , std ) <newline> assert_ ( all ( np . isnan ( sc . digamma ( [ - np . inf , - 1 ] ) ) ) ) <newline> <dedent>
 # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ DEAP. <encdom>  # ▁ DEAP ▁ is ▁ free ▁ software: ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <encdom>  # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as <encdom>  # ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ either ▁ version ▁ 3 ▁ of <encdom>  # ▁ the ▁ License, ▁ or ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ DEAP ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <encdom>  # ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public <encdom>  # ▁ License ▁ along ▁ with ▁ DEAP. ▁ If ▁ not, ▁ see ▁ <http://www.gnu.org/licenses/>. <encdom>  # ▁ Special ▁ thanks ▁ to ▁ Nikolaus ▁ Hansen ▁ for ▁ providing ▁ major ▁ part ▁ of <encdom>  # ▁ this ▁ code. ▁ The ▁ CMA-ES ▁ algorithm ▁ is ▁ provided ▁ in ▁ many ▁ other ▁ languages <encdom>  # ▁ and ▁ advanced ▁ versions ▁ at ▁ http://www.lri.fr/~hansen/cmaesintro.html. <encdom>  """ A ▁ module ▁ that ▁ provides ▁ support ▁ for ▁ the ▁ Covariance ▁ Matrix ▁ Adaptation <strnewline> Evolution ▁ Strategy. <strnewline> """  <newline> import numpy <newline> import copy <newline> from math import sqrt , log , exp <newline> import tools <newline> class Strategy ( object ) : <newline> <indent>  """ <strnewline> ▁ A ▁ strategy ▁ that ▁ will ▁ keep ▁ track ▁ of ▁ the ▁ basic ▁ parameters ▁ of ▁ the ▁ CMA-ES <strnewline> ▁ algorithm. <strnewline> <strnewline> ▁ :param ▁ centroid: ▁ An ▁ iterable ▁ object ▁ that ▁ indicates ▁ where ▁ to ▁ start ▁ the <strnewline> ▁ evolution. <strnewline> ▁ :param ▁ sigma: ▁ The ▁ initial ▁ standard ▁ deviation ▁ of ▁ the ▁ distribution. <strnewline> ▁ :param ▁ parameter: ▁ One ▁ or ▁ more ▁ parameter ▁ to ▁ pass ▁ to ▁ the ▁ strategy ▁ as <strnewline> ▁ described ▁ in ▁ the ▁ following ▁ table, ▁ optional. <strnewline> <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ Parameter ▁ | ▁ Default ▁ | ▁ Details ▁ | <strnewline> ▁ +=====+=====+=====+ <strnewline> ▁ | ▁ ``lambda_`` ▁ | ▁ ``int(4 ▁ + ▁ 3 ▁ * ▁ log(N))`` ▁ | ▁ Number ▁ of ▁ children ▁ to ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ produce ▁ at ▁ each ▁ generation,| <strnewline> ▁ | ▁ | ▁ | ▁ ``N`` ▁ is ▁ the ▁ individual's ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ size ▁ (integer). ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``mu`` ▁ | ▁ ``int(lambda_ ▁ / ▁ 2)`` ▁ | ▁ The ▁ number ▁ of ▁ parents ▁ to ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ keep ▁ from ▁ the ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ lambda ▁ children ▁ (integer). ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``cmatrix`` ▁ | ▁ ``identity(N)`` ▁ | ▁ The ▁ initial ▁ covariance ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ matrix ▁ of ▁ the ▁ distribution ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ that ▁ will ▁ be ▁ sampled. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``weights`` ▁ | ▁ ``"superlinear"`` ▁ | ▁ Decrease ▁ speed, ▁ can ▁ be ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ ``"superlinear"``, ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ ``"linear"`` ▁ or ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ ``"equal"``. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``cs`` ▁ | ▁ ``(mueff ▁ + ▁ 2) ▁ / ▁ | ▁ Cumulation ▁ constant ▁ for ▁ | <strnewline> ▁ | ▁ | ▁ (N ▁ + ▁ mueff ▁ + ▁ 3)`` ▁ | ▁ step-size. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``damps`` ▁ | ▁ ``1 ▁ + ▁ 2 ▁ * ▁ max(0, ▁ sqrt(( ▁ | ▁ Damping ▁ for ▁ step-size. ▁ | <strnewline> ▁ | ▁ | ▁ mueff ▁ - ▁ 1) ▁ / ▁ (N ▁ + ▁ 1)) ▁ - ▁ 1)| ▁ | <strnewline> ▁ | ▁ | ▁ + ▁ cs`` ▁ | ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ccum`` ▁ | ▁ ``4 ▁ / ▁ (N ▁ + ▁ 4)`` ▁ | ▁ Cumulation ▁ constant ▁ for ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ covariance ▁ matrix. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ccov1`` ▁ | ▁ ``2 ▁ / ▁ ((N ▁ + ▁ 1.3)^2 ▁ + ▁ | ▁ Learning ▁ rate ▁ for ▁ rank-one ▁ | <strnewline> ▁ | ▁ | ▁ mueff)`` ▁ | ▁ update. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ccovmu`` ▁ | ▁ ``2 ▁ * ▁ (mueff ▁ - ▁ 2 ▁ + ▁ 1 ▁ / ▁ | ▁ Learning ▁ rate ▁ for ▁ rank-mu ▁ | <strnewline> ▁ | ▁ | ▁ mueff) ▁ / ▁ ((N ▁ + ▁ 2)^2 ▁ + ▁ | ▁ update. ▁ | <strnewline> ▁ | ▁ | ▁ mueff)`` ▁ | ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> <strnewline> ▁ """  <newline> def __init__ ( self , centroid , sigma , ** kargs ) : <newline> <indent> self . params = kargs <newline>  # ▁ Create ▁ a ▁ centroid ▁ as ▁ a ▁ numpy ▁ array <encdom> self . centroid = numpy . array ( centroid ) <newline> self . dim = len ( self . centroid ) <newline> self . sigma = sigma <newline> self . pc = numpy . zeros ( self . dim ) <newline> self . ps = numpy . zeros ( self . dim ) <newline> self . chiN = sqrt ( self . dim ) * ( 1 - 1. / ( 4. * self . dim ) + 1. / ( 21. * self . dim ** 2 ) ) <newline> self . C = self . params . get ( "cmatrix" , numpy . identity ( self . dim ) ) <newline> self . diagD , self . B = numpy . linalg . eigh ( self . C ) <newline> indx = numpy . argsort ( self . diagD ) <newline> self . diagD = self . diagD [ indx ] ** 0.5 <newline> self . B = self . B [ : , indx ] <newline> self . BD = self . B * self . diagD <newline> self . cond = self . diagD [ indx [ - 1 ] ] / self . diagD [ indx [ 0 ] ] <newline> self . lambda_ = self . params . get ( "lambda_" , int ( 4 + 3 * log ( self . dim ) ) ) <newline> self . update_count = 0 <newline> self . computeParams ( self . params ) <newline> <dedent> def generate ( self , ind_init ) : <newline> <indent>  """ Generate ▁ a ▁ population ▁ of ▁ :math:`\lambda` ▁ individuals ▁ of ▁ type <strnewline> ▁ *ind_init* ▁ from ▁ the ▁ current ▁ strategy. <strnewline> <strnewline> ▁ :param ▁ ind_init: ▁ A ▁ function ▁ object ▁ that ▁ is ▁ able ▁ to ▁ initialize ▁ an <strnewline> ▁ individual ▁ from ▁ a ▁ list. <strnewline> ▁ :returns: ▁ A ▁ list ▁ of ▁ individuals. <strnewline> ▁ """  <newline> arz = numpy . random . standard_normal ( ( self . lambda_ , self . dim ) ) <newline> arz = self . centroid + self . sigma * numpy . dot ( arz , self . BD . T ) <newline> return map ( ind_init , arz ) <newline> <dedent> def update ( self , population ) : <newline> <indent>  """ Update ▁ the ▁ current ▁ covariance ▁ matrix ▁ strategy ▁ from ▁ the <strnewline> ▁ *population*. <strnewline> <strnewline> ▁ :param ▁ population: ▁ A ▁ list ▁ of ▁ individuals ▁ from ▁ which ▁ to ▁ update ▁ the <strnewline> ▁ parameters. <strnewline> ▁ """  <newline> population . sort ( key = lambda ind : ind . fitness , reverse = True ) <newline> old_centroid = self . centroid <newline> self . centroid = numpy . dot ( self . weights , population [ 0 : self . mu ] ) <newline> c_diff = self . centroid - old_centroid <newline>  # ▁ Cumulation ▁ : ▁ update ▁ evolution ▁ path <encdom> self . ps = ( 1 - self . cs ) * self . ps + sqrt ( self . cs * ( 2 - self . cs ) * self . mueff ) / self . sigma * numpy . dot ( self . B , ( 1. / self . diagD ) * numpy . dot ( self . B . T , c_diff ) ) <newline> hsig = float ( ( numpy . linalg . norm ( self . ps ) / sqrt ( 1. - ( 1. - self . cs ) ** ( 2. * ( self . update_count + 1. ) ) ) / self . chiN < ( 1.4 + 2. / ( self . dim + 1. ) ) ) ) <newline> self . update_count += 1 <newline> self . pc = ( 1 - self . cc ) * self . pc + hsig * sqrt ( self . cc * ( 2 - self . cc ) * self . mueff ) / self . sigma * c_diff <newline>  # ▁ Update ▁ covariance ▁ matrix <encdom> artmp = population [ 0 : self . mu ] - old_centroid <newline> self . C = ( 1 - self . ccov1 - self . ccovmu + ( 1 - hsig ) * self . ccov1 * self . cc * ( 2 - self . cc ) ) * self . C + self . ccov1 * numpy . outer ( self . pc , self . pc ) + self . ccovmu * numpy . dot ( ( self . weights * artmp . T ) , artmp ) / self . sigma ** 2 <newline> self . sigma *= numpy . exp ( ( numpy . linalg . norm ( self . ps ) / self . chiN - 1. ) * self . cs / self . damps ) <newline> self . diagD , self . B = numpy . linalg . eigh ( self . C ) <newline> indx = numpy . argsort ( self . diagD ) <newline> self . cond = self . diagD [ indx [ - 1 ] ] / self . diagD [ indx [ 0 ] ] <newline> self . diagD = self . diagD [ indx ] ** 0.5 <newline> self . B = self . B [ : , indx ] <newline> self . BD = self . B * self . diagD <newline> <dedent> def computeParams ( self , params ) : <newline> <indent>  """ Computes ▁ the ▁ parameters ▁ depending ▁ on ▁ :math:`\lambda`. ▁ It ▁ needs ▁ to <strnewline> ▁ be ▁ called ▁ again ▁ if ▁ :math:`\lambda` ▁ changes ▁ during ▁ evolution. <strnewline> <strnewline> ▁ :param ▁ params: ▁ A ▁ dictionary ▁ of ▁ the ▁ manually ▁ set ▁ parameters. <strnewline> ▁ """  <newline> self . mu = params . get ( "mu" , int ( self . lambda_ / 2 ) ) <newline> rweights = params . get ( "weights" , "superlinear" ) <newline> if rweights == "superlinear" : <newline> <indent> self . weights = log ( self . mu + 0.5 ) - numpy . log ( numpy . arange ( 1 , self . mu + 1 ) ) <newline> <dedent> elif rweights == "linear" : <newline> <indent> self . weights = self . mu + 0.5 - numpy . arange ( 1 , self . mu + 1 ) <newline> <dedent> elif rweights == "equal" : <newline> <indent> self . weights = numpy . ones ( self . mu ) <newline> <dedent> else : <newline> <indent> raise RuntimeError ( "Unknown ▁ weights ▁ : ▁ %s" % rweights ) <newline> <dedent> self . weights /= sum ( self . weights ) <newline> self . mueff = 1. / sum ( self . weights ** 2 ) <newline> self . cc = params . get ( "ccum" , 4. / ( self . dim + 4. ) ) <newline> self . cs = params . get ( "cs" , ( self . mueff + 2. ) / ( self . dim + self . mueff + 3. ) ) <newline> self . ccov1 = params . get ( "ccov1" , 2. / ( ( self . dim + 1.3 ) ** 2 + self . mueff ) ) <newline> self . ccovmu = params . get ( "ccovmu" , 2. * ( self . mueff - 2. + 1. / self . mueff ) / ( ( self . dim + 2. ) ** 2 + self . mueff ) ) <newline> self . ccovmu = min ( 1 - self . ccov1 , self . ccovmu ) <newline> self . damps = 1. + 2. * max ( 0 , sqrt ( ( self . mueff - 1. ) / ( self . dim + 1. ) ) - 1. ) + self . cs <newline> self . damps = params . get ( "damps" , self . damps ) <newline> <dedent> <dedent> class StrategyOnePlusLambda ( object ) : <newline> <indent>  """ <strnewline> ▁ A ▁ CMA-ES ▁ strategy ▁ that ▁ uses ▁ the ▁ :math:`1 ▁ + ▁ \lambda` ▁ paradigme. <strnewline> <strnewline> ▁ :param ▁ parent: ▁ An ▁ iterable ▁ object ▁ that ▁ indicates ▁ where ▁ to ▁ start ▁ the <strnewline> ▁ evolution. ▁ The ▁ parent ▁ requires ▁ a ▁ fitness ▁ attribute. <strnewline> ▁ :param ▁ sigma: ▁ The ▁ initial ▁ standard ▁ deviation ▁ of ▁ the ▁ distribution. <strnewline> ▁ :param ▁ lambda_: ▁ Number ▁ of ▁ offspring ▁ to ▁ produce ▁ from ▁ the ▁ parent. <strnewline> ▁ (optional, ▁ defaults ▁ to ▁ 1) <strnewline> ▁ :param ▁ parameter: ▁ One ▁ or ▁ more ▁ parameter ▁ to ▁ pass ▁ to ▁ the ▁ strategy ▁ as <strnewline> ▁ described ▁ in ▁ the ▁ following ▁ table. ▁ (optional) <strnewline> <strnewline> ▁ Other ▁ parameters ▁ can ▁ be ▁ provided ▁ as ▁ described ▁ in ▁ the ▁ next ▁ table <strnewline> <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ Parameter ▁ | ▁ Default ▁ | ▁ Details ▁ | <strnewline> ▁ +=====+=====+=====+ <strnewline> ▁ | ▁ ``d`` ▁ | ▁ ``1.0 ▁ + ▁ N ▁ / ▁ (2.0 ▁ * ▁ | ▁ Damping ▁ for ▁ step-size. ▁ | <strnewline> ▁ | ▁ | ▁ lambda_)`` ▁ | ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ptarg`` ▁ | ▁ ``1.0 ▁ / ▁ (5 ▁ + ▁ sqrt(lambda_)| ▁ Taget ▁ success ▁ rate. ▁ | <strnewline> ▁ | ▁ | ▁ / ▁ 2.0)`` ▁ | ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``cp`` ▁ | ▁ ``ptarg ▁ * ▁ lambda_ ▁ / ▁ (2.0 ▁ +| ▁ Step ▁ size ▁ learning ▁ rate. ▁ | <strnewline> ▁ | ▁ | ▁ ptarg ▁ * ▁ lambda_)`` ▁ | ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``cc`` ▁ | ▁ ``2.0 ▁ / ▁ (N ▁ + ▁ 2.0)`` ▁ | ▁ Cumulation ▁ time ▁ horizon. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ccov`` ▁ | ▁ ``2.0 ▁ / ▁ (N**2 ▁ + ▁ 6.0)`` ▁ | ▁ Covariance ▁ matrix ▁ learning ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ rate. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``pthresh`` ▁ | ▁ ``0.44`` ▁ | ▁ Threshold ▁ success ▁ rate. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ """  <newline> def __init__ ( self , parent , sigma , ** kargs ) : <newline> <indent> self . parent = parent <newline> self . sigma = sigma <newline> self . dim = len ( self . parent ) <newline> self . C = numpy . identity ( self . dim ) <newline> self . A = numpy . identity ( self . dim ) <newline> self . pc = numpy . zeros ( self . dim ) <newline> self . computeParams ( kargs ) <newline> self . psucc = self . ptarg <newline> <dedent> def computeParams ( self , params ) : <newline> <indent>  """ Computes ▁ the ▁ parameters ▁ depending ▁ on ▁ :math:`\lambda`. ▁ It ▁ needs ▁ to <strnewline> ▁ be ▁ called ▁ again ▁ if ▁ :math:`\lambda` ▁ changes ▁ during ▁ evolution. <strnewline> <strnewline> ▁ :param ▁ params: ▁ A ▁ dictionary ▁ of ▁ the ▁ manually ▁ set ▁ parameters. <strnewline> ▁ """  <newline>  # ▁ Selection ▁ : <encdom> self . lambda_ = params . get ( "lambda_" , 1 ) <newline>  # ▁ Step ▁ size ▁ control ▁ : <encdom> self . d = params . get ( "d" , 1.0 + self . dim / ( 2.0 * self . lambda_ ) ) <newline> self . ptarg = params . get ( "ptarg" , 1.0 / ( 5 + sqrt ( self . lambda_ ) / 2.0 ) ) <newline> self . cp = params . get ( "cp" , self . ptarg * self . lambda_ / ( 2 + self . ptarg * self . lambda_ ) ) <newline>  # ▁ Covariance ▁ matrix ▁ adaptation <encdom> self . cc = params . get ( "cc" , 2.0 / ( self . dim + 2.0 ) ) <newline> self . ccov = params . get ( "ccov" , 2.0 / ( self . dim ** 2 + 6.0 ) ) <newline> self . pthresh = params . get ( "pthresh" , 0.44 ) <newline> <dedent> def generate ( self , ind_init ) : <newline> <indent>  """ Generate ▁ a ▁ population ▁ of ▁ :math:`\lambda` ▁ individuals ▁ of ▁ type <strnewline> ▁ *ind_init* ▁ from ▁ the ▁ current ▁ strategy. <strnewline> <strnewline> ▁ :param ▁ ind_init: ▁ A ▁ function ▁ object ▁ that ▁ is ▁ able ▁ to ▁ initialize ▁ an <strnewline> ▁ individual ▁ from ▁ a ▁ list. <strnewline> ▁ :returns: ▁ A ▁ list ▁ of ▁ individuals. <strnewline> ▁ """  <newline>  # ▁ self.y ▁ = ▁ numpy.dot(self.A, ▁ numpy.random.standard_normal(self.dim)) <encdom> arz = numpy . random . standard_normal ( ( self . lambda_ , self . dim ) ) <newline> arz = self . parent + self . sigma * numpy . dot ( arz , self . A . T ) <newline> return map ( ind_init , arz ) <newline> <dedent> def update ( self , population ) : <newline> <indent>  """ Update ▁ the ▁ current ▁ covariance ▁ matrix ▁ strategy ▁ from ▁ the <strnewline> ▁ *population*. <strnewline> <strnewline> ▁ :param ▁ population: ▁ A ▁ list ▁ of ▁ individuals ▁ from ▁ which ▁ to ▁ update ▁ the <strnewline> ▁ parameters. <strnewline> ▁ """  <newline> population . sort ( key = lambda ind : ind . fitness , reverse = True ) <newline> lambda_succ = sum ( self . parent . fitness <= ind . fitness for ind in population ) <newline> p_succ = float ( lambda_succ ) / self . lambda_ <newline> self . psucc = ( 1 - self . cp ) * self . psucc + self . cp * p_succ <newline> if self . parent . fitness <= population [ 0 ] . fitness : <newline> <indent> x_step = ( population [ 0 ] - numpy . array ( self . parent ) ) / self . sigma <newline> self . parent = copy . deepcopy ( population [ 0 ] ) <newline> if self . psucc < self . pthresh : <newline> <indent> self . pc = ( 1 - self . cc ) * self . pc + sqrt ( self . cc * ( 2 - self . cc ) ) * x_step <newline> self . C = ( 1 - self . ccov ) * self . C + self . ccov * numpy . outer ( self . pc , self . pc ) <newline> <dedent> else : <newline> <indent> self . pc = ( 1 - self . cc ) * self . pc <newline> self . C = ( 1 - self . ccov ) * self . C + self . ccov * ( numpy . outer ( self . pc , self . pc ) + self . cc * ( 2 - self . cc ) * self . C ) <newline> <dedent> <dedent> self . sigma = self . sigma * exp ( 1.0 / self . d * ( self . psucc - self . ptarg ) / ( 1.0 - self . ptarg ) ) <newline>  # ▁ We ▁ use ▁ Cholesky ▁ since ▁ for ▁ now ▁ we ▁ have ▁ no ▁ use ▁ of ▁ eigen ▁ decomposition <encdom>  # ▁ Basically, ▁ Cholesky ▁ returns ▁ a ▁ matrix ▁ A ▁ as ▁ C ▁ = ▁ A*A.T <encdom>  # ▁ Eigen ▁ decomposition ▁ returns ▁ two ▁ matrix ▁ B ▁ and ▁ D^2 ▁ as ▁ C ▁ = ▁ B*D^2*B.T ▁ = ▁ B*D*D*B.T <encdom>  # ▁ So ▁ A ▁ == ▁ B*D <encdom>  # ▁ To ▁ compute ▁ the ▁ new ▁ individual ▁ we ▁ need ▁ to ▁ multiply ▁ each ▁ vector ▁ z ▁ by ▁ A <encdom>  # ▁ as ▁ y ▁ = ▁ centroid ▁ + ▁ sigma ▁ * ▁ A*z <encdom>  # ▁ So ▁ the ▁ Cholesky ▁ is ▁ more ▁ straightforward ▁ as ▁ we ▁ don't ▁ need ▁ to ▁ compute <encdom>  # ▁ the ▁ squareroot ▁ of ▁ D^2, ▁ and ▁ multiply ▁ B ▁ and ▁ D ▁ in ▁ order ▁ to ▁ get ▁ A, ▁ we ▁ directly ▁ get ▁ A. <encdom>  # ▁ This ▁ can't ▁ be ▁ done ▁ (without ▁ cost) ▁ with ▁ the ▁ standard ▁ CMA-ES ▁ as ▁ the ▁ eigen ▁ decomposition ▁ is ▁ used <encdom>  # ▁ to ▁ compute ▁ covariance ▁ matrix ▁ inverse ▁ in ▁ the ▁ step-size ▁ evolutionary ▁ path ▁ computation. <encdom> self . A = numpy . linalg . cholesky ( self . C ) <newline> <dedent> <dedent> class StrategyMultiObjective ( object ) : <newline> <indent>  """ Multiobjective ▁ CMA-ES ▁ strategy ▁ based ▁ on ▁ the ▁ paper ▁ [Voss2010]_. ▁ It <strnewline> ▁ is ▁ used ▁ similarly ▁ as ▁ the ▁ standard ▁ CMA-ES ▁ strategy ▁ with ▁ a ▁ generate-update <strnewline> ▁ scheme. <strnewline> <strnewline> ▁ :param ▁ population: ▁ An ▁ initial ▁ population ▁ of ▁ individual. <strnewline> ▁ :param ▁ sigma: ▁ The ▁ initial ▁ step ▁ size ▁ of ▁ the ▁ complete ▁ system. <strnewline> ▁ :param ▁ mu: ▁ The ▁ number ▁ of ▁ parents ▁ to ▁ use ▁ in ▁ the ▁ evolution. ▁ When ▁ not <strnewline> ▁ provided ▁ it ▁ defaults ▁ to ▁ the ▁ length ▁ of ▁ *population*. ▁ (optional) <strnewline> ▁ :param ▁ lambda_: ▁ The ▁ number ▁ of ▁ offspring ▁ to ▁ produce ▁ at ▁ each ▁ generation. <strnewline> ▁ (optional, ▁ defaults ▁ to ▁ 1) <strnewline> ▁ :param ▁ indicator: ▁ The ▁ indicator ▁ function ▁ to ▁ use. ▁ (optional, ▁ default ▁ to <strnewline> ▁ :func:`~deap.tools.hypervolume`) <strnewline> <strnewline> ▁ Other ▁ parameters ▁ can ▁ be ▁ provided ▁ as ▁ described ▁ in ▁ the ▁ next ▁ table <strnewline> <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ Parameter ▁ | ▁ Default ▁ | ▁ Details ▁ | <strnewline> ▁ +=====+=====+=====+ <strnewline> ▁ | ▁ ``d`` ▁ | ▁ ``1.0 ▁ + ▁ N ▁ / ▁ 2.0`` ▁ | ▁ Damping ▁ for ▁ step-size. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ptarg`` ▁ | ▁ ``1.0 ▁ / ▁ (5 ▁ + ▁ 1.0 ▁ / ▁ 2.0)`` ▁ | ▁ Taget ▁ success ▁ rate. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``cp`` ▁ | ▁ ``ptarg ▁ / ▁ (2.0 ▁ + ▁ ptarg)`` ▁ | ▁ Step ▁ size ▁ learning ▁ rate. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``cc`` ▁ | ▁ ``2.0 ▁ / ▁ (N ▁ + ▁ 2.0)`` ▁ | ▁ Cumulation ▁ time ▁ horizon. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``ccov`` ▁ | ▁ ``2.0 ▁ / ▁ (N**2 ▁ + ▁ 6.0)`` ▁ | ▁ Covariance ▁ matrix ▁ learning ▁ | <strnewline> ▁ | ▁ | ▁ | ▁ rate. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> ▁ | ▁ ``pthresh`` ▁ | ▁ ``0.44`` ▁ | ▁ Threshold ▁ success ▁ rate. ▁ | <strnewline> ▁ +-----+-----+-----+ <strnewline> <strnewline> ▁ .. ▁ [Voss2010] ▁ Voss, ▁ Hansen, ▁ Igel, ▁"Improved ▁ Step ▁ Size ▁ Adaptation <strnewline> ▁ for ▁ the ▁ MO-CMA-ES", ▁ 2010. <strnewline> <strnewline> ▁ """  <newline> def __init__ ( self , population , sigma , ** params ) : <newline> <indent> self . parents = population <newline> self . dim = len ( self . parents [ 0 ] ) <newline>  # ▁ Selection <encdom> self . mu = params . get ( "mu" , len ( self . parents ) ) <newline> self . lambda_ = params . get ( "lambda_" , 1 ) <newline>  # ▁ Step ▁ size ▁ control <encdom> self . d = params . get ( "d" , 1.0 + self . dim / 2.0 ) <newline> self . ptarg = params . get ( "ptarg" , 1.0 / ( 5.0 + 0.5 ) ) <newline> self . cp = params . get ( "cp" , self . ptarg / ( 2.0 + self . ptarg ) ) <newline>  # ▁ Covariance ▁ matrix ▁ adaptation <encdom> self . cc = params . get ( "cc" , 2.0 / ( self . dim + 2.0 ) ) <newline> self . ccov = params . get ( "ccov" , 2.0 / ( self . dim ** 2 + 6.0 ) ) <newline> self . pthresh = params . get ( "pthresh" , 0.44 ) <newline>  # ▁ Internal ▁ parameters ▁ associated ▁ to ▁ the ▁ mu ▁ parent <encdom> self . sigmas = [ sigma ] * len ( population ) <newline>  # ▁ Lower ▁ Cholesky ▁ matrix ▁ (Sampling ▁ matrix) <encdom> self . A = [ numpy . identity ( self . dim ) for _ in range ( len ( population ) ) ] <newline>  # ▁ Inverse ▁ Cholesky ▁ matrix ▁ (Used ▁ in ▁ the ▁ update ▁ of ▁ A) <encdom> self . invCholesky = [ numpy . identity ( self . dim ) for _ in range ( len ( population ) ) ] <newline> self . pc = [ numpy . zeros ( self . dim ) for _ in range ( len ( population ) ) ] <newline> self . psucc = [ self . ptarg ] * len ( population ) <newline> self . indicator = params . get ( "indicator" , tools . hypervolume ) <newline> <dedent> def generate ( self , ind_init ) : <newline> <indent>  """ Generate ▁ a ▁ population ▁ of ▁ :math:`\lambda` ▁ individuals ▁ of ▁ type <strnewline> ▁ *ind_init* ▁ from ▁ the ▁ current ▁ strategy. <strnewline> <strnewline> ▁ :param ▁ ind_init: ▁ A ▁ function ▁ object ▁ that ▁ is ▁ able ▁ to ▁ initialize ▁ an <strnewline> ▁ individual ▁ from ▁ a ▁ list. <strnewline> ▁ :returns: ▁ A ▁ list ▁ of ▁ individuals ▁ with ▁ a ▁ private ▁ attribute ▁ :attr:`_ps`. <strnewline> ▁ This ▁ last ▁ attribute ▁ is ▁ essential ▁ to ▁ the ▁ update ▁ function, ▁ it <strnewline> ▁ indicates ▁ that ▁ the ▁ individual ▁ is ▁ an ▁ offspring ▁ and ▁ the ▁ index <strnewline> ▁ of ▁ its ▁ parent. <strnewline> ▁ """  <newline> arz = numpy . random . randn ( self . lambda_ , self . dim ) <newline> individuals = list ( ) <newline>  # ▁ Make ▁ sure ▁ every ▁ parent ▁ has ▁ a ▁ parent ▁ tag ▁ and ▁ index <encdom> for i , p in enumerate ( self . parents ) : <newline> <indent> p . _ps = "p" , i <newline>  # ▁ Each ▁ parent ▁ produce ▁ an ▁ offspring <encdom> <dedent> if self . lambda_ == self . mu : <newline> <indent> for i in range ( self . lambda_ ) : <newline>  # ▁ print ▁"Z", ▁ list(arz[i]) <encdom> <indent> individuals . append ( ind_init ( self . parents [ i ] + self . sigmas [ i ] * numpy . dot ( self . A [ i ] , arz [ i ] ) ) ) <newline> individuals [ - 1 ] . _ps = "o" , i <newline>  # ▁ Parents ▁ producing ▁ an ▁ offspring ▁ are ▁ chosen ▁ at ▁ random ▁ from ▁ the ▁ first ▁ front <encdom> <dedent> <dedent> else : <newline> <indent> ndom = tools . sortLogNondominated ( self . parents , len ( self . parents ) , first_front_only = True ) <newline> for i in range ( self . lambda_ ) : <newline> <indent> j = numpy . random . randint ( 0 , len ( ndom ) ) <newline> _ , p_idx = ndom [ j ] . _ps <newline> individuals . append ( ind_init ( self . parents [ p_idx ] + self . sigmas [ p_idx ] * numpy . dot ( self . A [ p_idx ] , arz [ i ] ) ) ) <newline> individuals [ - 1 ] . _ps = "o" , p_idx <newline> <dedent> <dedent> return individuals <newline> <dedent> def _select ( self , candidates ) : <newline> <indent> if len ( candidates ) <= self . mu : <newline> <indent> return candidates , [ ] <newline> <dedent> pareto_fronts = tools . sortLogNondominated ( candidates , len ( candidates ) ) <newline> chosen = list ( ) <newline> mid_front = None <newline> not_chosen = list ( ) <newline>  # ▁ Fill ▁ the ▁ next ▁ population ▁ (chosen) ▁ with ▁ the ▁ fronts ▁ until ▁ there ▁ is ▁ not ▁ enouch ▁ space <encdom>  # ▁ When ▁ an ▁ entire ▁ front ▁ does ▁ not ▁ fit ▁ in ▁ the ▁ space ▁ left ▁ we ▁ rely ▁ on ▁ the ▁ hypervolume <encdom>  # ▁ for ▁ this ▁ front <encdom>  # ▁ The ▁ remaining ▁ fronts ▁ are ▁ explicitely ▁ not ▁ chosen <encdom> full = False <newline> for front in pareto_fronts : <newline> <indent> if len ( chosen ) + len ( front ) <= self . mu and not full : <newline> <indent> chosen += front <newline> <dedent> elif mid_front is None and len ( chosen ) < self . mu : <newline> <indent> mid_front = front <newline>  # ▁ With ▁ this ▁ front, ▁ we ▁ selected ▁ enough ▁ individuals <encdom> full = True <newline> <dedent> else : <newline> <indent> not_chosen += front <newline>  # ▁ Separate ▁ the ▁ mid ▁ front ▁ to ▁ accept ▁ only ▁ k ▁ individuals <encdom> <dedent> <dedent> k = self . mu - len ( chosen ) <newline> if k > 0 : <newline>  # ▁ reference ▁ point ▁ is ▁ chosen ▁ in ▁ the ▁ complete ▁ population <encdom>  # ▁ as ▁ the ▁ worst ▁ in ▁ each ▁ dimension ▁ +1 <encdom> <indent> ref = numpy . array ( [ ind . fitness . wvalues for ind in candidates ] ) * - 1 <newline> ref = numpy . max ( ref , axis = 0 ) + 1 <newline> for i in range ( len ( mid_front ) - k ) : <newline> <indent> idx = self . indicator ( mid_front , ref = ref ) <newline> not_chosen . append ( mid_front . pop ( idx ) ) <newline> <dedent> chosen += mid_front <newline> <dedent> return chosen , not_chosen <newline> <dedent> def _rankOneUpdate ( self , invCholesky , A , alpha , beta , v ) : <newline> <indent> w = numpy . dot ( invCholesky , v ) <newline>  # ▁ Under ▁ this ▁ threshold, ▁ the ▁ update ▁ is ▁ mostly ▁ noise <encdom> if w . max ( ) > 1e-20 : <newline> <indent> w_inv = numpy . dot ( w , invCholesky ) <newline> norm_w2 = numpy . sum ( w ** 2 ) <newline> a = sqrt ( alpha ) <newline> root = numpy . sqrt ( 1 + beta / alpha * norm_w2 ) <newline> b = a / norm_w2 * ( root - 1 ) <newline> A = a * A + b * numpy . outer ( v , w ) <newline> invCholesky = 1.0 / a * invCholesky - b / ( a ** 2 + a * b * norm_w2 ) * numpy . outer ( w , w_inv ) <newline> <dedent> return invCholesky , A <newline> <dedent> def update ( self , population ) : <newline> <indent>  """ Update ▁ the ▁ current ▁ covariance ▁ matrix ▁ strategies ▁ from ▁ the <strnewline> ▁ *population*. <strnewline> <strnewline> ▁ :param ▁ population: ▁ A ▁ list ▁ of ▁ individuals ▁ from ▁ which ▁ to ▁ update ▁ the <strnewline> ▁ parameters. <strnewline> ▁ """  <newline> chosen , not_chosen = self . _select ( population + self . parents ) <newline> cp , cc , ccov = self . cp , self . cc , self . ccov <newline> d , ptarg , pthresh = self . d , self . ptarg , self . pthresh <newline>  # ▁ Make ▁ copies ▁ for ▁ chosen ▁ offspring ▁ only <encdom> last_steps = [ self . sigmas [ ind . _ps [ 1 ] ] if ind . _ps [ 0 ] == "o" else None for ind in chosen ] <newline> sigmas = [ self . sigmas [ ind . _ps [ 1 ] ] if ind . _ps [ 0 ] == "o" else None for ind in chosen ] <newline> invCholesky = [ self . invCholesky [ ind . _ps [ 1 ] ] . copy ( ) if ind . _ps [ 0 ] == "o" else None for ind in chosen ] <newline> A = [ self . A [ ind . _ps [ 1 ] ] . copy ( ) if ind . _ps [ 0 ] == "o" else None for ind in chosen ] <newline> pc = [ self . pc [ ind . _ps [ 1 ] ] . copy ( ) if ind . _ps [ 0 ] == "o" else None for ind in chosen ] <newline> psucc = [ self . psucc [ ind . _ps [ 1 ] ] if ind . _ps [ 0 ] == "o" else None for ind in chosen ] <newline>  # ▁ Update ▁ the ▁ internal ▁ parameters ▁ for ▁ successful ▁ offspring <encdom> for i , ind in enumerate ( chosen ) : <newline> <indent> t , p_idx = ind . _ps <newline>  # ▁ Only ▁ the ▁ offspring ▁ update ▁ the ▁ parameter ▁ set <encdom> if t == "o" : <newline>  # ▁ Update ▁ (Success ▁ = ▁ 1 ▁ since ▁ it ▁ is ▁ chosen) <encdom> <indent> psucc [ i ] = ( 1.0 - cp ) * psucc [ i ] + cp <newline> sigmas [ i ] = sigmas [ i ] * exp ( ( psucc [ i ] - ptarg ) / ( d * ( 1.0 - ptarg ) ) ) <newline> if psucc [ i ] < pthresh : <newline> <indent> xp = numpy . array ( ind ) <newline> x = numpy . array ( self . parents [ p_idx ] ) <newline> pc [ i ] = ( 1.0 - cc ) * pc [ i ] + sqrt ( cc * ( 2.0 - cc ) ) * ( xp - x ) / last_steps [ i ] <newline> invCholesky [ i ] , A [ i ] = self . _rankOneUpdate ( invCholesky [ i ] , A [ i ] , 1 - ccov , ccov , pc [ i ] ) <newline> <dedent> else : <newline> <indent> pc [ i ] = ( 1.0 - cc ) * pc [ i ] <newline> pc_weight = cc * ( 2.0 - cc ) <newline> invCholesky [ i ] , A [ i ] = self . _rankOneUpdate ( invCholesky [ i ] , A [ i ] , 1 - ccov + pc_weight , ccov , pc [ i ] ) <newline> <dedent> self . psucc [ p_idx ] = ( 1.0 - cp ) * self . psucc [ p_idx ] + cp <newline> self . sigmas [ p_idx ] = self . sigmas [ p_idx ] * exp ( ( self . psucc [ p_idx ] - ptarg ) / ( d * ( 1.0 - ptarg ) ) ) <newline>  # ▁ It ▁ is ▁ unnecessary ▁ to ▁ update ▁ the ▁ entire ▁ parameter ▁ set ▁ for ▁ not ▁ chosen ▁ individuals <encdom>  # ▁ Their ▁ parameters ▁ will ▁ not ▁ make ▁ it ▁ to ▁ the ▁ next ▁ generation <encdom> <dedent> <dedent> for ind in not_chosen : <newline> <indent> t , p_idx = ind . _ps <newline>  # ▁ Only ▁ the ▁ offspring ▁ update ▁ the ▁ parameter ▁ set <encdom> if t == "o" : <newline> <indent> self . psucc [ p_idx ] = ( 1.0 - cp ) * self . psucc [ p_idx ] <newline> self . sigmas [ p_idx ] = self . sigmas [ p_idx ] * exp ( ( self . psucc [ p_idx ] - ptarg ) / ( d * ( 1.0 - ptarg ) ) ) <newline>  # ▁ Make ▁ a ▁ copy ▁ of ▁ the ▁ internal ▁ parameters <encdom>  # ▁ The ▁ parameter ▁ is ▁ in ▁ the ▁ temporary ▁ variable ▁ for ▁ offspring ▁ and ▁ in ▁ the ▁ original ▁ one ▁ for ▁ parents <encdom> <dedent> <dedent> self . parents = chosen <newline> self . sigmas = [ sigmas [ i ] if ind . _ps [ 0 ] == "o" else self . sigmas [ ind . _ps [ 1 ] ] for i , ind in enumerate ( chosen ) ] <newline> self . invCholesky = [ invCholesky [ i ] if ind . _ps [ 0 ] == "o" else self . invCholesky [ ind . _ps [ 1 ] ] for i , ind in enumerate ( chosen ) ] <newline> self . A = [ A [ i ] if ind . _ps [ 0 ] == "o" else self . A [ ind . _ps [ 1 ] ] for i , ind in enumerate ( chosen ) ] <newline> self . pc = [ pc [ i ] if ind . _ps [ 0 ] == "o" else self . pc [ ind . _ps [ 1 ] ] for i , ind in enumerate ( chosen ) ] <newline> self . psucc = [ psucc [ i ] if ind . _ps [ 0 ] == "o" else self . psucc [ ind . _ps [ 1 ] ] for i , ind in enumerate ( chosen ) ] <newline> <dedent> <dedent>
wksr = Runtime . createAndStart ( "webkitspeechrecognition" , "WebkitSpeechRecognition" ) <newline> htmlfilter = Runtime . createAndStart ( "htmlfilter" , "HtmlFilter" ) <newline> mouth = Runtime . createAndStart ( "mouth" , "AcapelaSpeech" ) <newline> alice = Runtime . createAndStart ( "alice" , "ProgramAB" ) <newline> webGui = Runtime . createAndStart ( "webGui" , "WebGui" ) <newline>  # voices ▁ = ▁ mouth.getVoices() <encdom> mouth . setVoice ( "will" ) <newline>  # ▁ add ▁ a ▁ link ▁ between ▁ the ▁ webkit ▁ speech ▁ to ▁ publish ▁ to ▁ ProgramAB <encdom> wksr . addTextListener ( alice ) <newline>  # ▁ Add ▁ route ▁ from ▁ Program ▁ AB ▁ to ▁ html ▁ filter <encdom> alice . addTextListener ( htmlfilter ) <newline>  # ▁ Add ▁ route ▁ from ▁ html ▁ filter ▁ to ▁ mouth <encdom> htmlfilter . addTextListener ( mouth ) <newline>  # ▁ Add ▁ route ▁ from ▁ ear ▁ to ▁ mouth ▁ to ▁ keep ▁ it ▁ from ▁ talking ▁ to ▁ itself <encdom> wksr . addMouth ( mouth ) <newline> python . subscribe ( 'htmlfilter' , 'publishText' ) <newline>  # ▁ talk ▁ function <encdom> def onText ( sent ) :  # ▁ this ▁ is ▁ the ▁ bit ▁ that ▁ makes ▁ the ▁ mouth ▁ move ▁ up ▁ and ▁ down ▁ <encdom> <newline> <indent> mouth . speak ( sent ) <newline> print ( "OnText ▁ " + sent ) <newline> ison = False <newline> a = sent . split ( ) <newline> for word in a : <newline> <indent> if word [ len ( word ) - 2 : ] == "es" :  # ▁ removing ▁ es ▁ at ▁ the ▁ end ▁ of ▁ the ▁ word <encdom> <newline> <indent> testword = word [ : - 2 ] + 'xx'  # ▁ adding ▁ x's ▁ to ▁ help ▁ keep ▁ the ▁ timing <encdom> <newline> <dedent> elif word [ len ( word ) - 1 : ] == "e" :  # ▁ removing ▁ the ▁ silant ▁ e ▁ at ▁ the ▁ end ▁ of ▁ the ▁ word <encdom> <newline> <indent> testword = word [ : - 1 ] + 'x' <newline> <dedent> else : <newline> <indent> testword = word <newline> <dedent> for x in range ( 0 , len ( testword ) ) : <newline> <indent> if testword [ x ] in ( 'a' , 'e' , 'i' , 'o' , 'u' , 'y' ) and ison == False : <newline>  # arduino.digitalWrite(13, ▁ Arduino.HIGH) <encdom> <indent> mouth . moveTo ( 80 )  # ▁ move ▁ the ▁ servo ▁ to ▁ the ▁ open ▁ spot <encdom> <newline> ison = True <newline> sleep ( 0.15 ) <newline> mouth . moveTo ( 15 )  # ▁ close ▁ the ▁ servo ▁ <encdom> <newline> <dedent> elif testword [ x ] in ( '.' ) : <newline>  # arduino.digitalWrite(13, ▁ Arduino.LOW) <encdom> <indent> ison = False <newline> sleep ( .95 ) <newline> <dedent> else :  # sleep(0.5) ▁ sleep ▁ half ▁ a ▁ second <encdom> <newline>  # arduino.digitalWrite(13, ▁ Arduino.LOW) <encdom> <indent> ison = False <newline> sleep ( 0.06 )  # ▁ sleep ▁ half ▁ a ▁ second <encdom> <newline>  # arduino.digitalWrite(13, ▁ Arduino.LOW) <encdom> <dedent> <dedent> sleep ( 0.08 ) <newline>  # ▁ end ▁ of ▁ talk ▁ function <encdom> <dedent> <dedent>
from . import contributor , node , register , tag , file , comment , drafts  # ▁ noqa <encdom> <newline>
 # ▁ -*- ▁ encoding: ▁ utf-8 ▁ -*- <encdom>  # ▁ This ▁ file ▁ is ▁ distributed ▁ under ▁ the ▁ same ▁ license ▁ as ▁ the ▁ Django ▁ package. <encdom>  # ▁ The ▁ *_FORMAT ▁ strings ▁ use ▁ the ▁ Django ▁ date ▁ format ▁ syntax, <encdom>  # ▁ see ▁ http://docs.djangoproject.com/en/dev/ref/templates/builtins/ # date <encdom> DATE_FORMAT = 'd ▁ F ▁ Y'  # ▁ 25 ▁ Ottobre ▁ 2006 <encdom> <newline> TIME_FORMAT = 'H:i:s'  # ▁ 14:30:59 <encdom> <newline> DATETIME_FORMAT = 'l ▁ d ▁ F ▁ Y ▁ H:i:s'  # ▁ Mercoledì ▁ 25 ▁ Ottobre ▁ 2006 ▁ 14:30:59 <encdom> <newline> YEAR_MONTH_FORMAT = 'F ▁ Y'  # ▁ Ottobre ▁ 2006 <encdom> <newline> MONTH_DAY_FORMAT = 'j/F'  # ▁ 10/2006 <encdom> <newline> SHORT_DATE_FORMAT = 'd/M/Y'  # ▁ 25/12/2009 <encdom> <newline> SHORT_DATETIME_FORMAT = 'd/M/Y ▁ H:i:s'  # ▁ 25/10/2009 ▁ 14:30:59 <encdom> <newline> FIRST_DAY_OF_WEEK = 1  # ▁ Lunedì <encdom> <newline>  # ▁ The ▁ *_INPUT_FORMATS ▁ strings ▁ use ▁ the ▁ Python ▁ strftime ▁ format ▁ syntax, <encdom>  # ▁ see ▁ http://docs.python.org/library/datetime.html # strftime-strptime-behavior <encdom> DATE_INPUT_FORMATS = ( '%Y-%m-%d' , '%Y/%m/%d' ,  # ▁'2008-10-25', ▁'2008/10/25' <encdom> '%d-%m-%Y' , '%d/%m/%Y' ,  # ▁'25-10-2006', ▁'25/10/2006' <encdom> '%d-%m-%y' , '%d/%m/%y' ,  # ▁'25-10-06', ▁'25/10/06' <encdom> ) <newline> TIME_INPUT_FORMATS = ( '%H:%M:%S' ,  # ▁'14:30:59' <encdom> '%H:%M' ,  # ▁'14:30' <encdom> ) <newline> DATETIME_INPUT_FORMATS = ( '%Y-%m-%d ▁ %H:%M:%S' ,  # ▁'2006-10-25 ▁ 14:30:59' <encdom> '%Y-%m-%d ▁ %H:%M' ,  # ▁'2006-10-25 ▁ 14:30' <encdom> '%Y-%m-%d' ,  # ▁'2006-10-25' <encdom> '%d-%m-%Y ▁ %H:%M:%S' ,  # ▁'25-10-2006 ▁ 14:30:59' <encdom> '%d-%m-%Y ▁ %H:%M' ,  # ▁'25-10-2006 ▁ 14:30' <encdom> '%d-%m-%Y' ,  # ▁'25-10-2006' <encdom> '%d-%m-%y ▁ %H:%M:%S' ,  # ▁'25-10-06 ▁ 14:30:59' <encdom> '%d-%m-%y ▁ %H:%M' ,  # ▁'25-10-06 ▁ 14:30' <encdom> '%d-%m-%y' ,  # ▁'25-10-06' <encdom> '%d/%m/%Y ▁ %H:%M:%S' ,  # ▁'25/10/2006 ▁ 14:30:59' <encdom> '%d/%m/%Y ▁ %H:%M' ,  # ▁'25/10/2006 ▁ 14:30' <encdom> '%d/%m/%Y' ,  # ▁'25/10/2006' <encdom> '%d/%m/%y ▁ %H:%M:%S' ,  # ▁'25/10/06 ▁ 14:30:59' <encdom> '%d/%m/%y ▁ %H:%M' ,  # ▁'25/10/06 ▁ 14:30' <encdom> '%d/%m/%y' ,  # ▁'25/10/06' <encdom> ) <newline> DECIMAL_SEPARATOR = ',' <newline> THOUSAND_SEPARATOR = '.' <newline> NUMBER_GROUPING = 3 <newline>
 # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); ▁ you ▁ may <encdom>  # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. ▁ You ▁ may ▁ obtain <encdom>  # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, ▁ WITHOUT <encdom>  # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. ▁ See ▁ the <encdom>  # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations <encdom>  # ▁ under ▁ the ▁ License. <encdom> import logging <newline> from django . conf import settings <newline> from django . utils . translation import ugettext_lazy as _ <newline> import six <newline> from horizon import exceptions <newline> from openstack_dashboard import api <newline> LOG = logging . getLogger ( __name__ ) <newline> def flavor_list ( request ) : <newline> <indent>  """ Utility ▁ method ▁ to ▁ retrieve ▁ a ▁ list ▁ of ▁ flavors. """  <newline> try : <newline> <indent> return api . nova . flavor_list ( request ) <newline> <dedent> except Exception : <newline> <indent> exceptions . handle ( request , _ ( 'Unable ▁ to ▁ retrieve ▁ instance ▁ flavors.' ) ) <newline> return [ ] <newline> <dedent> <dedent> def sort_flavor_list ( request , flavors ) : <newline> <indent>  """ Utility ▁ method ▁ to ▁ sort ▁ a ▁ list ▁ of ▁ flavors. <strnewline> ▁ By ▁ default, ▁ returns ▁ the ▁ available ▁ flavors, ▁ sorted ▁ by ▁ RAM <strnewline> ▁ usage ▁ (ascending). ▁ Override ▁ these ▁ behaviours ▁ with ▁ a <strnewline> ▁ CREATE_INSTANCE_FLAVOR_SORT ▁ dict <strnewline> ▁ in ▁ local_settings.py. <strnewline> ▁ """  <newline> def get_key ( flavor , sort_key ) : <newline> <indent> try : <newline> <indent> return getattr ( flavor , sort_key ) <newline> <dedent> except AttributeError : <newline> <indent> LOG . warning ( 'Could ▁ not ▁ find ▁ sort ▁ key ▁"%s". ▁ Using ▁ the ▁ default ▁ ' '"ram" ▁ instead.' , sort_key ) <newline> return getattr ( flavor , 'ram' ) <newline> <dedent> <dedent> try : <newline> <indent> flavor_sort = getattr ( settings , 'CREATE_INSTANCE_FLAVOR_SORT' , { } ) <newline> sort_key = flavor_sort . get ( 'key' , 'ram' ) <newline> rev = flavor_sort . get ( 'reverse' , False ) <newline> if not callable ( sort_key ) : <newline> <indent> key = lambda flavor : get_key ( flavor , sort_key ) <newline> <dedent> else : <newline> <indent> key = sort_key <newline> <dedent> flavor_list = [ ( flavor . id , '%s' % flavor . name ) for flavor in sorted ( flavors , key = key , reverse = rev ) ] <newline> return flavor_list <newline> <dedent> except Exception : <newline> <indent> exceptions . handle ( request , _ ( 'Unable ▁ to ▁ sort ▁ instance ▁ flavors.' ) ) <newline> return [ ] <newline> <dedent> <dedent> def availability_zone_list ( request ) : <newline> <indent>  """ Utility ▁ method ▁ to ▁ retrieve ▁ a ▁ list ▁ of ▁ availability ▁ zones. """  <newline> try : <newline> <indent> return api . nova . availability_zone_list ( request ) <newline> <dedent> except Exception : <newline> <indent> exceptions . handle ( request , _ ( 'Unable ▁ to ▁ retrieve ▁ Nova ▁ availability ▁ zones.' ) ) <newline> return [ ] <newline> <dedent> <dedent> def network_field_data ( request , include_empty_option = False ) : <newline> <indent>  """ Returns ▁ a ▁ list ▁ of ▁ tuples ▁ of ▁ all ▁ networks. <strnewline> <strnewline> ▁ Generates ▁ a ▁ list ▁ of ▁ networks ▁ available ▁ to ▁ the ▁ user ▁ (request). ▁ And ▁ returns <strnewline> ▁ a ▁ list ▁ of ▁ (id, ▁ name) ▁ tuples. <strnewline> <strnewline> ▁ :param ▁ request: ▁ django ▁ http ▁ request ▁ object <strnewline> ▁ :param ▁ include_empty_option: ▁ flag ▁ to ▁ include ▁ a ▁ empty ▁ tuple ▁ in ▁ the ▁ front ▁ of <strnewline> ▁ the ▁ list <strnewline> ▁ :return: ▁ list ▁ of ▁ (id, ▁ name) ▁ tuples <strnewline> ▁ """  <newline> tenant_id = request . user . tenant_id <newline> networks = [ ] <newline> if api . base . is_service_enabled ( request , 'network' ) : <newline> <indent> try : <newline> <indent> networks = api . neutron . network_list_for_tenant ( request , tenant_id ) <newline> networks = [ ( n . id , n . name_or_id ) for n in networks ] <newline> networks . sort ( key = lambda obj : obj [ 1 ] ) <newline> <dedent> except Exception as e : <newline> <indent> msg = _ ( 'Failed ▁ to ▁ get ▁ network ▁ list ▁ {0}' ) . format ( six . text_type ( e ) ) <newline> exceptions . handle ( request , msg ) <newline> <dedent> <dedent> if not networks : <newline> <indent> if include_empty_option : <newline> <indent> return [ ( "" , _ ( "No ▁ networks ▁ available" ) ) , ] <newline> <dedent> return [ ] <newline> <dedent> if include_empty_option : <newline> <indent> return [ ( "" , _ ( "Select ▁ Network" ) ) , ] + networks <newline> <dedent> return networks <newline> <dedent> def keypair_field_data ( request , include_empty_option = False ) : <newline> <indent>  """ Returns ▁ a ▁ list ▁ of ▁ tuples ▁ of ▁ all ▁ keypairs. <strnewline> <strnewline> ▁ Generates ▁ a ▁ list ▁ of ▁ keypairs ▁ available ▁ to ▁ the ▁ user ▁ (request). ▁ And ▁ returns <strnewline> ▁ a ▁ list ▁ of ▁ (id, ▁ name) ▁ tuples. <strnewline> <strnewline> ▁ :param ▁ request: ▁ django ▁ http ▁ request ▁ object <strnewline> ▁ :param ▁ include_empty_option: ▁ flag ▁ to ▁ include ▁ a ▁ empty ▁ tuple ▁ in ▁ the ▁ front ▁ of <strnewline> ▁ the ▁ list <strnewline> ▁ :return: ▁ list ▁ of ▁ (id, ▁ name) ▁ tuples <strnewline> ▁ """  <newline> keypair_list = [ ] <newline> try : <newline> <indent> keypairs = api . nova . keypair_list ( request ) <newline> keypair_list = [ ( kp . name , kp . name ) for kp in keypairs ] <newline> <dedent> except Exception : <newline> <indent> exceptions . handle ( request , _ ( 'Unable ▁ to ▁ retrieve ▁ key ▁ pairs.' ) ) <newline> <dedent> if not keypair_list : <newline> <indent> if include_empty_option : <newline> <indent> return [ ( "" , _ ( "No ▁ key ▁ pairs ▁ available" ) ) , ] <newline> <dedent> return [ ] <newline> <dedent> if include_empty_option : <newline> <indent> return [ ( "" , _ ( "Select ▁ a ▁ key ▁ pair" ) ) , ] + keypair_list <newline> <dedent> return keypair_list <newline> <dedent> def flavor_field_data ( request , include_empty_option = False ) : <newline> <indent>  """ Returns ▁ a ▁ list ▁ of ▁ tuples ▁ of ▁ all ▁ image ▁ flavors. <strnewline> <strnewline> ▁ Generates ▁ a ▁ list ▁ of ▁ image ▁ flavors ▁ available. ▁ And ▁ returns ▁ a ▁ list ▁ of <strnewline> ▁ (id, ▁ name) ▁ tuples. <strnewline> <strnewline> ▁ :param ▁ request: ▁ django ▁ http ▁ request ▁ object <strnewline> ▁ :param ▁ include_empty_option: ▁ flag ▁ to ▁ include ▁ a ▁ empty ▁ tuple ▁ in ▁ the ▁ front ▁ of <strnewline> ▁ the ▁ list <strnewline> ▁ :return: ▁ list ▁ of ▁ (id, ▁ name) ▁ tuples <strnewline> ▁ """  <newline> flavors = flavor_list ( request ) <newline> if flavors : <newline> <indent> flavors_list = sort_flavor_list ( request , flavors ) <newline> if include_empty_option : <newline> <indent> return [ ( "" , _ ( "Select ▁ Flavor" ) ) , ] + flavors_list <newline> <dedent> return flavors_list <newline> <dedent> if include_empty_option : <newline> <indent> return [ ( "" , _ ( "No ▁ flavors ▁ available" ) ) , ] <newline> <dedent> return [ ] <newline> <dedent>
 """ <strnewline> WARNING: ▁ The ▁ plugin ▁ API ▁ is ▁ still ▁ work ▁ in ▁ progress ▁ and ▁ will <strnewline> ▁ probably ▁ be ▁ completely ▁ reworked ▁ by ▁ v1.0.0. <strnewline> <strnewline> """  <newline> from httpie . plugins . base import ( AuthPlugin , FormatterPlugin , ConverterPlugin , TransportPlugin ) <newline> from httpie . plugins . manager import PluginManager <newline> from httpie . plugins . builtin import BasicAuthPlugin , DigestAuthPlugin <newline> from httpie . output . formatters . headers import HeadersFormatter <newline> from httpie . output . formatters . json import JSONFormatter <newline> from httpie . output . formatters . xml import XMLFormatter <newline> from httpie . output . formatters . colors import ColorFormatter <newline> plugin_manager = PluginManager ( ) <newline> plugin_manager . register ( BasicAuthPlugin , DigestAuthPlugin ) <newline> plugin_manager . register ( HeadersFormatter , JSONFormatter , XMLFormatter , ColorFormatter ) <newline>
 # ▁ Copyright ▁ (c) ▁ 2010 ▁ Citrix ▁ Systems, ▁ Inc. <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); ▁ you ▁ may <encdom>  # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. ▁ You ▁ may ▁ obtain <encdom>  # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, ▁ WITHOUT <encdom>  # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. ▁ See ▁ the <encdom>  # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations <encdom>  # ▁ under ▁ the ▁ License. <encdom>  # ▁ Parts ▁ of ▁ this ▁ file ▁ are ▁ based ▁ upon ▁ xmlrpclib.py, ▁ the ▁ XML-RPC ▁ client <encdom>  # ▁ interface ▁ included ▁ in ▁ the ▁ Python ▁ distribution. <encdom>  # ▁ Copyright ▁ (c) ▁ 1999-2002 ▁ by ▁ Secret ▁ Labs ▁ AB <encdom>  # ▁ Copyright ▁ (c) ▁ 1999-2002 ▁ by ▁ Fredrik ▁ Lundh <encdom>  # ▁ By ▁ obtaining, ▁ using, ▁ and/or ▁ copying ▁ this ▁ software ▁ and/or ▁ its <encdom>  # ▁ associated ▁ documentation, ▁ you ▁ agree ▁ that ▁ you ▁ have ▁ read, ▁ understood, <encdom>  # ▁ and ▁ will ▁ comply ▁ with ▁ the ▁ following ▁ terms ▁ and ▁ conditions: <encdom>  # ▁ Permission ▁ to ▁ use, ▁ copy, ▁ modify, ▁ and ▁ distribute ▁ this ▁ software ▁ and <encdom>  # ▁ its ▁ associated ▁ documentation ▁ for ▁ any ▁ purpose ▁ and ▁ without ▁ fee ▁ is <encdom>  # ▁ hereby ▁ granted, ▁ provided ▁ that ▁ the ▁ above ▁ copyright ▁ notice ▁ appears ▁ in <encdom>  # ▁ all ▁ copies, ▁ and ▁ that ▁ both ▁ that ▁ copyright ▁ notice ▁ and ▁ this ▁ permission <encdom>  # ▁ notice ▁ appear ▁ in ▁ supporting ▁ documentation, ▁ and ▁ that ▁ the ▁ name ▁ of <encdom>  # ▁ Secret ▁ Labs ▁ AB ▁ or ▁ the ▁ author ▁ not ▁ be ▁ used ▁ in ▁ advertising ▁ or ▁ publicity <encdom>  # ▁ pertaining ▁ to ▁ distribution ▁ of ▁ the ▁ software ▁ without ▁ specific, ▁ written <encdom>  # ▁ prior ▁ permission. <encdom>  # ▁ SECRET ▁ LABS ▁ AB ▁ AND ▁ THE ▁ AUTHOR ▁ DISCLAIMS ▁ ALL ▁ WARRANTIES ▁ WITH ▁ REGARD <encdom>  # ▁ TO ▁ THIS ▁ SOFTWARE, ▁ INCLUDING ▁ ALL ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANT- <encdom>  # ▁ ABILITY ▁ AND ▁ FITNESS. ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ SECRET ▁ LABS ▁ AB ▁ OR ▁ THE ▁ AUTHOR <encdom>  # ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ SPECIAL, ▁ INDIRECT ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ OR ▁ ANY <encdom>  # ▁ DAMAGES ▁ WHATSOEVER ▁ RESULTING ▁ FROM ▁ LOSS ▁ OF ▁ USE, ▁ DATA ▁ OR ▁ PROFITS, <encdom>  # ▁ WHETHER ▁ IN ▁ AN ▁ ACTION ▁ OF ▁ CONTRACT, ▁ NEGLIGENCE ▁ OR ▁ OTHER ▁ TORTIOUS <encdom>  # ▁ ACTION, ▁ ARISING ▁ OUT ▁ OF ▁ OR ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ USE ▁ OR ▁ PERFORMANCE <encdom>  # ▁ OF ▁ THIS ▁ SOFTWARE. <encdom>  """ <strnewline> A ▁ fake ▁ XenAPI ▁ SDK. <strnewline> """  <newline> import base64 <newline> import pickle <newline> import pprint <newline> import random <newline> import uuid <newline> from xml . sax import saxutils <newline> import zlib <newline> from oslo . serialization import jsonutils <newline> from oslo . utils import timeutils <newline> from oslo . utils import units <newline> from nova import exception <newline> from nova . i18n import _ <newline> from nova . openstack . common import log as logging <newline> from nova . virt . xenapi . client import session as xenapi_session <newline> _CLASSES = [ 'host' , 'network' , 'session' , 'pool' , 'SR' , 'VBD' , 'PBD' , 'VDI' , 'VIF' , 'PIF' , 'VM' , 'VLAN' , 'task' ] <newline> _db_content = { } <newline> LOG = logging . getLogger ( __name__ ) <newline> def log_db_contents ( msg = None ) : <newline> <indent> text = msg or "" <newline> content = pprint . pformat ( _db_content ) <newline> LOG . debug ( "%(text)s: ▁ _db_content ▁ => ▁ %(content)s" , { 'text' : text , 'content' : content } ) <newline> <dedent> def reset ( ) : <newline> <indent> for c in _CLASSES : <newline> <indent> _db_content [ c ] = { } <newline> <dedent> host = create_host ( 'fake' ) <newline> create_vm ( 'fake ▁ dom ▁ 0' , 'Running' , is_a_template = False , is_control_domain = True , resident_on = host ) <newline> <dedent> def reset_table ( table ) : <newline> <indent> if table not in _CLASSES : <newline> <indent> return <newline> <dedent> _db_content [ table ] = { } <newline> <dedent> def _create_pool ( name_label ) : <newline> <indent> return _create_object ( 'pool' , { 'name_label' : name_label } ) <newline> <dedent> def create_host ( name_label , hostname = 'fake_name' , address = 'fake_addr' ) : <newline> <indent> host_ref = _create_object ( 'host' , { 'name_label' : name_label , 'hostname' : hostname , 'address' : address } ) <newline> host_default_sr_ref = _create_local_srs ( host_ref ) <newline> _create_local_pif ( host_ref ) <newline>  # ▁ Create ▁ a ▁ pool ▁ if ▁ we ▁ don't ▁ have ▁ one ▁ already <encdom> if len ( _db_content [ 'pool' ] ) == 0 : <newline> <indent> pool_ref = _create_pool ( '' ) <newline> _db_content [ 'pool' ] [ pool_ref ] [ 'master' ] = host_ref <newline> _db_content [ 'pool' ] [ pool_ref ] [ 'default-SR' ] = host_default_sr_ref <newline> _db_content [ 'pool' ] [ pool_ref ] [ 'suspend-image-SR' ] = host_default_sr_ref <newline> <dedent> <dedent> def create_network ( name_label , bridge ) : <newline> <indent> return _create_object ( 'network' , { 'name_label' : name_label , 'bridge' : bridge } ) <newline> <dedent> def create_vm ( name_label , status , ** kwargs ) : <newline> <indent> if status == 'Running' : <newline> <indent> domid = random . randrange ( 1 , 1 << 16 ) <newline> resident_on = _db_content [ 'host' ] . keys ( ) [ 0 ] <newline> <dedent> else : <newline> <indent> domid = - 1 <newline> resident_on = '' <newline> <dedent> vm_rec = kwargs . copy ( ) <newline> vm_rec . update ( { 'name_label' : name_label , 'domid' : domid , 'power_state' : status , 'blocked_operations' : { } , 'resident_on' : resident_on } ) <newline> vm_ref = _create_object ( 'VM' , vm_rec ) <newline> after_VM_create ( vm_ref , vm_rec ) <newline> return vm_ref <newline> <dedent> def destroy_vm ( vm_ref ) : <newline> <indent> vm_rec = _db_content [ 'VM' ] [ vm_ref ] <newline> vbd_refs = vm_rec [ 'VBDs' ] <newline>  # ▁ NOTE(johannes): ▁ Shallow ▁ copy ▁ since ▁ destroy_vbd ▁ will ▁ remove ▁ itself <encdom>  # ▁ from ▁ the ▁ list <encdom> for vbd_ref in vbd_refs [ : ] : <newline> <indent> destroy_vbd ( vbd_ref ) <newline> <dedent> del _db_content [ 'VM' ] [ vm_ref ] <newline> <dedent> def destroy_vbd ( vbd_ref ) : <newline> <indent> vbd_rec = _db_content [ 'VBD' ] [ vbd_ref ] <newline> vm_ref = vbd_rec [ 'VM' ] <newline> vm_rec = _db_content [ 'VM' ] [ vm_ref ] <newline> vm_rec [ 'VBDs' ] . remove ( vbd_ref ) <newline> vdi_ref = vbd_rec [ 'VDI' ] <newline> vdi_rec = _db_content [ 'VDI' ] [ vdi_ref ] <newline> vdi_rec [ 'VBDs' ] . remove ( vbd_ref ) <newline> del _db_content [ 'VBD' ] [ vbd_ref ] <newline> <dedent> def destroy_vdi ( vdi_ref ) : <newline> <indent> vdi_rec = _db_content [ 'VDI' ] [ vdi_ref ] <newline> vbd_refs = vdi_rec [ 'VBDs' ] <newline>  # ▁ NOTE(johannes): ▁ Shallow ▁ copy ▁ since ▁ destroy_vbd ▁ will ▁ remove ▁ itself <encdom>  # ▁ from ▁ the ▁ list <encdom> for vbd_ref in vbd_refs [ : ] : <newline> <indent> destroy_vbd ( vbd_ref ) <newline> <dedent> del _db_content [ 'VDI' ] [ vdi_ref ] <newline> <dedent> def create_vdi ( name_label , sr_ref , ** kwargs ) : <newline> <indent> vdi_rec = { 'SR' : sr_ref , 'read_only' : False , 'type' : '' , 'name_label' : name_label , 'name_description' : '' , 'sharable' : False , 'other_config' : { } , 'location' : '' , 'xenstore_data' : { } , 'sm_config' : { 'vhd-parent' : None } , 'physical_utilisation' : '123' , 'managed' : True , } <newline> vdi_rec . update ( kwargs ) <newline> vdi_ref = _create_object ( 'VDI' , vdi_rec ) <newline> after_VDI_create ( vdi_ref , vdi_rec ) <newline> return vdi_ref <newline> <dedent> def after_VDI_create ( vdi_ref , vdi_rec ) : <newline> <indent> vdi_rec . setdefault ( 'VBDs' , [ ] ) <newline> <dedent> def create_vbd ( vm_ref , vdi_ref , userdevice = 0 , other_config = None ) : <newline> <indent> if other_config is None : <newline> <indent> other_config = { } <newline> <dedent> vbd_rec = { 'VM' : vm_ref , 'VDI' : vdi_ref , 'userdevice' : str ( userdevice ) , 'currently_attached' : False , 'other_config' : other_config } <newline> vbd_ref = _create_object ( 'VBD' , vbd_rec ) <newline> after_VBD_create ( vbd_ref , vbd_rec ) <newline> return vbd_ref <newline> <dedent> def after_VBD_create ( vbd_ref , vbd_rec ) : <newline> <indent>  """ Create ▁ read-only ▁ fields ▁ and ▁ backref ▁ from ▁ VM ▁ and ▁ VDI ▁ to ▁ VBD ▁ when ▁ VBD <strnewline> ▁ is ▁ created. <strnewline> ▁ """  <newline> vbd_rec [ 'currently_attached' ] = False <newline> vbd_rec [ 'device' ] = '' <newline> vbd_rec . setdefault ( 'other_config' , { } ) <newline> vm_ref = vbd_rec [ 'VM' ] <newline> vm_rec = _db_content [ 'VM' ] [ vm_ref ] <newline> vm_rec [ 'VBDs' ] . append ( vbd_ref ) <newline> vm_name_label = _db_content [ 'VM' ] [ vm_ref ] [ 'name_label' ] <newline> vbd_rec [ 'vm_name_label' ] = vm_name_label <newline> vdi_ref = vbd_rec [ 'VDI' ] <newline> if vdi_ref and vdi_ref != "OpaqueRef:NULL" : <newline> <indent> vdi_rec = _db_content [ 'VDI' ] [ vdi_ref ] <newline> vdi_rec [ 'VBDs' ] . append ( vbd_ref ) <newline> <dedent> <dedent> def after_VIF_create ( vif_ref , vif_rec ) : <newline> <indent>  """ Create ▁ backref ▁ from ▁ VM ▁ to ▁ VIF ▁ when ▁ VIF ▁ is ▁ created. <strnewline> ▁ """  <newline> vm_ref = vif_rec [ 'VM' ] <newline> vm_rec = _db_content [ 'VM' ] [ vm_ref ] <newline> vm_rec [ 'VIFs' ] . append ( vif_ref ) <newline> <dedent> def after_VM_create ( vm_ref , vm_rec ) : <newline> <indent>  """ Create ▁ read-only ▁ fields ▁ in ▁ the ▁ VM ▁ record. """  <newline> vm_rec . setdefault ( 'domid' , - 1 ) <newline> vm_rec . setdefault ( 'is_control_domain' , False ) <newline> vm_rec . setdefault ( 'is_a_template' , False ) <newline> vm_rec . setdefault ( 'memory_static_max' , str ( 8 * units . Gi ) ) <newline> vm_rec . setdefault ( 'memory_dynamic_max' , str ( 8 * units . Gi ) ) <newline> vm_rec . setdefault ( 'VCPUs_max' , str ( 4 ) ) <newline> vm_rec . setdefault ( 'VBDs' , [ ] ) <newline> vm_rec . setdefault ( 'VIFs' , [ ] ) <newline> vm_rec . setdefault ( 'resident_on' , '' ) <newline> <dedent> def create_pbd ( host_ref , sr_ref , attached ) : <newline> <indent> config = { 'path' : '/var/run/sr-mount/%s' % sr_ref } <newline> return _create_object ( 'PBD' , { 'device_config' : config , 'host' : host_ref , 'SR' : sr_ref , 'currently_attached' : attached } ) <newline> <dedent> def create_task ( name_label ) : <newline> <indent> return _create_object ( 'task' , { 'name_label' : name_label , 'status' : 'pending' } ) <newline> <dedent> def _create_local_srs ( host_ref ) : <newline> <indent>  """ Create ▁ an ▁ SR ▁ that ▁ looks ▁ like ▁ the ▁ one ▁ created ▁ on ▁ the ▁ local ▁ disk ▁ by <strnewline> ▁ default ▁ by ▁ the ▁ XenServer ▁ installer. ▁ Also, ▁ fake ▁ the ▁ installation ▁ of <strnewline> ▁ an ▁ ISO ▁ SR. <strnewline> ▁ """  <newline> create_sr ( name_label = 'Local ▁ storage ▁ ISO' , type = 'iso' , other_config = { 'i18n-original-value-name_label' : 'Local ▁ storage ▁ ISO' , 'i18n-key' : 'local-storage-iso' } , physical_size = 80000 , physical_utilisation = 40000 , virtual_allocation = 80000 , host_ref = host_ref ) <newline> return create_sr ( name_label = 'Local ▁ storage' , type = 'ext' , other_config = { 'i18n-original-value-name_label' : 'Local ▁ storage' , 'i18n-key' : 'local-storage' } , physical_size = 40000 , physical_utilisation = 20000 , virtual_allocation = 10000 , host_ref = host_ref ) <newline> <dedent> def create_sr ( ** kwargs ) : <newline> <indent> sr_ref = _create_object ( 'SR' , { 'name_label' : kwargs . get ( 'name_label' ) , 'type' : kwargs . get ( 'type' ) , 'content_type' : kwargs . get ( 'type' , 'user' ) , 'shared' : kwargs . get ( 'shared' , False ) , 'physical_size' : kwargs . get ( 'physical_size' , str ( 1 << 30 ) ) , 'physical_utilisation' : str ( kwargs . get ( 'physical_utilisation' , 0 ) ) , 'virtual_allocation' : str ( kwargs . get ( 'virtual_allocation' , 0 ) ) , 'other_config' : kwargs . get ( 'other_config' , { } ) , 'VDIs' : kwargs . get ( 'VDIs' , [ ] ) } ) <newline> pbd_ref = create_pbd ( kwargs . get ( 'host_ref' ) , sr_ref , True ) <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'PBDs' ] = [ pbd_ref ] <newline> return sr_ref <newline> <dedent> def _create_local_pif ( host_ref ) : <newline> <indent> pif_ref = _create_object ( 'PIF' , { 'name-label' : 'Fake ▁ PIF' , 'MAC' : '00:11:22:33:44:55' , 'physical' : True , 'VLAN' : - 1 , 'device' : 'fake0' , 'host_uuid' : host_ref , 'network' : '' , 'IP' : '10.1.1.1' , 'IPv6' : '' , 'uuid' : '' , 'management' : 'true' } ) <newline> _db_content [ 'PIF' ] [ pif_ref ] [ 'uuid' ] = pif_ref <newline> return pif_ref <newline> <dedent> def _create_object ( table , obj ) : <newline> <indent> ref = str ( uuid . uuid4 ( ) ) <newline> obj [ 'uuid' ] = str ( uuid . uuid4 ( ) ) <newline> _db_content [ table ] [ ref ] = obj <newline> return ref <newline> <dedent> def _create_sr ( table , obj ) : <newline> <indent> sr_type = obj [ 6 ] <newline>  # ▁ Forces ▁ fake ▁ to ▁ support ▁ iscsi ▁ only <encdom> if sr_type != 'iscsi' and sr_type != 'nfs' : <newline> <indent> raise Failure ( [ 'SR_UNKNOWN_DRIVER' , sr_type ] ) <newline> <dedent> host_ref = _db_content [ 'host' ] . keys ( ) [ 0 ] <newline> sr_ref = _create_object ( table , obj [ 2 ] ) <newline> if sr_type == 'iscsi' : <newline> <indent> vdi_ref = create_vdi ( '' , sr_ref ) <newline> pbd_ref = create_pbd ( host_ref , sr_ref , True ) <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'VDIs' ] = [ vdi_ref ] <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'PBDs' ] = [ pbd_ref ] <newline> _db_content [ 'VDI' ] [ vdi_ref ] [ 'SR' ] = sr_ref <newline> _db_content [ 'PBD' ] [ pbd_ref ] [ 'SR' ] = sr_ref <newline> <dedent> return sr_ref <newline> <dedent> def _create_vlan ( pif_ref , vlan_num , network_ref ) : <newline> <indent> pif_rec = get_record ( 'PIF' , pif_ref ) <newline> vlan_pif_ref = _create_object ( 'PIF' , { 'name-label' : 'Fake ▁ VLAN ▁ PIF' , 'MAC' : '00:11:22:33:44:55' , 'physical' : True , 'VLAN' : vlan_num , 'device' : pif_rec [ 'device' ] , 'host_uuid' : pif_rec [ 'host_uuid' ] } ) <newline> return _create_object ( 'VLAN' , { 'tagged-pif' : pif_ref , 'untagged-pif' : vlan_pif_ref , 'tag' : vlan_num } ) <newline> <dedent> def get_all ( table ) : <newline> <indent> return _db_content [ table ] . keys ( ) <newline> <dedent> def get_all_records ( table ) : <newline> <indent> return _db_content [ table ] <newline> <dedent> def _query_matches ( record , query ) : <newline>  # ▁ Simple ▁ support ▁ for ▁ the ▁ XenServer ▁ query ▁ language: <encdom>  # ▁'field ▁ "host"="<uuid>" ▁ and ▁ field ▁ "SR"="<sr ▁ uuid>"' <encdom>  # ▁ Tested ▁ through ▁ existing ▁ tests ▁ (e.g. ▁ calls ▁ to ▁ find_network_with_bridge) <encdom> <indent> and_clauses = query . split ( " ▁ and ▁ " ) <newline> if len ( and_clauses ) > 1 : <newline> <indent> matches = True <newline> for clause in and_clauses : <newline> <indent> matches = matches and _query_matches ( record , clause ) <newline> <dedent> return matches <newline> <dedent> or_clauses = query . split ( " ▁ or ▁ " ) <newline> if len ( or_clauses ) > 1 : <newline> <indent> matches = False <newline> for clause in or_clauses : <newline> <indent> matches = matches or _query_matches ( record , clause ) <newline> <dedent> return matches <newline> <dedent> if query [ : 4 ] == 'not ▁ ' : <newline> <indent> return not _query_matches ( record , query [ 4 : ] ) <newline>  # ▁ Now ▁ it ▁ must ▁ be ▁ a ▁ single ▁ field ▁ - ▁ bad ▁ queries ▁ never ▁ match <encdom> <dedent> if query [ : 5 ] != 'field' : <newline> <indent> return False <newline> <dedent> ( field , value ) = query [ 6 : ] . split ( '=' , 1 ) <newline>  # ▁ Some ▁ fields ▁ (e.g. ▁ name_label, ▁ memory_overhead) ▁ have ▁ double <encdom>  # ▁ underscores ▁ in ▁ the ▁ DB, ▁ but ▁ only ▁ single ▁ underscores ▁ when ▁ querying <encdom> field = field . replace ( "__" , "_" ) . strip ( " ▁ \"'" ) <newline> value = value . strip ( " ▁ \"'" ) <newline>  # ▁ Strings ▁ should ▁ be ▁ directly ▁ compared <encdom> if isinstance ( record [ field ] , str ) : <newline> <indent> return record [ field ] == value <newline>  # ▁ But ▁ for ▁ all ▁ other ▁ value-checks, ▁ convert ▁ to ▁ a ▁ string ▁ first <encdom>  # ▁ (Notably ▁ used ▁ for ▁ booleans ▁ - ▁ which ▁ can ▁ be ▁ lower ▁ or ▁ camel <encdom>  # ▁ case ▁ and ▁ are ▁ interpreted/sanitised ▁ by ▁ XAPI) <encdom> <dedent> return str ( record [ field ] ) . lower ( ) == value . lower ( ) <newline> <dedent> def get_all_records_where ( table_name , query ) : <newline> <indent> matching_records = { } <newline> table = _db_content [ table_name ] <newline> for record in table : <newline> <indent> if _query_matches ( table [ record ] , query ) : <newline> <indent> matching_records [ record ] = table [ record ] <newline> <dedent> <dedent> return matching_records <newline> <dedent> def get_record ( table , ref ) : <newline> <indent> if ref in _db_content [ table ] : <newline> <indent> return _db_content [ table ] . get ( ref ) <newline> <dedent> else : <newline> <indent> raise Failure ( [ 'HANDLE_INVALID' , table , ref ] ) <newline> <dedent> <dedent> def check_for_session_leaks ( ) : <newline> <indent> if len ( _db_content [ 'session' ] ) > 0 : <newline> <indent> raise exception . NovaException ( 'Sessions ▁ have ▁ leaked: ▁ %s' % _db_content [ 'session' ] ) <newline> <dedent> <dedent> def as_value ( s ) : <newline> <indent>  """ Helper ▁ function ▁ for ▁ simulating ▁ XenAPI ▁ plugin ▁ responses. ▁ It <strnewline> ▁ escapes ▁ and ▁ wraps ▁ the ▁ given ▁ argument. <strnewline> ▁ """  <newline> return '<value>%s</value>' % saxutils . escape ( s ) <newline> <dedent> def as_json ( * args , ** kwargs ) : <newline> <indent>  """ Helper ▁ function ▁ for ▁ simulating ▁ XenAPI ▁ plugin ▁ responses ▁ for ▁ those <strnewline> ▁ that ▁ are ▁ returning ▁ JSON. ▁ If ▁ this ▁ function ▁ is ▁ given ▁ plain ▁ arguments, <strnewline> ▁ then ▁ these ▁ are ▁ rendered ▁ as ▁ a ▁ JSON ▁ list. ▁ If ▁ it's ▁ given ▁ keyword <strnewline> ▁ arguments ▁ then ▁ these ▁ are ▁ rendered ▁ as ▁ a ▁ JSON ▁ dict. <strnewline> ▁ """  <newline> arg = args or kwargs <newline> return jsonutils . dumps ( arg ) <newline> <dedent> class Failure ( Exception ) : <newline> <indent> def __init__ ( self , details ) : <newline> <indent> self . details = details <newline> <dedent> def __str__ ( self ) : <newline> <indent> try : <newline> <indent> return str ( self . details ) <newline> <dedent> except Exception : <newline> <indent> return "XenAPI ▁ Fake ▁ Failure: ▁ %s" % str ( self . details ) <newline> <dedent> <dedent> def _details_map ( self ) : <newline> <indent> return dict ( [ ( str ( i ) , self . details [ i ] ) for i in range ( len ( self . details ) ) ] ) <newline> <dedent> <dedent> class SessionBase ( object ) : <newline> <indent>  """ Base ▁ class ▁ for ▁ Fake ▁ Sessions. """  <newline> def __init__ ( self , uri ) : <newline> <indent> self . _session = None <newline> xenapi_session . apply_session_helpers ( self ) <newline> <dedent> def pool_get_default_SR ( self , _1 , pool_ref ) : <newline> <indent> return _db_content [ 'pool' ] . values ( ) [ 0 ] [ 'default-SR' ] <newline> <dedent> def VBD_insert ( self , _1 , vbd_ref , vdi_ref ) : <newline> <indent> vbd_rec = get_record ( 'VBD' , vbd_ref ) <newline> get_record ( 'VDI' , vdi_ref ) <newline> vbd_rec [ 'empty' ] = False <newline> vbd_rec [ 'VDI' ] = vdi_ref <newline> <dedent> def VBD_plug ( self , _1 , ref ) : <newline> <indent> rec = get_record ( 'VBD' , ref ) <newline> if rec [ 'currently_attached' ] : <newline> <indent> raise Failure ( [ 'DEVICE_ALREADY_ATTACHED' , ref ] ) <newline> <dedent> rec [ 'currently_attached' ] = True <newline> rec [ 'device' ] = rec [ 'userdevice' ] <newline> <dedent> def VBD_unplug ( self , _1 , ref ) : <newline> <indent> rec = get_record ( 'VBD' , ref ) <newline> if not rec [ 'currently_attached' ] : <newline> <indent> raise Failure ( [ 'DEVICE_ALREADY_DETACHED' , ref ] ) <newline> <dedent> rec [ 'currently_attached' ] = False <newline> rec [ 'device' ] = '' <newline> <dedent> def VBD_add_to_other_config ( self , _1 , vbd_ref , key , value ) : <newline> <indent> db_ref = _db_content [ 'VBD' ] [ vbd_ref ] <newline> if 'other_config' not in db_ref : <newline> <indent> db_ref [ 'other_config' ] = { } <newline> <dedent> if key in db_ref [ 'other_config' ] : <newline> <indent> raise Failure ( [ 'MAP_DUPLICATE_KEY' , 'VBD' , 'other_config' , vbd_ref , key ] ) <newline> <dedent> db_ref [ 'other_config' ] [ key ] = value <newline> <dedent> def VBD_get_other_config ( self , _1 , vbd_ref ) : <newline> <indent> db_ref = _db_content [ 'VBD' ] [ vbd_ref ] <newline> if 'other_config' not in db_ref : <newline> <indent> return { } <newline> <dedent> return db_ref [ 'other_config' ] <newline> <dedent> def PBD_create ( self , _1 , pbd_rec ) : <newline> <indent> pbd_ref = _create_object ( 'PBD' , pbd_rec ) <newline> _db_content [ 'PBD' ] [ pbd_ref ] [ 'currently_attached' ] = False <newline> return pbd_ref <newline> <dedent> def PBD_plug ( self , _1 , pbd_ref ) : <newline> <indent> rec = get_record ( 'PBD' , pbd_ref ) <newline> if rec [ 'currently_attached' ] : <newline> <indent> raise Failure ( [ 'DEVICE_ALREADY_ATTACHED' , rec ] ) <newline> <dedent> rec [ 'currently_attached' ] = True <newline> sr_ref = rec [ 'SR' ] <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'PBDs' ] = [ pbd_ref ] <newline> <dedent> def PBD_unplug ( self , _1 , pbd_ref ) : <newline> <indent> rec = get_record ( 'PBD' , pbd_ref ) <newline> if not rec [ 'currently_attached' ] : <newline> <indent> raise Failure ( [ 'DEVICE_ALREADY_DETACHED' , rec ] ) <newline> <dedent> rec [ 'currently_attached' ] = False <newline> sr_ref = rec [ 'SR' ] <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'PBDs' ] . remove ( pbd_ref ) <newline> <dedent> def SR_introduce ( self , _1 , sr_uuid , label , desc , type , content_type , shared , sm_config ) : <newline> <indent> ref = None <newline> rec = None <newline> for ref , rec in _db_content [ 'SR' ] . iteritems ( ) : <newline> <indent> if rec . get ( 'uuid' ) == sr_uuid : <newline>  # ▁ make ▁ forgotten ▁ = ▁ 0 ▁ and ▁ return ▁ ref <encdom> <indent> _db_content [ 'SR' ] [ ref ] [ 'forgotten' ] = 0 <newline> return ref <newline>  # ▁ SR ▁ not ▁ found ▁ in ▁ db, ▁ so ▁ we ▁ create ▁ one <encdom> <dedent> <dedent> params = { 'sr_uuid' : sr_uuid , 'label' : label , 'desc' : desc , 'type' : type , 'content_type' : content_type , 'shared' : shared , 'sm_config' : sm_config } <newline> sr_ref = _create_object ( 'SR' , params ) <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'uuid' ] = sr_uuid <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'forgotten' ] = 0 <newline> vdi_per_lun = False <newline> if type == 'iscsi' : <newline>  # ▁ Just ▁ to ▁ be ▁ clear <encdom> <indent> vdi_per_lun = True <newline> <dedent> if vdi_per_lun : <newline>  # ▁ we ▁ need ▁ to ▁ create ▁ a ▁ vdi ▁ because ▁ this ▁ introduce <encdom>  # ▁ is ▁ likely ▁ meant ▁ for ▁ a ▁ single ▁ vdi <encdom> <indent> vdi_ref = create_vdi ( '' , sr_ref ) <newline> _db_content [ 'SR' ] [ sr_ref ] [ 'VDIs' ] = [ vdi_ref ] <newline> _db_content [ 'VDI' ] [ vdi_ref ] [ 'SR' ] = sr_ref <newline> <dedent> return sr_ref <newline> <dedent> def SR_forget ( self , _1 , sr_ref ) : <newline> <indent> _db_content [ 'SR' ] [ sr_ref ] [ 'forgotten' ] = 1 <newline> <dedent> def SR_scan ( self , _1 , sr_ref ) : <newline> <indent> return <newline> <dedent> def VM_get_xenstore_data ( self , _1 , vm_ref ) : <newline> <indent> return _db_content [ 'VM' ] [ vm_ref ] . get ( 'xenstore_data' , { } ) <newline> <dedent> def VM_remove_from_xenstore_data ( self , _1 , vm_ref , key ) : <newline> <indent> db_ref = _db_content [ 'VM' ] [ vm_ref ] <newline> if 'xenstore_data' not in db_ref : <newline> <indent> return <newline> <dedent> if key in db_ref [ 'xenstore_data' ] : <newline> <indent> del db_ref [ 'xenstore_data' ] [ key ] <newline> <dedent> <dedent> def VM_add_to_xenstore_data ( self , _1 , vm_ref , key , value ) : <newline> <indent> db_ref = _db_content [ 'VM' ] [ vm_ref ] <newline> if 'xenstore_data' not in db_ref : <newline> <indent> db_ref [ 'xenstore_data' ] = { } <newline> <dedent> db_ref [ 'xenstore_data' ] [ key ] = value <newline> <dedent> def VM_pool_migrate ( self , _1 , vm_ref , host_ref , options ) : <newline> <indent> pass <newline> <dedent> def VDI_remove_from_other_config ( self , _1 , vdi_ref , key ) : <newline> <indent> db_ref = _db_content [ 'VDI' ] [ vdi_ref ] <newline> if 'other_config' not in db_ref : <newline> <indent> return <newline> <dedent> if key in db_ref [ 'other_config' ] : <newline> <indent> del db_ref [ 'other_config' ] [ key ] <newline> <dedent> <dedent> def VDI_add_to_other_config ( self , _1 , vdi_ref , key , value ) : <newline> <indent> db_ref = _db_content [ 'VDI' ] [ vdi_ref ] <newline> if 'other_config' not in db_ref : <newline> <indent> db_ref [ 'other_config' ] = { } <newline> <dedent> if key in db_ref [ 'other_config' ] : <newline> <indent> raise Failure ( [ 'MAP_DUPLICATE_KEY' , 'VDI' , 'other_config' , vdi_ref , key ] ) <newline> <dedent> db_ref [ 'other_config' ] [ key ] = value <newline> <dedent> def VDI_copy ( self , _1 , vdi_to_copy_ref , sr_ref ) : <newline> <indent> db_ref = _db_content [ 'VDI' ] [ vdi_to_copy_ref ] <newline> name_label = db_ref [ 'name_label' ] <newline> read_only = db_ref [ 'read_only' ] <newline> sharable = db_ref [ 'sharable' ] <newline> other_config = db_ref [ 'other_config' ] . copy ( ) <newline> return create_vdi ( name_label , sr_ref , sharable = sharable , read_only = read_only , other_config = other_config ) <newline> <dedent> def VDI_clone ( self , _1 , vdi_to_clone_ref ) : <newline> <indent> db_ref = _db_content [ 'VDI' ] [ vdi_to_clone_ref ] <newline> sr_ref = db_ref [ 'SR' ] <newline> return self . VDI_copy ( _1 , vdi_to_clone_ref , sr_ref ) <newline> <dedent> def host_compute_free_memory ( self , _1 , ref ) : <newline>  # ▁ Always ▁ return ▁ 12GB ▁ available <encdom> <indent> return 12 * units . Gi <newline> <dedent> def _plugin_agent_version ( self , method , args ) : <newline> <indent> return as_json ( returncode = '0' , message = '1.0\\ \n ' ) <newline> <dedent> def _plugin_agent_key_init ( self , method , args ) : <newline> <indent> return as_json ( returncode = 'D0' , message = '1' ) <newline> <dedent> def _plugin_agent_password ( self , method , args ) : <newline> <indent> return as_json ( returncode = '0' , message = 'success' ) <newline> <dedent> def _plugin_agent_inject_file ( self , method , args ) : <newline> <indent> return as_json ( returncode = '0' , message = 'success' ) <newline> <dedent> def _plugin_agent_resetnetwork ( self , method , args ) : <newline> <indent> return as_json ( returncode = '0' , message = 'success' ) <newline> <dedent> def _plugin_agent_agentupdate ( self , method , args ) : <newline> <indent> url = args [ "url" ] <newline> md5 = args [ "md5sum" ] <newline> message = "success ▁ with ▁ %(url)s ▁ and ▁ hash:%(md5)s" % dict ( url = url , md5 = md5 ) <newline> return as_json ( returncode = '0' , message = message ) <newline> <dedent> def _plugin_noop ( self , method , args ) : <newline> <indent> return '' <newline> <dedent> def _plugin_pickle_noop ( self , method , args ) : <newline> <indent> return pickle . dumps ( None ) <newline> <dedent> def _plugin_migration_transfer_vhd ( self , method , args ) : <newline> <indent> kwargs = pickle . loads ( args [ 'params' ] ) [ 'kwargs' ] <newline> vdi_ref = self . xenapi_request ( 'VDI.get_by_uuid' , ( kwargs [ 'vdi_uuid' ] , ) ) <newline> assert vdi_ref <newline> return pickle . dumps ( None ) <newline> <dedent> _plugin_glance_upload_vhd = _plugin_pickle_noop <newline> _plugin_kernel_copy_vdi = _plugin_noop <newline> _plugin_kernel_create_kernel_ramdisk = _plugin_noop <newline> _plugin_kernel_remove_kernel_ramdisk = _plugin_noop <newline> _plugin_migration_move_vhds_into_sr = _plugin_noop <newline> def _plugin_xenhost_host_data ( self , method , args ) : <newline> <indent> return jsonutils . dumps ( { 'host_memory' : { 'total' : 10 , 'overhead' : 20 , 'free' : 30 , 'free-computed' : 40 } , 'host_hostname' : 'fake-xenhost' , 'host_cpu_info' : { 'cpu_count' : 50 } , } ) <newline> <dedent> def _plugin_poweraction ( self , method , args ) : <newline> <indent> return jsonutils . dumps ( { "power_action" : method [ 5 : ] } ) <newline> <dedent> _plugin_xenhost_host_reboot = _plugin_poweraction <newline> _plugin_xenhost_host_startup = _plugin_poweraction <newline> _plugin_xenhost_host_shutdown = _plugin_poweraction <newline> def _plugin_xenhost_set_host_enabled ( self , method , args ) : <newline> <indent> enabled = 'enabled' if args . get ( 'enabled' ) == 'true' else 'disabled' <newline> return jsonutils . dumps ( { "status" : enabled } ) <newline> <dedent> def _plugin_xenhost_host_uptime ( self , method , args ) : <newline> <indent> return jsonutils . dumps ( { "uptime" : "fake ▁ uptime" } ) <newline> <dedent> def _plugin_xenhost_get_pci_device_details ( self , method , args ) : <newline> <indent>  """ Simulate ▁ the ▁ ouput ▁ of ▁ three ▁ pci ▁ devices. <strnewline> <strnewline> ▁ Both ▁ of ▁ those ▁ devices ▁ are ▁ available ▁ for ▁ pci ▁ passtrough ▁ but <strnewline> ▁ only ▁ one ▁ will ▁ match ▁ with ▁ the ▁ pci ▁ whitelist ▁ used ▁ in ▁ the <strnewline> ▁ method ▁ test_pci_passthrough_devices_*(). <strnewline> ▁ Return ▁ a ▁ single ▁ list. <strnewline> <strnewline> ▁ """  <newline>  # ▁ Driver ▁ is ▁ not ▁ pciback <encdom> dev_bad1 = [ "Slot:\t0000:86:10.0" , "Class:\t0604" , "Vendor:\t10b5" , "Device:\t8747" , "Rev:\tba" , "Driver:\tpcieport" , " \n " ] <newline>  # ▁ Driver ▁ is ▁ pciback ▁ but ▁ vendor ▁ and ▁ device ▁ are ▁ bad <encdom> dev_bad2 = [ "Slot:\t0000:88:00.0" , "Class:\t0300" , "Vendor:\t0bad" , "Device:\tcafe" , "SVendor:\t10de" , "SDevice:\t100d" , "Rev:\ta1" , "Driver:\tpciback" , " \n " ] <newline>  # ▁ Driver ▁ is ▁ pciback ▁ and ▁ vendor, ▁ device ▁ are ▁ used ▁ for ▁ matching <encdom> dev_good = [ "Slot:\t0000:87:00.0" , "Class:\t0300" , "Vendor:\t10de" , "Device:\t11bf" , "SVendor:\t10de" , "SDevice:\t100d" , "Rev:\ta1" , "Driver:\tpciback" , " \n " ] <newline> lspci_output = " \n " . join ( dev_bad1 + dev_bad2 + dev_good ) <newline> return pickle . dumps ( lspci_output ) <newline> <dedent> def _plugin_xenhost_get_pci_type ( self , method , args ) : <newline> <indent> return pickle . dumps ( "type-PCI" ) <newline> <dedent> def _plugin_console_get_console_log ( self , method , args ) : <newline> <indent> dom_id = args [ "dom_id" ] <newline> if dom_id == 0 : <newline> <indent> raise Failure ( 'Guest ▁ does ▁ not ▁ have ▁ a ▁ console' ) <newline> <dedent> return base64 . b64encode ( zlib . compress ( "dom_id: ▁ %s" % dom_id ) ) <newline> <dedent> def _plugin_nova_plugin_version_get_version ( self , method , args ) : <newline> <indent> return pickle . dumps ( "1.2" ) <newline> <dedent> def _plugin_xenhost_query_gc ( self , method , args ) : <newline> <indent> return pickle . dumps ( "False" ) <newline> <dedent> def host_call_plugin ( self , _1 , _2 , plugin , method , args ) : <newline> <indent> func = getattr ( self , '_plugin_%s_%s' % ( plugin , method ) , None ) <newline> if not func : <newline> <indent> raise Exception ( 'No ▁ simulation ▁ in ▁ host_call_plugin ▁ for ▁ %s,%s' % ( plugin , method ) ) <newline> <dedent> return func ( method , args ) <newline> <dedent> def VDI_get_virtual_size ( self , * args ) : <newline> <indent> return 1 * units . Gi <newline> <dedent> def VDI_resize_online ( self , * args ) : <newline> <indent> return 'derp' <newline> <dedent> VDI_resize = VDI_resize_online <newline> def _VM_reboot ( self , session , vm_ref ) : <newline> <indent> db_ref = _db_content [ 'VM' ] [ vm_ref ] <newline> if db_ref [ 'power_state' ] != 'Running' : <newline> <indent> raise Failure ( [ 'VM_BAD_POWER_STATE' , 'fake-opaque-ref' , db_ref [ 'power_state' ] . lower ( ) , 'halted' ] ) <newline> <dedent> db_ref [ 'power_state' ] = 'Running' <newline> db_ref [ 'domid' ] = random . randrange ( 1 , 1 << 16 ) <newline> <dedent> def VM_clean_reboot ( self , session , vm_ref ) : <newline> <indent> return self . _VM_reboot ( session , vm_ref ) <newline> <dedent> def VM_hard_reboot ( self , session , vm_ref ) : <newline> <indent> return self . _VM_reboot ( session , vm_ref ) <newline> <dedent> def VM_hard_shutdown ( self , session , vm_ref ) : <newline> <indent> db_ref = _db_content [ 'VM' ] [ vm_ref ] <newline> db_ref [ 'power_state' ] = 'Halted' <newline> db_ref [ 'domid' ] = - 1 <newline> <dedent> VM_clean_shutdown = VM_hard_shutdown <newline> def VM_suspend ( self , session , vm_ref ) : <newline> <indent> db_ref = _db_content [ 'VM' ] [ vm_ref ] <newline> db_ref [ 'power_state' ] = 'Suspended' <newline> <dedent> def VM_pause ( self , session , vm_ref ) : <newline> <indent> db_ref = _db_content [ 'VM' ] [ vm_ref ] <newline> db_ref [ 'power_state' ] = 'Paused' <newline> <dedent> def pool_eject ( self , session , host_ref ) : <newline> <indent> pass <newline> <dedent> def pool_join ( self , session , hostname , username , password ) : <newline> <indent> pass <newline> <dedent> def pool_set_name_label ( self , session , pool_ref , name ) : <newline> <indent> pass <newline> <dedent> def host_migrate_receive ( self , session , destref , nwref , options ) : <newline> <indent> return "fake_migrate_data" <newline> <dedent> def VM_assert_can_migrate ( self , session , vmref , migrate_data , live , vdi_map , vif_map , options ) : <newline> <indent> pass <newline> <dedent> def VM_migrate_send ( self , session , mref , migrate_data , live , vdi_map , vif_map , options ) : <newline> <indent> pass <newline> <dedent> def VM_remove_from_blocked_operations ( self , session , vm_ref , key ) : <newline>  # ▁ operation ▁ is ▁ idempotent, ▁ XenServer ▁ doesn't ▁ care ▁ if ▁ the ▁ key ▁ exists <encdom> <indent> _db_content [ 'VM' ] [ vm_ref ] [ 'blocked_operations' ] . pop ( key , None ) <newline> <dedent> def xenapi_request ( self , methodname , params ) : <newline> <indent> if methodname . startswith ( 'login' ) : <newline> <indent> self . _login ( methodname , params ) <newline> return None <newline> <dedent> elif methodname == 'logout' or methodname == 'session.logout' : <newline> <indent> self . _logout ( ) <newline> return None <newline> <dedent> else : <newline> <indent> full_params = ( self . _session , ) + params <newline> meth = getattr ( self , methodname , None ) <newline> if meth is None : <newline> <indent> LOG . debug ( 'Raising ▁ NotImplemented' ) <newline> raise NotImplementedError ( _ ( 'xenapi.fake ▁ does ▁ not ▁ have ▁ an ▁ implementation ▁ for ▁ %s' ) % methodname ) <newline> <dedent> return meth ( * full_params ) <newline> <dedent> <dedent> def _login ( self , method , params ) : <newline> <indent> self . _session = str ( uuid . uuid4 ( ) ) <newline> _session_info = { 'uuid' : str ( uuid . uuid4 ( ) ) , 'this_host' : _db_content [ 'host' ] . keys ( ) [ 0 ] } <newline> _db_content [ 'session' ] [ self . _session ] = _session_info <newline> <dedent> def _logout ( self ) : <newline> <indent> s = self . _session <newline> self . _session = None <newline> if s not in _db_content [ 'session' ] : <newline> <indent> raise exception . NovaException ( "Logging ▁ out ▁ a ▁ session ▁ that ▁ is ▁ invalid ▁ or ▁ already ▁ logged ▁ " "out: ▁ %s" % s ) <newline> <dedent> del _db_content [ 'session' ] [ s ] <newline> <dedent> def __getattr__ ( self , name ) : <newline> <indent> if name == 'handle' : <newline> <indent> return self . _session <newline> <dedent> elif name == 'xenapi' : <newline> <indent> return _Dispatcher ( self . xenapi_request , None ) <newline> <dedent> elif name . startswith ( 'login' ) or name . startswith ( 'slave_local' ) : <newline> <indent> return lambda * params : self . _login ( name , params ) <newline> <dedent> elif name . startswith ( 'Async' ) : <newline> <indent> return lambda * params : self . _async ( name , params ) <newline> <dedent> elif '.' in name : <newline> <indent> impl = getattr ( self , name . replace ( '.' , '_' ) ) <newline> if impl is not None : <newline> <indent> def callit ( * params ) : <newline> <indent> LOG . debug ( 'Calling ▁ %(name)s ▁ %(impl)s' , { 'name' : name , 'impl' : impl } ) <newline> self . _check_session ( params ) <newline> return impl ( * params ) <newline> <dedent> return callit <newline> <dedent> <dedent> if self . _is_gettersetter ( name , True ) : <newline> <indent> LOG . debug ( 'Calling ▁ getter ▁ %s' , name ) <newline> return lambda * params : self . _getter ( name , params ) <newline> <dedent> elif self . _is_gettersetter ( name , False ) : <newline> <indent> LOG . debug ( 'Calling ▁ setter ▁ %s' , name ) <newline> return lambda * params : self . _setter ( name , params ) <newline> <dedent> elif self . _is_create ( name ) : <newline> <indent> return lambda * params : self . _create ( name , params ) <newline> <dedent> elif self . _is_destroy ( name ) : <newline> <indent> return lambda * params : self . _destroy ( name , params ) <newline> <dedent> elif name == 'XenAPI' : <newline> <indent> return FakeXenAPI ( ) <newline> <dedent> else : <newline> <indent> return None <newline> <dedent> <dedent> def _is_gettersetter ( self , name , getter ) : <newline> <indent> bits = name . split ( '.' ) <newline> return ( len ( bits ) == 2 and bits [ 0 ] in _CLASSES and bits [ 1 ] . startswith ( getter and 'get_' or 'set_' ) ) <newline> <dedent> def _is_create ( self , name ) : <newline> <indent> return self . _is_method ( name , 'create' ) <newline> <dedent> def _is_destroy ( self , name ) : <newline> <indent> return self . _is_method ( name , 'destroy' ) <newline> <dedent> def _is_method ( self , name , meth ) : <newline> <indent> bits = name . split ( '.' ) <newline> return ( len ( bits ) == 2 and bits [ 0 ] in _CLASSES and bits [ 1 ] == meth ) <newline> <dedent> def _getter ( self , name , params ) : <newline> <indent> self . _check_session ( params ) <newline> ( cls , func ) = name . split ( '.' ) <newline> if func == 'get_all' : <newline> <indent> self . _check_arg_count ( params , 1 ) <newline> return get_all ( cls ) <newline> <dedent> if func == 'get_all_records' : <newline> <indent> self . _check_arg_count ( params , 1 ) <newline> return get_all_records ( cls ) <newline> <dedent> if func == 'get_all_records_where' : <newline> <indent> self . _check_arg_count ( params , 2 ) <newline> return get_all_records_where ( cls , params [ 1 ] ) <newline> <dedent> if func == 'get_record' : <newline> <indent> self . _check_arg_count ( params , 2 ) <newline> return get_record ( cls , params [ 1 ] ) <newline> <dedent> if func in ( 'get_by_name_label' , 'get_by_uuid' ) : <newline> <indent> self . _check_arg_count ( params , 2 ) <newline> return_singleton = ( func == 'get_by_uuid' ) <newline> return self . _get_by_field ( _db_content [ cls ] , func [ len ( 'get_by_' ) : ] , params [ 1 ] , return_singleton = return_singleton ) <newline> <dedent> if len ( params ) == 2 : <newline> <indent> field = func [ len ( 'get_' ) : ] <newline> ref = params [ 1 ] <newline> if ( ref in _db_content [ cls ] ) : <newline> <indent> if ( field in _db_content [ cls ] [ ref ] ) : <newline> <indent> return _db_content [ cls ] [ ref ] [ field ] <newline> <dedent> <dedent> else : <newline> <indent> raise Failure ( [ 'HANDLE_INVALID' , cls , ref ] ) <newline> <dedent> <dedent> LOG . debug ( 'Raising ▁ NotImplemented' ) <newline> raise NotImplementedError ( _ ( 'xenapi.fake ▁ does ▁ not ▁ have ▁ an ▁ implementation ▁ for ▁ %s ▁ or ▁ it ▁ has ▁ ' 'been ▁ called ▁ with ▁ the ▁ wrong ▁ number ▁ of ▁ arguments' ) % name ) <newline> <dedent> def _setter ( self , name , params ) : <newline> <indent> self . _check_session ( params ) <newline> ( cls , func ) = name . split ( '.' ) <newline> if len ( params ) == 3 : <newline> <indent> field = func [ len ( 'set_' ) : ] <newline> ref = params [ 1 ] <newline> val = params [ 2 ] <newline> if ( ref in _db_content [ cls ] and field in _db_content [ cls ] [ ref ] ) : <newline> <indent> _db_content [ cls ] [ ref ] [ field ] = val <newline> return <newline> <dedent> <dedent> LOG . debug ( 'Raising ▁ NotImplemented' ) <newline> raise NotImplementedError ( 'xenapi.fake ▁ does ▁ not ▁ have ▁ an ▁ implementation ▁ for ▁ %s ▁ or ▁ it ▁ has ▁ ' 'been ▁ called ▁ with ▁ the ▁ wrong ▁ number ▁ of ▁ arguments ▁ or ▁ the ▁ database ▁ ' 'is ▁ missing ▁ that ▁ field' % name ) <newline> <dedent> def _create ( self , name , params ) : <newline> <indent> self . _check_session ( params ) <newline> is_sr_create = name == 'SR.create' <newline> is_vlan_create = name == 'VLAN.create' <newline>  # ▁ Storage ▁ Repositories ▁ have ▁ a ▁ different ▁ API <encdom> expected = is_sr_create and 10 or is_vlan_create and 4 or 2 <newline> self . _check_arg_count ( params , expected ) <newline> ( cls , _ ) = name . split ( '.' ) <newline> ref = ( is_sr_create and _create_sr ( cls , params ) or is_vlan_create and _create_vlan ( params [ 1 ] , params [ 2 ] , params [ 3 ] ) or _create_object ( cls , params [ 1 ] ) ) <newline>  # ▁ Call ▁ hook ▁ to ▁ provide ▁ any ▁ fixups ▁ needed ▁ (ex. ▁ creating ▁ backrefs) <encdom> after_hook = 'after_%s_create' % cls <newline> if after_hook in globals ( ) : <newline> <indent> globals ( ) [ after_hook ] ( ref , params [ 1 ] ) <newline> <dedent> obj = get_record ( cls , ref ) <newline>  # ▁ Add ▁ RO ▁ fields <encdom> if cls == 'VM' : <newline> <indent> obj [ 'power_state' ] = 'Halted' <newline> <dedent> return ref <newline> <dedent> def _destroy ( self , name , params ) : <newline> <indent> self . _check_session ( params ) <newline> self . _check_arg_count ( params , 2 ) <newline> table = name . split ( '.' ) [ 0 ] <newline> ref = params [ 1 ] <newline> if ref not in _db_content [ table ] : <newline> <indent> raise Failure ( [ 'HANDLE_INVALID' , table , ref ] ) <newline>  # ▁ Call ▁ destroy ▁ function ▁ (if ▁ exists) <encdom> <dedent> destroy_func = globals ( ) . get ( 'destroy_%s' % table . lower ( ) ) <newline> if destroy_func : <newline> <indent> destroy_func ( ref ) <newline> <dedent> else : <newline> <indent> del _db_content [ table ] [ ref ] <newline> <dedent> <dedent> def _async ( self , name , params ) : <newline> <indent> task_ref = create_task ( name ) <newline> task = _db_content [ 'task' ] [ task_ref ] <newline> func = name [ len ( 'Async.' ) : ] <newline> try : <newline> <indent> result = self . xenapi_request ( func , params [ 1 : ] ) <newline> if result : <newline> <indent> result = as_value ( result ) <newline> <dedent> task [ 'result' ] = result <newline> task [ 'status' ] = 'success' <newline> <dedent> except Failure as exc : <newline> <indent> task [ 'error_info' ] = exc . details <newline> task [ 'status' ] = 'failed' <newline> <dedent> task [ 'finished' ] = timeutils . utcnow ( ) <newline> return task_ref <newline> <dedent> def _check_session ( self , params ) : <newline> <indent> if ( self . _session is None or self . _session not in _db_content [ 'session' ] ) : <newline> <indent> raise Failure ( [ 'HANDLE_INVALID' , 'session' , self . _session ] ) <newline> <dedent> if len ( params ) == 0 or params [ 0 ] != self . _session : <newline> <indent> LOG . debug ( 'Raising ▁ NotImplemented' ) <newline> raise NotImplementedError ( 'Call ▁ to ▁ XenAPI ▁ without ▁ using ▁ .xenapi' ) <newline> <dedent> <dedent> def _check_arg_count ( self , params , expected ) : <newline> <indent> actual = len ( params ) <newline> if actual != expected : <newline> <indent> raise Failure ( [ 'MESSAGE_PARAMETER_COUNT_MISMATCH' , expected , actual ] ) <newline> <dedent> <dedent> def _get_by_field ( self , recs , k , v , return_singleton ) : <newline> <indent> result = [ ] <newline> for ref , rec in recs . iteritems ( ) : <newline> <indent> if rec . get ( k ) == v : <newline> <indent> result . append ( ref ) <newline> <dedent> <dedent> if return_singleton : <newline> <indent> try : <newline> <indent> return result [ 0 ] <newline> <dedent> except IndexError : <newline> <indent> raise Failure ( [ 'UUID_INVALID' , v , result , recs , k ] ) <newline> <dedent> <dedent> return result <newline> <dedent> <dedent> class FakeXenAPI ( object ) : <newline> <indent> def __init__ ( self ) : <newline> <indent> self . Failure = Failure <newline>  # ▁ Based ▁ upon ▁ _Method ▁ from ▁ xmlrpclib. <encdom> <dedent> <dedent> class _Dispatcher : <newline> <indent> def __init__ ( self , send , name ) : <newline> <indent> self . __send = send <newline> self . __name = name <newline> <dedent> def __repr__ ( self ) : <newline> <indent> if self . __name : <newline> <indent> return '<xenapi.fake._Dispatcher ▁ for ▁ %s>' % self . __name <newline> <dedent> else : <newline> <indent> return '<xenapi.fake._Dispatcher>' <newline> <dedent> <dedent> def __getattr__ ( self , name ) : <newline> <indent> if self . __name is None : <newline> <indent> return _Dispatcher ( self . __send , name ) <newline> <dedent> else : <newline> <indent> return _Dispatcher ( self . __send , "%s.%s" % ( self . __name , name ) ) <newline> <dedent> <dedent> def __call__ ( self , * args ) : <newline> <indent> return self . __send ( self . __name , args ) <newline> <dedent> <dedent>
 # !/usr/bin/python <encdom>  ''' <strnewline> ▁ Jsunpackn ▁ - ▁ A ▁ generic ▁ JavaScript ▁ Unpacker ▁ Network ▁ Edition <strnewline> ▁ Copyright ▁ (C) ▁ 2010 ▁ Blake ▁ Hartstein <strnewline> ▁ http://jsunpack.jeek.org/ <strnewline> <strnewline> ▁ This ▁ program ▁ is ▁ free ▁ software; ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or ▁ modify <strnewline> ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by <strnewline> ▁ the ▁ Free ▁ Software ▁ Foundation; ▁ either ▁ version ▁ 2 ▁ of ▁ the ▁ License, ▁ or <strnewline> ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <strnewline> <strnewline> ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <strnewline> ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <strnewline> ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the <strnewline> ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <strnewline> <strnewline> ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ along <strnewline> ▁ with ▁ this ▁ program; ▁ if ▁ not, ▁ write ▁ to ▁ the ▁ Free ▁ Software ▁ Foundation, ▁ Inc., <strnewline> ▁ 51 ▁ Franklin ▁ Street, ▁ Fifth ▁ Floor, ▁ Boston, ▁ MA ▁ 02110-1301 ▁ USA. <strnewline> '''  <newline> from hashlib import sha1 <newline> import datetime <newline> import socket <newline> import jsunpackn <newline>  # ▁ Error ▁ Reporting ▁ to ▁ /tmp <encdom> socket . setdefaulttimeout ( 10 ) <newline> class cmdline_filler : <newline> <indent> options = { 'timeout' : 30 , 'redoevaltime' : 1 , 'maxruntime' : 0 , 'urlfetch' : '' , 'configfile' : 'options.config' , 'saveallfiles' : True ,  # ▁ for ▁ pcaps? <encdom> 'saveallexes' : False , 'quiet' : True , 'verbose' : True , 'veryverbose' : True , 'graphfile' : '' , 'debug' : False , 'active' : True , 'interface' : '' , 'nojs' : False , 'log_ips' : './maliciousips.txt' , 'pre' : './pre.js' , 'post' : './post.js' , 'htmlparse' : './htmlparse.config' , 'fasteval' : False , 'proxy' : '' , 'currentproxy' : '' , } <newline> def __init__ ( self , inhash ) : <newline> <indent> self . tmpdir = '/tmp'  # ▁ these ▁ temporary ▁ files ▁ are ▁ necessary ▁ for ▁ decoding, ▁ but ▁ you ▁ can ▁ use ▁ any ▁ path ▁ and ▁ they ▁ will ▁ be ▁ deleted ▁ afterwards <encdom> <newline> self . logdir = self . outdir = ''  # ▁ an ▁ empty ▁ storage ▁ filepath ▁ means ▁ no ▁ directory ▁ of ▁ output ▁ files ▁ will ▁ be ▁ created <encdom> <newline> self . decoded = ''  # NO ▁ decoding ▁ logfile, ▁ otherwise ▁ = ▁ self.outdir ▁ + ▁'/decoded.log' <encdom> <newline> for item in self . options : <newline> <indent> setattr ( self , item , self . options [ item ] ) <newline>  # Feel ▁ free ▁ to ▁ hard ▁ code ▁ all ▁ your ▁ files ▁"rules", ▁"rules.ascii", ▁ and ▁"htmlparse.config" ▁ in ▁ this ▁ file ▁ instead, ▁ only ▁ problem ▁ is ▁ updating ▁ them <encdom> <dedent> fin = open ( 'rules' , 'r' ) <newline> if fin : <newline> <indent> self . rules = fin . read ( ) <newline> fin . close ( ) <newline> <dedent> fin = open ( 'rules.ascii' , 'r' ) <newline> if fin : <newline> <indent> self . rulesAscii = fin . read ( ) <newline> fin . close ( ) <newline> <dedent> if self . options [ 'htmlparse' ] : <newline> <indent> fin = open ( self . options [ 'htmlparse' ] , 'r' ) <newline> self . htmlparseconfig = fin . read ( ) <newline> fin . close ( ) <newline> <dedent> <dedent> <dedent> def main ( userdata ) : <newline> <indent>  ''' userdata ▁ contains ▁ the ▁ javascript, ▁ html, ▁ or ▁ pdf ▁ data ▁ to ▁ decode '''  <newline>  ''' if ▁ you'd ▁ like ▁ to ▁ do ▁ other ▁ things ▁ with ▁ the ▁ results, ▁ then ▁ modify ▁ this ▁ function '''  <newline> HASH = sha1 ( str ( datetime . datetime . now ( ) ) + userdata ) . hexdigest ( ) <newline> options = cmdline_filler ( HASH ) <newline> root_of_tree = ''  # ▁ This ▁ can ▁ be ▁ empty ▁ but ▁ its ▁ sometimes ▁ useful ▁ to ▁ specify ▁ a ▁ filename ▁ here <encdom> <newline> url_or_name = '/'  # ▁ This ▁ can ▁ also ▁ be ▁ empty ▁ but ▁ if ▁ you ▁ have ▁ the ▁ URL, ▁ you'd ▁ want ▁ to ▁ set ▁ that ▁ here <encdom> <newline> prevRooturl = { }  # ▁ This ▁ can ▁ also ▁ be ▁ empty ▁ but ▁ if ▁ you ▁ want ▁ to ▁ decode ▁ something ▁ with ▁ more ▁ context ▁ its ▁ useful ▁ to ▁ keep ▁ state ▁ <encdom> <newline> js = jsunpackn . jsunpack ( root_of_tree , [ url_or_name , userdata , root_of_tree ] , options , prevRooturl ) <newline> for url in js . rooturl :  # ▁ set ▁ all ▁ the ▁ state ▁ variables ▁ for ▁ printing <encdom> <newline> <indent> js . rooturl [ url ] . seen = { } <newline> <dedent> results = '' <newline> for url in [ js . start ] :  # recursive <encdom> <newline> <indent> print 'The ▁ key ▁ %s ▁ has ▁ the ▁ following ▁ output ▁ in ▁ recursive ▁ mode' % ( url ) <newline> results = js . rooturl [ url ] . tostring ( '' , True ) [ 0 ] + ' \n ' <newline> print results <newline> <dedent> print 'Note ▁ that ▁ none ▁ of ▁ the ▁ files ▁ are ▁ actually ▁ created ▁ since ▁ self.outdir ▁ is ▁ empty.' <newline> print 'Instead, ▁ you ▁ could ▁ go ▁ through ▁ each ▁ url ▁ and ▁ look ▁ at ▁ the ▁ decodings ▁ that ▁ it ▁ creates' <newline> for url in js . rooturl : <newline> <indent> print 'Looking ▁ at ▁ key ▁ %s, ▁ has ▁ %d ▁ files ▁ and ▁ %d ▁ messages, ▁ that ▁ follow:' % ( url , len ( js . rooturl [ url ] . files ) , len ( js . rooturl [ url ] . msg ) ) <newline> for type , hash , data in js . rooturl [ url ] . files : <newline> <indent> print 'file ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type=%s, ▁ hash=%s, ▁ data=%d ▁ bytes' % ( type , hash , len ( data ) ) <newline> <dedent> for printable , impact , msg in js . rooturl [ url ] . msg : <newline> <indent> print 'output ▁ message ▁ ▁ ▁ ▁ printable=%d, ▁ impact=%d, ▁ msg=%s' % ( printable , impact , msg ) <newline> <dedent> <dedent> <dedent> if __name__ == "__main__" : <newline> <indent> main ( 'eval("var ▁ a=123;");' ) <newline> <dedent>
import numpy as np <newline> import numpy . random as npr <newline> import kayak <newline> from . import * <newline> def test_identity ( ) : <newline> <indent> npr . seed ( 1 ) <newline> np_A = npr . randn ( 6 , 7 ) <newline> A = kayak . Parameter ( np_A ) <newline> B = kayak . Identity ( A ) <newline> assert np . all ( close_float ( B . value , np_A ) ) <newline> assert np . all ( close_float ( B . grad ( A ) , np . ones ( ( 6 , 7 ) ) ) ) <newline> <dedent>
 # ▁ Copyright ▁ (C) ▁ 2009 ▁ Google ▁ Inc. ▁ All ▁ rights ▁ reserved. <encdom>  # ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms, ▁ with ▁ or ▁ without <encdom>  # ▁ modification, ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are <encdom>  # ▁ met: <encdom>  # ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright <encdom>  # ▁ notice, ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer. <encdom>  # ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above <encdom>  # ▁ copyright ▁ notice, ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer <encdom>  # ▁ in ▁ the ▁ documentation ▁ and/or ▁ other ▁ materials ▁ provided ▁ with ▁ the <encdom>  # ▁ distribution. <encdom>  # ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ Google ▁ Inc. ▁ nor ▁ the ▁ names ▁ of ▁ its <encdom>  # ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from <encdom>  # ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ▁ permission. <encdom>  # ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS <encdom>  # ▁"AS ▁ IS" ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES, ▁ INCLUDING, ▁ BUT ▁ NOT <encdom>  # ▁ LIMITED ▁ TO, ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR <encdom>  # ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED. ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT <encdom>  # ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT, ▁ INDIRECT, ▁ INCIDENTAL, <encdom>  # ▁ SPECIAL, ▁ EXEMPLARY, ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ (INCLUDING, ▁ BUT ▁ NOT <encdom>  # ▁ LIMITED ▁ TO, ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES; ▁ LOSS ▁ OF ▁ USE, <encdom>  # ▁ DATA, ▁ OR ▁ PROFITS; ▁ OR ▁ BUSINESS ▁ INTERRUPTION) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY <encdom>  # ▁ THEORY ▁ OF ▁ LIABILITY, ▁ WHETHER ▁ IN ▁ CONTRACT, ▁ STRICT ▁ LIABILITY, ▁ OR ▁ TORT <encdom>  # ▁ (INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE <encdom>  # ▁ OF ▁ THIS ▁ SOFTWARE, ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE. <encdom> from google . appengine . ext import webapp <newline> import model <newline> class SVNRevision ( webapp . RequestHandler ) : <newline> <indent> def get ( self , svn_revision_number ) : <newline> <indent> svn_revisions = model . SVNRevision . all ( ) . filter ( 'number ▁ =' , int ( svn_revision_number ) ) . order ( '-date' ) . fetch ( 1 ) <newline> if not svn_revisions : <newline> <indent> self . error ( 404 ) <newline> return <newline> <dedent> self . response . out . write ( svn_revisions [ 0 ] . to_xml ( ) ) <newline> <dedent> <dedent>
 # ▁ $Id: ▁ __init__.py ▁ 3265 ▁ 2007-09-06 ▁ 20:42:00Z ▁ fredrik ▁ $ <encdom>  # ▁ elementtree ▁ package <encdom>  # ▁ The ▁ ElementTree ▁ toolkit ▁ is <encdom>  # ▁ Copyright ▁ (c) ▁ 1999-2007 ▁ by ▁ Fredrik ▁ Lundh <encdom>  # ▁ By ▁ obtaining, ▁ using, ▁ and/or ▁ copying ▁ this ▁ software ▁ and/or ▁ its <encdom>  # ▁ associated ▁ documentation, ▁ you ▁ agree ▁ that ▁ you ▁ have ▁ read, ▁ understood, <encdom>  # ▁ and ▁ will ▁ comply ▁ with ▁ the ▁ following ▁ terms ▁ and ▁ conditions: <encdom>  # ▁ Permission ▁ to ▁ use, ▁ copy, ▁ modify, ▁ and ▁ distribute ▁ this ▁ software ▁ and <encdom>  # ▁ its ▁ associated ▁ documentation ▁ for ▁ any ▁ purpose ▁ and ▁ without ▁ fee ▁ is <encdom>  # ▁ hereby ▁ granted, ▁ provided ▁ that ▁ the ▁ above ▁ copyright ▁ notice ▁ appears ▁ in <encdom>  # ▁ all ▁ copies, ▁ and ▁ that ▁ both ▁ that ▁ copyright ▁ notice ▁ and ▁ this ▁ permission <encdom>  # ▁ notice ▁ appear ▁ in ▁ supporting ▁ documentation, ▁ and ▁ that ▁ the ▁ name ▁ of <encdom>  # ▁ Secret ▁ Labs ▁ AB ▁ or ▁ the ▁ author ▁ not ▁ be ▁ used ▁ in ▁ advertising ▁ or ▁ publicity <encdom>  # ▁ pertaining ▁ to ▁ distribution ▁ of ▁ the ▁ software ▁ without ▁ specific, ▁ written <encdom>  # ▁ prior ▁ permission. <encdom>  # ▁ SECRET ▁ LABS ▁ AB ▁ AND ▁ THE ▁ AUTHOR ▁ DISCLAIMS ▁ ALL ▁ WARRANTIES ▁ WITH ▁ REGARD <encdom>  # ▁ TO ▁ THIS ▁ SOFTWARE, ▁ INCLUDING ▁ ALL ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANT- <encdom>  # ▁ ABILITY ▁ AND ▁ FITNESS. ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ SECRET ▁ LABS ▁ AB ▁ OR ▁ THE ▁ AUTHOR <encdom>  # ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ SPECIAL, ▁ INDIRECT ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ OR ▁ ANY <encdom>  # ▁ DAMAGES ▁ WHATSOEVER ▁ RESULTING ▁ FROM ▁ LOSS ▁ OF ▁ USE, ▁ DATA ▁ OR ▁ PROFITS, <encdom>  # ▁ WHETHER ▁ IN ▁ AN ▁ ACTION ▁ OF ▁ CONTRACT, ▁ NEGLIGENCE ▁ OR ▁ OTHER ▁ TORTIOUS <encdom>  # ▁ ACTION, ▁ ARISING ▁ OUT ▁ OF ▁ OR ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ USE ▁ OR ▁ PERFORMANCE <encdom>  # ▁ OF ▁ THIS ▁ SOFTWARE. <encdom>
 # !python <encdom>  """ Bootstrap ▁ setuptools ▁ installation <strnewline> <strnewline> If ▁ you ▁ want ▁ to ▁ use ▁ setuptools ▁ in ▁ your ▁ package's ▁ setup.py, ▁ just ▁ include ▁ this <strnewline> file ▁ in ▁ the ▁ same ▁ directory ▁ with ▁ it, ▁ and ▁ add ▁ this ▁ to ▁ the ▁ top ▁ of ▁ your ▁ setup.py:: <strnewline> <strnewline> ▁ from ▁ ez_setup ▁ import ▁ use_setuptools <strnewline> ▁ use_setuptools() <strnewline> <strnewline> If ▁ you ▁ want ▁ to ▁ require ▁ a ▁ specific ▁ version ▁ of ▁ setuptools, ▁ set ▁ a ▁ download <strnewline> mirror, ▁ or ▁ use ▁ an ▁ alternate ▁ download ▁ directory, ▁ you ▁ can ▁ do ▁ so ▁ by ▁ supplying <strnewline> the ▁ appropriate ▁ options ▁ to ▁ ``use_setuptools()``. <strnewline> <strnewline> This ▁ file ▁ can ▁ also ▁ be ▁ run ▁ as ▁ a ▁ script ▁ to ▁ install ▁ or ▁ upgrade ▁ setuptools. <strnewline> """  <newline> import sys <newline> DEFAULT_VERSION = "0.6c11" <newline> DEFAULT_URL = "http://pypi.python.org/packages/%s/s/setuptools/" % sys . version [ : 3 ] <newline> md5_data = { 'setuptools-0.6b1-py2.3.egg' : '8822caf901250d848b996b7f25c6e6ca' , 'setuptools-0.6b1-py2.4.egg' : 'b79a8a403e4502fbb85ee3f1941735cb' , 'setuptools-0.6b2-py2.3.egg' : '5657759d8a6d8fc44070a9d07272d99b' , 'setuptools-0.6b2-py2.4.egg' : '4996a8d169d2be661fa32a6e52e4f82a' , 'setuptools-0.6b3-py2.3.egg' : 'bb31c0fc7399a63579975cad9f5a0618' , 'setuptools-0.6b3-py2.4.egg' : '38a8c6b3d6ecd22247f179f7da669fac' , 'setuptools-0.6b4-py2.3.egg' : '62045a24ed4e1ebc77fe039aa4e6f7e5' , 'setuptools-0.6b4-py2.4.egg' : '4cb2a185d228dacffb2d17f103b3b1c4' , 'setuptools-0.6c1-py2.3.egg' : 'b3f2b5539d65cb7f74ad79127f1a908c' , 'setuptools-0.6c1-py2.4.egg' : 'b45adeda0667d2d2ffe14009364f2a4b' , 'setuptools-0.6c10-py2.3.egg' : 'ce1e2ab5d3a0256456d9fc13800a7090' , 'setuptools-0.6c10-py2.4.egg' : '57d6d9d6e9b80772c59a53a8433a5dd4' , 'setuptools-0.6c10-py2.5.egg' : 'de46ac8b1c97c895572e5e8596aeb8c7' , 'setuptools-0.6c10-py2.6.egg' : '58ea40aef06da02ce641495523a0b7f5' , 'setuptools-0.6c11-py2.3.egg' : '2baeac6e13d414a9d28e7ba5b5a596de' , 'setuptools-0.6c11-py2.4.egg' : 'bd639f9b0eac4c42497034dec2ec0c2b' , 'setuptools-0.6c11-py2.5.egg' : '64c94f3bf7a72a13ec83e0b24f2749b2' , 'setuptools-0.6c11-py2.6.egg' : 'bfa92100bd772d5a213eedd356d64086' , 'setuptools-0.6c2-py2.3.egg' : 'f0064bf6aa2b7d0f3ba0b43f20817c27' , 'setuptools-0.6c2-py2.4.egg' : '616192eec35f47e8ea16cd6a122b7277' , 'setuptools-0.6c3-py2.3.egg' : 'f181fa125dfe85a259c9cd6f1d7b78fa' , 'setuptools-0.6c3-py2.4.egg' : 'e0ed74682c998bfb73bf803a50e7b71e' , 'setuptools-0.6c3-py2.5.egg' : 'abef16fdd61955514841c7c6bd98965e' , 'setuptools-0.6c4-py2.3.egg' : 'b0b9131acab32022bfac7f44c5d7971f' , 'setuptools-0.6c4-py2.4.egg' : '2a1f9656d4fbf3c97bf946c0a124e6e2' , 'setuptools-0.6c4-py2.5.egg' : '8f5a052e32cdb9c72bcf4b5526f28afc' , 'setuptools-0.6c5-py2.3.egg' : 'ee9fd80965da04f2f3e6b3576e9d8167' , 'setuptools-0.6c5-py2.4.egg' : 'afe2adf1c01701ee841761f5bcd8aa64' , 'setuptools-0.6c5-py2.5.egg' : 'a8d3f61494ccaa8714dfed37bccd3d5d' , 'setuptools-0.6c6-py2.3.egg' : '35686b78116a668847237b69d549ec20' , 'setuptools-0.6c6-py2.4.egg' : '3c56af57be3225019260a644430065ab' , 'setuptools-0.6c6-py2.5.egg' : 'b2f8a7520709a5b34f80946de5f02f53' , 'setuptools-0.6c7-py2.3.egg' : '209fdf9adc3a615e5115b725658e13e2' , 'setuptools-0.6c7-py2.4.egg' : '5a8f954807d46a0fb67cf1f26c55a82e' , 'setuptools-0.6c7-py2.5.egg' : '45d2ad28f9750e7434111fde831e8372' , 'setuptools-0.6c8-py2.3.egg' : '50759d29b349db8cfd807ba8303f1902' , 'setuptools-0.6c8-py2.4.egg' : 'cba38d74f7d483c06e9daa6070cce6de' , 'setuptools-0.6c8-py2.5.egg' : '1721747ee329dc150590a58b3e1ac95b' , 'setuptools-0.6c9-py2.3.egg' : 'a83c4020414807b496e4cfbe08507c03' , 'setuptools-0.6c9-py2.4.egg' : '260a2be2e5388d66bdaee06abec6342a' , 'setuptools-0.6c9-py2.5.egg' : 'fe67c3e5a17b12c0e7c541b7ea43a8e6' , 'setuptools-0.6c9-py2.6.egg' : 'ca37b1ff16fa2ede6e19383e7b59245a' , } <newline> import sys , os <newline> try : from hashlib import md5 <newline> except ImportError : from md5 import md5 <newline> def _validate_md5 ( egg_name , data ) : <newline> <indent> if egg_name in md5_data : <newline> <indent> digest = md5 ( data ) . hexdigest ( ) <newline> if digest != md5_data [ egg_name ] : <newline> <indent> print >> sys . stderr , ( "md5 ▁ validation ▁ of ▁ %s ▁ failed! ▁ (Possible ▁ download ▁ problem?)" % egg_name ) <newline> sys . exit ( 2 ) <newline> <dedent> <dedent> return data <newline> <dedent> def use_setuptools ( version = DEFAULT_VERSION , download_base = DEFAULT_URL , to_dir = os . curdir , download_delay = 15 ) : <newline> <indent>  """ Automatically ▁ find/download ▁ setuptools ▁ and ▁ make ▁ it ▁ available ▁ on ▁ sys.path <strnewline> <strnewline> ▁ `version` ▁ should ▁ be ▁ a ▁ valid ▁ setuptools ▁ version ▁ number ▁ that ▁ is ▁ available <strnewline> ▁ as ▁ an ▁ egg ▁ for ▁ download ▁ under ▁ the ▁ `download_base` ▁ URL ▁ (which ▁ should ▁ end ▁ with <strnewline> ▁ a ▁'/'). ▁ `to_dir` ▁ is ▁ the ▁ directory ▁ where ▁ setuptools ▁ will ▁ be ▁ downloaded, ▁ if <strnewline> ▁ it ▁ is ▁ not ▁ already ▁ available. ▁ If ▁ `download_delay` ▁ is ▁ specified, ▁ it ▁ should <strnewline> ▁ be ▁ the ▁ number ▁ of ▁ seconds ▁ that ▁ will ▁ be ▁ paused ▁ before ▁ initiating ▁ a ▁ download, <strnewline> ▁ should ▁ one ▁ be ▁ required. ▁ If ▁ an ▁ older ▁ version ▁ of ▁ setuptools ▁ is ▁ installed, <strnewline> ▁ this ▁ routine ▁ will ▁ print ▁ a ▁ message ▁ to ▁ ``sys.stderr`` ▁ and ▁ raise ▁ SystemExit ▁ in <strnewline> ▁ an ▁ attempt ▁ to ▁ abort ▁ the ▁ calling ▁ script. <strnewline> ▁ """  <newline> was_imported = 'pkg_resources' in sys . modules or 'setuptools' in sys . modules <newline> def do_download ( ) : <newline> <indent> egg = download_setuptools ( version , download_base , to_dir , download_delay ) <newline> sys . path . insert ( 0 , egg ) <newline> import setuptools ; setuptools . bootstrap_install_from = egg <newline> <dedent> try : <newline> <indent> import pkg_resources <newline> <dedent> except ImportError : <newline> <indent> return do_download ( ) <newline> <dedent> try : <newline> <indent> pkg_resources . require ( "setuptools>=" + version ) ; return <newline> <dedent> except pkg_resources . VersionConflict , e : <newline> <indent> if was_imported : <newline> <indent> print >> sys . stderr , ( "The ▁ required ▁ version ▁ of ▁ setuptools ▁ (>=%s) ▁ is ▁ not ▁ available, ▁ and \n " "can't ▁ be ▁ installed ▁ while ▁ this ▁ script ▁ is ▁ running. ▁ Please ▁ install \n " " ▁ a ▁ more ▁ recent ▁ version ▁ first, ▁ using ▁'easy_install ▁ -U ▁ setuptools'." " \n \n (Currently ▁ using ▁ %r)" ) % ( version , e . args [ 0 ] ) <newline> sys . exit ( 2 ) <newline> <dedent> else : <newline> <indent> del pkg_resources , sys . modules [ 'pkg_resources' ]  # ▁ reload ▁ ok <encdom> <newline> return do_download ( ) <newline> <dedent> <dedent> except pkg_resources . DistributionNotFound : <newline> <indent> return do_download ( ) <newline> <dedent> <dedent> def download_setuptools ( version = DEFAULT_VERSION , download_base = DEFAULT_URL , to_dir = os . curdir , delay = 15 ) : <newline> <indent>  """ Download ▁ setuptools ▁ from ▁ a ▁ specified ▁ location ▁ and ▁ return ▁ its ▁ filename <strnewline> <strnewline> ▁ `version` ▁ should ▁ be ▁ a ▁ valid ▁ setuptools ▁ version ▁ number ▁ that ▁ is ▁ available <strnewline> ▁ as ▁ an ▁ egg ▁ for ▁ download ▁ under ▁ the ▁ `download_base` ▁ URL ▁ (which ▁ should ▁ end <strnewline> ▁ with ▁ a ▁'/'). ▁ `to_dir` ▁ is ▁ the ▁ directory ▁ where ▁ the ▁ egg ▁ will ▁ be ▁ downloaded. <strnewline> ▁ `delay` ▁ is ▁ the ▁ number ▁ of ▁ seconds ▁ to ▁ pause ▁ before ▁ an ▁ actual ▁ download ▁ attempt. <strnewline> ▁ """  <newline> import urllib2 , shutil <newline> egg_name = "setuptools-%s-py%s.egg" % ( version , sys . version [ : 3 ] ) <newline> url = download_base + egg_name <newline> saveto = os . path . join ( to_dir , egg_name ) <newline> src = dst = None <newline> if not os . path . exists ( saveto ) :  # ▁ Avoid ▁ repeated ▁ downloads <encdom> <newline> <indent> try : <newline> <indent> from distutils import log <newline> if delay : <newline> <indent> log . warn (  """ <strnewline> --------------------------------------------------------------------------- <strnewline> This ▁ script ▁ requires ▁ setuptools ▁ version ▁ %s ▁ to ▁ run ▁ (even ▁ to ▁ display <strnewline> help). ▁ ▁ I ▁ will ▁ attempt ▁ to ▁ download ▁ it ▁ for ▁ you ▁ (from <strnewline> %s), ▁ but <strnewline> you ▁ may ▁ need ▁ to ▁ enable ▁ firewall ▁ access ▁ for ▁ this ▁ script ▁ first. <strnewline> I ▁ will ▁ start ▁ the ▁ download ▁ in ▁ %d ▁ seconds. <strnewline> <strnewline> (Note: ▁ if ▁ this ▁ machine ▁ does ▁ not ▁ have ▁ network ▁ access, ▁ please ▁ obtain ▁ the ▁ file <strnewline> <strnewline> ▁ ▁ ▁ %s <strnewline> <strnewline> and ▁ place ▁ it ▁ in ▁ this ▁ directory ▁ before ▁ rerunning ▁ this ▁ script.) <strnewline> --------------------------------------------------------------------------- """  , version , download_base , delay , url ) ; from time import sleep ; sleep ( delay ) <newline> <dedent> log . warn ( "Downloading ▁ %s" , url ) <newline> src = urllib2 . urlopen ( url ) <newline>  # ▁ Read/write ▁ all ▁ in ▁ one ▁ block, ▁ so ▁ we ▁ don't ▁ create ▁ a ▁ corrupt ▁ file <encdom>  # ▁ if ▁ the ▁ download ▁ is ▁ interrupted. <encdom> data = _validate_md5 ( egg_name , src . read ( ) ) <newline> dst = open ( saveto , "wb" ) ; dst . write ( data ) <newline> <dedent> finally : <newline> <indent> if src : src . close ( ) <newline> if dst : dst . close ( ) <newline> <dedent> <dedent> return os . path . realpath ( saveto ) <newline> <dedent> def main ( argv , version = DEFAULT_VERSION ) : <newline> <indent>  """ Install ▁ or ▁ upgrade ▁ setuptools ▁ and ▁ EasyInstall """  <newline> try : <newline> <indent> import setuptools <newline> <dedent> except ImportError : <newline> <indent> egg = None <newline> try : <newline> <indent> egg = download_setuptools ( version , delay = 0 ) <newline> sys . path . insert ( 0 , egg ) <newline> from setuptools . command . easy_install import main <newline> return main ( list ( argv ) + [ egg ] )  # ▁ we're ▁ done ▁ here <encdom> <newline> <dedent> finally : <newline> <indent> if egg and os . path . exists ( egg ) : <newline> <indent> os . unlink ( egg ) <newline> <dedent> <dedent> <dedent> else : <newline> <indent> if setuptools . __version__ == '0.0.1' : <newline> <indent> print >> sys . stderr , ( "You ▁ have ▁ an ▁ obsolete ▁ version ▁ of ▁ setuptools ▁ installed. ▁ Please \n " "remove ▁ it ▁ from ▁ your ▁ system ▁ entirely ▁ before ▁ rerunning ▁ this ▁ script." ) <newline> sys . exit ( 2 ) <newline> <dedent> <dedent> req = "setuptools>=" + version <newline> import pkg_resources <newline> try : <newline> <indent> pkg_resources . require ( req ) <newline> <dedent> except pkg_resources . VersionConflict : <newline> <indent> try : <newline> <indent> from setuptools . command . easy_install import main <newline> <dedent> except ImportError : <newline> <indent> from easy_install import main <newline> <dedent> main ( list ( argv ) + [ download_setuptools ( delay = 0 ) ] ) <newline> sys . exit ( 0 )  # ▁ try ▁ to ▁ force ▁ an ▁ exit <encdom> <newline> <dedent> else : <newline> <indent> if argv : <newline> <indent> from setuptools . command . easy_install import main <newline> main ( argv ) <newline> <dedent> else : <newline> <indent> print "Setuptools ▁ version" , version , "or ▁ greater ▁ has ▁ been ▁ installed." <newline> print '(Run ▁"ez_setup.py ▁ -U ▁ setuptools" ▁ to ▁ reinstall ▁ or ▁ upgrade.)' <newline> <dedent> <dedent> <dedent> def update_md5 ( filenames ) : <newline> <indent>  """ Update ▁ our ▁ built-in ▁ md5 ▁ registry """  <newline> import re <newline> for name in filenames : <newline> <indent> base = os . path . basename ( name ) <newline> f = open ( name , 'rb' ) <newline> md5_data [ base ] = md5 ( f . read ( ) ) . hexdigest ( ) <newline> f . close ( ) <newline> <dedent> data = [ " ▁ ▁ ▁ ▁ %r: ▁ %r, \n " % it for it in md5_data . items ( ) ] <newline> data . sort ( ) <newline> repl = "" . join ( data ) <newline> import inspect <newline> srcfile = inspect . getsourcefile ( sys . modules [ __name__ ] ) <newline> f = open ( srcfile , 'rb' ) ; src = f . read ( ) ; f . close ( ) <newline> match = re . search ( " \n md5_data ▁ = ▁ { \n ([^}]+)}" , src ) <newline> if not match : <newline> <indent> print >> sys . stderr , "Internal ▁ error!" <newline> sys . exit ( 2 ) <newline> <dedent> src = src [ : match . start ( 1 ) ] + repl + src [ match . end ( 1 ) : ] <newline> f = open ( srcfile , 'w' ) <newline> f . write ( src ) <newline> f . close ( ) <newline> <dedent> if __name__ == '__main__' : <newline> <indent> if len ( sys . argv ) > 2 and sys . argv [ 1 ] == '--md5update' : <newline> <indent> update_md5 ( sys . argv [ 2 : ] ) <newline> <dedent> else : <newline> <indent> main ( sys . argv [ 1 : ] ) <newline> <dedent> <dedent>
n = 0 <newline> while ( n < 30 ) : <newline> <indent> print ( 0.5 * n * ( n + 1 ) ) <newline> n = n + 1 <newline> <dedent>
 """ <strnewline> Table ▁ of ▁ Contents ▁ Extension ▁ for ▁ Python-Markdown <strnewline> * ▁ * ▁ * <strnewline> <strnewline> (c) ▁ 2008 ▁ [Jack ▁ Miller](http://codezen.org) <strnewline> <strnewline> Dependencies: <strnewline> * ▁ [Markdown ▁ 2.1+](http://packages.python.org/Markdown/) <strnewline> <strnewline> Pull ▁ request ▁ to ▁ include ▁ the ▁ below ▁ code ▁ in ▁ Python-Markdown: <strnewline> https://github.com/waylan/Python-Markdown/pull/191 <strnewline> <strnewline> Until ▁ it's ▁ released, ▁ we ▁ have ▁ a ▁ copy ▁ here. <strnewline> <strnewline> /benjaoming <strnewline> <strnewline> <strnewline> UPDATE ▁ PR ▁ WAS ▁ MERGED ▁ FOR ▁ MARKDOWN ▁ 2.3 <strnewline> <strnewline> SO ▁ WE ▁ AN ▁ JUST ▁ DEPEND ▁ ON ▁ THAT! <strnewline> <strnewline> <strnewline> """  <newline> from __future__ import absolute_import , unicode_literals <newline> import re <newline> import unicodedata <newline> import markdown <newline> from markdown . util import etree <newline> from six . moves import range <newline> from wiki . plugins . macros import settings <newline> HEADER_ID_PREFIX = "wiki-toc-" <newline> IDCOUNT_RE = re . compile ( r'^(.*)_([0-9]+)$' ) <newline> def slugify ( value , separator ) : <newline> <indent>  """ ▁ Slugify ▁ a ▁ string, ▁ to ▁ make ▁ it ▁ URL ▁ friendly. ▁ """  <newline> value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) <newline> value = re . sub ( '[^\w\s-]' , '' , value . decode ( 'ascii' ) ) . strip ( ) . lower ( ) <newline> return re . sub ( '[%s\s]+' % separator , separator , value ) <newline> <dedent> def itertext ( elem ) : <newline> <indent>  """ ▁ Loop ▁ through ▁ all ▁ children ▁ and ▁ return ▁ text ▁ only. <strnewline> <strnewline> ▁ Reimplements ▁ method ▁ of ▁ same ▁ name ▁ added ▁ to ▁ ElementTree ▁ in ▁ Python ▁ 2.7 <strnewline> <strnewline> ▁ """  <newline> if elem . text : <newline> <indent> yield elem . text <newline> <dedent> for e in elem : <newline> <indent> for s in itertext ( e ) : <newline> <indent> yield s <newline> <dedent> if e . tail : <newline> <indent> yield e . tail <newline> <dedent> <dedent> <dedent> def unique ( elem_id , ids ) : <newline> <indent>  """ ▁ Ensure ▁ id ▁ is ▁ unique ▁ in ▁ set ▁ of ▁ ids. ▁ Append ▁'_1', ▁'_2'... ▁ if ▁ not ▁ """  <newline> while elem_id in ids : <newline> <indent> m = IDCOUNT_RE . match ( elem_id ) <newline> if m : <newline> <indent> elem_id = '%s_%d' % ( m . group ( 1 ) , int ( m . group ( 2 ) ) + 1 ) <newline> <dedent> else : <newline> <indent> elem_id = '%s_%d' % ( elem_id , 1 ) <newline> <dedent> <dedent> ids . add ( elem_id ) <newline> return HEADER_ID_PREFIX + elem_id <newline> <dedent> def order_toc_list ( toc_list ) : <newline> <indent>  """ Given ▁ an ▁ unsorted ▁ list ▁ with ▁ errors ▁ and ▁ skips, ▁ return ▁ a ▁ nested ▁ one. <strnewline> ▁ [{'level': ▁ 1}, ▁ {'level': ▁ 2}] <strnewline> ▁ => <strnewline> ▁ [{'level': ▁ 1, ▁'children': ▁ [{'level': ▁ 2, ▁'children': ▁ []}]}] <strnewline> <strnewline> ▁ A ▁ wrong ▁ list ▁ is ▁ also ▁ converted: <strnewline> ▁ [{'level': ▁ 2}, ▁ {'level': ▁ 1}] <strnewline> ▁ => <strnewline> ▁ [{'level': ▁ 2, ▁'children': ▁ []}, ▁ {'level': ▁ 1, ▁'children': ▁ []}] <strnewline> ▁ """  <newline> def build_correct ( remaining_list , prev_elements = [ { 'level' : 1000 } ] ) : <newline> <indent> if not remaining_list : <newline> <indent> return [ ] , [ ] <newline> <dedent> current = remaining_list . pop ( 0 ) <newline> if 'children' not in list ( current . keys ( ) ) : <newline> <indent> current [ 'children' ] = [ ] <newline> <dedent> if not prev_elements : <newline>  # ▁ This ▁ happens ▁ for ▁ instance ▁ with ▁ [8, ▁ 1, ▁ 1], ▁ ie. ▁ when ▁ some <encdom>  # ▁ header ▁ level ▁ is ▁ outside ▁ a ▁ scope. ▁ We ▁ treat ▁ it ▁ as ▁ a <encdom>  # ▁ top-level <encdom> <indent> next_elements , children = build_correct ( remaining_list , [ current ] ) <newline> current [ 'children' ] . append ( children ) <newline> return [ current ] + next_elements , [ ] <newline> <dedent> prev_element = prev_elements . pop ( ) <newline> children = [ ] <newline> next_elements = [ ] <newline>  # ▁ Is ▁ current ▁ part ▁ of ▁ the ▁ child ▁ list ▁ or ▁ next ▁ list? <encdom> if current [ 'level' ] > prev_element [ 'level' ] : <newline>  # ▁ print ▁"%d ▁ is ▁ a ▁ child ▁ of ▁ %d" ▁ % ▁ (current['level'], <encdom>  # ▁ prev_element['level']) <encdom> <indent> prev_elements . append ( prev_element ) <newline> prev_elements . append ( current ) <newline> prev_element [ 'children' ] . append ( current ) <newline> next_elements2 , children2 = build_correct ( remaining_list , prev_elements ) <newline> children += children2 <newline> next_elements += next_elements2 <newline> <dedent> else : <newline>  # ▁ print ▁"%d ▁ is ▁ ancestor ▁ of ▁ %d" ▁ % ▁ (current['level'], <encdom>  # ▁ prev_element['level']) <encdom> <indent> if not prev_elements : <newline>  # ▁ print ▁"No ▁ previous ▁ elements, ▁ so ▁ appending ▁ to ▁ the ▁ next ▁ set" <encdom> <indent> next_elements . append ( current ) <newline> prev_elements = [ current ] <newline> next_elements2 , children2 = build_correct ( remaining_list , prev_elements ) <newline> current [ 'children' ] . extend ( children2 ) <newline> <dedent> else : <newline>  # ▁ print ▁"Previous ▁ elements, ▁ comparing ▁ to ▁ those ▁ first" <encdom> <indent> remaining_list . insert ( 0 , current ) <newline> next_elements2 , children2 = build_correct ( remaining_list , prev_elements ) <newline> children . extend ( children2 ) <newline> <dedent> next_elements += next_elements2 <newline> <dedent> return next_elements , children <newline> <dedent> flattened_list , __ = build_correct ( toc_list ) <newline> return flattened_list <newline> <dedent> class TocTreeprocessor ( markdown . treeprocessors . Treeprocessor ) : <newline>  # ▁ Iterator ▁ wrapper ▁ to ▁ get ▁ parent ▁ and ▁ child ▁ all ▁ at ▁ once <encdom> <indent> def iterparent ( self , root ) : <newline> <indent> for parent in root . getiterator ( ) : <newline> <indent> for child in parent : <newline> <indent> yield parent , child <newline> <dedent> <dedent> <dedent> def add_anchor ( self , c , elem_id ) :  # ▁ @ReservedAssignment <encdom> <newline> <indent> if self . use_anchors : <newline> <indent> anchor = etree . Element ( "a" ) <newline> anchor . text = c . text <newline> anchor . attrib [ "href" ] = " # " + elem_id <newline> anchor . attrib [ "class" ] = "toclink" <newline> c . text = "" <newline> for elem in c . getchildren ( ) : <newline> <indent> anchor . append ( elem ) <newline> c . remove ( elem ) <newline> <dedent> c . append ( anchor ) <newline> <dedent> <dedent> def build_toc_etree ( self , div , toc_list ) : <newline> <indent> def build_etree_ul ( toc_list , parent ) : <newline> <indent> ul = etree . SubElement ( parent , "ul" ) <newline> for item in toc_list : <newline>  # ▁ List ▁ item ▁ link, ▁ to ▁ be ▁ inserted ▁ into ▁ the ▁ toc ▁ div <encdom> <indent> li = etree . SubElement ( ul , "li" ) <newline> link = etree . SubElement ( li , "a" ) <newline> link . text = item . get ( 'name' , '' ) <newline> link . attrib [ "href" ] = ' # ' + item . get ( 'id' , '' ) <newline> if item [ 'children' ] : <newline> <indent> build_etree_ul ( item [ 'children' ] , li ) <newline> <dedent> <dedent> return ul <newline> <dedent> return build_etree_ul ( toc_list , div ) <newline> <dedent> def run ( self , doc ) :  # ▁ noqa <encdom> <newline> <indent> div = etree . Element ( "div" ) <newline> div . attrib [ "class" ] = "toc" <newline> header_rgx = re . compile ( "[Hh][123456]" ) <newline> self . use_anchors = self . config [ "anchorlink" ] in [ 1 , '1' , True , 'True' , 'true' ] <newline>  # ▁ Get ▁ a ▁ list ▁ of ▁ id ▁ attributes <encdom> used_ids = set ( ) <newline> for c in doc . getiterator ( ) : <newline> <indent> if "id" in c . attrib : <newline> <indent> used_ids . add ( c . attrib [ "id" ] ) <newline> <dedent> <dedent> toc_list = [ ] <newline> marker_found = False <newline> for ( p , c ) in self . iterparent ( doc ) : <newline> <indent> text = '' . join ( itertext ( c ) ) . strip ( ) <newline> if not text : <newline> <indent> continue <newline>  # ▁ To ▁ keep ▁ the ▁ output ▁ from ▁ screwing ▁ up ▁ the <encdom>  # ▁ validation ▁ by ▁ putting ▁ a ▁ <div> ▁ inside ▁ of ▁ a ▁ <p> <encdom>  # ▁ we ▁ actually ▁ replace ▁ the ▁ <p> ▁ in ▁ its ▁ entirety. <encdom>  # ▁ We ▁ do ▁ not ▁ allow ▁ the ▁ marker ▁ inside ▁ a ▁ header ▁ as ▁ that <encdom>  # ▁ would ▁ causes ▁ an ▁ enless ▁ loop ▁ of ▁ placing ▁ a ▁ new ▁ TOC <encdom>  # ▁ inside ▁ previously ▁ generated ▁ TOC. <encdom> <dedent> if c . text and c . text . strip ( ) == self . config [ "marker" ] and not header_rgx . match ( c . tag ) and c . tag not in [ 'pre' , 'code' ] : <newline> <indent> for i in range ( len ( p ) ) : <newline> <indent> if p [ i ] == c : <newline> <indent> p [ i ] = div <newline> break <newline> <dedent> <dedent> marker_found = True <newline> <dedent> if header_rgx . match ( c . tag ) : <newline>  # ▁ Do ▁ not ▁ override ▁ pre-existing ▁ ids <encdom> <indent> if "id" not in c . attrib : <newline> <indent> elem_id = unique ( self . config [ "slugify" ] ( text , '-' ) , used_ids ) <newline> c . attrib [ "id" ] = elem_id <newline> <dedent> else : <newline> <indent> elem_id = c . attrib [ "id" ] <newline> <dedent> tag_level = int ( c . tag [ - 1 ] ) <newline> toc_list . append ( { 'level' : tag_level , 'id' : elem_id , 'name' : c . text } ) <newline> self . add_anchor ( c , elem_id ) <newline> <dedent> <dedent> if marker_found : <newline> <indent> toc_list_nested = order_toc_list ( toc_list ) <newline> self . build_toc_etree ( div , toc_list_nested ) <newline>  # ▁ serialize ▁ and ▁ attach ▁ to ▁ markdown ▁ instance. <encdom> prettify = self . markdown . treeprocessors . get ( 'prettify' ) <newline> if prettify : <newline> <indent> prettify . run ( div ) <newline> <dedent> toc = self . markdown . serializer ( div ) <newline> for pp in list ( self . markdown . postprocessors . values ( ) ) : <newline> <indent> toc = pp . run ( toc ) <newline> <dedent> self . markdown . toc = toc <newline> <dedent> <dedent> <dedent> class TocExtension ( markdown . Extension ) : <newline> <indent> TreeProcessorClass = TocTreeprocessor <newline> def __init__ ( self , configs = [ ] ) : <newline> <indent> self . config = { "marker" : [ "[TOC]" , "Text ▁ to ▁ find ▁ and ▁ replace ▁ with ▁ Table ▁ of ▁ Contents ▁ -" "Defaults ▁ to ▁ \"[TOC]\"" ] , "slugify" : [ slugify , "Function ▁ to ▁ generate ▁ anchors ▁ based ▁ on ▁ header ▁ text-" "Defaults ▁ to ▁ the ▁ headerid ▁ ext's ▁ slugify ▁ function." ] , "title" : [ None , "Title ▁ to ▁ insert ▁ into ▁ TOC ▁ <div> ▁ - ▁ " "Defaults ▁ to ▁ None" ] , "anchorlink" : [ 0 , "1 ▁ if ▁ header ▁ should ▁ be ▁ a ▁ self ▁ link" "Defaults ▁ to ▁ 0" ] } <newline> for key , value in configs : <newline> <indent> self . setConfig ( key , value ) <newline> <dedent> <dedent> def extendMarkdown ( self , md , md_globals ) : <newline> <indent> tocext = self . TreeProcessorClass ( md ) <newline> tocext . config = self . getConfigs ( ) <newline>  # ▁ Headerid ▁ ext ▁ is ▁ set ▁ to ▁'>inline'. ▁ With ▁ this ▁ set ▁ to ▁'<prettify', <encdom>  # ▁ it ▁ should ▁ always ▁ come ▁ after ▁ headerid ▁ ext ▁ (and ▁ honor ▁ ids ▁ assinged <encdom>  # ▁ by ▁ the ▁ header ▁ id ▁ extension) ▁ if ▁ both ▁ are ▁ used. ▁ Same ▁ goes ▁ for <encdom>  # ▁ attr_list ▁ extension. ▁ This ▁ must ▁ come ▁ last ▁ because ▁ we ▁ don't ▁ want <encdom>  # ▁ to ▁ redefine ▁ ids ▁ after ▁ toc ▁ is ▁ created. ▁ But ▁ we ▁ do ▁ want ▁ toc ▁ prettified. <encdom> md . treeprocessors . add ( "toc" , tocext , ">attr_list" ) <newline> <dedent> <dedent> def makeExtension ( configs = { } ) : <newline> <indent> return TocExtension ( configs = configs ) <newline> <dedent> class WikiTreeProcessorClass ( TocTreeprocessor ) : <newline> <indent> def build_toc_etree ( self , div , toc_list ) : <newline>  # ▁ Add ▁ title ▁ to ▁ the ▁ div <encdom> <indent> if self . config [ "title" ] : <newline> <indent> header = etree . SubElement ( div , "span" ) <newline> header . attrib [ "class" ] = "toctitle" <newline> header . text = self . config [ "title" ] <newline> <dedent> def build_etree_ul ( toc_list , parent ) : <newline> <indent> ul = etree . SubElement ( parent , "ul" ) <newline> for item in toc_list : <newline>  # ▁ List ▁ item ▁ link, ▁ to ▁ be ▁ inserted ▁ into ▁ the ▁ toc ▁ div <encdom> <indent> li = etree . SubElement ( ul , "li" ) <newline> link = etree . SubElement ( li , "a" ) <newline> link . text = item . get ( 'name' , '' ) <newline> link . attrib [ "href" ] = ' # ' + item . get ( 'id' , '' ) <newline> if item [ 'children' ] : <newline> <indent> build_etree_ul ( item [ 'children' ] , li ) <newline> <dedent> <dedent> return ul <newline> <dedent> return build_etree_ul ( toc_list , div ) <newline> <dedent> <dedent> class WikiTocExtension ( TocExtension ) : <newline> <indent> TreeProcessorClass = WikiTreeProcessorClass <newline> def extendMarkdown ( self , md , md_globals ) : <newline> <indent> if 'toc' in settings . METHODS : <newline> <indent> TocExtension . extendMarkdown ( self , md , md_globals ) <newline> <dedent> <dedent> <dedent>
 # # # # # ▁ BEGIN ▁ LICENSE ▁ BLOCK ▁ # # # # # <encdom>  # ▁ The ▁ Original ▁ Code ▁ is ▁ Mozilla ▁ Communicator ▁ client ▁ code. <encdom>  # ▁ The ▁ Initial ▁ Developer ▁ of ▁ the ▁ Original ▁ Code ▁ is <encdom>  # ▁ Netscape ▁ Communications ▁ Corporation. <encdom>  # ▁ Portions ▁ created ▁ by ▁ the ▁ Initial ▁ Developer ▁ are ▁ Copyright ▁ (C) ▁ 1998 <encdom>  # ▁ the ▁ Initial ▁ Developer. ▁ All ▁ Rights ▁ Reserved. <encdom>  # ▁ Contributor(s): <encdom>  # ▁ Mark ▁ Pilgrim ▁ - ▁ port ▁ to ▁ Python <encdom>  # ▁ This ▁ library ▁ is ▁ free ▁ software; ▁ you ▁ can ▁ redistribute ▁ it ▁ and/or <encdom>  # ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public <encdom>  # ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation; ▁ either <encdom>  # ▁ version ▁ 2.1 ▁ of ▁ the ▁ License, ▁ or ▁ (at ▁ your ▁ option) ▁ any ▁ later ▁ version. <encdom>  # ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful, <encdom>  # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of <encdom>  # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE. ▁ See ▁ the ▁ GNU <encdom>  # ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details. <encdom>  # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public <encdom>  # ▁ License ▁ along ▁ with ▁ this ▁ library; ▁ if ▁ not, ▁ write ▁ to ▁ the ▁ Free ▁ Software <encdom>  # ▁ Foundation, ▁ Inc., ▁ 51 ▁ Franklin ▁ St, ▁ Fifth ▁ Floor, ▁ Boston, ▁ MA <encdom>  # ▁ 02110-1301 ▁ USA <encdom>  # # # # # ▁ END ▁ LICENSE ▁ BLOCK ▁ # # # # # <encdom>  # ▁ 255: ▁ Control ▁ characters ▁ that ▁ usually ▁ does ▁ not ▁ exist ▁ in ▁ any ▁ text <encdom>  # ▁ 254: ▁ Carriage/Return <encdom>  # ▁ 253: ▁ symbol ▁ (punctuation) ▁ that ▁ does ▁ not ▁ belong ▁ to ▁ word <encdom>  # ▁ 252: ▁ 0 ▁ - ▁ 9 <encdom>  # ▁ Character ▁ Mapping ▁ Table: <encdom> Latin7_CharToOrderMap = ( 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 254 , 255 , 255 , 254 , 255 , 255 ,  # ▁ 00 <encdom> 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 ,  # ▁ 10 <encdom> 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 20 <encdom> 252 , 252 , 252 , 252 , 252 , 252 , 252 , 252 , 252 , 252 , 253 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 30 <encdom> 253 , 82 , 100 , 104 , 94 , 98 , 101 , 116 , 102 , 111 , 187 , 117 , 92 , 88 , 113 , 85 ,  # ▁ 40 <encdom> 79 , 118 , 105 , 83 , 67 , 114 , 119 , 95 , 99 , 109 , 188 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 50 <encdom> 253 , 72 , 70 , 80 , 81 , 60 , 96 , 93 , 89 , 68 , 120 , 97 , 77 , 86 , 69 , 55 ,  # ▁ 60 <encdom> 78 , 115 , 65 , 66 , 58 , 76 , 106 , 103 , 87 , 107 , 112 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 70 <encdom> 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 ,  # ▁ 80 <encdom> 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 ,  # ▁ 90 <encdom> 253 , 233 , 90 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 74 , 253 , 253 ,  # ▁ a0 <encdom> 253 , 253 , 253 , 253 , 247 , 248 , 61 , 36 , 46 , 71 , 73 , 253 , 54 , 253 , 108 , 123 ,  # ▁ b0 <encdom> 110 , 31 , 51 , 43 , 41 , 34 , 91 , 40 , 52 , 47 , 44 , 53 , 38 , 49 , 59 , 39 ,  # ▁ c0 <encdom> 35 , 48 , 250 , 37 , 33 , 45 , 56 , 50 , 84 , 57 , 120 , 121 , 17 , 18 , 22 , 15 ,  # ▁ d0 <encdom> 124 , 1 , 29 , 20 , 21 , 3 , 32 , 13 , 25 , 5 , 11 , 16 , 10 , 6 , 30 , 4 ,  # ▁ e0 <encdom> 9 , 8 , 14 , 7 , 2 , 12 , 28 , 23 , 42 , 24 , 64 , 75 , 19 , 26 , 27 , 253 ,  # ▁ f0 <encdom> ) <newline> win1253_CharToOrderMap = ( 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 254 , 255 , 255 , 254 , 255 , 255 ,  # ▁ 00 <encdom> 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 ,  # ▁ 10 <encdom> 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 20 <encdom> 252 , 252 , 252 , 252 , 252 , 252 , 252 , 252 , 252 , 252 , 253 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 30 <encdom> 253 , 82 , 100 , 104 , 94 , 98 , 101 , 116 , 102 , 111 , 187 , 117 , 92 , 88 , 113 , 85 ,  # ▁ 40 <encdom> 79 , 118 , 105 , 83 , 67 , 114 , 119 , 95 , 99 , 109 , 188 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 50 <encdom> 253 , 72 , 70 , 80 , 81 , 60 , 96 , 93 , 89 , 68 , 120 , 97 , 77 , 86 , 69 , 55 ,  # ▁ 60 <encdom> 78 , 115 , 65 , 66 , 58 , 76 , 106 , 103 , 87 , 107 , 112 , 253 , 253 , 253 , 253 , 253 ,  # ▁ 70 <encdom> 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 ,  # ▁ 80 <encdom> 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 , 255 ,  # ▁ 90 <encdom> 253 , 233 , 61 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 253 , 74 , 253 , 253 ,  # ▁ a0 <encdom> 253 , 253 , 253 , 253 , 247 , 253 , 253 , 36 , 46 , 71 , 73 , 253 , 54 , 253 , 108 , 123 ,  # ▁ b0 <encdom> 110 , 31 , 51 , 43 , 41 , 34 , 91 , 40 , 52 , 47 , 44 , 53 , 38 , 49 , 59 , 39 ,  # ▁ c0 <encdom> 35 , 48 , 250 , 37 , 33 , 45 , 56 , 50 , 84 , 57 , 120 , 121 , 17 , 18 , 22 , 15 ,  # ▁ d0 <encdom> 124 , 1 , 29 , 20 , 21 , 3 , 32 , 13 , 25 , 5 , 11 , 16 , 10 , 6 , 30 , 4 ,  # ▁ e0 <encdom> 9 , 8 , 14 , 7 , 2 , 12 , 28 , 23 , 42 , 24 , 64 , 75 , 19 , 26 , 27 , 253 ,  # ▁ f0 <encdom> ) <newline>  # ▁ Model ▁ Table: <encdom>  # ▁ total ▁ sequences: ▁ 100% <encdom>  # ▁ first ▁ 512 ▁ sequences: ▁ 98.2851% <encdom>  # ▁ first ▁ 1024 ▁ sequences:1.7001% <encdom>  # ▁ rest ▁ sequences: ▁ 0.0359% <encdom>  # ▁ negative ▁ sequences: ▁ 0.0148% <encdom> GreekLangModel = ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 1 , 3 , 3 , 3 , 0 , 2 , 2 , 3 , 3 , 0 , 3 , 0 , 3 , 2 , 0 , 3 , 3 , 3 , 0 , 3 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 0 , 3 , 2 , 3 , 3 , 0 , 3 , 2 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 3 , 3 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 3 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 0 , 2 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 2 , 3 , 3 , 3 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 3 , 3 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 2 , 1 , 3 , 3 , 3 , 3 , 2 , 3 , 3 , 2 , 3 , 3 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 2 , 3 , 3 , 0 , 2 , 0 , 1 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 2 , 3 , 0 , 0 , 0 , 0 , 3 , 3 , 0 , 3 , 1 , 3 , 3 , 3 , 0 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 2 , 2 , 2 , 3 , 0 , 2 , 3 , 3 , 3 , 3 , 3 , 2 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 0 , 3 , 1 , 3 , 3 , 3 , 3 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 2 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 2 , 3 , 3 , 3 , 3 , 3 , 0 , 0 , 3 , 2 , 3 , 0 , 2 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 3 , 3 , 3 , 3 , 0 , 0 , 3 , 3 , 0 , 2 , 3 , 0 , 3 , 0 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 2 , 2 , 3 , 3 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 2 , 0 , 3 , 2 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 2 , 3 , 2 , 3 , 3 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 2 , 3 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 2 , 3 , 2 , 3 , 2 , 2 , 2 , 3 , 2 , 3 , 3 , 2 , 3 , 0 , 2 , 2 , 2 , 3 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 3 , 2 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 0 , 0 , 3 , 2 , 0 , 3 , 0 , 3 , 0 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 0 , 3 , 3 , 3 , 0 , 0 , 1 , 2 , 3 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 2 , 0 , 0 , 3 , 2 , 2 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 2 , 1 , 3 , 0 , 3 , 2 , 3 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 0 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 0 , 3 , 2 , 3 , 0 , 0 , 3 , 3 , 3 , 0 , 3 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 0 , 0 , 3 , 2 , 0 , 3 , 2 , 3 , 0 , 0 , 3 , 2 , 3 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 1 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 2 , 3 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 0 , 3 , 0 , 2 , 0 , 0 , 2 , 3 , 1 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 3 , 3 , 3 , 3 , 0 , 3 , 0 , 3 , 3 , 2 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 0 , 2 , 3 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 0 , 3 , 0 , 2 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 2 , 0 , 0 , 0 , 3 , 3 , 0 , 3 , 0 , 3 , 0 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 3 , 0 , 2 , 0 , 3 , 2 , 0 , 3 , 2 , 3 , 2 , 3 , 0 , 0 , 3 , 2 , 3 , 2 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 2 , 3 , 3 , 3 , 3 , 3 , 0 , 0 , 0 , 3 , 0 , 2 , 1 , 0 , 0 , 3 , 2 , 2 , 2 , 0 , 3 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 3 , 3 , 3 , 2 , 0 , 3 , 0 , 3 , 0 , 3 , 3 , 0 , 2 , 1 , 2 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 0 , 3 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 3 , 3 , 3 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 2 , 3 , 0 , 3 , 0 , 0 , 0 , 2 , 1 , 0 , 2 , 2 , 3 , 0 , 0 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 2 , 3 , 3 , 3 , 2 , 3 , 0 , 0 , 1 , 3 , 0 , 2 , 0 , 0 , 0 , 0 , 3 , 0 , 1 , 0 , 2 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 1 , 0 , 3 , 0 , 0 , 0 , 3 , 2 , 0 , 3 , 2 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 3 , 2 , 2 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 3 , 3 , 3 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 3 , 3 , 2 , 2 , 2 , 2 , 3 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 3 , 0 , 2 , 0 , 2 , 3 , 2 , 0 , 0 , 3 , 0 , 3 , 0 , 3 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 2 , 3 , 3 , 2 , 2 , 3 , 0 , 2 , 0 , 3 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 2 , 0 , 2 , 0 , 2 , 0 , 0 , 2 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 1 , 0 , 2 , 2 , 2 , 0 , 2 , 2 , 2 , 0 , 2 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 3 , 3 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 3 , 0 , 2 , 0 , 2 , 2 , 2 , 0 , 0 , 2 , 0 , 3 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 2 , 3 , 2 , 0 , 2 , 2 , 0 , 2 , 0 , 2 , 2 , 0 , 2 , 0 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 3 , 0 , 0 , 0 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 2 , 1 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 1 , 0 , 2 , 3 , 2 , 2 , 3 , 2 , 3 , 2 , 0 , 0 , 3 , 3 , 3 , 0 , 0 , 3 , 2 , 0 , 0 , 0 , 1 , 1 , 0 , 2 , 0 , 2 , 2 , 0 , 2 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 2 , 0 , 2 , 2 , 2 , 0 , 2 , 2 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 3 , 3 , 2 , 2 , 0 , 3 , 0 , 0 , 0 , 2 , 2 , 0 , 2 , 2 , 2 , 1 , 2 , 0 , 0 , 1 , 2 , 2 , 0 , 0 , 3 , 0 , 0 , 0 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 3 , 3 , 2 , 2 , 0 , 0 , 0 , 2 , 0 , 2 , 3 , 3 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 0 , 2 , 2 , 0 , 2 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 2 , 2 , 2 , 2 , 1 , 0 , 0 , 2 , 2 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 3 , 2 , 3 , 0 , 0 , 0 , 3 , 0 , 0 , 2 , 2 , 0 , 2 , 0 , 2 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 2 , 0 , 0 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 3 , 2 , 0 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 1 , 0 , 0 , 2 , 0 , 1 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 0 , 2 , 2 , 0 , 1 , 2 , 0 , 2 , 2 , 2 , 0 , 2 , 2 , 2 , 2 , 1 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 2 , 1 , 0 , 0 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 2 , 3 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 2 , 0 , 2 , 0 , 0 , 0 , 1 , 0 , 0 , 2 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 3 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 3 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 1 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 0 , 3 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 2 , 1 , 2 , 0 , 2 , 2 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 2 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 3 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 1 , 2 , 2 , 1 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 1 , 2 , 0 , 2 , 2 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 2 , 1 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 3 , 1 , 2 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 1 , 0 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 2 , 2 , 0 , 1 , 0 , 2 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 2 , 2 , 1 , 0 , 1 , 0 , 1 , 0 , 2 , 2 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 2 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 2 , 2 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 2 , 0 , 0 , 0 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 2 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 1 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ) <newline> Latin7GreekModel = { 'charToOrderMap' : Latin7_CharToOrderMap , 'precedenceMatrix' : GreekLangModel , 'mTypicalPositiveRatio' : 0.982851 , 'keepEnglishLetter' : False , 'charsetName' : "ISO-8859-7" } <newline> Win1253GreekModel = { 'charToOrderMap' : win1253_CharToOrderMap , 'precedenceMatrix' : GreekLangModel , 'mTypicalPositiveRatio' : 0.982851 , 'keepEnglishLetter' : False , 'charsetName' : "windows-1253" } <newline>  # ▁ flake8: ▁ noqa <encdom>
 # ▁ Copyright ▁ (c) ▁ 2012 ▁ Nebula, ▁ Inc. <encdom>  # ▁ All ▁ Rights ▁ Reserved. <encdom>  # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License, ▁ Version ▁ 2.0 ▁ (the ▁"License"); ▁ you ▁ may <encdom>  # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License. ▁ You ▁ may ▁ obtain <encdom>  # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at <encdom>  # ▁ http://www.apache.org/licenses/LICENSE-2.0 <encdom>  # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing, ▁ software <encdom>  # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁"AS ▁ IS" ▁ BASIS, ▁ WITHOUT <encdom>  # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND, ▁ either ▁ express ▁ or ▁ implied. ▁ See ▁ the <encdom>  # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations <encdom>  # ▁ under ▁ the ▁ License. <encdom>  """ The ▁ server ▁ password ▁ extension. """  <newline> from nova . api . metadata import password <newline> from nova . api . openstack import common <newline> from nova . api . openstack import extensions <newline> from nova . api . openstack import wsgi <newline> from nova import compute <newline> ALIAS = 'os-server-password' <newline> authorize = extensions . os_compute_authorizer ( ALIAS ) <newline> class ServerPasswordController ( wsgi . Controller ) : <newline> <indent>  """ The ▁ Server ▁ Password ▁ API ▁ controller ▁ for ▁ the ▁ OpenStack ▁ API. """  <newline> def __init__ ( self ) : <newline> <indent> self . compute_api = compute . API ( skip_policy_check = True ) <newline> <dedent> @ extensions . expected_errors ( 404 ) <newline> def index ( self , req , server_id ) : <newline> <indent> context = req . environ [ 'nova.context' ] <newline> authorize ( context ) <newline> instance = common . get_instance ( self . compute_api , context , server_id ) <newline> passw = password . extract_password ( instance ) <newline> return { 'password' : passw or '' } <newline> <dedent> @ extensions . expected_errors ( 404 ) <newline> @ wsgi . response ( 204 ) <newline> def clear ( self , req , server_id ) : <newline> <indent>  """ Removes ▁ the ▁ encrypted ▁ server ▁ password ▁ from ▁ the ▁ metadata ▁ server <strnewline> <strnewline> ▁ Note ▁ that ▁ this ▁ does ▁ not ▁ actually ▁ change ▁ the ▁ instance ▁ server <strnewline> ▁ password. <strnewline> ▁ """  <newline> context = req . environ [ 'nova.context' ] <newline> authorize ( context ) <newline> instance = common . get_instance ( self . compute_api , context , server_id ) <newline> meta = password . convert_password ( context , None ) <newline> instance . system_metadata . update ( meta ) <newline> instance . save ( ) <newline> <dedent> <dedent> class ServerPassword ( extensions . V3APIExtensionBase ) : <newline> <indent>  """ Server ▁ password ▁ support. """  <newline> name = "ServerPassword" <newline> alias = ALIAS <newline> version = 1 <newline> def get_resources ( self ) : <newline> <indent> resources = [ extensions . ResourceExtension ( ALIAS , ServerPasswordController ( ) , collection_actions = { 'clear' : 'DELETE' } , parent = dict ( member_name = 'server' , collection_name = 'servers' ) ) ] <newline> return resources <newline> <dedent> def get_controller_extensions ( self ) : <newline> <indent> return [ ] <newline> <dedent> <dedent>
import json <newline> from social . tests . backends . oauth import OAuth2Test <newline> class TwitchOAuth2Test ( OAuth2Test ) : <newline> <indent> backend_path = 'social.backends.twitch.TwitchOAuth2' <newline> user_data_url = 'https://api.twitch.tv/kraken/user/' <newline> expected_username = 'test_user1' <newline> access_token_body = json . dumps ( { 'access_token' : 'foobar' , } ) <newline> user_data_body = json . dumps ( { 'type' : 'user' , 'name' : 'test_user1' , 'created_at' : '2011-06-03T17:49:19Z' , 'updated_at' : '2012-06-18T17:19:57Z' , '_links' : { 'self' : 'https://api.twitch.tv/kraken/users/test_user1' } , 'logo' : 'http://static-cdn.jtvnw.net/jtv_user_pictures/' 'test_user1-profile_image-62e8318af864d6d7-300x300.jpeg' , '_id' : 22761313 , 'display_name' : 'test_user1' , 'email' : 'asdf@asdf.com' , 'partnered' : True , 'bio' : 'test ▁ bio ▁ woo ▁ I\'m ▁ a ▁ test ▁ user' } ) <newline> def test_login ( self ) : <newline> <indent> self . do_login ( ) <newline> <dedent> def test_partial_pipeline ( self ) : <newline> <indent> self . do_partial_pipeline ( ) <newline> <dedent> <dedent>
 # !/usr/bin/env ▁ python <encdom>  # Copyright ▁ (c) ▁ The ▁ Shogun ▁ Machine ▁ Learning ▁ Toolbox <encdom>  # Written ▁ (W) ▁ 2014 ▁ Alejandro ▁ Hernandez ▁ Cordero <encdom>  # All ▁ rights ▁ reserved. <encdom>  # Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms, ▁ with ▁ or ▁ without <encdom>  # modification, ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are ▁ met: <encdom>  # 1. ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ▁ notice, ▁ this <encdom>  # ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer. <encdom>  # 2. ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ▁ notice, <encdom>  # ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the ▁ documentation <encdom>  # ▁ and/or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution. <encdom>  # THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS ▁"AS ▁ IS" ▁ AND <encdom>  # ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES, ▁ INCLUDING, ▁ BUT ▁ NOT ▁ LIMITED ▁ TO, ▁ THE ▁ IMPLIED <encdom>  # WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE <encdom>  # DISCLAIMED. ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR <encdom>  # ANY ▁ DIRECT, ▁ INDIRECT, ▁ INCIDENTAL, ▁ SPECIAL, ▁ EXEMPLARY, ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES <encdom>  # (INCLUDING, ▁ BUT ▁ NOT ▁ LIMITED ▁ TO, ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES; <encdom>  # LOSS ▁ OF ▁ USE, ▁ DATA, ▁ OR ▁ PROFITS; ▁ OR ▁ BUSINESS ▁ INTERRUPTION) ▁ HOWEVER ▁ CAUSED ▁ AND <encdom>  # ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY, ▁ WHETHER ▁ IN ▁ CONTRACT, ▁ STRICT ▁ LIABILITY, ▁ OR ▁ TORT <encdom>  # (INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE) ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS <encdom>  # SOFTWARE, ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE. <encdom>  # The ▁ views ▁ and ▁ conclusions ▁ contained ▁ in ▁ the ▁ software ▁ and ▁ documentation ▁ are ▁ those <encdom>  # of ▁ the ▁ authors ▁ and ▁ should ▁ not ▁ be ▁ interpreted ▁ as ▁ representing ▁ official ▁ policies, <encdom>  # either ▁ expressed ▁ or ▁ implied, ▁ of ▁ the ▁ Shogun ▁ Development ▁ Team. <encdom>  # This ▁ example ▁ is ▁ about ▁ learning ▁ and ▁ using ▁ eigenfaces ▁ in ▁ Shogun. <encdom>  # We ▁ demonstrate ▁ how ▁ to ▁ use ▁ them ▁ for ▁ a ▁ set ▁ of ▁ faces. <encdom>  # OpenCV ▁ must ▁ be ▁ installed <encdom> try : <newline> <indent> import cv2 <newline> <dedent> except ImportError : <newline> <indent> print 'Error: ▁ OpenCV ▁ must ▁ be ▁ installed' <newline> exit ( ) <newline> <dedent> import numpy as np <newline> from numpy import random <newline> from modshogun import RealFeatures <newline> from modshogun import PCA <newline> from modshogun import EuclideanDistance <newline> import math <newline> import os <newline> import pylab as pl <newline> IMAGE_WIDHT = 80 <newline> IMAGE_HEIGHT = 80 <newline> N_SUBSET = 10 <newline> class EigenFaces ( ) : <newline> <indent> def __init__ ( self , num_components ) : <newline> <indent>  """ <strnewline> ▁ Constructor <strnewline> ▁ """  <newline> self . _num_components = num_components ; <newline> self . _projections = [ ] <newline> <dedent> def train ( self , images , labels ) : <newline> <indent>  """ <strnewline> ▁ Train ▁ eigenfaces <strnewline> ▁ """  <newline> print "Train..." , <newline>  # copy ▁ labels <encdom> self . _labels = labels ; <newline>  # transform ▁ the ▁ numpe ▁ vector ▁ to ▁ shogun ▁ structure <encdom> features = RealFeatures ( images ) <newline>  # PCA <encdom> self . pca = PCA ( ) <newline>  # set ▁ dimension <encdom> self . pca . set_target_dim ( self . _num_components ) ; <newline>  # compute ▁ PCA <encdom> self . pca . init ( features ) <newline> for sampleIdx in range ( features . get_num_vectors ( ) ) : <newline> <indent> v = features . get_feature_vector ( sampleIdx ) ; <newline> p = self . pca . apply_to_feature_vector ( v ) ; <newline> self . _projections . insert ( sampleIdx , p ) ; <newline> <dedent> print "ok!" <newline> <dedent> def predict ( self , image ) : <newline> <indent>  """ <strnewline> ▁ Predict ▁ the ▁ face <strnewline> ▁ """  <newline>  # image ▁ as ▁ row <encdom> imageAsRow = np . asarray ( image . reshape ( image . shape [ 0 ] * image . shape [ 1 ] , 1 ) , np . float64 ) ; <newline>  # project ▁ inthe ▁ subspace <encdom> p = self . pca . apply_to_feature_vector ( RealFeatures ( imageAsRow ) . get_feature_vector ( 0 ) ) ; <newline>  # min ▁ value ▁ to ▁ find ▁ the ▁ face <encdom> minDist = 1e100 ; <newline>  # class <encdom> minClass = - 1 ; <newline>  # search ▁ which ▁ face ▁ is ▁ the ▁ best ▁ match <encdom> for sampleIdx in range ( len ( self . _projections ) ) : <newline> <indent> test = RealFeatures ( np . asmatrix ( p , np . float64 ) . T ) <newline> projection = RealFeatures ( np . asmatrix ( self . _projections [ sampleIdx ] , np . float64 ) . T ) <newline> dist = EuclideanDistance ( test , projection ) . distance ( 0 , 0 ) <newline> if ( dist < minDist ) : <newline> <indent> minDist = dist ; <newline> minClass = self . _labels [ sampleIdx ] ; <newline> <dedent> <dedent> return minClass <newline> <dedent> def getMean ( self ) : <newline> <indent>  """ <strnewline> ▁ Return ▁ the ▁ mean ▁ vector <strnewline> ▁ """  <newline> return self . pca . get_mean ( ) <newline> <dedent> def getEigenValues ( self ) : <newline> <indent>  """ <strnewline> ▁ Return ▁ the ▁ eigenvalues ▁ vector <strnewline> ▁ """  <newline> return self . pca . get_eigenvalues ( ) ; <newline> <dedent> <dedent> def readImages ( list_filenames ) : <newline> <indent>  """ <strnewline> ▁ Read ▁ all ▁ the ▁ image. ▁ Image ▁ as ▁ rows <strnewline> ▁ """  <newline> print "Reading ▁ images ▁ ..." , <newline>  # reserve ▁ space ▁ for ▁ the ▁ matrix <encdom> images = np . empty ( ( IMAGE_HEIGHT * IMAGE_WIDHT , ( len ( list_filenames ) ) - 1 ) ) <newline> index = 0 ; <newline> for im_filename in list_filenames : <newline>  # read ▁ image ▁ with ▁ opencv <encdom> <indent> imagen = cv2 . imread ( im_filename , cv2 . IMREAD_GRAYSCALE ) <newline>  # resize ▁ image ▁ -> ▁ problem ▁ with ▁ PCA ▁ N>>D <encdom> imagen = cv2 . resize ( imagen , ( IMAGE_HEIGHT , IMAGE_WIDHT ) , interpolation = cv2 . INTER_LINEAR ) ; <newline> images [ : , index ] = imagen . reshape ( imagen . shape [ 0 ] * imagen . shape [ 1 ] , 1 ) . T ; <newline> index = index + 1 <newline>  # don't ▁ read ▁ the ▁ last ▁ value ▁ (last ▁ value ▁ is ▁ to ▁ test ▁ eigenfaces) <encdom> if ( ( len ( list_filenames ) - 1 ) == index ) : <newline> <indent> break <newline> <dedent> <dedent> print "OK! ▁ " <newline> return images <newline>  # contains ▁ images ▁ (path) ▁ and ▁ labels <encdom>  # DATABASE: ▁ AT&T ▁ Facedatabase <encdom> <dedent> def get_imlist ( path , NUM_PERSONS , NUM_IMAGES_PER_PERSON ) : <newline> <indent>  """ ▁ Returns ▁ a ▁ list ▁ of ▁ filenames ▁ for ▁ NUM_PERSONS ▁ and ▁ NUM_IMAGES_PER_PERSON ▁ """  <newline> list_filenames = [ ] <newline> list_labels = [ ] <newline>  # add ▁ labels ▁ and ▁ images <encdom> for num_person in range ( NUM_PERSONS ) : <newline> <indent> for num_faces in range ( NUM_IMAGES_PER_PERSON ) : <newline> <indent> filename = path + os . sep + str ( ( num_faces + 1 ) + ( num_person * 10 ) ) + '.pgm' <newline>  # exits? <encdom> if os . path . exists ( filename ) : <newline> <indent> list_filenames . append ( filename ) <newline> list_labels . append ( num_person ) <newline> <dedent> <dedent> <dedent> return [ list_filenames , list_labels ] <newline> <dedent> def plot_gallery ( images , titles , h , w , n_row = 3 , n_col = 4 ) : <newline> <indent>  """ Helper ▁ function ▁ to ▁ plot ▁ a ▁ gallery ▁ of ▁ portraits """  <newline> pl . figure ( figsize = ( 1.8 * n_col , 2.4 * n_row ) ) <newline> pl . subplots_adjust ( bottom = 0 , left = .01 , right = .99 , top = .90 , hspace = .35 ) <newline> for i in range ( n_row * n_col ) : <newline> <indent> pl . subplot ( n_row , n_col , i + 1 ) <newline> pl . imshow ( images [ i ] . reshape ( ( h , w ) ) , cmap = pl . cm . gray ) <newline> pl . title ( titles [ i ] , size = 12 ) <newline> pl . xticks ( ( ) ) <newline> pl . yticks ( ( ) ) <newline> <dedent> <dedent> if __name__ == '__main__' : <newline>  # return ▁ list ▁ of ▁ filenames ▁ and ▁ labels <encdom> <indent> [ list_filenames , list_labels ] = get_imlist ( os . pardir + os . sep + os . pardir + os . sep + os . pardir + os . sep + os . pardir + os . sep + 'data' + os . sep + 'att_dataset' + os . sep + 'training' , 25 , 10 ) <newline>  # read ▁ all ▁ images <encdom> images = readImages ( list_filenames ) ; <newline>  # subset ▁ of ▁ data ▁ image <encdom> random . seed ( 0 ) <newline> subset = random . permutation ( images . shape [ 1 ] ) <newline> test_images = images [ : , subset [ : N_SUBSET ] ] <newline> show_images = [ ] <newline> show_images_titles = [ ] ; <newline> for n in range ( N_SUBSET ) : <newline> <indent> show_images_titles . append ( "Sample ▁ image ▁ " + str ( n ) ) ; <newline> show_images . append ( test_images [ : , n ] . reshape ( IMAGE_HEIGHT , IMAGE_WIDHT ) ) <newline>  # this ▁ class ▁ resolves ▁ the ▁ eigenfaces <encdom> <dedent> eigenfaces = EigenFaces ( 100 ) <newline>  # train ▁ eigenfaces <encdom> eigenfaces . train ( images , list_labels ) <newline>  # test ▁ eigenfaces <encdom> image = cv2 . resize ( cv2 . imread ( list_filenames [ - 1 ] , cv2 . IMREAD_GRAYSCALE ) , ( IMAGE_HEIGHT , IMAGE_WIDHT ) , interpolation = cv2 . INTER_LINEAR ) ; <newline> print "predicted: ▁ " , eigenfaces . predict ( image ) , " ▁ // ▁ real: ▁ " , list_labels [ - 1 ] <newline>  # Mean ▁ face <encdom>  # get ▁ mean ▁ and ▁ reshape ▁ ( ▁ height ▁ and ▁ width ▁ original ▁ size) <encdom> mean = eigenfaces . getMean ( ) . reshape ( IMAGE_HEIGHT , IMAGE_WIDHT ) ; <newline> show_images_titles . append ( "Mean ▁ face" ) ; <newline> show_images . append ( mean ) <newline>  # Reconstruction ▁ with ▁ diferents ▁ values ▁ of ▁ eigenvectos <encdom>  # Read ▁ the ▁ last ▁ image ▁ of ▁ the ▁ file ▁ to ▁ test ▁ Eigenfaces <encdom> image = cv2 . resize ( cv2 . imread ( list_filenames [ 0 ] , cv2 . IMREAD_GRAYSCALE ) , ( IMAGE_HEIGHT , IMAGE_WIDHT ) , interpolation = cv2 . INTER_LINEAR ) ; <newline>  # image ▁ as ▁ row <encdom> imageAsRow = np . asarray ( image . reshape ( image . shape [ 0 ] * image . shape [ 1 ] , 1 ) , np . float64 ) ; <newline> reconstructions = range ( 10 , 250 , 50 ) <newline> reconstructions_images = np . empty ( ( IMAGE_HEIGHT , IMAGE_WIDHT * len ( reconstructions ) ) , np . uint8 ) <newline>  # Reconstruct ▁ 10 ▁ eigen ▁ vectors ▁ to ▁ 300, ▁ step ▁ 15 <encdom> for i in reconstructions : <newline> <indent> print "Reconstruct ▁ with ▁ " + str ( i ) + " ▁ eigenvectors" <newline> pca = PCA ( ) <newline>  # set ▁ dimension <encdom> pca . set_target_dim ( i ) ; <newline>  # compute ▁ PCA <encdom> pca . init ( RealFeatures ( images ) ) <newline> pca . apply_to_feature_vector ( RealFeatures ( imageAsRow ) . get_feature_vector ( 0 ) ) ; <newline>  # reconstruct <encdom> projection = pca . apply_to_feature_vector ( RealFeatures ( imageAsRow ) . get_feature_vector ( 0 ) ) ; <newline> reconstruction = np . asmatrix ( np . asarray ( projection , np . float64 ) ) * np . asmatrix ( pca . get_transformation_matrix ( ) ) . T <newline> reconstruction = reconstruction + pca . get_mean ( ) <newline>  # prepare ▁ the ▁ data ▁ to ▁ visualize ▁ in ▁ one ▁ window <encdom> show_images_titles . append ( str ( i ) + " ▁ eigenvectors" ) ; <newline> show_images . append ( reconstruction . reshape ( IMAGE_HEIGHT , IMAGE_WIDHT ) ) <newline> <dedent> plot_gallery ( show_images , show_images_titles , IMAGE_HEIGHT , IMAGE_WIDHT , 4 , 4 ) ; <newline> pl . show ( ) <newline> <dedent>