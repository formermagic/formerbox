"""
This type stub file was generated by pyright.
"""

import argparse
import os
import torch
from pathlib import Path
from typing import Dict, List, Union
from transformers import MarianMTModel

"""
This type stub file was generated by pyright.
"""
def remove_suffix(text: str, suffix: str):
    ...

def remove_prefix(text: str, prefix: str):
    ...

def convert_encoder_layer(opus_dict, layer_prefix: str, converter: dict):
    ...

def load_layers_(layer_lst: torch.nn.ModuleList, opus_state: dict, converter, is_decoder=...):
    ...

def find_pretrained_model(src_lang: str, tgt_lang: str) -> List[str]:
    """Find models that can accept src_lang as input and return tgt_lang as output."""
    ...

def add_emb_entries(wemb, final_bias, n_special_tokens=...):
    ...

def cast_marian_config(raw_cfg: Dict[str, str]) -> Dict:
    ...

CONFIG_KEY = "special:model.yml"
def load_config_from_state_dict(opus_dict):
    ...

def find_model_file(dest_dir):
    ...

ROM_GROUP = "fr+fr_BE+fr_CA+fr_FR+wa+frp+oc+ca+rm+lld+fur+lij+lmo+es+es_AR+es_CL+es_CO+es_CR+es_DO+es_EC+es_ES+es_GT" "+es_HN+es_MX+es_NI+es_PA+es_PE+es_PR+es_SV+es_UY+es_VE+pt+pt_br+pt_BR+pt_PT+gl+lad+an+mwl+it+it_IT+co" "+nap+scn+vec+sc+ro+la"
GROUPS = [("cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh", "ZH"), (ROM_GROUP, "ROMANCE"), ("de+nl+fy+af+da+fo+is+no+nb+nn+sv", "NORTH_EU"), ("da+fo+is+no+nb+nn+sv", "SCANDINAVIA"), ("se+sma+smj+smn+sms", "SAMI"), ("nb_NO+nb+nn_NO+nn+nog+no_nb+no", "NORWAY"), ("ga+cy+br+gd+kw+gv", "CELTIC")]
GROUP_TO_OPUS_NAME = { "opus-mt-ZH-de": "cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh-de","opus-mt-ZH-fi": "cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh-fi","opus-mt-ZH-sv": "cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh-sv","opus-mt-SCANDINAVIA-SCANDINAVIA": "da+fo+is+no+nb+nn+sv-da+fo+is+no+nb+nn+sv","opus-mt-NORTH_EU-NORTH_EU": "de+nl+fy+af+da+fo+is+no+nb+nn+sv-de+nl+fy+af+da+fo+is+no+nb+nn+sv","opus-mt-de-ZH": "de-cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh","opus-mt-en_el_es_fi-en_el_es_fi": "en+el+es+fi-en+el+es+fi","opus-mt-en-ROMANCE": "en-fr+fr_BE+fr_CA+fr_FR+wa+frp+oc+ca+rm+lld+fur+lij+lmo+es+es_AR+es_CL+es_CO+es_CR+es_DO" "+es_EC+es_ES+es_GT+es_HN+es_MX+es_NI+es_PA+es_PE+es_PR+es_SV+es_UY+es_VE+pt+pt_br+pt_BR" "+pt_PT+gl+lad+an+mwl+it+it_IT+co+nap+scn+vec+sc+ro+la","opus-mt-en-CELTIC": "en-ga+cy+br+gd+kw+gv","opus-mt-es-NORWAY": "es-nb_NO+nb+nn_NO+nn+nog+no_nb+no","opus-mt-fi_nb_no_nn_ru_sv_en-SAMI": "fi+nb+no+nn+ru+sv+en-se+sma+smj+smn+sms","opus-mt-fi-ZH": "fi-cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh","opus-mt-fi-NORWAY": "fi-nb_NO+nb+nn_NO+nn+nog+no_nb+no","opus-mt-ROMANCE-en": "fr+fr_BE+fr_CA+fr_FR+wa+frp+oc+ca+rm+lld+fur+lij+lmo+es+es_AR+es_CL+es_CO+es_CR+es_DO" "+es_EC+es_ES+es_GT+es_HN+es_MX+es_NI+es_PA+es_PE+es_PR+es_SV+es_UY+es_VE+pt+pt_br+pt_BR" "+pt_PT+gl+lad+an+mwl+it+it_IT+co+nap+scn+vec+sc+ro+la-en","opus-mt-CELTIC-en": "ga+cy+br+gd+kw+gv-en","opus-mt-sv-ZH": "sv-cmn+cn+yue+ze_zh+zh_cn+zh_CN+zh_HK+zh_tw+zh_TW+zh_yue+zhs+zht+zh","opus-mt-sv-NORWAY": "sv-nb_NO+nb+nn_NO+nn+nog+no_nb+no" }
OPUS_GITHUB_URL = "https://github.com/Helsinki-NLP/OPUS-MT-train/blob/master/models/"
ORG_NAME = "Helsinki-NLP/"
def convert_opus_name_to_hf_name(x):
    """For OPUS-MT-Train/ DEPRECATED"""
    ...

def convert_hf_name_to_opus_name(hf_model_name):
    """Relies on the assumption that there are no language codes like pt_br in models that are not in
    GROUP_TO_OPUS_NAME."""
    ...

def get_system_metadata(repo_root):
    ...

FRONT_MATTER_TEMPLATE = """---
language:
{}
tags:
- translation

license: apache-2.0
---

"""
DEFAULT_REPO = "Tatoeba-Challenge"
DEFAULT_MODEL_DIR = os.path.join(DEFAULT_REPO, "models")
def write_model_card(hf_model_name: str, repo_root=..., save_dir=..., dry_run=..., extra_metadata=...) -> str:
    """Copy the most recent model's readme section from opus, and add metadata.
    upload command: aws s3 sync model_card_dir s3://models.huggingface.co/bert/Helsinki-NLP/ --dryrun
    """
    ...

def make_registry(repo_path=...):
    ...

def convert_all_sentencepiece_models(model_list=..., repo_path=..., dest_dir=...):
    """Requires 300GB"""
    ...

def lmap(f, x) -> List:
    ...

def fetch_test_set(test_set_url):
    ...

def convert_whole_dir(path=...):
    ...

def save_tokenizer_config(dest_dir: Path):
    ...

def add_to_vocab_(vocab: Dict[str, int], special_tokens: List[str]):
    ...

def find_vocab_file(model_dir):
    ...

def add_special_tokens_to_vocab(model_dir: Path) -> None:
    ...

def check_equal(marian_cfg, k1, k2):
    ...

def check_marian_cfg_assumptions(marian_cfg):
    ...

BIAS_KEY = "decoder_ff_logit_out_b"
BART_CONVERTER = { "self_Wq": "self_attn.q_proj.weight","self_Wk": "self_attn.k_proj.weight","self_Wv": "self_attn.v_proj.weight","self_Wo": "self_attn.out_proj.weight","self_bq": "self_attn.q_proj.bias","self_bk": "self_attn.k_proj.bias","self_bv": "self_attn.v_proj.bias","self_bo": "self_attn.out_proj.bias","self_Wo_ln_scale": "self_attn_layer_norm.weight","self_Wo_ln_bias": "self_attn_layer_norm.bias","ffn_W1": "fc1.weight","ffn_b1": "fc1.bias","ffn_W2": "fc2.weight","ffn_b2": "fc2.bias","ffn_ffn_ln_scale": "final_layer_norm.weight","ffn_ffn_ln_bias": "final_layer_norm.bias","context_Wk": "encoder_attn.k_proj.weight","context_Wo": "encoder_attn.out_proj.weight","context_Wq": "encoder_attn.q_proj.weight","context_Wv": "encoder_attn.v_proj.weight","context_bk": "encoder_attn.k_proj.bias","context_bo": "encoder_attn.out_proj.bias","context_bq": "encoder_attn.q_proj.bias","context_bv": "encoder_attn.v_proj.bias","context_Wo_ln_scale": "encoder_attn_layer_norm.weight","context_Wo_ln_bias": "encoder_attn_layer_norm.bias" }
class OpusState:
    def __init__(self, source_dir) -> None:
        ...
    
    @property
    def extra_keys(self):
        ...
    
    def sub_keys(self, layer_prefix):
        ...
    
    def load_marian_model(self) -> MarianMTModel:
        ...
    


def download_and_unzip(url, dest_dir):
    ...

def convert(source_dir: Path, dest_dir):
    ...

def load_yaml(path):
    ...

def save_json(content: Union[Dict, List], path: str) -> None:
    ...

def unzip(zip_path: str, dest_dir: str) -> None:
    ...

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    args = parser.parse_args()
    source_dir = Path(args.src)
    dest_dir = <Expression>
